/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fpedrorosalba%2Fmediolano-dapp%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fpedrorosalba%2Fmediolano-dapp%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnBlZHJvcm9zYWxiYSUyRm1lZGlvbGFuby1kYXBwJTJGd2ViJTJGc3JjJTJGYXBwJTJGcGFnZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw4SkFBMkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8yYWYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL2hvbWUvcGVkcm9yb3NhbGJhL21lZGlvbGFuby1kYXBwL3dlYi9zcmMvYXBwL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fpedrorosalba%2Fmediolano-dapp%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2JkNDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/eventemitter3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/isomorphic-fetch/fetch-npm-browserify.js":
/*!***************************************************************!*\
  !*** ./node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(/*! whatwg-fetch */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js\");\nmodule.exports = self.fetch.bind(self);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLWZldGNoL2ZldGNoLW5wbS1icm93c2VyaWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQyx3R0FBYztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaXNvbW9ycGhpYy1mZXRjaC9mZXRjaC1ucG0tYnJvd3NlcmlmeS5qcz8xYTI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoZSB3aGF0d2ctZmV0Y2ggcG9seWZpbGwgaW5zdGFsbHMgdGhlIGZldGNoKCkgZnVuY3Rpb25cbi8vIG9uIHRoZSBnbG9iYWwgb2JqZWN0ICh3aW5kb3cgb3Igc2VsZilcbi8vXG4vLyBSZXR1cm4gdGhhdCBhcyB0aGUgZXhwb3J0IGZvciB1c2UgaW4gV2VicGFjaywgQnJvd3NlcmlmeSBldGMuXG5yZXF1aXJlKCd3aGF0d2ctZmV0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gc2VsZi5mZXRjaC5iaW5kKHNlbGYpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/isomorphic-fetch/fetch-npm-browserify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/app-dynamic.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/api/app-dynamic.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/app-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-dynamic.js\");\n/* harmony import */ var _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_app_dynamic__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=app-dynamic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2FwcC1keW5hbWljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwQztBQUNVOztBQUVwRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9hcHAtZHluYW1pYy5qcz9kYjk0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuLi9zaGFyZWQvbGliL2FwcC1keW5hbWljXCI7XG5leHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi4uL3NoYXJlZC9saWIvYXBwLWR5bmFtaWNcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLWR5bmFtaWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/app-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* globals self */ \nexports.Headers = self.Headers;\nexports.Request = self.Request;\nexports.Response = self.Response;\nexports.fetch = self.fetch;\n\n//# sourceMappingURL=whatwg-fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL2ZldGNoL3doYXR3Zy1mZXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBZ0M7QUFDaEMsZUFBZTtBQUNmLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsYUFBYTs7QUFFYiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9mZXRjaC93aGF0d2ctZmV0Y2guanM/OWEyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIHNlbGYgKi8gXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLkhlYWRlcnMgPSBzZWxmLkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBzZWxmLlJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gc2VsZi5SZXNwb25zZTtcbmV4cG9ydHMuZmV0Y2ggPSBzZWxmLmZldGNoO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aGF0d2ctZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/fetch/whatwg-fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/OTU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMs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Q0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz81ZWJkIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz9lZjE3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(function(){var r={992:function(r){r.exports=function(r,t,o){if(r.filter)return r.filter(t,o);if(void 0===r||null===r)throw new TypeError;if(\"function\"!=typeof t)throw new TypeError;var n=[];for(var i=0;i<r.length;i++){if(!e.call(r,i))continue;var a=r[i];if(t.call(o,a,i,r))n.push(a)}return n};var e=Object.prototype.hasOwnProperty},256:function(r,e,t){\"use strict\";var o=t(925);var n=t(139);var i=n(o(\"String.prototype.indexOf\"));r.exports=function callBoundIntrinsic(r,e){var t=o(r,!!e);if(typeof t===\"function\"&&i(r,\".prototype.\")>-1){return n(t)}return t}},139:function(r,e,t){\"use strict\";var o=t(174);var n=t(925);var i=n(\"%Function.prototype.apply%\");var a=n(\"%Function.prototype.call%\");var y=n(\"%Reflect.apply%\",true)||o.call(a,i);var f=n(\"%Object.getOwnPropertyDescriptor%\",true);var p=n(\"%Object.defineProperty%\",true);var u=n(\"%Math.max%\");if(p){try{p({},\"a\",{value:1})}catch(r){p=null}}r.exports=function callBind(r){var e=y(o,a,arguments);if(f&&p){var t=f(e,\"length\");if(t.configurable){p(e,\"length\",{value:1+u(0,r.length-(arguments.length-1))})}}return e};var s=function applyBind(){return y(o,i,arguments)};if(p){p(r.exports,\"apply\",{value:s})}else{r.exports.apply=s}},144:function(r){var e=Object.prototype.hasOwnProperty;var t=Object.prototype.toString;r.exports=function forEach(r,o,n){if(t.call(o)!==\"[object Function]\"){throw new TypeError(\"iterator must be a function\")}var i=r.length;if(i===+i){for(var a=0;a<i;a++){o.call(n,r[a],a,r)}}else{for(var y in r){if(e.call(r,y)){o.call(n,r[y],y,r)}}}}},426:function(r){\"use strict\";var e=\"Function.prototype.bind called on incompatible \";var t=Array.prototype.slice;var o=Object.prototype.toString;var n=\"[object Function]\";r.exports=function bind(r){var i=this;if(typeof i!==\"function\"||o.call(i)!==n){throw new TypeError(e+i)}var a=t.call(arguments,1);var y;var binder=function(){if(this instanceof y){var e=i.apply(this,a.concat(t.call(arguments)));if(Object(e)===e){return e}return this}else{return i.apply(r,a.concat(t.call(arguments)))}};var f=Math.max(0,i.length-a.length);var p=[];for(var u=0;u<f;u++){p.push(\"$\"+u)}y=Function(\"binder\",\"return function (\"+p.join(\",\")+\"){ return binder.apply(this,arguments); }\")(binder);if(i.prototype){var s=function Empty(){};s.prototype=i.prototype;y.prototype=new s;s.prototype=null}return y}},174:function(r,e,t){\"use strict\";var o=t(426);r.exports=Function.prototype.bind||o},500:function(r,e,t){\"use strict\";var o;var n=SyntaxError;var i=Function;var a=TypeError;var getEvalledConstructor=function(r){try{return i('\"use strict\"; return ('+r+\").constructor;\")()}catch(r){}};var y=Object.getOwnPropertyDescriptor;if(y){try{y({},\"\")}catch(r){y=null}}var throwTypeError=function(){throw new a};var f=y?function(){try{arguments.callee;return throwTypeError}catch(r){try{return y(arguments,\"callee\").get}catch(r){return throwTypeError}}}():throwTypeError;var p=t(115)();var u=Object.getPrototypeOf||function(r){return r.__proto__};var s={};var c=typeof Uint8Array===\"undefined\"?o:u(Uint8Array);var l={\"%AggregateError%\":typeof AggregateError===\"undefined\"?o:AggregateError,\"%Array%\":Array,\"%ArrayBuffer%\":typeof ArrayBuffer===\"undefined\"?o:ArrayBuffer,\"%ArrayIteratorPrototype%\":p?u([][Symbol.iterator]()):o,\"%AsyncFromSyncIteratorPrototype%\":o,\"%AsyncFunction%\":s,\"%AsyncGenerator%\":s,\"%AsyncGeneratorFunction%\":s,\"%AsyncIteratorPrototype%\":s,\"%Atomics%\":typeof Atomics===\"undefined\"?o:Atomics,\"%BigInt%\":typeof BigInt===\"undefined\"?o:BigInt,\"%Boolean%\":Boolean,\"%DataView%\":typeof DataView===\"undefined\"?o:DataView,\"%Date%\":Date,\"%decodeURI%\":decodeURI,\"%decodeURIComponent%\":decodeURIComponent,\"%encodeURI%\":encodeURI,\"%encodeURIComponent%\":encodeURIComponent,\"%Error%\":Error,\"%eval%\":eval,\"%EvalError%\":EvalError,\"%Float32Array%\":typeof Float32Array===\"undefined\"?o:Float32Array,\"%Float64Array%\":typeof Float64Array===\"undefined\"?o:Float64Array,\"%FinalizationRegistry%\":typeof FinalizationRegistry===\"undefined\"?o:FinalizationRegistry,\"%Function%\":i,\"%GeneratorFunction%\":s,\"%Int8Array%\":typeof Int8Array===\"undefined\"?o:Int8Array,\"%Int16Array%\":typeof Int16Array===\"undefined\"?o:Int16Array,\"%Int32Array%\":typeof Int32Array===\"undefined\"?o:Int32Array,\"%isFinite%\":isFinite,\"%isNaN%\":isNaN,\"%IteratorPrototype%\":p?u(u([][Symbol.iterator]())):o,\"%JSON%\":typeof JSON===\"object\"?JSON:o,\"%Map%\":typeof Map===\"undefined\"?o:Map,\"%MapIteratorPrototype%\":typeof Map===\"undefined\"||!p?o:u((new Map)[Symbol.iterator]()),\"%Math%\":Math,\"%Number%\":Number,\"%Object%\":Object,\"%parseFloat%\":parseFloat,\"%parseInt%\":parseInt,\"%Promise%\":typeof Promise===\"undefined\"?o:Promise,\"%Proxy%\":typeof Proxy===\"undefined\"?o:Proxy,\"%RangeError%\":RangeError,\"%ReferenceError%\":ReferenceError,\"%Reflect%\":typeof Reflect===\"undefined\"?o:Reflect,\"%RegExp%\":RegExp,\"%Set%\":typeof Set===\"undefined\"?o:Set,\"%SetIteratorPrototype%\":typeof Set===\"undefined\"||!p?o:u((new Set)[Symbol.iterator]()),\"%SharedArrayBuffer%\":typeof SharedArrayBuffer===\"undefined\"?o:SharedArrayBuffer,\"%String%\":String,\"%StringIteratorPrototype%\":p?u(\"\"[Symbol.iterator]()):o,\"%Symbol%\":p?Symbol:o,\"%SyntaxError%\":n,\"%ThrowTypeError%\":f,\"%TypedArray%\":c,\"%TypeError%\":a,\"%Uint8Array%\":typeof Uint8Array===\"undefined\"?o:Uint8Array,\"%Uint8ClampedArray%\":typeof Uint8ClampedArray===\"undefined\"?o:Uint8ClampedArray,\"%Uint16Array%\":typeof Uint16Array===\"undefined\"?o:Uint16Array,\"%Uint32Array%\":typeof Uint32Array===\"undefined\"?o:Uint32Array,\"%URIError%\":URIError,\"%WeakMap%\":typeof WeakMap===\"undefined\"?o:WeakMap,\"%WeakRef%\":typeof WeakRef===\"undefined\"?o:WeakRef,\"%WeakSet%\":typeof WeakSet===\"undefined\"?o:WeakSet};var d=function doEval(r){var e;if(r===\"%AsyncFunction%\"){e=getEvalledConstructor(\"async function () {}\")}else if(r===\"%GeneratorFunction%\"){e=getEvalledConstructor(\"function* () {}\")}else if(r===\"%AsyncGeneratorFunction%\"){e=getEvalledConstructor(\"async function* () {}\")}else if(r===\"%AsyncGenerator%\"){var t=doEval(\"%AsyncGeneratorFunction%\");if(t){e=t.prototype}}else if(r===\"%AsyncIteratorPrototype%\"){var o=doEval(\"%AsyncGenerator%\");if(o){e=u(o.prototype)}}l[r]=e;return e};var g={\"%ArrayBufferPrototype%\":[\"ArrayBuffer\",\"prototype\"],\"%ArrayPrototype%\":[\"Array\",\"prototype\"],\"%ArrayProto_entries%\":[\"Array\",\"prototype\",\"entries\"],\"%ArrayProto_forEach%\":[\"Array\",\"prototype\",\"forEach\"],\"%ArrayProto_keys%\":[\"Array\",\"prototype\",\"keys\"],\"%ArrayProto_values%\":[\"Array\",\"prototype\",\"values\"],\"%AsyncFunctionPrototype%\":[\"AsyncFunction\",\"prototype\"],\"%AsyncGenerator%\":[\"AsyncGeneratorFunction\",\"prototype\"],\"%AsyncGeneratorPrototype%\":[\"AsyncGeneratorFunction\",\"prototype\",\"prototype\"],\"%BooleanPrototype%\":[\"Boolean\",\"prototype\"],\"%DataViewPrototype%\":[\"DataView\",\"prototype\"],\"%DatePrototype%\":[\"Date\",\"prototype\"],\"%ErrorPrototype%\":[\"Error\",\"prototype\"],\"%EvalErrorPrototype%\":[\"EvalError\",\"prototype\"],\"%Float32ArrayPrototype%\":[\"Float32Array\",\"prototype\"],\"%Float64ArrayPrototype%\":[\"Float64Array\",\"prototype\"],\"%FunctionPrototype%\":[\"Function\",\"prototype\"],\"%Generator%\":[\"GeneratorFunction\",\"prototype\"],\"%GeneratorPrototype%\":[\"GeneratorFunction\",\"prototype\",\"prototype\"],\"%Int8ArrayPrototype%\":[\"Int8Array\",\"prototype\"],\"%Int16ArrayPrototype%\":[\"Int16Array\",\"prototype\"],\"%Int32ArrayPrototype%\":[\"Int32Array\",\"prototype\"],\"%JSONParse%\":[\"JSON\",\"parse\"],\"%JSONStringify%\":[\"JSON\",\"stringify\"],\"%MapPrototype%\":[\"Map\",\"prototype\"],\"%NumberPrototype%\":[\"Number\",\"prototype\"],\"%ObjectPrototype%\":[\"Object\",\"prototype\"],\"%ObjProto_toString%\":[\"Object\",\"prototype\",\"toString\"],\"%ObjProto_valueOf%\":[\"Object\",\"prototype\",\"valueOf\"],\"%PromisePrototype%\":[\"Promise\",\"prototype\"],\"%PromiseProto_then%\":[\"Promise\",\"prototype\",\"then\"],\"%Promise_all%\":[\"Promise\",\"all\"],\"%Promise_reject%\":[\"Promise\",\"reject\"],\"%Promise_resolve%\":[\"Promise\",\"resolve\"],\"%RangeErrorPrototype%\":[\"RangeError\",\"prototype\"],\"%ReferenceErrorPrototype%\":[\"ReferenceError\",\"prototype\"],\"%RegExpPrototype%\":[\"RegExp\",\"prototype\"],\"%SetPrototype%\":[\"Set\",\"prototype\"],\"%SharedArrayBufferPrototype%\":[\"SharedArrayBuffer\",\"prototype\"],\"%StringPrototype%\":[\"String\",\"prototype\"],\"%SymbolPrototype%\":[\"Symbol\",\"prototype\"],\"%SyntaxErrorPrototype%\":[\"SyntaxError\",\"prototype\"],\"%TypedArrayPrototype%\":[\"TypedArray\",\"prototype\"],\"%TypeErrorPrototype%\":[\"TypeError\",\"prototype\"],\"%Uint8ArrayPrototype%\":[\"Uint8Array\",\"prototype\"],\"%Uint8ClampedArrayPrototype%\":[\"Uint8ClampedArray\",\"prototype\"],\"%Uint16ArrayPrototype%\":[\"Uint16Array\",\"prototype\"],\"%Uint32ArrayPrototype%\":[\"Uint32Array\",\"prototype\"],\"%URIErrorPrototype%\":[\"URIError\",\"prototype\"],\"%WeakMapPrototype%\":[\"WeakMap\",\"prototype\"],\"%WeakSetPrototype%\":[\"WeakSet\",\"prototype\"]};var v=t(174);var b=t(101);var A=v.call(Function.call,Array.prototype.concat);var m=v.call(Function.apply,Array.prototype.splice);var S=v.call(Function.call,String.prototype.replace);var h=v.call(Function.call,String.prototype.slice);var P=v.call(Function.call,RegExp.prototype.exec);var O=/[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;var w=/\\\\(\\\\)?/g;var j=function stringToPath(r){var e=h(r,0,1);var t=h(r,-1);if(e===\"%\"&&t!==\"%\"){throw new n(\"invalid intrinsic syntax, expected closing `%`\")}else if(t===\"%\"&&e!==\"%\"){throw new n(\"invalid intrinsic syntax, expected opening `%`\")}var o=[];S(r,O,(function(r,e,t,n){o[o.length]=t?S(n,w,\"$1\"):e||r}));return o};var E=function getBaseIntrinsic(r,e){var t=r;var o;if(b(g,t)){o=g[t];t=\"%\"+o[0]+\"%\"}if(b(l,t)){var i=l[t];if(i===s){i=d(t)}if(typeof i===\"undefined\"&&!e){throw new a(\"intrinsic \"+r+\" exists, but is not available. Please file an issue!\")}return{alias:o,name:t,value:i}}throw new n(\"intrinsic \"+r+\" does not exist!\")};r.exports=function GetIntrinsic(r,e){if(typeof r!==\"string\"||r.length===0){throw new a(\"intrinsic name must be a non-empty string\")}if(arguments.length>1&&typeof e!==\"boolean\"){throw new a('\"allowMissing\" argument must be a boolean')}if(P(/^%?[^%]*%?$/g,r)===null){throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\")}var t=j(r);var i=t.length>0?t[0]:\"\";var f=E(\"%\"+i+\"%\",e);var p=f.name;var u=f.value;var s=false;var c=f.alias;if(c){i=c[0];m(t,A([0,1],c))}for(var d=1,g=true;d<t.length;d+=1){var v=t[d];var S=h(v,0,1);var O=h(v,-1);if((S==='\"'||S===\"'\"||S===\"`\"||(O==='\"'||O===\"'\"||O===\"`\"))&&S!==O){throw new n(\"property names with quotes must have matching quotes\")}if(v===\"constructor\"||!g){s=true}i+=\".\"+v;p=\"%\"+i+\"%\";if(b(l,p)){u=l[p]}else if(u!=null){if(!(v in u)){if(!e){throw new a(\"base intrinsic for \"+r+\" exists, but the property is not available.\")}return void o}if(y&&d+1>=t.length){var w=y(u,v);g=!!w;if(g&&\"get\"in w&&!(\"originalValue\"in w.get)){u=w.get}else{u=u[v]}}else{g=b(u,v);u=u[v]}if(g&&!s){l[p]=u}}}return u}},925:function(r,e,t){\"use strict\";var o;var n=SyntaxError;var i=Function;var a=TypeError;var getEvalledConstructor=function(r){try{return i('\"use strict\"; return ('+r+\").constructor;\")()}catch(r){}};var y=Object.getOwnPropertyDescriptor;if(y){try{y({},\"\")}catch(r){y=null}}var throwTypeError=function(){throw new a};var f=y?function(){try{arguments.callee;return throwTypeError}catch(r){try{return y(arguments,\"callee\").get}catch(r){return throwTypeError}}}():throwTypeError;var p=t(115)();var u=t(504)();var s=Object.getPrototypeOf||(u?function(r){return r.__proto__}:null);var c={};var l=typeof Uint8Array===\"undefined\"||!s?o:s(Uint8Array);var d={\"%AggregateError%\":typeof AggregateError===\"undefined\"?o:AggregateError,\"%Array%\":Array,\"%ArrayBuffer%\":typeof ArrayBuffer===\"undefined\"?o:ArrayBuffer,\"%ArrayIteratorPrototype%\":p&&s?s([][Symbol.iterator]()):o,\"%AsyncFromSyncIteratorPrototype%\":o,\"%AsyncFunction%\":c,\"%AsyncGenerator%\":c,\"%AsyncGeneratorFunction%\":c,\"%AsyncIteratorPrototype%\":c,\"%Atomics%\":typeof Atomics===\"undefined\"?o:Atomics,\"%BigInt%\":typeof BigInt===\"undefined\"?o:BigInt,\"%BigInt64Array%\":typeof BigInt64Array===\"undefined\"?o:BigInt64Array,\"%BigUint64Array%\":typeof BigUint64Array===\"undefined\"?o:BigUint64Array,\"%Boolean%\":Boolean,\"%DataView%\":typeof DataView===\"undefined\"?o:DataView,\"%Date%\":Date,\"%decodeURI%\":decodeURI,\"%decodeURIComponent%\":decodeURIComponent,\"%encodeURI%\":encodeURI,\"%encodeURIComponent%\":encodeURIComponent,\"%Error%\":Error,\"%eval%\":eval,\"%EvalError%\":EvalError,\"%Float32Array%\":typeof Float32Array===\"undefined\"?o:Float32Array,\"%Float64Array%\":typeof Float64Array===\"undefined\"?o:Float64Array,\"%FinalizationRegistry%\":typeof FinalizationRegistry===\"undefined\"?o:FinalizationRegistry,\"%Function%\":i,\"%GeneratorFunction%\":c,\"%Int8Array%\":typeof Int8Array===\"undefined\"?o:Int8Array,\"%Int16Array%\":typeof Int16Array===\"undefined\"?o:Int16Array,\"%Int32Array%\":typeof Int32Array===\"undefined\"?o:Int32Array,\"%isFinite%\":isFinite,\"%isNaN%\":isNaN,\"%IteratorPrototype%\":p&&s?s(s([][Symbol.iterator]())):o,\"%JSON%\":typeof JSON===\"object\"?JSON:o,\"%Map%\":typeof Map===\"undefined\"?o:Map,\"%MapIteratorPrototype%\":typeof Map===\"undefined\"||!p||!s?o:s((new Map)[Symbol.iterator]()),\"%Math%\":Math,\"%Number%\":Number,\"%Object%\":Object,\"%parseFloat%\":parseFloat,\"%parseInt%\":parseInt,\"%Promise%\":typeof Promise===\"undefined\"?o:Promise,\"%Proxy%\":typeof Proxy===\"undefined\"?o:Proxy,\"%RangeError%\":RangeError,\"%ReferenceError%\":ReferenceError,\"%Reflect%\":typeof Reflect===\"undefined\"?o:Reflect,\"%RegExp%\":RegExp,\"%Set%\":typeof Set===\"undefined\"?o:Set,\"%SetIteratorPrototype%\":typeof Set===\"undefined\"||!p||!s?o:s((new Set)[Symbol.iterator]()),\"%SharedArrayBuffer%\":typeof SharedArrayBuffer===\"undefined\"?o:SharedArrayBuffer,\"%String%\":String,\"%StringIteratorPrototype%\":p&&s?s(\"\"[Symbol.iterator]()):o,\"%Symbol%\":p?Symbol:o,\"%SyntaxError%\":n,\"%ThrowTypeError%\":f,\"%TypedArray%\":l,\"%TypeError%\":a,\"%Uint8Array%\":typeof Uint8Array===\"undefined\"?o:Uint8Array,\"%Uint8ClampedArray%\":typeof Uint8ClampedArray===\"undefined\"?o:Uint8ClampedArray,\"%Uint16Array%\":typeof Uint16Array===\"undefined\"?o:Uint16Array,\"%Uint32Array%\":typeof Uint32Array===\"undefined\"?o:Uint32Array,\"%URIError%\":URIError,\"%WeakMap%\":typeof WeakMap===\"undefined\"?o:WeakMap,\"%WeakRef%\":typeof WeakRef===\"undefined\"?o:WeakRef,\"%WeakSet%\":typeof WeakSet===\"undefined\"?o:WeakSet};if(s){try{null.error}catch(r){var g=s(s(r));d[\"%Error.prototype%\"]=g}}var v=function doEval(r){var e;if(r===\"%AsyncFunction%\"){e=getEvalledConstructor(\"async function () {}\")}else if(r===\"%GeneratorFunction%\"){e=getEvalledConstructor(\"function* () {}\")}else if(r===\"%AsyncGeneratorFunction%\"){e=getEvalledConstructor(\"async function* () {}\")}else if(r===\"%AsyncGenerator%\"){var t=doEval(\"%AsyncGeneratorFunction%\");if(t){e=t.prototype}}else if(r===\"%AsyncIteratorPrototype%\"){var o=doEval(\"%AsyncGenerator%\");if(o&&s){e=s(o.prototype)}}d[r]=e;return e};var b={\"%ArrayBufferPrototype%\":[\"ArrayBuffer\",\"prototype\"],\"%ArrayPrototype%\":[\"Array\",\"prototype\"],\"%ArrayProto_entries%\":[\"Array\",\"prototype\",\"entries\"],\"%ArrayProto_forEach%\":[\"Array\",\"prototype\",\"forEach\"],\"%ArrayProto_keys%\":[\"Array\",\"prototype\",\"keys\"],\"%ArrayProto_values%\":[\"Array\",\"prototype\",\"values\"],\"%AsyncFunctionPrototype%\":[\"AsyncFunction\",\"prototype\"],\"%AsyncGenerator%\":[\"AsyncGeneratorFunction\",\"prototype\"],\"%AsyncGeneratorPrototype%\":[\"AsyncGeneratorFunction\",\"prototype\",\"prototype\"],\"%BooleanPrototype%\":[\"Boolean\",\"prototype\"],\"%DataViewPrototype%\":[\"DataView\",\"prototype\"],\"%DatePrototype%\":[\"Date\",\"prototype\"],\"%ErrorPrototype%\":[\"Error\",\"prototype\"],\"%EvalErrorPrototype%\":[\"EvalError\",\"prototype\"],\"%Float32ArrayPrototype%\":[\"Float32Array\",\"prototype\"],\"%Float64ArrayPrototype%\":[\"Float64Array\",\"prototype\"],\"%FunctionPrototype%\":[\"Function\",\"prototype\"],\"%Generator%\":[\"GeneratorFunction\",\"prototype\"],\"%GeneratorPrototype%\":[\"GeneratorFunction\",\"prototype\",\"prototype\"],\"%Int8ArrayPrototype%\":[\"Int8Array\",\"prototype\"],\"%Int16ArrayPrototype%\":[\"Int16Array\",\"prototype\"],\"%Int32ArrayPrototype%\":[\"Int32Array\",\"prototype\"],\"%JSONParse%\":[\"JSON\",\"parse\"],\"%JSONStringify%\":[\"JSON\",\"stringify\"],\"%MapPrototype%\":[\"Map\",\"prototype\"],\"%NumberPrototype%\":[\"Number\",\"prototype\"],\"%ObjectPrototype%\":[\"Object\",\"prototype\"],\"%ObjProto_toString%\":[\"Object\",\"prototype\",\"toString\"],\"%ObjProto_valueOf%\":[\"Object\",\"prototype\",\"valueOf\"],\"%PromisePrototype%\":[\"Promise\",\"prototype\"],\"%PromiseProto_then%\":[\"Promise\",\"prototype\",\"then\"],\"%Promise_all%\":[\"Promise\",\"all\"],\"%Promise_reject%\":[\"Promise\",\"reject\"],\"%Promise_resolve%\":[\"Promise\",\"resolve\"],\"%RangeErrorPrototype%\":[\"RangeError\",\"prototype\"],\"%ReferenceErrorPrototype%\":[\"ReferenceError\",\"prototype\"],\"%RegExpPrototype%\":[\"RegExp\",\"prototype\"],\"%SetPrototype%\":[\"Set\",\"prototype\"],\"%SharedArrayBufferPrototype%\":[\"SharedArrayBuffer\",\"prototype\"],\"%StringPrototype%\":[\"String\",\"prototype\"],\"%SymbolPrototype%\":[\"Symbol\",\"prototype\"],\"%SyntaxErrorPrototype%\":[\"SyntaxError\",\"prototype\"],\"%TypedArrayPrototype%\":[\"TypedArray\",\"prototype\"],\"%TypeErrorPrototype%\":[\"TypeError\",\"prototype\"],\"%Uint8ArrayPrototype%\":[\"Uint8Array\",\"prototype\"],\"%Uint8ClampedArrayPrototype%\":[\"Uint8ClampedArray\",\"prototype\"],\"%Uint16ArrayPrototype%\":[\"Uint16Array\",\"prototype\"],\"%Uint32ArrayPrototype%\":[\"Uint32Array\",\"prototype\"],\"%URIErrorPrototype%\":[\"URIError\",\"prototype\"],\"%WeakMapPrototype%\":[\"WeakMap\",\"prototype\"],\"%WeakSetPrototype%\":[\"WeakSet\",\"prototype\"]};var A=t(174);var m=t(101);var S=A.call(Function.call,Array.prototype.concat);var h=A.call(Function.apply,Array.prototype.splice);var P=A.call(Function.call,String.prototype.replace);var O=A.call(Function.call,String.prototype.slice);var w=A.call(Function.call,RegExp.prototype.exec);var j=/[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;var E=/\\\\(\\\\)?/g;var I=function stringToPath(r){var e=O(r,0,1);var t=O(r,-1);if(e===\"%\"&&t!==\"%\"){throw new n(\"invalid intrinsic syntax, expected closing `%`\")}else if(t===\"%\"&&e!==\"%\"){throw new n(\"invalid intrinsic syntax, expected opening `%`\")}var o=[];P(r,j,(function(r,e,t,n){o[o.length]=t?P(n,E,\"$1\"):e||r}));return o};var B=function getBaseIntrinsic(r,e){var t=r;var o;if(m(b,t)){o=b[t];t=\"%\"+o[0]+\"%\"}if(m(d,t)){var i=d[t];if(i===c){i=v(t)}if(typeof i===\"undefined\"&&!e){throw new a(\"intrinsic \"+r+\" exists, but is not available. Please file an issue!\")}return{alias:o,name:t,value:i}}throw new n(\"intrinsic \"+r+\" does not exist!\")};r.exports=function GetIntrinsic(r,e){if(typeof r!==\"string\"||r.length===0){throw new a(\"intrinsic name must be a non-empty string\")}if(arguments.length>1&&typeof e!==\"boolean\"){throw new a('\"allowMissing\" argument must be a boolean')}if(w(/^%?[^%]*%?$/,r)===null){throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\")}var t=I(r);var i=t.length>0?t[0]:\"\";var f=B(\"%\"+i+\"%\",e);var p=f.name;var u=f.value;var s=false;var c=f.alias;if(c){i=c[0];h(t,S([0,1],c))}for(var l=1,g=true;l<t.length;l+=1){var v=t[l];var b=O(v,0,1);var A=O(v,-1);if((b==='\"'||b===\"'\"||b===\"`\"||(A==='\"'||A===\"'\"||A===\"`\"))&&b!==A){throw new n(\"property names with quotes must have matching quotes\")}if(v===\"constructor\"||!g){s=true}i+=\".\"+v;p=\"%\"+i+\"%\";if(m(d,p)){u=d[p]}else if(u!=null){if(!(v in u)){if(!e){throw new a(\"base intrinsic for \"+r+\" exists, but the property is not available.\")}return void o}if(y&&l+1>=t.length){var P=y(u,v);g=!!P;if(g&&\"get\"in P&&!(\"originalValue\"in P.get)){u=P.get}else{u=u[v]}}else{g=m(u,v);u=u[v]}if(g&&!s){d[p]=u}}}return u}},504:function(r){\"use strict\";var e={foo:{}};var t=Object;r.exports=function hasProto(){return{__proto__:e}.foo===e.foo&&!({__proto__:null}instanceof t)}},942:function(r,e,t){\"use strict\";var o=typeof Symbol!==\"undefined\"&&Symbol;var n=t(773);r.exports=function hasNativeSymbols(){if(typeof o!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof o(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return n()}},773:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var o=42;r[e]=o;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var n=Object.getOwnPropertySymbols(r);if(n.length!==1||n[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==o||i.enumerable!==true){return false}}return true}},115:function(r,e,t){\"use strict\";var o=typeof Symbol!==\"undefined\"&&Symbol;var n=t(832);r.exports=function hasNativeSymbols(){if(typeof o!==\"function\"){return false}if(typeof Symbol!==\"function\"){return false}if(typeof o(\"foo\")!==\"symbol\"){return false}if(typeof Symbol(\"bar\")!==\"symbol\"){return false}return n()}},832:function(r){\"use strict\";r.exports=function hasSymbols(){if(typeof Symbol!==\"function\"||typeof Object.getOwnPropertySymbols!==\"function\"){return false}if(typeof Symbol.iterator===\"symbol\"){return true}var r={};var e=Symbol(\"test\");var t=Object(e);if(typeof e===\"string\"){return false}if(Object.prototype.toString.call(e)!==\"[object Symbol]\"){return false}if(Object.prototype.toString.call(t)!==\"[object Symbol]\"){return false}var o=42;r[e]=o;for(e in r){return false}if(typeof Object.keys===\"function\"&&Object.keys(r).length!==0){return false}if(typeof Object.getOwnPropertyNames===\"function\"&&Object.getOwnPropertyNames(r).length!==0){return false}var n=Object.getOwnPropertySymbols(r);if(n.length!==1||n[0]!==e){return false}if(!Object.prototype.propertyIsEnumerable.call(r,e)){return false}if(typeof Object.getOwnPropertyDescriptor===\"function\"){var i=Object.getOwnPropertyDescriptor(r,e);if(i.value!==o||i.enumerable!==true){return false}}return true}},101:function(r,e,t){\"use strict\";var o=t(174);r.exports=o.call(Function.call,Object.prototype.hasOwnProperty)},782:function(r){if(typeof Object.create===\"function\"){r.exports=function inherits(r,e){if(e){r.super_=e;r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:false,writable:true,configurable:true}})}}}else{r.exports=function inherits(r,e){if(e){r.super_=e;var TempCtor=function(){};TempCtor.prototype=e.prototype;r.prototype=new TempCtor;r.prototype.constructor=r}}}},157:function(r){\"use strict\";var e=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var t=Object.prototype.toString;var o=function isArguments(r){if(e&&r&&typeof r===\"object\"&&Symbol.toStringTag in r){return false}return t.call(r)===\"[object Arguments]\"};var n=function isArguments(r){if(o(r)){return true}return r!==null&&typeof r===\"object\"&&typeof r.length===\"number\"&&r.length>=0&&t.call(r)!==\"[object Array]\"&&t.call(r.callee)===\"[object Function]\"};var i=function(){return o(arguments)}();o.isLegacyArguments=n;r.exports=i?o:n},391:function(r){\"use strict\";var e=Object.prototype.toString;var t=Function.prototype.toString;var o=/^\\s*(?:function)?\\*/;var n=typeof Symbol===\"function\"&&typeof Symbol.toStringTag===\"symbol\";var i=Object.getPrototypeOf;var getGeneratorFunc=function(){if(!n){return false}try{return Function(\"return function*() {}\")()}catch(r){}};var a=getGeneratorFunc();var y=a?i(a):{};r.exports=function isGeneratorFunction(r){if(typeof r!==\"function\"){return false}if(o.test(t.call(r))){return true}if(!n){var a=e.call(r);return a===\"[object GeneratorFunction]\"}return i(r)===y}},994:function(r,e,t){\"use strict\";var o=t(144);var n=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var y=t(942)();var f=y&&typeof Symbol.toStringTag===\"symbol\";var p=n();var u=i(\"Array.prototype.indexOf\",true)||function indexOf(r,e){for(var t=0;t<r.length;t+=1){if(r[t]===e){return t}}return-1};var s=i(\"String.prototype.slice\");var c={};var l=t(24);var d=Object.getPrototypeOf;if(f&&l&&d){o(p,(function(r){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=d(e);var o=l(t,Symbol.toStringTag);if(!o){var n=d(t);o=l(n,Symbol.toStringTag)}c[r]=o.get}))}var g=function tryAllTypedArrays(r){var e=false;o(c,(function(t,o){if(!e){try{e=t.call(r)===o}catch(r){}}}));return e};r.exports=function isTypedArray(r){if(!r||typeof r!==\"object\"){return false}if(!f){var e=s(a(r),8,-1);return u(p,e)>-1}if(!l){return false}return g(r)}},369:function(r){r.exports=function isBuffer(r){return r instanceof Buffer}},584:function(r,e,t){\"use strict\";var o=t(157);var n=t(391);var i=t(490);var a=t(994);function uncurryThis(r){return r.call.bind(r)}var y=typeof BigInt!==\"undefined\";var f=typeof Symbol!==\"undefined\";var p=uncurryThis(Object.prototype.toString);var u=uncurryThis(Number.prototype.valueOf);var s=uncurryThis(String.prototype.valueOf);var c=uncurryThis(Boolean.prototype.valueOf);if(y){var l=uncurryThis(BigInt.prototype.valueOf)}if(f){var d=uncurryThis(Symbol.prototype.valueOf)}function checkBoxedPrimitive(r,e){if(typeof r!==\"object\"){return false}try{e(r);return true}catch(r){return false}}e.isArgumentsObject=o;e.isGeneratorFunction=n;e.isTypedArray=a;function isPromise(r){return typeof Promise!==\"undefined\"&&r instanceof Promise||r!==null&&typeof r===\"object\"&&typeof r.then===\"function\"&&typeof r.catch===\"function\"}e.isPromise=isPromise;function isArrayBufferView(r){if(typeof ArrayBuffer!==\"undefined\"&&ArrayBuffer.isView){return ArrayBuffer.isView(r)}return a(r)||isDataView(r)}e.isArrayBufferView=isArrayBufferView;function isUint8Array(r){return i(r)===\"Uint8Array\"}e.isUint8Array=isUint8Array;function isUint8ClampedArray(r){return i(r)===\"Uint8ClampedArray\"}e.isUint8ClampedArray=isUint8ClampedArray;function isUint16Array(r){return i(r)===\"Uint16Array\"}e.isUint16Array=isUint16Array;function isUint32Array(r){return i(r)===\"Uint32Array\"}e.isUint32Array=isUint32Array;function isInt8Array(r){return i(r)===\"Int8Array\"}e.isInt8Array=isInt8Array;function isInt16Array(r){return i(r)===\"Int16Array\"}e.isInt16Array=isInt16Array;function isInt32Array(r){return i(r)===\"Int32Array\"}e.isInt32Array=isInt32Array;function isFloat32Array(r){return i(r)===\"Float32Array\"}e.isFloat32Array=isFloat32Array;function isFloat64Array(r){return i(r)===\"Float64Array\"}e.isFloat64Array=isFloat64Array;function isBigInt64Array(r){return i(r)===\"BigInt64Array\"}e.isBigInt64Array=isBigInt64Array;function isBigUint64Array(r){return i(r)===\"BigUint64Array\"}e.isBigUint64Array=isBigUint64Array;function isMapToString(r){return p(r)===\"[object Map]\"}isMapToString.working=typeof Map!==\"undefined\"&&isMapToString(new Map);function isMap(r){if(typeof Map===\"undefined\"){return false}return isMapToString.working?isMapToString(r):r instanceof Map}e.isMap=isMap;function isSetToString(r){return p(r)===\"[object Set]\"}isSetToString.working=typeof Set!==\"undefined\"&&isSetToString(new Set);function isSet(r){if(typeof Set===\"undefined\"){return false}return isSetToString.working?isSetToString(r):r instanceof Set}e.isSet=isSet;function isWeakMapToString(r){return p(r)===\"[object WeakMap]\"}isWeakMapToString.working=typeof WeakMap!==\"undefined\"&&isWeakMapToString(new WeakMap);function isWeakMap(r){if(typeof WeakMap===\"undefined\"){return false}return isWeakMapToString.working?isWeakMapToString(r):r instanceof WeakMap}e.isWeakMap=isWeakMap;function isWeakSetToString(r){return p(r)===\"[object WeakSet]\"}isWeakSetToString.working=typeof WeakSet!==\"undefined\"&&isWeakSetToString(new WeakSet);function isWeakSet(r){return isWeakSetToString(r)}e.isWeakSet=isWeakSet;function isArrayBufferToString(r){return p(r)===\"[object ArrayBuffer]\"}isArrayBufferToString.working=typeof ArrayBuffer!==\"undefined\"&&isArrayBufferToString(new ArrayBuffer);function isArrayBuffer(r){if(typeof ArrayBuffer===\"undefined\"){return false}return isArrayBufferToString.working?isArrayBufferToString(r):r instanceof ArrayBuffer}e.isArrayBuffer=isArrayBuffer;function isDataViewToString(r){return p(r)===\"[object DataView]\"}isDataViewToString.working=typeof ArrayBuffer!==\"undefined\"&&typeof DataView!==\"undefined\"&&isDataViewToString(new DataView(new ArrayBuffer(1),0,1));function isDataView(r){if(typeof DataView===\"undefined\"){return false}return isDataViewToString.working?isDataViewToString(r):r instanceof DataView}e.isDataView=isDataView;var g=typeof SharedArrayBuffer!==\"undefined\"?SharedArrayBuffer:undefined;function isSharedArrayBufferToString(r){return p(r)===\"[object SharedArrayBuffer]\"}function isSharedArrayBuffer(r){if(typeof g===\"undefined\"){return false}if(typeof isSharedArrayBufferToString.working===\"undefined\"){isSharedArrayBufferToString.working=isSharedArrayBufferToString(new g)}return isSharedArrayBufferToString.working?isSharedArrayBufferToString(r):r instanceof g}e.isSharedArrayBuffer=isSharedArrayBuffer;function isAsyncFunction(r){return p(r)===\"[object AsyncFunction]\"}e.isAsyncFunction=isAsyncFunction;function isMapIterator(r){return p(r)===\"[object Map Iterator]\"}e.isMapIterator=isMapIterator;function isSetIterator(r){return p(r)===\"[object Set Iterator]\"}e.isSetIterator=isSetIterator;function isGeneratorObject(r){return p(r)===\"[object Generator]\"}e.isGeneratorObject=isGeneratorObject;function isWebAssemblyCompiledModule(r){return p(r)===\"[object WebAssembly.Module]\"}e.isWebAssemblyCompiledModule=isWebAssemblyCompiledModule;function isNumberObject(r){return checkBoxedPrimitive(r,u)}e.isNumberObject=isNumberObject;function isStringObject(r){return checkBoxedPrimitive(r,s)}e.isStringObject=isStringObject;function isBooleanObject(r){return checkBoxedPrimitive(r,c)}e.isBooleanObject=isBooleanObject;function isBigIntObject(r){return y&&checkBoxedPrimitive(r,l)}e.isBigIntObject=isBigIntObject;function isSymbolObject(r){return f&&checkBoxedPrimitive(r,d)}e.isSymbolObject=isSymbolObject;function isBoxedPrimitive(r){return isNumberObject(r)||isStringObject(r)||isBooleanObject(r)||isBigIntObject(r)||isSymbolObject(r)}e.isBoxedPrimitive=isBoxedPrimitive;function isAnyArrayBuffer(r){return typeof Uint8Array!==\"undefined\"&&(isArrayBuffer(r)||isSharedArrayBuffer(r))}e.isAnyArrayBuffer=isAnyArrayBuffer;[\"isProxy\",\"isExternal\",\"isModuleNamespaceObject\"].forEach((function(r){Object.defineProperty(e,r,{enumerable:false,value:function(){throw new Error(r+\" is not supported in userland\")}})}))},177:function(r,e,t){var o=Object.getOwnPropertyDescriptors||function getOwnPropertyDescriptors(r){var e=Object.keys(r);var t={};for(var o=0;o<e.length;o++){t[e[o]]=Object.getOwnPropertyDescriptor(r,e[o])}return t};var n=/%[sdj%]/g;e.format=function(r){if(!isString(r)){var e=[];for(var t=0;t<arguments.length;t++){e.push(inspect(arguments[t]))}return e.join(\" \")}var t=1;var o=arguments;var i=o.length;var a=String(r).replace(n,(function(r){if(r===\"%%\")return\"%\";if(t>=i)return r;switch(r){case\"%s\":return String(o[t++]);case\"%d\":return Number(o[t++]);case\"%j\":try{return JSON.stringify(o[t++])}catch(r){return\"[Circular]\"}default:return r}}));for(var y=o[t];t<i;y=o[++t]){if(isNull(y)||!isObject(y)){a+=\" \"+y}else{a+=\" \"+inspect(y)}}return a};e.deprecate=function(r,t){if(typeof process!==\"undefined\"&&process.noDeprecation===true){return r}if(typeof process===\"undefined\"){return function(){return e.deprecate(r,t).apply(this,arguments)}}var o=false;function deprecated(){if(!o){if(process.throwDeprecation){throw new Error(t)}else if(process.traceDeprecation){console.trace(t)}else{console.error(t)}o=true}return r.apply(this,arguments)}return deprecated};var i={};var a=/^$/;if(process.env.NODE_DEBUG){var y=process.env.NODE_DEBUG;y=y.replace(/[|\\\\{}()[\\]^$+?.]/g,\"\\\\$&\").replace(/\\*/g,\".*\").replace(/,/g,\"$|^\").toUpperCase();a=new RegExp(\"^\"+y+\"$\",\"i\")}e.debuglog=function(r){r=r.toUpperCase();if(!i[r]){if(a.test(r)){var t=process.pid;i[r]=function(){var o=e.format.apply(e,arguments);console.error(\"%s %d: %s\",r,t,o)}}else{i[r]=function(){}}}return i[r]};function inspect(r,t){var o={seen:[],stylize:stylizeNoColor};if(arguments.length>=3)o.depth=arguments[2];if(arguments.length>=4)o.colors=arguments[3];if(isBoolean(t)){o.showHidden=t}else if(t){e._extend(o,t)}if(isUndefined(o.showHidden))o.showHidden=false;if(isUndefined(o.depth))o.depth=2;if(isUndefined(o.colors))o.colors=false;if(isUndefined(o.customInspect))o.customInspect=true;if(o.colors)o.stylize=stylizeWithColor;return formatValue(o,r,o.depth)}e.inspect=inspect;inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]};inspect.styles={special:\"cyan\",number:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",date:\"magenta\",regexp:\"red\"};function stylizeWithColor(r,e){var t=inspect.styles[e];if(t){return\"\u001b[\"+inspect.colors[t][0]+\"m\"+r+\"\u001b[\"+inspect.colors[t][1]+\"m\"}else{return r}}function stylizeNoColor(r,e){return r}function arrayToHash(r){var e={};r.forEach((function(r,t){e[r]=true}));return e}function formatValue(r,t,o){if(r.customInspect&&t&&isFunction(t.inspect)&&t.inspect!==e.inspect&&!(t.constructor&&t.constructor.prototype===t)){var n=t.inspect(o,r);if(!isString(n)){n=formatValue(r,n,o)}return n}var i=formatPrimitive(r,t);if(i){return i}var a=Object.keys(t);var y=arrayToHash(a);if(r.showHidden){a=Object.getOwnPropertyNames(t)}if(isError(t)&&(a.indexOf(\"message\")>=0||a.indexOf(\"description\")>=0)){return formatError(t)}if(a.length===0){if(isFunction(t)){var f=t.name?\": \"+t.name:\"\";return r.stylize(\"[Function\"+f+\"]\",\"special\")}if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}if(isDate(t)){return r.stylize(Date.prototype.toString.call(t),\"date\")}if(isError(t)){return formatError(t)}}var p=\"\",u=false,s=[\"{\",\"}\"];if(isArray(t)){u=true;s=[\"[\",\"]\"]}if(isFunction(t)){var c=t.name?\": \"+t.name:\"\";p=\" [Function\"+c+\"]\"}if(isRegExp(t)){p=\" \"+RegExp.prototype.toString.call(t)}if(isDate(t)){p=\" \"+Date.prototype.toUTCString.call(t)}if(isError(t)){p=\" \"+formatError(t)}if(a.length===0&&(!u||t.length==0)){return s[0]+p+s[1]}if(o<0){if(isRegExp(t)){return r.stylize(RegExp.prototype.toString.call(t),\"regexp\")}else{return r.stylize(\"[Object]\",\"special\")}}r.seen.push(t);var l;if(u){l=formatArray(r,t,o,y,a)}else{l=a.map((function(e){return formatProperty(r,t,o,y,e,u)}))}r.seen.pop();return reduceToSingleString(l,p,s)}function formatPrimitive(r,e){if(isUndefined(e))return r.stylize(\"undefined\",\"undefined\");if(isString(e)){var t=\"'\"+JSON.stringify(e).replace(/^\"|\"$/g,\"\").replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"')+\"'\";return r.stylize(t,\"string\")}if(isNumber(e))return r.stylize(\"\"+e,\"number\");if(isBoolean(e))return r.stylize(\"\"+e,\"boolean\");if(isNull(e))return r.stylize(\"null\",\"null\")}function formatError(r){return\"[\"+Error.prototype.toString.call(r)+\"]\"}function formatArray(r,e,t,o,n){var i=[];for(var a=0,y=e.length;a<y;++a){if(hasOwnProperty(e,String(a))){i.push(formatProperty(r,e,t,o,String(a),true))}else{i.push(\"\")}}n.forEach((function(n){if(!n.match(/^\\d+$/)){i.push(formatProperty(r,e,t,o,n,true))}}));return i}function formatProperty(r,e,t,o,n,i){var a,y,f;f=Object.getOwnPropertyDescriptor(e,n)||{value:e[n]};if(f.get){if(f.set){y=r.stylize(\"[Getter/Setter]\",\"special\")}else{y=r.stylize(\"[Getter]\",\"special\")}}else{if(f.set){y=r.stylize(\"[Setter]\",\"special\")}}if(!hasOwnProperty(o,n)){a=\"[\"+n+\"]\"}if(!y){if(r.seen.indexOf(f.value)<0){if(isNull(t)){y=formatValue(r,f.value,null)}else{y=formatValue(r,f.value,t-1)}if(y.indexOf(\"\\n\")>-1){if(i){y=y.split(\"\\n\").map((function(r){return\"  \"+r})).join(\"\\n\").substr(2)}else{y=\"\\n\"+y.split(\"\\n\").map((function(r){return\"   \"+r})).join(\"\\n\")}}}else{y=r.stylize(\"[Circular]\",\"special\")}}if(isUndefined(a)){if(i&&n.match(/^\\d+$/)){return y}a=JSON.stringify(\"\"+n);if(a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)){a=a.substr(1,a.length-2);a=r.stylize(a,\"name\")}else{a=a.replace(/'/g,\"\\\\'\").replace(/\\\\\"/g,'\"').replace(/(^\"|\"$)/g,\"'\");a=r.stylize(a,\"string\")}}return a+\": \"+y}function reduceToSingleString(r,e,t){var o=0;var n=r.reduce((function(r,e){o++;if(e.indexOf(\"\\n\")>=0)o++;return r+e.replace(/\\u001b\\[\\d\\d?m/g,\"\").length+1}),0);if(n>60){return t[0]+(e===\"\"?\"\":e+\"\\n \")+\" \"+r.join(\",\\n  \")+\" \"+t[1]}return t[0]+e+\" \"+r.join(\", \")+\" \"+t[1]}e.types=t(584);function isArray(r){return Array.isArray(r)}e.isArray=isArray;function isBoolean(r){return typeof r===\"boolean\"}e.isBoolean=isBoolean;function isNull(r){return r===null}e.isNull=isNull;function isNullOrUndefined(r){return r==null}e.isNullOrUndefined=isNullOrUndefined;function isNumber(r){return typeof r===\"number\"}e.isNumber=isNumber;function isString(r){return typeof r===\"string\"}e.isString=isString;function isSymbol(r){return typeof r===\"symbol\"}e.isSymbol=isSymbol;function isUndefined(r){return r===void 0}e.isUndefined=isUndefined;function isRegExp(r){return isObject(r)&&objectToString(r)===\"[object RegExp]\"}e.isRegExp=isRegExp;e.types.isRegExp=isRegExp;function isObject(r){return typeof r===\"object\"&&r!==null}e.isObject=isObject;function isDate(r){return isObject(r)&&objectToString(r)===\"[object Date]\"}e.isDate=isDate;e.types.isDate=isDate;function isError(r){return isObject(r)&&(objectToString(r)===\"[object Error]\"||r instanceof Error)}e.isError=isError;e.types.isNativeError=isError;function isFunction(r){return typeof r===\"function\"}e.isFunction=isFunction;function isPrimitive(r){return r===null||typeof r===\"boolean\"||typeof r===\"number\"||typeof r===\"string\"||typeof r===\"symbol\"||typeof r===\"undefined\"}e.isPrimitive=isPrimitive;e.isBuffer=t(369);function objectToString(r){return Object.prototype.toString.call(r)}function pad(r){return r<10?\"0\"+r.toString(10):r.toString(10)}var f=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];function timestamp(){var r=new Date;var e=[pad(r.getHours()),pad(r.getMinutes()),pad(r.getSeconds())].join(\":\");return[r.getDate(),f[r.getMonth()],e].join(\" \")}e.log=function(){console.log(\"%s - %s\",timestamp(),e.format.apply(e,arguments))};e.inherits=t(782);e._extend=function(r,e){if(!e||!isObject(e))return r;var t=Object.keys(e);var o=t.length;while(o--){r[t[o]]=e[t[o]]}return r};function hasOwnProperty(r,e){return Object.prototype.hasOwnProperty.call(r,e)}var p=typeof Symbol!==\"undefined\"?Symbol(\"util.promisify.custom\"):undefined;e.promisify=function promisify(r){if(typeof r!==\"function\")throw new TypeError('The \"original\" argument must be of type Function');if(p&&r[p]){var e=r[p];if(typeof e!==\"function\"){throw new TypeError('The \"util.promisify.custom\" argument must be of type Function')}Object.defineProperty(e,p,{value:e,enumerable:false,writable:false,configurable:true});return e}function e(){var e,t;var o=new Promise((function(r,o){e=r;t=o}));var n=[];for(var i=0;i<arguments.length;i++){n.push(arguments[i])}n.push((function(r,o){if(r){t(r)}else{e(o)}}));try{r.apply(this,n)}catch(r){t(r)}return o}Object.setPrototypeOf(e,Object.getPrototypeOf(r));if(p)Object.defineProperty(e,p,{value:e,enumerable:false,writable:false,configurable:true});return Object.defineProperties(e,o(r))};e.promisify.custom=p;function callbackifyOnRejected(r,e){if(!r){var t=new Error(\"Promise was rejected with a falsy value\");t.reason=r;r=t}return e(r)}function callbackify(r){if(typeof r!==\"function\"){throw new TypeError('The \"original\" argument must be of type Function')}function callbackified(){var e=[];for(var t=0;t<arguments.length;t++){e.push(arguments[t])}var o=e.pop();if(typeof o!==\"function\"){throw new TypeError(\"The last argument must be of type Function\")}var n=this;var cb=function(){return o.apply(n,arguments)};r.apply(this,e).then((function(r){process.nextTick(cb.bind(null,null,r))}),(function(r){process.nextTick(callbackifyOnRejected.bind(null,r,cb))}))}Object.setPrototypeOf(callbackified,Object.getPrototypeOf(r));Object.defineProperties(callbackified,o(r));return callbackified}e.callbackify=callbackify},490:function(r,e,t){\"use strict\";var o=t(144);var n=t(349);var i=t(256);var a=i(\"Object.prototype.toString\");var y=t(942)();var f=y&&typeof Symbol.toStringTag===\"symbol\";var p=n();var u=i(\"String.prototype.slice\");var s={};var c=t(24);var l=Object.getPrototypeOf;if(f&&c&&l){o(p,(function(r){if(typeof __webpack_require__.g[r]===\"function\"){var e=new __webpack_require__.g[r];if(!(Symbol.toStringTag in e)){throw new EvalError(\"this engine has support for Symbol.toStringTag, but \"+r+\" does not have the property! Please report this.\")}var t=l(e);var o=c(t,Symbol.toStringTag);if(!o){var n=l(t);o=c(n,Symbol.toStringTag)}s[r]=o.get}}))}var d=function tryAllTypedArrays(r){var e=false;o(s,(function(t,o){if(!e){try{var n=t.call(r);if(n===o){e=n}}catch(r){}}}));return e};var g=t(994);r.exports=function whichTypedArray(r){if(!g(r)){return false}if(!f){return u(a(r),8,-1)}return d(r)}},349:function(r,e,t){\"use strict\";var o=t(992);r.exports=function availableTypedArrays(){return o([\"BigInt64Array\",\"BigUint64Array\",\"Float32Array\",\"Float64Array\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\"],(function(r){return typeof __webpack_require__.g[r]===\"function\"}))}},24:function(r,e,t){\"use strict\";var o=t(500);var n=o(\"%Object.getOwnPropertyDescriptor%\",true);if(n){try{n([],\"length\")}catch(r){n=null}}r.exports=n}};var e={};function __nccwpck_require__(t){var o=e[t];if(o!==undefined){return o.exports}var n=e[t]={exports:{}};var i=true;try{r[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete e[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(177);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBLFlBQVksT0FBTyxnQkFBZ0IsMEJBQTBCLGlDQUFpQyw0Q0FBNEMsNENBQTRDLFNBQVMsWUFBWSxXQUFXLEtBQUsseUJBQXlCLFdBQVcsNkJBQTZCLFVBQVUsc0NBQXNDLHFCQUFxQixhQUFhLGFBQWEsYUFBYSx1Q0FBdUMsMkNBQTJDLGVBQWUsaURBQWlELFlBQVksVUFBVSxxQkFBcUIsYUFBYSxhQUFhLGFBQWEsc0NBQXNDLHFDQUFxQyw2Q0FBNkMsa0RBQWtELHdDQUF3QyxzQkFBc0IsTUFBTSxJQUFJLElBQUksTUFBTSxRQUFRLEVBQUUsU0FBUyxRQUFRLCtCQUErQix1QkFBdUIsU0FBUyxvQkFBb0IsbUJBQW1CLGNBQWMsMkNBQTJDLEdBQUcsVUFBVSwyQkFBMkIseUJBQXlCLE1BQU0scUJBQXFCLFFBQVEsRUFBRSxLQUFLLG1CQUFtQixpQkFBaUIsc0NBQXNDLGdDQUFnQyxrQ0FBa0Msb0NBQW9DLG1EQUFtRCxlQUFlLFdBQVcsWUFBWSxJQUFJLEtBQUssb0JBQW9CLEtBQUssZ0JBQWdCLGdCQUFnQix1QkFBdUIsaUJBQWlCLGFBQWEsd0RBQXdELDRCQUE0QixnQ0FBZ0MsMEJBQTBCLDJCQUEyQixXQUFXLHlDQUF5Qyx5QkFBeUIsMEJBQTBCLE1BQU0sc0JBQXNCLHNCQUFzQixnREFBZ0Qsa0JBQWtCLFNBQVMsWUFBWSxLQUFLLGdEQUFnRCxvQ0FBb0MsU0FBUyxZQUFZLElBQUksS0FBSyxjQUFjLHdEQUF3RCxzQ0FBc0MsV0FBVyxnQkFBZ0IseUJBQXlCLHdCQUF3QixrQkFBa0IsaUJBQWlCLFVBQVUscUJBQXFCLGFBQWEsYUFBYSxxQ0FBcUMscUJBQXFCLGFBQWEsTUFBTSxrQkFBa0IsZUFBZSxnQkFBZ0Isc0NBQXNDLElBQUksd0JBQXdCLDJCQUEyQixLQUFLLFlBQVksc0NBQXNDLE1BQU0sSUFB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X0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz8xZjhlIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTI6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxvKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxvKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbj1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG8sYSxpLHIpKW4ucHVzaChhKX1yZXR1cm4gbn07dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMjU2OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDkyNSk7dmFyIG49dCgxMzkpO3ZhciBpPW4obyhcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW8ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG4odCl9cmV0dXJuIHR9fSwxMzk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTt2YXIgbj10KDkyNSk7dmFyIGk9bihcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW4oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciB5PW4oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8by5jYWxsKGEsaSk7dmFyIGY9bihcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBwPW4oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciB1PW4oXCIlTWF0aC5tYXglXCIpO2lmKHApe3RyeXtwKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cD1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9eShvLGEsYXJndW1lbnRzKTtpZihmJiZwKXt2YXIgdD1mKGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3AoZSxcImxlbmd0aFwiLHt2YWx1ZToxK3UoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciBzPWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiB5KG8saSxhcmd1bWVudHMpfTtpZihwKXtwKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnN9KX1lbHNle3IuZXhwb3J0cy5hcHBseT1zfX0sMTQ0OmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG8sbil7aWYodC5jYWxsKG8pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7by5jYWxsKG4sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgeSBpbiByKXtpZihlLmNhbGwocix5KSl7by5jYWxsKG4sclt5XSx5LHIpfX19fX0sNDI2OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8by5jYWxsKGkpIT09bil7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIHk7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB5KXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciBmPU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBwPVtdO2Zvcih2YXIgdT0wO3U8Zjt1Kyspe3AucHVzaChcIiRcIit1KX15PUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Auam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgcz1mdW5jdGlvbiBFbXB0eSgpe307cy5wcm90b3R5cGU9aS5wcm90b3R5cGU7eS5wcm90b3R5cGU9bmV3IHM7cy5wcm90b3R5cGU9bnVsbH1yZXR1cm4geX19LDE3NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg0MjYpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8b30sNTAwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbzt2YXIgbj1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIHk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZih5KXt0cnl7eSh7fSxcIlwiKX1jYXRjaChyKXt5PW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgZj15P2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4geShhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBwPXQoMTE1KSgpO3ZhciB1PU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgcz17fTt2YXIgYz10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzp1KFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOnMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6cyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpzLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bzpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP286RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bzpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KHUoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6byxcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm8sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP286TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpvLFwiJVN5bWJvbCVcIjpwP1N5bWJvbDpvLFwiJVN5bnRheEVycm9yJVwiOm4sXCIlVGhyb3dUeXBlRXJyb3IlXCI6ZixcIiVUeXBlZEFycmF5JVwiOmMsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP286V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9vOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bzpXZWFrU2V0fTt2YXIgZD1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG89ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihvKXtlPXUoby5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBnPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgdj10KDE3NCk7dmFyIGI9dCgxMDEpO3ZhciBBPXYuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBtPXYuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgUz12LmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPXYuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBQPXYuY2FsbChGdW5jdGlvbi5jYWxsLFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7dmFyIE89L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIHc9L1xcXFwoXFxcXCk/L2c7dmFyIGo9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBuKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG89W107UyhyLE8sKGZ1bmN0aW9uKHIsZSx0LG4pe29bby5sZW5ndGhdPXQ/UyhuLHcsXCIkMVwiKTplfHxyfSkpO3JldHVybiBvfTt2YXIgRT1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbztpZihiKGcsdCkpe289Z1t0XTt0PVwiJVwiK29bMF0rXCIlXCJ9aWYoYihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1zKXtpPWQodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm8sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBuKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfWlmKFAoL14lP1teJV0qJT8kL2cscik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9aihyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1FKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07bSh0LEEoWzAsMV0sYykpfWZvcih2YXIgZD0xLGc9dHJ1ZTtkPHQubGVuZ3RoO2QrPTEpe3ZhciB2PXRbZF07dmFyIFM9aCh2LDAsMSk7dmFyIE89aCh2LC0xKTtpZigoUz09PSdcIid8fFM9PT1cIidcInx8Uz09PVwiYFwifHwoTz09PSdcIid8fE89PT1cIidcInx8Tz09PVwiYFwiKSkmJlMhPT1PKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihiKGwscCkpe3U9bFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmZCsxPj10Lmxlbmd0aCl7dmFyIHc9eSh1LHYpO2c9ISF3O2lmKGcmJlwiZ2V0XCJpbiB3JiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gdy5nZXQpKXt1PXcuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9Yih1LHYpO3U9dVt2XX1pZihnJiYhcyl7bFtwXT11fX19cmV0dXJuIHV9fSw5MjU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvO3ZhciBuPVN5bnRheEVycm9yO3ZhciBpPUZ1bmN0aW9uO3ZhciBhPVR5cGVFcnJvcjt2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yPWZ1bmN0aW9uKHIpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytyK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChyKXt9fTt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2lmKHkpe3RyeXt5KHt9LFwiXCIpfWNhdGNoKHIpe3k9bnVsbH19dmFyIHRocm93VHlwZUVycm9yPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IGF9O3ZhciBmPXk/ZnVuY3Rpb24oKXt0cnl7YXJndW1lbnRzLmNhbGxlZTtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9Y2F0Y2gocil7dHJ5e3JldHVybiB5KGFyZ3VtZW50cyxcImNhbGxlZVwiKS5nZXR9Y2F0Y2gocil7cmV0dXJuIHRocm93VHlwZUVycm9yfX19KCk6dGhyb3dUeXBlRXJyb3I7dmFyIHA9dCgxMTUpKCk7dmFyIHU9dCg1MDQpKCk7dmFyIHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHwodT9mdW5jdGlvbihyKXtyZXR1cm4gci5fX3Byb3RvX199Om51bGwpO3ZhciBjPXt9O3ZhciBsPXR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcInx8IXM/bzpzKFVpbnQ4QXJyYXkpO3ZhciBkPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cCYmcz9zKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOmMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6YyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOmMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpjLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQmlnSW50NjRBcnJheSVcIjp0eXBlb2YgQmlnSW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQ2NEFycmF5LFwiJUJpZ1VpbnQ2NEFycmF5JVwiOnR5cGVvZiBCaWdVaW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdVaW50NjRBcnJheSxcIiVCb29sZWFuJVwiOkJvb2xlYW4sXCIlRGF0YVZpZXclXCI6dHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIj9vOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjp0eXBlb2YgRmxvYXQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkZsb2F0MzJBcnJheSxcIiVGbG9hdDY0QXJyYXklXCI6dHlwZW9mIEZsb2F0NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDY0QXJyYXksXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5PT09XCJ1bmRlZmluZWRcIj9vOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVJbnQ4QXJyYXklXCI6dHlwZW9mIEludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQ4QXJyYXksXCIlSW50MTZBcnJheSVcIjp0eXBlb2YgSW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQxNkFycmF5LFwiJUludDMyQXJyYXklXCI6dHlwZW9mIEludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjpwJiZzP3MocyhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpvLFwiJUpTT04lXCI6dHlwZW9mIEpTT049PT1cIm9iamVjdFwiP0pTT046byxcIiVNYXAlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCI/bzpNYXAsXCIlTWFwSXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCJ8fCFwfHwhcz9vOnMoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcHx8IXM/bzpzKChuZXcgU2V0KVtTeW1ib2wuaXRlcmF0b3JdKCkpLFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOnR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCI/bzpTaGFyZWRBcnJheUJ1ZmZlcixcIiVTdHJpbmclXCI6U3RyaW5nLFwiJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVwiOnAmJnM/cyhcIlwiW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVTeW1ib2wlXCI6cD9TeW1ib2w6byxcIiVTeW50YXhFcnJvciVcIjpuLFwiJVRocm93VHlwZUVycm9yJVwiOmYsXCIlVHlwZWRBcnJheSVcIjpsLFwiJVR5cGVFcnJvciVcIjphLFwiJVVpbnQ4QXJyYXklXCI6dHlwZW9mIFVpbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhBcnJheSxcIiVVaW50OENsYW1wZWRBcnJheSVcIjp0eXBlb2YgVWludDhDbGFtcGVkQXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhDbGFtcGVkQXJyYXksXCIlVWludDE2QXJyYXklXCI6dHlwZW9mIFVpbnQxNkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQxNkFycmF5LFwiJVVpbnQzMkFycmF5JVwiOnR5cGVvZiBVaW50MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50MzJBcnJheSxcIiVVUklFcnJvciVcIjpVUklFcnJvcixcIiVXZWFrTWFwJVwiOnR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIj9vOldlYWtNYXAsXCIlV2Vha1JlZiVcIjp0eXBlb2YgV2Vha1JlZj09PVwidW5kZWZpbmVkXCI/bzpXZWFrUmVmLFwiJVdlYWtTZXQlXCI6dHlwZW9mIFdlYWtTZXQ9PT1cInVuZGVmaW5lZFwiP286V2Vha1NldH07aWYocyl7dHJ5e251bGwuZXJyb3J9Y2F0Y2gocil7dmFyIGc9cyhzKHIpKTtkW1wiJUVycm9yLnByb3RvdHlwZSVcIl09Z319dmFyIHY9ZnVuY3Rpb24gZG9FdmFsKHIpe3ZhciBlO2lmKHI9PT1cIiVBc3luY0Z1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvciVcIil7dmFyIHQ9ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpO2lmKHQpe2U9dC5wcm90b3R5cGV9fWVsc2UgaWYocj09PVwiJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlXCIpe3ZhciBvPWRvRXZhbChcIiVBc3luY0dlbmVyYXRvciVcIik7aWYobyYmcyl7ZT1zKG8ucHJvdG90eXBlKX19ZFtyXT1lO3JldHVybiBlfTt2YXIgYj17XCIlQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvdHlwZSVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG9fZW50cmllcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJlbnRyaWVzXCJdLFwiJUFycmF5UHJvdG9fZm9yRWFjaCVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJmb3JFYWNoXCJdLFwiJUFycmF5UHJvdG9fa2V5cyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJrZXlzXCJdLFwiJUFycmF5UHJvdG9fdmFsdWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcInZhbHVlc1wiXSxcIiVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJVwiOltcIkFzeW5jRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvciVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlQm9vbGVhblByb3RvdHlwZSVcIjpbXCJCb29sZWFuXCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0YVZpZXdQcm90b3R5cGUlXCI6W1wiRGF0YVZpZXdcIixcInByb3RvdHlwZVwiXSxcIiVEYXRlUHJvdG90eXBlJVwiOltcIkRhdGVcIixcInByb3RvdHlwZVwiXSxcIiVFcnJvclByb3RvdHlwZSVcIjpbXCJFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUV2YWxFcnJvclByb3RvdHlwZSVcIjpbXCJFdmFsRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQ2NEFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0NjRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZ1bmN0aW9uUHJvdG90eXBlJVwiOltcIkZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVJbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSlNPTlBhcnNlJVwiOltcIkpTT05cIixcInBhcnNlXCJdLFwiJUpTT05TdHJpbmdpZnklXCI6W1wiSlNPTlwiLFwic3RyaW5naWZ5XCJdLFwiJU1hcFByb3RvdHlwZSVcIjpbXCJNYXBcIixcInByb3RvdHlwZVwiXSxcIiVOdW1iZXJQcm90b3R5cGUlXCI6W1wiTnVtYmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqZWN0UHJvdG90eXBlJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCJdLFwiJU9ialByb3RvX3RvU3RyaW5nJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ0b1N0cmluZ1wiXSxcIiVPYmpQcm90b192YWx1ZU9mJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZU9mXCJdLFwiJVByb21pc2VQcm90b3R5cGUlXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCJdLFwiJVByb21pc2VQcm90b190aGVuJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiLFwidGhlblwiXSxcIiVQcm9taXNlX2FsbCVcIjpbXCJQcm9taXNlXCIsXCJhbGxcIl0sXCIlUHJvbWlzZV9yZWplY3QlXCI6W1wiUHJvbWlzZVwiLFwicmVqZWN0XCJdLFwiJVByb21pc2VfcmVzb2x2ZSVcIjpbXCJQcm9taXNlXCIsXCJyZXNvbHZlXCJdLFwiJVJhbmdlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmFuZ2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJVwiOltcIlJlZmVyZW5jZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVnRXhwUHJvdG90eXBlJVwiOltcIlJlZ0V4cFwiLFwicHJvdG90eXBlXCJdLFwiJVNldFByb3RvdHlwZSVcIjpbXCJTZXRcIixcInByb3RvdHlwZVwiXSxcIiVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJTaGFyZWRBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJVN0cmluZ1Byb3RvdHlwZSVcIjpbXCJTdHJpbmdcIixcInByb3RvdHlwZVwiXSxcIiVTeW1ib2xQcm90b3R5cGUlXCI6W1wiU3ltYm9sXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ludGF4RXJyb3JQcm90b3R5cGUlXCI6W1wiU3ludGF4RXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlR5cGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlRXJyb3JQcm90b3R5cGUlXCI6W1wiVHlwZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhDbGFtcGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVVJJRXJyb3JQcm90b3R5cGUlXCI6W1wiVVJJRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrTWFwUHJvdG90eXBlJVwiOltcIldlYWtNYXBcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrU2V0UHJvdG90eXBlJVwiOltcIldlYWtTZXRcIixcInByb3RvdHlwZVwiXX07dmFyIEE9dCgxNzQpO3ZhciBtPXQoMTAxKTt2YXIgUz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxBcnJheS5wcm90b3R5cGUuY29uY2F0KTt2YXIgaD1BLmNhbGwoRnVuY3Rpb24uYXBwbHksQXJyYXkucHJvdG90eXBlLnNwbGljZSk7dmFyIFA9QS5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTt2YXIgTz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnNsaWNlKTt2YXIgdz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxSZWdFeHAucHJvdG90eXBlLmV4ZWMpO3ZhciBqPS9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO3ZhciBFPS9cXFxcKFxcXFwpPy9nO3ZhciBJPWZ1bmN0aW9uIHN0cmluZ1RvUGF0aChyKXt2YXIgZT1PKHIsMCwxKTt2YXIgdD1PKHIsLTEpO2lmKGU9PT1cIiVcIiYmdCE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIil9ZWxzZSBpZih0PT09XCIlXCImJmUhPT1cIiVcIil7dGhyb3cgbmV3IG4oXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpfXZhciBvPVtdO1AocixqLChmdW5jdGlvbihyLGUsdCxuKXtvW28ubGVuZ3RoXT10P1AobixFLFwiJDFcIik6ZXx8cn0pKTtyZXR1cm4gb307dmFyIEI9ZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhyLGUpe3ZhciB0PXI7dmFyIG87aWYobShiLHQpKXtvPWJbdF07dD1cIiVcIitvWzBdK1wiJVwifWlmKG0oZCx0KSl7dmFyIGk9ZFt0XTtpZihpPT09Yyl7aT12KHQpfWlmKHR5cGVvZiBpPT09XCJ1bmRlZmluZWRcIiYmIWUpe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIFwiK3IrXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpfXJldHVybnthbGlhczpvLG5hbWU6dCx2YWx1ZTppfX10aHJvdyBuZXcgbihcImludHJpbnNpYyBcIityK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07ci5leHBvcnRzPWZ1bmN0aW9uIEdldEludHJpbnNpYyhyLGUpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8ci5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgYShcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWlmKGFyZ3VtZW50cy5sZW5ndGg+MSYmdHlwZW9mIGUhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IGEoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKX1pZih3KC9eJT9bXiVdKiU/JC8scik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9SShyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1CKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07aCh0LFMoWzAsMV0sYykpfWZvcih2YXIgbD0xLGc9dHJ1ZTtsPHQubGVuZ3RoO2wrPTEpe3ZhciB2PXRbbF07dmFyIGI9Tyh2LDAsMSk7dmFyIEE9Tyh2LC0xKTtpZigoYj09PSdcIid8fGI9PT1cIidcInx8Yj09PVwiYFwifHwoQT09PSdcIid8fEE9PT1cIidcInx8QT09PVwiYFwiKSkmJmIhPT1BKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihtKGQscCkpe3U9ZFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmbCsxPj10Lmxlbmd0aCl7dmFyIFA9eSh1LHYpO2c9ISFQO2lmKGcmJlwiZ2V0XCJpbiBQJiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gUC5nZXQpKXt1PVAuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9bSh1LHYpO3U9dVt2XX1pZihnJiYhcyl7ZFtwXT11fX19cmV0dXJuIHV9fSw1MDQ6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e2Zvbzp7fX07dmFyIHQ9T2JqZWN0O3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNQcm90bygpe3JldHVybntfX3Byb3RvX186ZX0uZm9vPT09ZS5mb28mJiEoe19fcHJvdG9fXzpudWxsfWluc3RhbmNlb2YgdCl9fSw5NDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg3NzMpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sNzczOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMTU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg4MzIpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sODMyOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMDE6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTtyLmV4cG9ydHM9by5jYWxsKEZ1bmN0aW9uLmNhbGwsT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl9LDc4MjpmdW5jdGlvbihyKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTtyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9ZS5wcm90b3R5cGU7ci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJ9fX19LDE1NzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKGUmJnImJnR5cGVvZiByPT09XCJvYmplY3RcIiYmU3ltYm9sLnRvU3RyaW5nVGFnIGluIHIpe3JldHVybiBmYWxzZX1yZXR1cm4gdC5jYWxsKHIpPT09XCJbb2JqZWN0IEFyZ3VtZW50c11cIn07dmFyIG49ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYobyhyKSl7cmV0dXJuIHRydWV9cmV0dXJuIHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLmxlbmd0aD09PVwibnVtYmVyXCImJnIubGVuZ3RoPj0wJiZ0LmNhbGwocikhPT1cIltvYmplY3QgQXJyYXldXCImJnQuY2FsbChyLmNhbGxlZSk9PT1cIltvYmplY3QgRnVuY3Rpb25dXCJ9O3ZhciBpPWZ1bmN0aW9uKCl7cmV0dXJuIG8oYXJndW1lbnRzKX0oKTtvLmlzTGVnYWN5QXJndW1lbnRzPW47ci5leHBvcnRzPWk/bzpufSwzOTE6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgdD1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG89L15cXHMqKD86ZnVuY3Rpb24pP1xcKi87dmFyIG49dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mO3ZhciBnZXRHZW5lcmF0b3JGdW5jPWZ1bmN0aW9uKCl7aWYoIW4pe3JldHVybiBmYWxzZX10cnl7cmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uKigpIHt9XCIpKCl9Y2F0Y2gocil7fX07dmFyIGE9Z2V0R2VuZXJhdG9yRnVuYygpO3ZhciB5PWE/aShhKTp7fTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKG8udGVzdCh0LmNhbGwocikpKXtyZXR1cm4gdHJ1ZX1pZighbil7dmFyIGE9ZS5jYWxsKHIpO3JldHVybiBhPT09XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwifXJldHVybiBpKHIpPT09eX19LDk5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCgxNDQpO3ZhciBuPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIHk9dCg5NDIpKCk7dmFyIGY9eSYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHA9bigpO3ZhciB1PWkoXCJBcnJheS5wcm90b3R5cGUuaW5kZXhPZlwiLHRydWUpfHxmdW5jdGlvbiBpbmRleE9mKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kz0xKXtpZihyW3RdPT09ZSl7cmV0dXJuIHR9fXJldHVybi0xfTt2YXIgcz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgYz17fTt2YXIgbD10KDI0KTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYoZiYmbCYmZCl7byhwLChmdW5jdGlvbihyKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9ZChlKTt2YXIgbz1sKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbyl7dmFyIG49ZCh0KTtvPWwobixTeW1ib2wudG9TdHJpbmdUYWcpfWNbcl09by5nZXR9KSl9dmFyIGc9ZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXMocil7dmFyIGU9ZmFsc2U7byhjLChmdW5jdGlvbih0LG8pe2lmKCFlKXt0cnl7ZT10LmNhbGwocik9PT1vfWNhdGNoKHIpe319fSkpO3JldHVybiBlfTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNUeXBlZEFycmF5KHIpe2lmKCFyfHx0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX1pZighZil7dmFyIGU9cyhhKHIpLDgsLTEpO3JldHVybiB1KHAsZSk+LTF9aWYoIWwpe3JldHVybiBmYWxzZX1yZXR1cm4gZyhyKX19LDM2OTpmdW5jdGlvbihyKXtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNCdWZmZXIocil7cmV0dXJuIHIgaW5zdGFuY2VvZiBCdWZmZXJ9fSw1ODQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTU3KTt2YXIgbj10KDM5MSk7dmFyIGk9dCg0OTApO3ZhciBhPXQoOTk0KTtmdW5jdGlvbiB1bmN1cnJ5VGhpcyhyKXtyZXR1cm4gci5jYWxsLmJpbmQocil9dmFyIHk9dHlwZW9mIEJpZ0ludCE9PVwidW5kZWZpbmVkXCI7dmFyIGY9dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCI7dmFyIHA9dW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7dmFyIHU9dW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTt2YXIgcz11bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO3ZhciBjPXVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO2lmKHkpe3ZhciBsPXVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZil9aWYoZil7dmFyIGQ9dW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKX1mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHIsZSl7aWYodHlwZW9mIHIhPT1cIm9iamVjdFwiKXtyZXR1cm4gZmFsc2V9dHJ5e2Uocik7cmV0dXJuIHRydWV9Y2F0Y2gocil7cmV0dXJuIGZhbHNlfX1lLmlzQXJndW1lbnRzT2JqZWN0PW87ZS5pc0dlbmVyYXRvckZ1bmN0aW9uPW47ZS5pc1R5cGVkQXJyYXk9YTtmdW5jdGlvbiBpc1Byb21pc2Uocil7cmV0dXJuIHR5cGVvZiBQcm9taXNlIT09XCJ1bmRlZmluZWRcIiYmciBpbnN0YW5jZW9mIFByb21pc2V8fHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLnRoZW49PT1cImZ1bmN0aW9uXCImJnR5cGVvZiByLmNhdGNoPT09XCJmdW5jdGlvblwifWUuaXNQcm9taXNlPWlzUHJvbWlzZTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhyKXtpZih0eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZBcnJheUJ1ZmZlci5pc1ZpZXcpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcocil9cmV0dXJuIGEocil8fGlzRGF0YVZpZXcocil9ZS5pc0FycmF5QnVmZmVyVmlldz1pc0FycmF5QnVmZmVyVmlldztmdW5jdGlvbiBpc1VpbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQ4QXJyYXlcIn1lLmlzVWludDhBcnJheT1pc1VpbnQ4QXJyYXk7ZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhDbGFtcGVkQXJyYXlcIn1lLmlzVWludDhDbGFtcGVkQXJyYXk9aXNVaW50OENsYW1wZWRBcnJheTtmdW5jdGlvbiBpc1VpbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50MTZBcnJheVwifWUuaXNVaW50MTZBcnJheT1pc1VpbnQxNkFycmF5O2Z1bmN0aW9uIGlzVWludDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQzMkFycmF5XCJ9ZS5pc1VpbnQzMkFycmF5PWlzVWludDMyQXJyYXk7ZnVuY3Rpb24gaXNJbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDhBcnJheVwifWUuaXNJbnQ4QXJyYXk9aXNJbnQ4QXJyYXk7ZnVuY3Rpb24gaXNJbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQxNkFycmF5XCJ9ZS5pc0ludDE2QXJyYXk9aXNJbnQxNkFycmF5O2Z1bmN0aW9uIGlzSW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50MzJBcnJheVwifWUuaXNJbnQzMkFycmF5PWlzSW50MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQzMkFycmF5XCJ9ZS5pc0Zsb2F0MzJBcnJheT1pc0Zsb2F0MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQ2NEFycmF5XCJ9ZS5pc0Zsb2F0NjRBcnJheT1pc0Zsb2F0NjRBcnJheTtmdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkJpZ0ludDY0QXJyYXlcIn1lLmlzQmlnSW50NjRBcnJheT1pc0JpZ0ludDY0QXJyYXk7ZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnVWludDY0QXJyYXlcIn1lLmlzQmlnVWludDY0QXJyYXk9aXNCaWdVaW50NjRBcnJheTtmdW5jdGlvbiBpc01hcFRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcF1cIn1pc01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIE1hcCE9PVwidW5kZWZpbmVkXCImJmlzTWFwVG9TdHJpbmcobmV3IE1hcCk7ZnVuY3Rpb24gaXNNYXAocil7aWYodHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nP2lzTWFwVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIE1hcH1lLmlzTWFwPWlzTWFwO2Z1bmN0aW9uIGlzU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgU2V0XVwifWlzU2V0VG9TdHJpbmcud29ya2luZz10eXBlb2YgU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNTZXRUb1N0cmluZyhuZXcgU2V0KTtmdW5jdGlvbiBpc1NldChyKXtpZih0eXBlb2YgU2V0PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmc/aXNTZXRUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgU2V0fWUuaXNTZXQ9aXNTZXQ7ZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha01hcF1cIn1pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXApO2Z1bmN0aW9uIGlzV2Vha01hcChyKXtpZih0eXBlb2YgV2Vha01hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZz9pc1dlYWtNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgV2Vha01hcH1lLmlzV2Vha01hcD1pc1dlYWtNYXA7ZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha1NldF1cIn1pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQpO2Z1bmN0aW9uIGlzV2Vha1NldChyKXtyZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcocil9ZS5pc1dlYWtTZXQ9aXNXZWFrU2V0O2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIn1pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcn1lLmlzQXJyYXlCdWZmZXI9aXNBcnJheUJ1ZmZlcjtmdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgRGF0YVZpZXddXCJ9aXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc9dHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIERhdGFWaWV3IT09XCJ1bmRlZmluZWRcIiYmaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksMCwxKSk7ZnVuY3Rpb24gaXNEYXRhVmlldyhyKXtpZih0eXBlb2YgRGF0YVZpZXc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nP2lzRGF0YVZpZXdUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgRGF0YVZpZXd9ZS5pc0RhdGFWaWV3PWlzRGF0YVZpZXc7dmFyIGc9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIj9TaGFyZWRBcnJheUJ1ZmZlcjp1bmRlZmluZWQ7ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXVwifWZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIGc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPT09XCJ1bmRlZmluZWRcIil7aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBnKX1yZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBnfWUuaXNTaGFyZWRBcnJheUJ1ZmZlcj1pc1NoYXJlZEFycmF5QnVmZmVyO2Z1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbihyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwifWUuaXNBc3luY0Z1bmN0aW9uPWlzQXN5bmNGdW5jdGlvbjtmdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcCBJdGVyYXRvcl1cIn1lLmlzTWFwSXRlcmF0b3I9aXNNYXBJdGVyYXRvcjtmdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNldCBJdGVyYXRvcl1cIn1lLmlzU2V0SXRlcmF0b3I9aXNTZXRJdGVyYXRvcjtmdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdChyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBHZW5lcmF0b3JdXCJ9ZS5pc0dlbmVyYXRvck9iamVjdD1pc0dlbmVyYXRvck9iamVjdDtmdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXVwifWUuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlPWlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtmdW5jdGlvbiBpc051bWJlck9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLHUpfWUuaXNOdW1iZXJPYmplY3Q9aXNOdW1iZXJPYmplY3Q7ZnVuY3Rpb24gaXNTdHJpbmdPYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixzKX1lLmlzU3RyaW5nT2JqZWN0PWlzU3RyaW5nT2JqZWN0O2Z1bmN0aW9uIGlzQm9vbGVhbk9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGMpfWUuaXNCb29sZWFuT2JqZWN0PWlzQm9vbGVhbk9iamVjdDtmdW5jdGlvbiBpc0JpZ0ludE9iamVjdChyKXtyZXR1cm4geSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGwpfWUuaXNCaWdJbnRPYmplY3Q9aXNCaWdJbnRPYmplY3Q7ZnVuY3Rpb24gaXNTeW1ib2xPYmplY3Qocil7cmV0dXJuIGYmJmNoZWNrQm94ZWRQcmltaXRpdmUocixkKX1lLmlzU3ltYm9sT2JqZWN0PWlzU3ltYm9sT2JqZWN0O2Z1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUocil7cmV0dXJuIGlzTnVtYmVyT2JqZWN0KHIpfHxpc1N0cmluZ09iamVjdChyKXx8aXNCb29sZWFuT2JqZWN0KHIpfHxpc0JpZ0ludE9iamVjdChyKXx8aXNTeW1ib2xPYmplY3Qocil9ZS5pc0JveGVkUHJpbWl0aXZlPWlzQm94ZWRQcmltaXRpdmU7ZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcihyKXtyZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiJiYoaXNBcnJheUJ1ZmZlcihyKXx8aXNTaGFyZWRBcnJheUJ1ZmZlcihyKSl9ZS5pc0FueUFycmF5QnVmZmVyPWlzQW55QXJyYXlCdWZmZXI7W1wiaXNQcm94eVwiLFwiaXNFeHRlcm5hbFwiLFwiaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcIl0uZm9yRWFjaCgoZnVuY3Rpb24ocil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTpmYWxzZSx2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihyK1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmRcIil9fSl9KSl9LDE3NzpmdW5jdGlvbihyLGUsdCl7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocil7dmFyIGU9T2JqZWN0LmtleXMocik7dmFyIHQ9e307Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspe3RbZVtvXV09T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGVbb10pfXJldHVybiB0fTt2YXIgbj0vJVtzZGolXS9nO2UuZm9ybWF0PWZ1bmN0aW9uKHIpe2lmKCFpc1N0cmluZyhyKSl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZS5wdXNoKGluc3BlY3QoYXJndW1lbnRzW3RdKSl9cmV0dXJuIGUuam9pbihcIiBcIil9dmFyIHQ9MTt2YXIgbz1hcmd1bWVudHM7dmFyIGk9by5sZW5ndGg7dmFyIGE9U3RyaW5nKHIpLnJlcGxhY2UobiwoZnVuY3Rpb24ocil7aWYocj09PVwiJSVcIilyZXR1cm5cIiVcIjtpZih0Pj1pKXJldHVybiByO3N3aXRjaChyKXtjYXNlXCIlc1wiOnJldHVybiBTdHJpbmcob1t0KytdKTtjYXNlXCIlZFwiOnJldHVybiBOdW1iZXIob1t0KytdKTtjYXNlXCIlalwiOnRyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkob1t0KytdKX1jYXRjaChyKXtyZXR1cm5cIltDaXJjdWxhcl1cIn1kZWZhdWx0OnJldHVybiByfX0pKTtmb3IodmFyIHk9b1t0XTt0PGk7eT1vWysrdF0pe2lmKGlzTnVsbCh5KXx8IWlzT2JqZWN0KHkpKXthKz1cIiBcIit5fWVsc2V7YSs9XCIgXCIraW5zcGVjdCh5KX19cmV0dXJuIGF9O2UuZGVwcmVjYXRlPWZ1bmN0aW9uKHIsdCl7aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLm5vRGVwcmVjYXRpb249PT10cnVlKXtyZXR1cm4gcn1pZih0eXBlb2YgcHJvY2Vzcz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmRlcHJlY2F0ZShyLHQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIG89ZmFsc2U7ZnVuY3Rpb24gZGVwcmVjYXRlZCgpe2lmKCFvKXtpZihwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pe3Rocm93IG5ldyBFcnJvcih0KX1lbHNlIGlmKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbil7Y29uc29sZS50cmFjZSh0KX1lbHNle2NvbnNvbGUuZXJyb3IodCl9bz10cnVlfXJldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZGVwcmVjYXRlZH07dmFyIGk9e307dmFyIGE9L14kLztpZihwcm9jZXNzLmVudi5OT0RFX0RFQlVHKXt2YXIgeT1wcm9jZXNzLmVudi5OT0RFX0RFQlVHO3k9eS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcKi9nLFwiLipcIikucmVwbGFjZSgvLC9nLFwiJHxeXCIpLnRvVXBwZXJDYXNlKCk7YT1uZXcgUmVnRXhwKFwiXlwiK3krXCIkXCIsXCJpXCIpfWUuZGVidWdsb2c9ZnVuY3Rpb24ocil7cj1yLnRvVXBwZXJDYXNlKCk7aWYoIWlbcl0pe2lmKGEudGVzdChyKSl7dmFyIHQ9cHJvY2Vzcy5waWQ7aVtyXT1mdW5jdGlvbigpe3ZhciBvPWUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKTtjb25zb2xlLmVycm9yKFwiJXMgJWQ6ICVzXCIscix0LG8pfX1lbHNle2lbcl09ZnVuY3Rpb24oKXt9fX1yZXR1cm4gaVtyXX07ZnVuY3Rpb24gaW5zcGVjdChyLHQpe3ZhciBvPXtzZWVuOltdLHN0eWxpemU6c3R5bGl6ZU5vQ29sb3J9O2lmKGFyZ3VtZW50cy5sZW5ndGg+PTMpby5kZXB0aD1hcmd1bWVudHNbMl07aWYoYXJndW1lbnRzLmxlbmd0aD49NClvLmNvbG9ycz1hcmd1bWVudHNbM107aWYoaXNCb29sZWFuKHQpKXtvLnNob3dIaWRkZW49dH1lbHNlIGlmKHQpe2UuX2V4dGVuZChvLHQpfWlmKGlzVW5kZWZpbmVkKG8uc2hvd0hpZGRlbikpby5zaG93SGlkZGVuPWZhbHNlO2lmKGlzVW5kZWZpbmVkKG8uZGVwdGgpKW8uZGVwdGg9MjtpZihpc1VuZGVmaW5lZChvLmNvbG9ycykpby5jb2xvcnM9ZmFsc2U7aWYoaXNVbmRlZmluZWQoby5jdXN0b21JbnNwZWN0KSlvLmN1c3RvbUluc3BlY3Q9dHJ1ZTtpZihvLmNvbG9ycylvLnN0eWxpemU9c3R5bGl6ZVdpdGhDb2xvcjtyZXR1cm4gZm9ybWF0VmFsdWUobyxyLG8uZGVwdGgpfWUuaW5zcGVjdD1pbnNwZWN0O2luc3BlY3QuY29sb3JzPXtib2xkOlsxLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0saW52ZXJzZTpbNywyN10sd2hpdGU6WzM3LDM5XSxncmV5Ols5MCwzOV0sYmxhY2s6WzMwLDM5XSxibHVlOlszNCwzOV0sY3lhbjpbMzYsMzldLGdyZWVuOlszMiwzOV0sbWFnZW50YTpbMzUsMzldLHJlZDpbMzEsMzldLHllbGxvdzpbMzMsMzldfTtpbnNwZWN0LnN0eWxlcz17c3BlY2lhbDpcImN5YW5cIixudW1iZXI6XCJ5ZWxsb3dcIixib29sZWFuOlwieWVsbG93XCIsdW5kZWZpbmVkOlwiZ3JleVwiLG51bGw6XCJib2xkXCIsc3RyaW5nOlwiZ3JlZW5cIixkYXRlOlwibWFnZW50YVwiLHJlZ2V4cDpcInJlZFwifTtmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHIsZSl7dmFyIHQ9aW5zcGVjdC5zdHlsZXNbZV07aWYodCl7cmV0dXJuXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbdF1bMF0rXCJtXCIrcitcIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVsxXStcIm1cIn1lbHNle3JldHVybiByfX1mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihyLGUpe3JldHVybiByfWZ1bmN0aW9uIGFycmF5VG9IYXNoKHIpe3ZhciBlPXt9O3IuZm9yRWFjaCgoZnVuY3Rpb24ocix0KXtlW3JdPXRydWV9KSk7cmV0dXJuIGV9ZnVuY3Rpb24gZm9ybWF0VmFsdWUocix0LG8pe2lmKHIuY3VzdG9tSW5zcGVjdCYmdCYmaXNGdW5jdGlvbih0Lmluc3BlY3QpJiZ0Lmluc3BlY3QhPT1lLmluc3BlY3QmJiEodC5jb25zdHJ1Y3RvciYmdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU9PT10KSl7dmFyIG49dC5pbnNwZWN0KG8scik7aWYoIWlzU3RyaW5nKG4pKXtuPWZvcm1hdFZhbHVlKHIsbixvKX1yZXR1cm4gbn12YXIgaT1mb3JtYXRQcmltaXRpdmUocix0KTtpZihpKXtyZXR1cm4gaX12YXIgYT1PYmplY3Qua2V5cyh0KTt2YXIgeT1hcnJheVRvSGFzaChhKTtpZihyLnNob3dIaWRkZW4pe2E9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCl9aWYoaXNFcnJvcih0KSYmKGEuaW5kZXhPZihcIm1lc3NhZ2VcIik+PTB8fGEuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpPj0wKSl7cmV0dXJuIGZvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCl7aWYoaXNGdW5jdGlvbih0KSl7dmFyIGY9dC5uYW1lP1wiOiBcIit0Lm5hbWU6XCJcIjtyZXR1cm4gci5zdHlsaXplKFwiW0Z1bmN0aW9uXCIrZitcIl1cIixcInNwZWNpYWxcIil9aWYoaXNSZWdFeHAodCkpe3JldHVybiByLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwicmVnZXhwXCIpfWlmKGlzRGF0ZSh0KSl7cmV0dXJuIHIuc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwiZGF0ZVwiKX1pZihpc0Vycm9yKHQpKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9fXZhciBwPVwiXCIsdT1mYWxzZSxzPVtcIntcIixcIn1cIl07aWYoaXNBcnJheSh0KSl7dT10cnVlO3M9W1wiW1wiLFwiXVwiXX1pZihpc0Z1bmN0aW9uKHQpKXt2YXIgYz10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3A9XCIgW0Z1bmN0aW9uXCIrYytcIl1cIn1pZihpc1JlZ0V4cCh0KSl7cD1cIiBcIitSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9aWYoaXNEYXRlKHQpKXtwPVwiIFwiK0RhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodCl9aWYoaXNFcnJvcih0KSl7cD1cIiBcIitmb3JtYXRFcnJvcih0KX1pZihhLmxlbmd0aD09PTAmJighdXx8dC5sZW5ndGg9PTApKXtyZXR1cm4gc1swXStwK3NbMV19aWYobzwwKXtpZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9ZWxzZXtyZXR1cm4gci5zdHlsaXplKFwiW09iamVjdF1cIixcInNwZWNpYWxcIil9fXIuc2Vlbi5wdXNoKHQpO3ZhciBsO2lmKHUpe2w9Zm9ybWF0QXJyYXkocix0LG8seSxhKX1lbHNle2w9YS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBmb3JtYXRQcm9wZXJ0eShyLHQsbyx5LGUsdSl9KSl9ci5zZWVuLnBvcCgpO3JldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhsLHAscyl9ZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKHIsZSl7aWYoaXNVbmRlZmluZWQoZSkpcmV0dXJuIHIuc3R5bGl6ZShcInVuZGVmaW5lZFwiLFwidW5kZWZpbmVkXCIpO2lmKGlzU3RyaW5nKGUpKXt2YXIgdD1cIidcIitKU09OLnN0cmluZ2lmeShlKS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIikucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykrXCInXCI7cmV0dXJuIHIuc3R5bGl6ZSh0LFwic3RyaW5nXCIpfWlmKGlzTnVtYmVyKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwibnVtYmVyXCIpO2lmKGlzQm9vbGVhbihlKSlyZXR1cm4gci5zdHlsaXplKFwiXCIrZSxcImJvb2xlYW5cIik7aWYoaXNOdWxsKGUpKXJldHVybiByLnN0eWxpemUoXCJudWxsXCIsXCJudWxsXCIpfWZ1bmN0aW9uIGZvcm1hdEVycm9yKHIpe3JldHVyblwiW1wiK0Vycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpK1wiXVwifWZ1bmN0aW9uIGZvcm1hdEFycmF5KHIsZSx0LG8sbil7dmFyIGk9W107Zm9yKHZhciBhPTAseT1lLmxlbmd0aDthPHk7KythKXtpZihoYXNPd25Qcm9wZXJ0eShlLFN0cmluZyhhKSkpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxvLFN0cmluZyhhKSx0cnVlKSl9ZWxzZXtpLnB1c2goXCJcIil9fW4uZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW4ubWF0Y2goL15cXGQrJC8pKXtpLnB1c2goZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLHRydWUpKX19KSk7cmV0dXJuIGl9ZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLGkpe3ZhciBhLHksZjtmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKXx8e3ZhbHVlOmVbbl19O2lmKGYuZ2V0KXtpZihmLnNldCl7eT1yLnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIixcInNwZWNpYWxcIil9ZWxzZXt5PXIuc3R5bGl6ZShcIltHZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1lbHNle2lmKGYuc2V0KXt5PXIuc3R5bGl6ZShcIltTZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1pZighaGFzT3duUHJvcGVydHkobyxuKSl7YT1cIltcIituK1wiXVwifWlmKCF5KXtpZihyLnNlZW4uaW5kZXhPZihmLnZhbHVlKTwwKXtpZihpc051bGwodCkpe3k9Zm9ybWF0VmFsdWUocixmLnZhbHVlLG51bGwpfWVsc2V7eT1mb3JtYXRWYWx1ZShyLGYudmFsdWUsdC0xKX1pZih5LmluZGV4T2YoXCJcXG5cIik+LTEpe2lmKGkpe3k9eS5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICBcIityfSkpLmpvaW4oXCJcXG5cIikuc3Vic3RyKDIpfWVsc2V7eT1cIlxcblwiK3kuc3BsaXQoXCJcXG5cIikubWFwKChmdW5jdGlvbihyKXtyZXR1cm5cIiAgIFwiK3J9KSkuam9pbihcIlxcblwiKX19fWVsc2V7eT1yLnN0eWxpemUoXCJbQ2lyY3VsYXJdXCIsXCJzcGVjaWFsXCIpfX1pZihpc1VuZGVmaW5lZChhKSl7aWYoaSYmbi5tYXRjaCgvXlxcZCskLykpe3JldHVybiB5fWE9SlNPTi5zdHJpbmdpZnkoXCJcIituKTtpZihhLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSl7YT1hLnN1YnN0cigxLGEubGVuZ3RoLTIpO2E9ci5zdHlsaXplKGEsXCJuYW1lXCIpfWVsc2V7YT1hLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLFwiJ1wiKTthPXIuc3R5bGl6ZShhLFwic3RyaW5nXCIpfX1yZXR1cm4gYStcIjogXCIreX1mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhyLGUsdCl7dmFyIG89MDt2YXIgbj1yLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtvKys7aWYoZS5pbmRleE9mKFwiXFxuXCIpPj0wKW8rKztyZXR1cm4gcitlLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLFwiXCIpLmxlbmd0aCsxfSksMCk7aWYobj42MCl7cmV0dXJuIHRbMF0rKGU9PT1cIlwiP1wiXCI6ZStcIlxcbiBcIikrXCIgXCIrci5qb2luKFwiLFxcbiAgXCIpK1wiIFwiK3RbMV19cmV0dXJuIHRbMF0rZStcIiBcIityLmpvaW4oXCIsIFwiKStcIiBcIit0WzFdfWUudHlwZXM9dCg1ODQpO2Z1bmN0aW9uIGlzQXJyYXkocil7cmV0dXJuIEFycmF5LmlzQXJyYXkocil9ZS5pc0FycmF5PWlzQXJyYXk7ZnVuY3Rpb24gaXNCb29sZWFuKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiYm9vbGVhblwifWUuaXNCb29sZWFuPWlzQm9vbGVhbjtmdW5jdGlvbiBpc051bGwocil7cmV0dXJuIHI9PT1udWxsfWUuaXNOdWxsPWlzTnVsbDtmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChyKXtyZXR1cm4gcj09bnVsbH1lLmlzTnVsbE9yVW5kZWZpbmVkPWlzTnVsbE9yVW5kZWZpbmVkO2Z1bmN0aW9uIGlzTnVtYmVyKHIpe3JldHVybiB0eXBlb2Ygcj09PVwibnVtYmVyXCJ9ZS5pc051bWJlcj1pc051bWJlcjtmdW5jdGlvbiBpc1N0cmluZyhyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN0cmluZ1wifWUuaXNTdHJpbmc9aXNTdHJpbmc7ZnVuY3Rpb24gaXNTeW1ib2wocil7cmV0dXJuIHR5cGVvZiByPT09XCJzeW1ib2xcIn1lLmlzU3ltYm9sPWlzU3ltYm9sO2Z1bmN0aW9uIGlzVW5kZWZpbmVkKHIpe3JldHVybiByPT09dm9pZCAwfWUuaXNVbmRlZmluZWQ9aXNVbmRlZmluZWQ7ZnVuY3Rpb24gaXNSZWdFeHAocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBSZWdFeHBdXCJ9ZS5pc1JlZ0V4cD1pc1JlZ0V4cDtlLnR5cGVzLmlzUmVnRXhwPWlzUmVnRXhwO2Z1bmN0aW9uIGlzT2JqZWN0KHIpe3JldHVybiB0eXBlb2Ygcj09PVwib2JqZWN0XCImJnIhPT1udWxsfWUuaXNPYmplY3Q9aXNPYmplY3Q7ZnVuY3Rpb24gaXNEYXRlKHIpe3JldHVybiBpc09iamVjdChyKSYmb2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRGF0ZV1cIn1lLmlzRGF0ZT1pc0RhdGU7ZS50eXBlcy5pc0RhdGU9aXNEYXRlO2Z1bmN0aW9uIGlzRXJyb3Iocil7cmV0dXJuIGlzT2JqZWN0KHIpJiYob2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRXJyb3JdXCJ8fHIgaW5zdGFuY2VvZiBFcnJvcil9ZS5pc0Vycm9yPWlzRXJyb3I7ZS50eXBlcy5pc05hdGl2ZUVycm9yPWlzRXJyb3I7ZnVuY3Rpb24gaXNGdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cImZ1bmN0aW9uXCJ9ZS5pc0Z1bmN0aW9uPWlzRnVuY3Rpb247ZnVuY3Rpb24gaXNQcmltaXRpdmUocil7cmV0dXJuIHI9PT1udWxsfHx0eXBlb2Ygcj09PVwiYm9vbGVhblwifHx0eXBlb2Ygcj09PVwibnVtYmVyXCJ8fHR5cGVvZiByPT09XCJzdHJpbmdcInx8dHlwZW9mIHI9PT1cInN5bWJvbFwifHx0eXBlb2Ygcj09PVwidW5kZWZpbmVkXCJ9ZS5pc1ByaW1pdGl2ZT1pc1ByaW1pdGl2ZTtlLmlzQnVmZmVyPXQoMzY5KTtmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpfWZ1bmN0aW9uIHBhZChyKXtyZXR1cm4gcjwxMD9cIjBcIityLnRvU3RyaW5nKDEwKTpyLnRvU3RyaW5nKDEwKX12YXIgZj1bXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiLFwiRGVjXCJdO2Z1bmN0aW9uIHRpbWVzdGFtcCgpe3ZhciByPW5ldyBEYXRlO3ZhciBlPVtwYWQoci5nZXRIb3VycygpKSxwYWQoci5nZXRNaW51dGVzKCkpLHBhZChyLmdldFNlY29uZHMoKSldLmpvaW4oXCI6XCIpO3JldHVybltyLmdldERhdGUoKSxmW3IuZ2V0TW9udGgoKV0sZV0uam9pbihcIiBcIil9ZS5sb2c9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIiVzIC0gJXNcIix0aW1lc3RhbXAoKSxlLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cykpfTtlLmluaGVyaXRzPXQoNzgyKTtlLl9leHRlbmQ9ZnVuY3Rpb24ocixlKXtpZighZXx8IWlzT2JqZWN0KGUpKXJldHVybiByO3ZhciB0PU9iamVjdC5rZXlzKGUpO3ZhciBvPXQubGVuZ3RoO3doaWxlKG8tLSl7clt0W29dXT1lW3Rbb11dfXJldHVybiByfTtmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShyLGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixlKX12YXIgcD10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIj9TeW1ib2woXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIik6dW5kZWZpbmVkO2UucHJvbWlzaWZ5PWZ1bmN0aW9uIHByb21pc2lmeShyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO2lmKHAmJnJbcF0pe3ZhciBlPXJbcF07aWYodHlwZW9mIGUhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBlfWZ1bmN0aW9uIGUoKXt2YXIgZSx0O3ZhciBvPW5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe2U9cjt0PW99KSk7dmFyIG49W107Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7bi5wdXNoKGFyZ3VtZW50c1tpXSl9bi5wdXNoKChmdW5jdGlvbihyLG8pe2lmKHIpe3Qocil9ZWxzZXtlKG8pfX0pKTt0cnl7ci5hcHBseSh0aGlzLG4pfWNhdGNoKHIpe3Qocil9cmV0dXJuIG99T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKTtpZihwKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLG8ocikpfTtlLnByb21pc2lmeS5jdXN0b209cDtmdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocixlKXtpZighcil7dmFyIHQ9bmV3IEVycm9yKFwiUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlXCIpO3QucmVhc29uPXI7cj10fXJldHVybiBlKHIpfWZ1bmN0aW9uIGNhbGxiYWNraWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfWZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goYXJndW1lbnRzW3RdKX12YXIgbz1lLnBvcCgpO2lmKHR5cGVvZiBvIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uXCIpfXZhciBuPXRoaXM7dmFyIGNiPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXBwbHkobixhcmd1bWVudHMpfTtyLmFwcGx5KHRoaXMsZSkudGhlbigoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsbnVsbCxyKSl9KSwoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLHIsY2IpKX0pKX1PYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsbyhyKSk7cmV0dXJuIGNhbGxiYWNraWZpZWR9ZS5jYWxsYmFja2lmeT1jYWxsYmFja2lmeX0sNDkwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDE0NCk7dmFyIG49dCgzNDkpO3ZhciBpPXQoMjU2KTt2YXIgYT1pKFwiT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1wiKTt2YXIgeT10KDk0MikoKTt2YXIgZj15JiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgcD1uKCk7dmFyIHU9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHM9e307dmFyIGM9dCgyNCk7dmFyIGw9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKGYmJmMmJmwpe28ocCwoZnVuY3Rpb24ocil7aWYodHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWwoZSk7dmFyIG89Yyh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW8pe3ZhciBuPWwodCk7bz1jKG4sU3ltYm9sLnRvU3RyaW5nVGFnKX1zW3JdPW8uZ2V0fX0pKX12YXIgZD1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtvKHMsKGZ1bmN0aW9uKHQsbyl7aWYoIWUpe3RyeXt2YXIgbj10LmNhbGwocik7aWYobj09PW8pe2U9bn19Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3ZhciBnPXQoOTk0KTtyLmV4cG9ydHM9ZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHIpe2lmKCFnKHIpKXtyZXR1cm4gZmFsc2V9aWYoIWYpe3JldHVybiB1KGEociksOCwtMSl9cmV0dXJuIGQocil9fSwzNDk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoOTkyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKXtyZXR1cm4gbyhbXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkludDE2QXJyYXlcIixcIkludDMyQXJyYXlcIixcIkludDhBcnJheVwiLFwiVWludDE2QXJyYXlcIixcIlVpbnQzMkFycmF5XCIsXCJVaW50OEFycmF5XCIsXCJVaW50OENsYW1wZWRBcnJheVwiXSwoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCJ9KSl9fSwyNDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg1MDApO3ZhciBuPW8oXCIlT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciVcIix0cnVlKTtpZihuKXt0cnl7bihbXSxcImxlbmd0aFwiKX1jYXRjaChyKXtuPW51bGx9fXIuZXhwb3J0cz1ufX07dmFyIGU9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgbz1lW3RdO2lmKG8hPT11bmRlZmluZWQpe3JldHVybiBvLmV4cG9ydHN9dmFyIG49ZVt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7clt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgZVt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDE3Nyk7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/psl/index.js":
/*!***********************************!*\
  !*** ./node_modules/psl/index.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*eslint no-var:0, prefer-arrow-callback: 0, object-shorthand: 0 */\n\n\n\nvar Punycode = __webpack_require__(/*! punycode */ \"(app-pages-browser)/./node_modules/punycode/punycode.es6.js\");\n\n\nvar internals = {};\n\n\n//\n// Read rules from file.\n//\ninternals.rules = (__webpack_require__(/*! ./data/rules.json */ \"(app-pages-browser)/./node_modules/psl/data/rules.json\").map)(function (rule) {\n\n  return {\n    rule: rule,\n    suffix: rule.replace(/^(\\*\\.|\\!)/, ''),\n    punySuffix: -1,\n    wildcard: rule.charAt(0) === '*',\n    exception: rule.charAt(0) === '!'\n  };\n});\n\n\n//\n// Check is given string ends with `suffix`.\n//\ninternals.endsWith = function (str, suffix) {\n\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n};\n\n\n//\n// Find rule for a given domain.\n//\ninternals.findRule = function (domain) {\n\n  var punyDomain = Punycode.toASCII(domain);\n  return internals.rules.reduce(function (memo, rule) {\n\n    if (rule.punySuffix === -1){\n      rule.punySuffix = Punycode.toASCII(rule.suffix);\n    }\n    if (!internals.endsWith(punyDomain, '.' + rule.punySuffix) && punyDomain !== rule.punySuffix) {\n      return memo;\n    }\n    // This has been commented out as it never seems to run. This is because\n    // sub tlds always appear after their parents and we never find a shorter\n    // match.\n    //if (memo) {\n    //  var memoSuffix = Punycode.toASCII(memo.suffix);\n    //  if (memoSuffix.length >= punySuffix.length) {\n    //    return memo;\n    //  }\n    //}\n    return rule;\n  }, null);\n};\n\n\n//\n// Error codes and messages.\n//\nexports.errorCodes = {\n  DOMAIN_TOO_SHORT: 'Domain name too short.',\n  DOMAIN_TOO_LONG: 'Domain name too long. It should be no more than 255 chars.',\n  LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',\n  LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',\n  LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',\n  LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',\n  LABEL_INVALID_CHARS: 'Domain name label can only contain alphanumeric characters or dashes.'\n};\n\n\n//\n// Validate domain name and throw if not valid.\n//\n// From wikipedia:\n//\n// Hostnames are composed of series of labels concatenated with dots, as are all\n// domain names. Each label must be between 1 and 63 characters long, and the\n// entire hostname (including the delimiting dots) has a maximum of 255 chars.\n//\n// Allowed chars:\n//\n// * `a-z`\n// * `0-9`\n// * `-` but not as a starting or ending character\n// * `.` as a separator for the textual portions of a domain name\n//\n// * http://en.wikipedia.org/wiki/Domain_name\n// * http://en.wikipedia.org/wiki/Hostname\n//\ninternals.validate = function (input) {\n\n  // Before we can validate we need to take care of IDNs with unicode chars.\n  var ascii = Punycode.toASCII(input);\n\n  if (ascii.length < 1) {\n    return 'DOMAIN_TOO_SHORT';\n  }\n  if (ascii.length > 255) {\n    return 'DOMAIN_TOO_LONG';\n  }\n\n  // Check each part's length and allowed chars.\n  var labels = ascii.split('.');\n  var label;\n\n  for (var i = 0; i < labels.length; ++i) {\n    label = labels[i];\n    if (!label.length) {\n      return 'LABEL_TOO_SHORT';\n    }\n    if (label.length > 63) {\n      return 'LABEL_TOO_LONG';\n    }\n    if (label.charAt(0) === '-') {\n      return 'LABEL_STARTS_WITH_DASH';\n    }\n    if (label.charAt(label.length - 1) === '-') {\n      return 'LABEL_ENDS_WITH_DASH';\n    }\n    if (!/^[a-z0-9\\-]+$/.test(label)) {\n      return 'LABEL_INVALID_CHARS';\n    }\n  }\n};\n\n\n//\n// Public API\n//\n\n\n//\n// Parse domain.\n//\nexports.parse = function (input) {\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Domain name must be a string.');\n  }\n\n  // Force domain to lowercase.\n  var domain = input.slice(0).toLowerCase();\n\n  // Handle FQDN.\n  // TODO: Simply remove trailing dot?\n  if (domain.charAt(domain.length - 1) === '.') {\n    domain = domain.slice(0, domain.length - 1);\n  }\n\n  // Validate and sanitise input.\n  var error = internals.validate(domain);\n  if (error) {\n    return {\n      input: input,\n      error: {\n        message: exports.errorCodes[error],\n        code: error\n      }\n    };\n  }\n\n  var parsed = {\n    input: input,\n    tld: null,\n    sld: null,\n    domain: null,\n    subdomain: null,\n    listed: false\n  };\n\n  var domainParts = domain.split('.');\n\n  // Non-Internet TLD\n  if (domainParts[domainParts.length - 1] === 'local') {\n    return parsed;\n  }\n\n  var handlePunycode = function () {\n\n    if (!/xn--/.test(domain)) {\n      return parsed;\n    }\n    if (parsed.domain) {\n      parsed.domain = Punycode.toASCII(parsed.domain);\n    }\n    if (parsed.subdomain) {\n      parsed.subdomain = Punycode.toASCII(parsed.subdomain);\n    }\n    return parsed;\n  };\n\n  var rule = internals.findRule(domain);\n\n  // Unlisted tld.\n  if (!rule) {\n    if (domainParts.length < 2) {\n      return parsed;\n    }\n    parsed.tld = domainParts.pop();\n    parsed.sld = domainParts.pop();\n    parsed.domain = [parsed.sld, parsed.tld].join('.');\n    if (domainParts.length) {\n      parsed.subdomain = domainParts.pop();\n    }\n    return handlePunycode();\n  }\n\n  // At this point we know the public suffix is listed.\n  parsed.listed = true;\n\n  var tldParts = rule.suffix.split('.');\n  var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);\n\n  if (rule.exception) {\n    privateParts.push(tldParts.shift());\n  }\n\n  parsed.tld = tldParts.join('.');\n\n  if (!privateParts.length) {\n    return handlePunycode();\n  }\n\n  if (rule.wildcard) {\n    tldParts.unshift(privateParts.pop());\n    parsed.tld = tldParts.join('.');\n  }\n\n  if (!privateParts.length) {\n    return handlePunycode();\n  }\n\n  parsed.sld = privateParts.pop();\n  parsed.domain = [parsed.sld,  parsed.tld].join('.');\n\n  if (privateParts.length) {\n    parsed.subdomain = privateParts.join('.');\n  }\n\n  return handlePunycode();\n};\n\n\n//\n// Get domain.\n//\nexports.get = function (domain) {\n\n  if (!domain) {\n    return null;\n  }\n  return exports.parse(domain).domain || null;\n};\n\n\n//\n// Check whether domain belongs to a known public suffix.\n//\nexports.isValid = function (domain) {\n\n  var parsed = exports.parse(domain);\n  return Boolean(parsed.domain && parsed.listed);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wc2wvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7O0FBR2IsZUFBZSxtQkFBTyxDQUFDLDZFQUFVOzs7QUFHakM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0R0FBZ0M7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHNsL2luZGV4LmpzP2UzZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyplc2xpbnQgbm8tdmFyOjAsIHByZWZlci1hcnJvdy1jYWxsYmFjazogMCwgb2JqZWN0LXNob3J0aGFuZDogMCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBQdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbi8vXG4vLyBSZWFkIHJ1bGVzIGZyb20gZmlsZS5cbi8vXG5pbnRlcm5hbHMucnVsZXMgPSByZXF1aXJlKCcuL2RhdGEvcnVsZXMuanNvbicpLm1hcChmdW5jdGlvbiAocnVsZSkge1xuXG4gIHJldHVybiB7XG4gICAgcnVsZTogcnVsZSxcbiAgICBzdWZmaXg6IHJ1bGUucmVwbGFjZSgvXihcXCpcXC58XFwhKS8sICcnKSxcbiAgICBwdW55U3VmZml4OiAtMSxcbiAgICB3aWxkY2FyZDogcnVsZS5jaGFyQXQoMCkgPT09ICcqJyxcbiAgICBleGNlcHRpb246IHJ1bGUuY2hhckF0KDApID09PSAnISdcbiAgfTtcbn0pO1xuXG5cbi8vXG4vLyBDaGVjayBpcyBnaXZlbiBzdHJpbmcgZW5kcyB3aXRoIGBzdWZmaXhgLlxuLy9cbmludGVybmFscy5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzdHIsIHN1ZmZpeCkge1xuXG4gIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG59O1xuXG5cbi8vXG4vLyBGaW5kIHJ1bGUgZm9yIGEgZ2l2ZW4gZG9tYWluLlxuLy9cbmludGVybmFscy5maW5kUnVsZSA9IGZ1bmN0aW9uIChkb21haW4pIHtcblxuICB2YXIgcHVueURvbWFpbiA9IFB1bnljb2RlLnRvQVNDSUkoZG9tYWluKTtcbiAgcmV0dXJuIGludGVybmFscy5ydWxlcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHJ1bGUpIHtcblxuICAgIGlmIChydWxlLnB1bnlTdWZmaXggPT09IC0xKXtcbiAgICAgIHJ1bGUucHVueVN1ZmZpeCA9IFB1bnljb2RlLnRvQVNDSUkocnVsZS5zdWZmaXgpO1xuICAgIH1cbiAgICBpZiAoIWludGVybmFscy5lbmRzV2l0aChwdW55RG9tYWluLCAnLicgKyBydWxlLnB1bnlTdWZmaXgpICYmIHB1bnlEb21haW4gIT09IHJ1bGUucHVueVN1ZmZpeCkge1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuICAgIC8vIFRoaXMgaGFzIGJlZW4gY29tbWVudGVkIG91dCBhcyBpdCBuZXZlciBzZWVtcyB0byBydW4uIFRoaXMgaXMgYmVjYXVzZVxuICAgIC8vIHN1YiB0bGRzIGFsd2F5cyBhcHBlYXIgYWZ0ZXIgdGhlaXIgcGFyZW50cyBhbmQgd2UgbmV2ZXIgZmluZCBhIHNob3J0ZXJcbiAgICAvLyBtYXRjaC5cbiAgICAvL2lmIChtZW1vKSB7XG4gICAgLy8gIHZhciBtZW1vU3VmZml4ID0gUHVueWNvZGUudG9BU0NJSShtZW1vLnN1ZmZpeCk7XG4gICAgLy8gIGlmIChtZW1vU3VmZml4Lmxlbmd0aCA+PSBwdW55U3VmZml4Lmxlbmd0aCkge1xuICAgIC8vICAgIHJldHVybiBtZW1vO1xuICAgIC8vICB9XG4gICAgLy99XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0sIG51bGwpO1xufTtcblxuXG4vL1xuLy8gRXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxuLy9cbmV4cG9ydHMuZXJyb3JDb2RlcyA9IHtcbiAgRE9NQUlOX1RPT19TSE9SVDogJ0RvbWFpbiBuYW1lIHRvbyBzaG9ydC4nLFxuICBET01BSU5fVE9PX0xPTkc6ICdEb21haW4gbmFtZSB0b28gbG9uZy4gSXQgc2hvdWxkIGJlIG5vIG1vcmUgdGhhbiAyNTUgY2hhcnMuJyxcbiAgTEFCRUxfU1RBUlRTX1dJVEhfREFTSDogJ0RvbWFpbiBuYW1lIGxhYmVsIGNhbiBub3Qgc3RhcnQgd2l0aCBhIGRhc2guJyxcbiAgTEFCRUxfRU5EU19XSVRIX0RBU0g6ICdEb21haW4gbmFtZSBsYWJlbCBjYW4gbm90IGVuZCB3aXRoIGEgZGFzaC4nLFxuICBMQUJFTF9UT09fTE9ORzogJ0RvbWFpbiBuYW1lIGxhYmVsIHNob3VsZCBiZSBhdCBtb3N0IDYzIGNoYXJzIGxvbmcuJyxcbiAgTEFCRUxfVE9PX1NIT1JUOiAnRG9tYWluIG5hbWUgbGFiZWwgc2hvdWxkIGJlIGF0IGxlYXN0IDEgY2hhcmFjdGVyIGxvbmcuJyxcbiAgTEFCRUxfSU5WQUxJRF9DSEFSUzogJ0RvbWFpbiBuYW1lIGxhYmVsIGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb3IgZGFzaGVzLidcbn07XG5cblxuLy9cbi8vIFZhbGlkYXRlIGRvbWFpbiBuYW1lIGFuZCB0aHJvdyBpZiBub3QgdmFsaWQuXG4vL1xuLy8gRnJvbSB3aWtpcGVkaWE6XG4vL1xuLy8gSG9zdG5hbWVzIGFyZSBjb21wb3NlZCBvZiBzZXJpZXMgb2YgbGFiZWxzIGNvbmNhdGVuYXRlZCB3aXRoIGRvdHMsIGFzIGFyZSBhbGxcbi8vIGRvbWFpbiBuYW1lcy4gRWFjaCBsYWJlbCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNjMgY2hhcmFjdGVycyBsb25nLCBhbmQgdGhlXG4vLyBlbnRpcmUgaG9zdG5hbWUgKGluY2x1ZGluZyB0aGUgZGVsaW1pdGluZyBkb3RzKSBoYXMgYSBtYXhpbXVtIG9mIDI1NSBjaGFycy5cbi8vXG4vLyBBbGxvd2VkIGNoYXJzOlxuLy9cbi8vICogYGEtemBcbi8vICogYDAtOWBcbi8vICogYC1gIGJ1dCBub3QgYXMgYSBzdGFydGluZyBvciBlbmRpbmcgY2hhcmFjdGVyXG4vLyAqIGAuYCBhcyBhIHNlcGFyYXRvciBmb3IgdGhlIHRleHR1YWwgcG9ydGlvbnMgb2YgYSBkb21haW4gbmFtZVxuLy9cbi8vICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb21haW5fbmFtZVxuLy8gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvc3RuYW1lXG4vL1xuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgLy8gQmVmb3JlIHdlIGNhbiB2YWxpZGF0ZSB3ZSBuZWVkIHRvIHRha2UgY2FyZSBvZiBJRE5zIHdpdGggdW5pY29kZSBjaGFycy5cbiAgdmFyIGFzY2lpID0gUHVueWNvZGUudG9BU0NJSShpbnB1dCk7XG5cbiAgaWYgKGFzY2lpLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gJ0RPTUFJTl9UT09fU0hPUlQnO1xuICB9XG4gIGlmIChhc2NpaS5sZW5ndGggPiAyNTUpIHtcbiAgICByZXR1cm4gJ0RPTUFJTl9UT09fTE9ORyc7XG4gIH1cblxuICAvLyBDaGVjayBlYWNoIHBhcnQncyBsZW5ndGggYW5kIGFsbG93ZWQgY2hhcnMuXG4gIHZhciBsYWJlbHMgPSBhc2NpaS5zcGxpdCgnLicpO1xuICB2YXIgbGFiZWw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICBpZiAoIWxhYmVsLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICdMQUJFTF9UT09fU0hPUlQnO1xuICAgIH1cbiAgICBpZiAobGFiZWwubGVuZ3RoID4gNjMpIHtcbiAgICAgIHJldHVybiAnTEFCRUxfVE9PX0xPTkcnO1xuICAgIH1cbiAgICBpZiAobGFiZWwuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgIHJldHVybiAnTEFCRUxfU1RBUlRTX1dJVEhfREFTSCc7XG4gICAgfVxuICAgIGlmIChsYWJlbC5jaGFyQXQobGFiZWwubGVuZ3RoIC0gMSkgPT09ICctJykge1xuICAgICAgcmV0dXJuICdMQUJFTF9FTkRTX1dJVEhfREFTSCc7XG4gICAgfVxuICAgIGlmICghL15bYS16MC05XFwtXSskLy50ZXN0KGxhYmVsKSkge1xuICAgICAgcmV0dXJuICdMQUJFTF9JTlZBTElEX0NIQVJTJztcbiAgICB9XG4gIH1cbn07XG5cblxuLy9cbi8vIFB1YmxpYyBBUElcbi8vXG5cblxuLy9cbi8vIFBhcnNlIGRvbWFpbi5cbi8vXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEb21haW4gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgLy8gRm9yY2UgZG9tYWluIHRvIGxvd2VyY2FzZS5cbiAgdmFyIGRvbWFpbiA9IGlucHV0LnNsaWNlKDApLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gSGFuZGxlIEZRRE4uXG4gIC8vIFRPRE86IFNpbXBseSByZW1vdmUgdHJhaWxpbmcgZG90P1xuICBpZiAoZG9tYWluLmNoYXJBdChkb21haW4ubGVuZ3RoIC0gMSkgPT09ICcuJykge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgwLCBkb21haW4ubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBhbmQgc2FuaXRpc2UgaW5wdXQuXG4gIHZhciBlcnJvciA9IGludGVybmFscy52YWxpZGF0ZShkb21haW4pO1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgZXJyb3I6IHtcbiAgICAgICAgbWVzc2FnZTogZXhwb3J0cy5lcnJvckNvZGVzW2Vycm9yXSxcbiAgICAgICAgY29kZTogZXJyb3JcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IHtcbiAgICBpbnB1dDogaW5wdXQsXG4gICAgdGxkOiBudWxsLFxuICAgIHNsZDogbnVsbCxcbiAgICBkb21haW46IG51bGwsXG4gICAgc3ViZG9tYWluOiBudWxsLFxuICAgIGxpc3RlZDogZmFsc2VcbiAgfTtcblxuICB2YXIgZG9tYWluUGFydHMgPSBkb21haW4uc3BsaXQoJy4nKTtcblxuICAvLyBOb24tSW50ZXJuZXQgVExEXG4gIGlmIChkb21haW5QYXJ0c1tkb21haW5QYXJ0cy5sZW5ndGggLSAxXSA9PT0gJ2xvY2FsJykge1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICB2YXIgaGFuZGxlUHVueWNvZGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIS94bi0tLy50ZXN0KGRvbWFpbikpIHtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChwYXJzZWQuZG9tYWluKSB7XG4gICAgICBwYXJzZWQuZG9tYWluID0gUHVueWNvZGUudG9BU0NJSShwYXJzZWQuZG9tYWluKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zdWJkb21haW4pIHtcbiAgICAgIHBhcnNlZC5zdWJkb21haW4gPSBQdW55Y29kZS50b0FTQ0lJKHBhcnNlZC5zdWJkb21haW4pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9O1xuXG4gIHZhciBydWxlID0gaW50ZXJuYWxzLmZpbmRSdWxlKGRvbWFpbik7XG5cbiAgLy8gVW5saXN0ZWQgdGxkLlxuICBpZiAoIXJ1bGUpIHtcbiAgICBpZiAoZG9tYWluUGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgcGFyc2VkLnRsZCA9IGRvbWFpblBhcnRzLnBvcCgpO1xuICAgIHBhcnNlZC5zbGQgPSBkb21haW5QYXJ0cy5wb3AoKTtcbiAgICBwYXJzZWQuZG9tYWluID0gW3BhcnNlZC5zbGQsIHBhcnNlZC50bGRdLmpvaW4oJy4nKTtcbiAgICBpZiAoZG9tYWluUGFydHMubGVuZ3RoKSB7XG4gICAgICBwYXJzZWQuc3ViZG9tYWluID0gZG9tYWluUGFydHMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVQdW55Y29kZSgpO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoZSBwdWJsaWMgc3VmZml4IGlzIGxpc3RlZC5cbiAgcGFyc2VkLmxpc3RlZCA9IHRydWU7XG5cbiAgdmFyIHRsZFBhcnRzID0gcnVsZS5zdWZmaXguc3BsaXQoJy4nKTtcbiAgdmFyIHByaXZhdGVQYXJ0cyA9IGRvbWFpblBhcnRzLnNsaWNlKDAsIGRvbWFpblBhcnRzLmxlbmd0aCAtIHRsZFBhcnRzLmxlbmd0aCk7XG5cbiAgaWYgKHJ1bGUuZXhjZXB0aW9uKSB7XG4gICAgcHJpdmF0ZVBhcnRzLnB1c2godGxkUGFydHMuc2hpZnQoKSk7XG4gIH1cblxuICBwYXJzZWQudGxkID0gdGxkUGFydHMuam9pbignLicpO1xuXG4gIGlmICghcHJpdmF0ZVBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBoYW5kbGVQdW55Y29kZSgpO1xuICB9XG5cbiAgaWYgKHJ1bGUud2lsZGNhcmQpIHtcbiAgICB0bGRQYXJ0cy51bnNoaWZ0KHByaXZhdGVQYXJ0cy5wb3AoKSk7XG4gICAgcGFyc2VkLnRsZCA9IHRsZFBhcnRzLmpvaW4oJy4nKTtcbiAgfVxuXG4gIGlmICghcHJpdmF0ZVBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBoYW5kbGVQdW55Y29kZSgpO1xuICB9XG5cbiAgcGFyc2VkLnNsZCA9IHByaXZhdGVQYXJ0cy5wb3AoKTtcbiAgcGFyc2VkLmRvbWFpbiA9IFtwYXJzZWQuc2xkLCAgcGFyc2VkLnRsZF0uam9pbignLicpO1xuXG4gIGlmIChwcml2YXRlUGFydHMubGVuZ3RoKSB7XG4gICAgcGFyc2VkLnN1YmRvbWFpbiA9IHByaXZhdGVQYXJ0cy5qb2luKCcuJyk7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlUHVueWNvZGUoKTtcbn07XG5cblxuLy9cbi8vIEdldCBkb21haW4uXG4vL1xuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoZG9tYWluKSB7XG5cbiAgaWYgKCFkb21haW4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZXhwb3J0cy5wYXJzZShkb21haW4pLmRvbWFpbiB8fCBudWxsO1xufTtcblxuXG4vL1xuLy8gQ2hlY2sgd2hldGhlciBkb21haW4gYmVsb25ncyB0byBhIGtub3duIHB1YmxpYyBzdWZmaXguXG4vL1xuZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gKGRvbWFpbikge1xuXG4gIHZhciBwYXJzZWQgPSBleHBvcnRzLnBhcnNlKGRvbWFpbik7XG4gIHJldHVybiBCb29sZWFuKHBhcnNlZC5kb21haW4gJiYgcGFyc2VkLmxpc3RlZCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/psl/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/punycode/punycode.es6.js":
/*!***********************************************!*\
  !*** ./node_modules/punycode/punycode.es6.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; },\n/* harmony export */   toASCII: function() { return /* binding */ toASCII; },\n/* harmony export */   toUnicode: function() { return /* binding */ toUnicode; },\n/* harmony export */   ucs2decode: function() { return /* binding */ ucs2decode; },\n/* harmony export */   ucs2encode: function() { return /* binding */ ucs2encode; }\n/* harmony export */ });\n\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (punycode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7O0FBRWI7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qiw2Q0FBNkMscUJBQXFCOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0U7QUFDdEUsK0RBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5lczYuanM/NzM2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbmNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbmNvbnN0IHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xuY29uc3QgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3Rl0vOyAvLyBOb3RlOiBVKzAwN0YgREVMIGlzIGV4Y2x1ZGVkIHRvby5cbmNvbnN0IHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5jb25zdCBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgY2FsbGJhY2spIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gY2FsbGJhY2soYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXBEb21haW4oZG9tYWluLCBjYWxsYmFjaykge1xuXHRjb25zdCBwYXJ0cyA9IGRvbWFpbi5zcGxpdCgnQCcpO1xuXHRsZXQgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0ZG9tYWluID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRkb21haW4gPSBkb21haW4ucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRjb25zdCBsYWJlbHMgPSBkb21haW4uc3BsaXQoJy4nKTtcblx0Y29uc3QgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGNhbGxiYWNrKS5qb2luKCcuJyk7XG5cdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0bGV0IGNvdW50ZXIgPSAwO1xuXHRjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdGNvbnN0IHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0Y29uc3QgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbmNvbnN0IHVjczJlbmNvZGUgPSBjb2RlUG9pbnRzID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmNvbnN0IGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50ID49IDB4MzAgJiYgY29kZVBvaW50IDwgMHgzQSkge1xuXHRcdHJldHVybiAyNiArIChjb2RlUG9pbnQgLSAweDMwKTtcblx0fVxuXHRpZiAoY29kZVBvaW50ID49IDB4NDEgJiYgY29kZVBvaW50IDwgMHg1Qikge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDQxO1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgPj0gMHg2MSAmJiBjb2RlUG9pbnQgPCAweDdCKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFkYXB0ID0gZnVuY3Rpb24oZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdGxldCBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBpID0gMDtcblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0bGV0IGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdGNvbnN0IG9sZGkgPSBpO1xuXHRcdGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSkge1xuXHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0aSAlPSBvdXQ7XG5cblx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0LlxuXHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHR9XG5cblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLm91dHB1dCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbmNvbnN0IGVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXG5cdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIGFuIGFycmF5IG9mIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0Ly8gQ2FjaGUgdGhlIGxlbmd0aC5cblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdGxldCBuID0gaW5pdGlhbE47XG5cdGxldCBkZWx0YSA9IDA7XG5cdGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0bGV0IGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0bGV0IG0gPSBtYXhJbnQ7XG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdGNvbnN0IGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PT0gbikge1xuXHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0bGV0IHEgPSBkZWx0YTtcblx0XHRcdFx0Zm9yIChsZXQgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cblx0fVxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAqIHN0cmluZy5cbiAqL1xuY29uc3QgdG9Vbmljb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbmNvbnN0IHRvQVNDSUkgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5jb25zdCBwdW55Y29kZSA9IHtcblx0LyoqXG5cdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKi9cblx0J3ZlcnNpb24nOiAnMi4zLjEnLFxuXHQvKipcblx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdCd1Y3MyJzoge1xuXHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdH0sXG5cdCdkZWNvZGUnOiBkZWNvZGUsXG5cdCdlbmNvZGUnOiBlbmNvZGUsXG5cdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxufTtcblxuZXhwb3J0IHsgdWNzMmRlY29kZSwgdWNzMmVuY29kZSwgZGVjb2RlLCBlbmNvZGUsIHRvQVNDSUksIHRvVW5pY29kZSB9O1xuZXhwb3J0IGRlZmF1bHQgcHVueWNvZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/punycode/punycode.es6.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5naWZ5L2luZGV4LmpzP2U3ODIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHVuZGVmO1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmNvZGUgYSBnaXZlbiBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyMmXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIC8vIEluIHRoZSBjYXNlIGlmIGZhaWxlZCBkZWNvZGluZywgd2Ugd2FudCB0byBvbWl0IHRoZSBrZXkvdmFsdWUgcGFpcnNcbiAgICAvLyBmcm9tIHRoZSByZXN1bHQuXG4gICAgLy9cbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsIHx8IGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW11cbiAgICAsIHZhbHVlXG4gICAgLCBrZXk7XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVkZ2UgY2FzZXMgd2hlcmUgd2UgYWN0dWFsbHkgd2FudCB0byBlbmNvZGUgdGhlIHZhbHVlIHRvIGFuIGVtcHR5XG4gICAgICAvLyBzdHJpbmcgaW5zdGVhZCBvZiB0aGUgc3RyaW5naWZpZWQgdmFsdWUuXG4gICAgICAvL1xuICAgICAgaWYgKCF2YWx1ZSAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmIHx8IGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAga2V5ID0gZW5jb2RlKGtleSk7XG4gICAgICB2YWx1ZSA9IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gZW5jb2RlIHRoZSBzdHJpbmdzLCB3ZSBzaG91bGQgYmFpbCBvdXQgYXMgd2UgZG9uJ3RcbiAgICAgIC8vIHdhbnQgdG8gYWRkIGludmFsaWQgc3RyaW5ncyB0byB0aGUgcXVlcnkuXG4gICAgICAvL1xuICAgICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBwYWlycy5wdXNoKGtleSArJz0nKyB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/querystringify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZXF1aXJlcy1wb3J0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZXF1aXJlcy1wb3J0L2luZGV4LmpzP2FjNjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/requires-port/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js":
/*!**********************************************************!*\
  !*** ./node_modules/set-cookie-parser/lib/set-cookie.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else if (key === \"partitioned\") {\n      cookie.partitioned = true;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQSxzRUFBc0U7QUFDdEUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb01BQW9NLGNBQWM7QUFDbE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NldC1jb29raWUtcGFyc2VyL2xpYi9zZXQtY29va2llLmpzP2QzZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICBkZWNvZGVWYWx1ZXM6IHRydWUsXG4gIG1hcDogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IHNldENvb2tpZVZhbHVlLnNwbGl0KFwiO1wiKS5maWx0ZXIoaXNOb25FbXB0eVN0cmluZyk7XG5cbiAgdmFyIG5hbWVWYWx1ZVBhaXJTdHIgPSBwYXJ0cy5zaGlmdCgpO1xuICB2YXIgcGFyc2VkID0gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpO1xuICB2YXIgbmFtZSA9IHBhcnNlZC5uYW1lO1xuICB2YXIgdmFsdWUgPSBwYXJzZWQudmFsdWU7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIHRyeSB7XG4gICAgdmFsdWUgPSBvcHRpb25zLmRlY29kZVZhbHVlcyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTsgLy8gZGVjb2RlIGNvb2tpZSB2YWx1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgK1xuICAgICAgICB2YWx1ZSArXG4gICAgICAgIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgZVxuICAgICk7XG4gIH1cblxuICB2YXIgY29va2llID0ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICB9O1xuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB2YXIgc2lkZXMgPSBwYXJ0LnNwbGl0KFwiPVwiKTtcbiAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gc2lkZXMuam9pbihcIj1cIik7XG4gICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImh0dHBvbmx5XCIpIHtcbiAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgY29va2llLnNhbWVTaXRlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwicGFydGl0aW9uZWRcIikge1xuICAgICAgY29va2llLnBhcnRpdGlvbmVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29va2llW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb29raWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKSB7XG4gIC8vIFBhcnNlcyBuYW1lLXZhbHVlLXBhaXIgYWNjb3JkaW5nIHRvIHJmYzYyNjViaXMgZHJhZnRcblxuICB2YXIgbmFtZSA9IFwiXCI7XG4gIHZhciB2YWx1ZSA9IFwiXCI7XG4gIHZhciBuYW1lVmFsdWVBcnIgPSBuYW1lVmFsdWVQYWlyU3RyLnNwbGl0KFwiPVwiKTtcbiAgaWYgKG5hbWVWYWx1ZUFyci5sZW5ndGggPiAxKSB7XG4gICAgbmFtZSA9IG5hbWVWYWx1ZUFyci5zaGlmdCgpO1xuICAgIHZhbHVlID0gbmFtZVZhbHVlQXJyLmpvaW4oXCI9XCIpOyAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCA9LCBqb2luZWQgYnkgYSBcIj1cIiBpZiB0aGVyZSB3YXMgbW9yZSB0aGFuIG9uZSBwYXJ0XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyU3RyO1xuICB9XG5cbiAgcmV0dXJuIHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIWlucHV0KSB7XG4gICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIGZvciBmZXRjaCByZXNwb25zZXMgLSB0aGV5IGNvbWJpbmUgaGVhZGVycyBvZiB0aGUgc2FtZSB0eXBlIGluIHRoZSBoZWFkZXJzIGFycmF5LFxuICAgICAgLy8gYnV0IGdldFNldENvb2tpZSByZXR1cm5zIGFuIHVuY29tYmluZWQgYXJyYXlcbiAgICAgIGlucHV0ID0gaW5wdXQuaGVhZGVycy5nZXRTZXRDb29raWUoKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgICAvLyBmYXN0LXBhdGggZm9yIG5vZGUuanMgKHdoaWNoIGF1dG9tYXRpY2FsbHkgbm9ybWFsaXplcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXItY2FzZVxuICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2xvdy1wYXRoIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBzZWUgIzI1XG4gICAgICB2YXIgc2NoID1cbiAgICAgICAgaW5wdXQuaGVhZGVyc1tcbiAgICAgICAgICBPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCI7XG4gICAgICAgICAgfSlcbiAgICAgICAgXTtcbiAgICAgIC8vIHdhcm4gaWYgY2FsbGVkIG9uIGEgcmVxdWVzdC1saWtlIG9iamVjdCB3aXRoIGEgY29va2llIGhlYWRlciByYXRoZXIgdGhhbiBhIHNldC1jb29raWUgaGVhZGVyIC0gc2VlICMzNCwgMzZcbiAgICAgIGlmICghc2NoICYmIGlucHV0LmhlYWRlcnMuY29va2llICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJXYXJuaW5nOiBzZXQtY29va2llLXBhcnNlciBhcHBlYXJzIHRvIGhhdmUgYmVlbiBjYWxsZWQgb24gYSByZXF1ZXN0IG9iamVjdC4gSXQgaXMgZGVzaWduZWQgdG8gcGFyc2UgU2V0LUNvb2tpZSBoZWFkZXJzIGZyb20gcmVzcG9uc2VzLCBub3QgQ29va2llIGhlYWRlcnMgZnJvbSByZXF1ZXN0cy4gU2V0IHRoZSBvcHRpb24ge3NpbGVudDogdHJ1ZX0gdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IHNjaDtcbiAgICB9XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlucHV0ID0gW2lucHV0XTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvb2tpZXMgPSB7fTtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLnJlZHVjZShmdW5jdGlvbiAoY29va2llcywgc3RyKSB7XG4gICAgICB2YXIgY29va2llID0gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgIGNvb2tpZXNbY29va2llLm5hbWVdID0gY29va2llO1xuICAgICAgcmV0dXJuIGNvb2tpZXM7XG4gICAgfSwgY29va2llcyk7XG4gIH1cbn1cblxuLypcbiAgU2V0LUNvb2tpZSBoZWFkZXIgZmllbGQtdmFsdWVzIGFyZSBzb21ldGltZXMgY29tbWEgam9pbmVkIGluIG9uZSBzdHJpbmcuIFRoaXMgc3BsaXRzIHRoZW0gd2l0aG91dCBjaG9raW5nIG9uIGNvbW1hc1xuICB0aGF0IGFyZSB3aXRoaW4gYSBzaW5nbGUgc2V0LWNvb2tpZSBmaWVsZC12YWx1ZSwgc3VjaCBhcyBpbiB0aGUgRXhwaXJlcyBwb3J0aW9uLlxuXG4gIFRoaXMgaXMgdW5jb21tb24sIGJ1dCBleHBsaWNpdGx5IGFsbG93ZWQgLSBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTYjc2VjdGlvbi00LjJcbiAgTm9kZS5qcyBkb2VzIHRoaXMgZm9yIGV2ZXJ5IGhlYWRlciAqZXhjZXB0KiBzZXQtY29va2llIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2Q1ZTM2M2I3N2ViYWYxY2FmNjdjZDc1MjgyMjRiNjUxYzg2ODE1YzEvbGliL19odHRwX2luY29taW5nLmpzI0wxMjhcbiAgUmVhY3QgTmF0aXZlJ3MgZmV0Y2ggZG9lcyB0aGlzIGZvciAqZXZlcnkqIGhlYWRlciwgaW5jbHVkaW5nIHNldC1jb29raWUuXG5cbiAgQmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvajJvYmpjL2NvbW1pdC8xNjgyMGZkYmM4Zjc2Y2EwYzMzNDcyODEwY2UwY2IwM2QyMGVmZTI1XG4gIENyZWRpdHMgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS90b21iYWxsIGZvciBvcmlnaW5hbCBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2NocnVzYXJ0IGZvciBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uXG4qL1xuZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nKGNvb2tpZXNTdHJpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29va2llc1N0cmluZykpIHtcbiAgICByZXR1cm4gY29va2llc1N0cmluZztcbiAgfVxuICBpZiAodHlwZW9mIGNvb2tpZXNTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgY29va2llc1N0cmluZ3MgPSBbXTtcbiAgdmFyIHBvcyA9IDA7XG4gIHZhciBzdGFydDtcbiAgdmFyIGNoO1xuICB2YXIgbGFzdENvbW1hO1xuICB2YXIgbmV4dFN0YXJ0O1xuICB2YXIgY29va2llc1NlcGFyYXRvckZvdW5kO1xuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICBwb3MgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuXG4gICAgcmV0dXJuIGNoICE9PSBcIj1cIiAmJiBjaCAhPT0gXCI7XCIgJiYgY2ggIT09IFwiLFwiO1xuICB9XG5cbiAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSBwb3M7XG4gICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoc2tpcFdoaXRlc3BhY2UoKSkge1xuICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICAvLyAnLCcgaXMgYSBjb29raWUgc2VwYXJhdG9yIGlmIHdlIGhhdmUgbGF0ZXIgZmlyc3QgJz0nLCBub3QgJzsnIG9yICcsJ1xuICAgICAgICBsYXN0Q29tbWEgPSBwb3M7XG4gICAgICAgIHBvcyArPSAxO1xuXG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIG5leHRTdGFydCA9IHBvcztcblxuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgbm90U3BlY2lhbENoYXIoKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VycmVudGx5IHNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpID09PSBcIj1cIikge1xuICAgICAgICAgIC8vIHdlIGZvdW5kIGNvb2tpZXMgc2VwYXJhdG9yXG4gICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAvLyBwb3MgaXMgaW5zaWRlIHRoZSBuZXh0IGNvb2tpZSwgc28gYmFjayB1cCBhbmQgcmV0dXJuIGl0LlxuICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBwYXJhbSAnLCcgb3IgcGFyYW0gc2VwYXJhdG9yICc7JyxcbiAgICAgICAgICAvLyB3ZSBjb250aW51ZSBmcm9tIHRoYXQgY29tbWFcbiAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvb2tpZXNTZXBhcmF0b3JGb3VuZCB8fCBwb3MgPj0gY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5zcGxpdENvb2tpZXNTdHJpbmcgPSBzcGxpdENvb2tpZXNTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/cookie.js":
/*!*************************************************!*\
  !*** ./node_modules/tough-cookie/lib/cookie.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * Copyright (c) 2015-2020, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst punycode = __webpack_require__(/*! punycode/ */ \"(app-pages-browser)/./node_modules/punycode/punycode.es6.js\");\nconst urlParse = __webpack_require__(/*! url-parse */ \"(app-pages-browser)/./node_modules/url-parse/index.js\");\nconst pubsuffix = __webpack_require__(/*! ./pubsuffix-psl */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/pubsuffix-psl.js\");\nconst Store = (__webpack_require__(/*! ./store */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/store.js\").Store);\nconst MemoryCookieStore = (__webpack_require__(/*! ./memstore */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/memstore.js\").MemoryCookieStore);\nconst pathMatch = (__webpack_require__(/*! ./pathMatch */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/pathMatch.js\").pathMatch);\nconst validators = __webpack_require__(/*! ./validators.js */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/validators.js\");\nconst VERSION = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/version.js\");\nconst { fromCallback } = __webpack_require__(/*! universalify */ \"(app-pages-browser)/./node_modules/tough-cookie/node_modules/universalify/index.js\");\nconst { getCustomInspectSymbol } = __webpack_require__(/*! ./utilHelper */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/utilHelper.js\");\n\n// From RFC6265 S4.1.1\n// note that it excludes \\x3B \";\"\nconst COOKIE_OCTETS = /^[\\x21\\x23-\\x2B\\x2D-\\x3A\\x3C-\\x5B\\x5D-\\x7E]+$/;\n\nconst CONTROL_CHARS = /[\\x00-\\x1F]/;\n\n// From Chromium // '\\r', '\\n' and '\\0' should be treated as a terminator in\n// the \"relaxed\" mode, see:\n// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60\nconst TERMINATORS = [\"\\n\", \"\\r\", \"\\0\"];\n\n// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or \";\"'\n// Note ';' is \\x3B\nconst PATH_VALUE = /[\\x20-\\x3A\\x3C-\\x7E]+/;\n\n// date-time parsing constants (RFC6265 S5.1.1)\n\nconst DATE_DELIM = /[\\x09\\x20-\\x2F\\x3B-\\x40\\x5B-\\x60\\x7B-\\x7E]/;\n\nconst MONTH_TO_NUM = {\n  jan: 0,\n  feb: 1,\n  mar: 2,\n  apr: 3,\n  may: 4,\n  jun: 5,\n  jul: 6,\n  aug: 7,\n  sep: 8,\n  oct: 9,\n  nov: 10,\n  dec: 11\n};\n\nconst MAX_TIME = 2147483647000; // 31-bit max\nconst MIN_TIME = 0; // 31-bit min\nconst SAME_SITE_CONTEXT_VAL_ERR =\n  'Invalid sameSiteContext option for getCookies(); expected one of \"strict\", \"lax\", or \"none\"';\n\nfunction checkSameSiteContext(value) {\n  validators.validate(validators.isNonEmptyString(value), value);\n  const context = String(value).toLowerCase();\n  if (context === \"none\" || context === \"lax\" || context === \"strict\") {\n    return context;\n  } else {\n    return null;\n  }\n}\n\nconst PrefixSecurityEnum = Object.freeze({\n  SILENT: \"silent\",\n  STRICT: \"strict\",\n  DISABLED: \"unsafe-disabled\"\n});\n\n// Dumped from ip-regex@4.0.0, with the following changes:\n// * all capturing groups converted to non-capturing -- \"(?:)\"\n// * support for IPv6 Scoped Literal (\"%eth1\") removed\n// * lowercase hexadecimal only\nconst IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$)|(?:^(?:(?:[a-f\\d]{1,4}:){7}(?:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,2}|:)|(?:[a-f\\d]{1,4}:){4}(?:(?::[a-f\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,3}|:)|(?:[a-f\\d]{1,4}:){3}(?:(?::[a-f\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,4}|:)|(?:[a-f\\d]{1,4}:){2}(?:(?::[a-f\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,5}|:)|(?:[a-f\\d]{1,4}:){1}(?:(?::[a-f\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,7}|:)))$)/;\nconst IP_V6_REGEX = `\n\\\\[?(?:\n(?:[a-fA-F\\\\d]{1,4}:){7}(?:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|:[a-fA-F\\\\d]{1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,2}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){4}(?:(?::[a-fA-F\\\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,3}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){3}(?:(?::[a-fA-F\\\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,4}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){2}(?:(?::[a-fA-F\\\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,5}|:)|\n(?:[a-fA-F\\\\d]{1,4}:){1}(?:(?::[a-fA-F\\\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,6}|:)|\n(?::(?:(?::[a-fA-F\\\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}|(?::[a-fA-F\\\\d]{1,4}){1,7}|:))\n)(?:%[0-9a-zA-Z]{1,})?\\\\]?\n`\n  .replace(/\\s*\\/\\/.*$/gm, \"\")\n  .replace(/\\n/g, \"\")\n  .trim();\nconst IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);\n\n/*\n * Parses a Natural number (i.e., non-negative integer) with either the\n *    <min>*<max>DIGIT ( non-digit *OCTET )\n * or\n *    <min>*<max>DIGIT\n * grammar (RFC6265 S5.1.1).\n *\n * The \"trailingOK\" boolean controls if the grammar accepts a\n * \"( non-digit *OCTET )\" trailer.\n */\nfunction parseDigits(token, minDigits, maxDigits, trailingOK) {\n  let count = 0;\n  while (count < token.length) {\n    const c = token.charCodeAt(count);\n    // \"non-digit = %x00-2F / %x3A-FF\"\n    if (c <= 0x2f || c >= 0x3a) {\n      break;\n    }\n    count++;\n  }\n\n  // constrain to a minimum and maximum number of digits.\n  if (count < minDigits || count > maxDigits) {\n    return null;\n  }\n\n  if (!trailingOK && count != token.length) {\n    return null;\n  }\n\n  return parseInt(token.substr(0, count), 10);\n}\n\nfunction parseTime(token) {\n  const parts = token.split(\":\");\n  const result = [0, 0, 0];\n\n  /* RF6256 S5.1.1:\n   *      time            = hms-time ( non-digit *OCTET )\n   *      hms-time        = time-field \":\" time-field \":\" time-field\n   *      time-field      = 1*2DIGIT\n   */\n\n  if (parts.length !== 3) {\n    return null;\n  }\n\n  for (let i = 0; i < 3; i++) {\n    // \"time-field\" must be strictly \"1*2DIGIT\", HOWEVER, \"hms-time\" can be\n    // followed by \"( non-digit *OCTET )\" so therefore the last time-field can\n    // have a trailer\n    const trailingOK = i == 2;\n    const num = parseDigits(parts[i], 1, 2, trailingOK);\n    if (num === null) {\n      return null;\n    }\n    result[i] = num;\n  }\n\n  return result;\n}\n\nfunction parseMonth(token) {\n  token = String(token)\n    .substr(0, 3)\n    .toLowerCase();\n  const num = MONTH_TO_NUM[token];\n  return num >= 0 ? num : null;\n}\n\n/*\n * RFC6265 S5.1.1 date parser (see RFC for full grammar)\n */\nfunction parseDate(str) {\n  if (!str) {\n    return;\n  }\n\n  /* RFC6265 S5.1.1:\n   * 2. Process each date-token sequentially in the order the date-tokens\n   * appear in the cookie-date\n   */\n  const tokens = str.split(DATE_DELIM);\n  if (!tokens) {\n    return;\n  }\n\n  let hour = null;\n  let minute = null;\n  let second = null;\n  let dayOfMonth = null;\n  let month = null;\n  let year = null;\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i].trim();\n    if (!token.length) {\n      continue;\n    }\n\n    let result;\n\n    /* 2.1. If the found-time flag is not set and the token matches the time\n     * production, set the found-time flag and set the hour- value,\n     * minute-value, and second-value to the numbers denoted by the digits in\n     * the date-token, respectively.  Skip the remaining sub-steps and continue\n     * to the next date-token.\n     */\n    if (second === null) {\n      result = parseTime(token);\n      if (result) {\n        hour = result[0];\n        minute = result[1];\n        second = result[2];\n        continue;\n      }\n    }\n\n    /* 2.2. If the found-day-of-month flag is not set and the date-token matches\n     * the day-of-month production, set the found-day-of- month flag and set\n     * the day-of-month-value to the number denoted by the date-token.  Skip\n     * the remaining sub-steps and continue to the next date-token.\n     */\n    if (dayOfMonth === null) {\n      // \"day-of-month = 1*2DIGIT ( non-digit *OCTET )\"\n      result = parseDigits(token, 1, 2, true);\n      if (result !== null) {\n        dayOfMonth = result;\n        continue;\n      }\n    }\n\n    /* 2.3. If the found-month flag is not set and the date-token matches the\n     * month production, set the found-month flag and set the month-value to\n     * the month denoted by the date-token.  Skip the remaining sub-steps and\n     * continue to the next date-token.\n     */\n    if (month === null) {\n      result = parseMonth(token);\n      if (result !== null) {\n        month = result;\n        continue;\n      }\n    }\n\n    /* 2.4. If the found-year flag is not set and the date-token matches the\n     * year production, set the found-year flag and set the year-value to the\n     * number denoted by the date-token.  Skip the remaining sub-steps and\n     * continue to the next date-token.\n     */\n    if (year === null) {\n      // \"year = 2*4DIGIT ( non-digit *OCTET )\"\n      result = parseDigits(token, 2, 4, true);\n      if (result !== null) {\n        year = result;\n        /* From S5.1.1:\n         * 3.  If the year-value is greater than or equal to 70 and less\n         * than or equal to 99, increment the year-value by 1900.\n         * 4.  If the year-value is greater than or equal to 0 and less\n         * than or equal to 69, increment the year-value by 2000.\n         */\n        if (year >= 70 && year <= 99) {\n          year += 1900;\n        } else if (year >= 0 && year <= 69) {\n          year += 2000;\n        }\n      }\n    }\n  }\n\n  /* RFC 6265 S5.1.1\n   * \"5. Abort these steps and fail to parse the cookie-date if:\n   *     *  at least one of the found-day-of-month, found-month, found-\n   *        year, or found-time flags is not set,\n   *     *  the day-of-month-value is less than 1 or greater than 31,\n   *     *  the year-value is less than 1601,\n   *     *  the hour-value is greater than 23,\n   *     *  the minute-value is greater than 59, or\n   *     *  the second-value is greater than 59.\n   *     (Note that leap seconds cannot be represented in this syntax.)\"\n   *\n   * So, in order as above:\n   */\n  if (\n    dayOfMonth === null ||\n    month === null ||\n    year === null ||\n    second === null ||\n    dayOfMonth < 1 ||\n    dayOfMonth > 31 ||\n    year < 1601 ||\n    hour > 23 ||\n    minute > 59 ||\n    second > 59\n  ) {\n    return;\n  }\n\n  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));\n}\n\nfunction formatDate(date) {\n  validators.validate(validators.isDate(date), date);\n  return date.toUTCString();\n}\n\n// S5.1.2 Canonicalized Host Names\nfunction canonicalDomain(str) {\n  if (str == null) {\n    return null;\n  }\n  str = str.trim().replace(/^\\./, \"\"); // S4.1.2.3 & S5.2.3: ignore leading .\n\n  if (IP_V6_REGEX_OBJECT.test(str)) {\n    str = str.replace(\"[\", \"\").replace(\"]\", \"\");\n  }\n\n  // convert to IDN if any non-ASCII characters\n  if (punycode && /[^\\u0001-\\u007f]/.test(str)) {\n    str = punycode.toASCII(str);\n  }\n\n  return str.toLowerCase();\n}\n\n// S5.1.3 Domain Matching\nfunction domainMatch(str, domStr, canonicalize) {\n  if (str == null || domStr == null) {\n    return null;\n  }\n  if (canonicalize !== false) {\n    str = canonicalDomain(str);\n    domStr = canonicalDomain(domStr);\n  }\n\n  /*\n   * S5.1.3:\n   * \"A string domain-matches a given domain string if at least one of the\n   * following conditions hold:\"\n   *\n   * \" o The domain string and the string are identical. (Note that both the\n   * domain string and the string will have been canonicalized to lower case at\n   * this point)\"\n   */\n  if (str == domStr) {\n    return true;\n  }\n\n  /* \" o All of the following [three] conditions hold:\" */\n\n  /* \"* The domain string is a suffix of the string\" */\n  const idx = str.lastIndexOf(domStr);\n  if (idx <= 0) {\n    return false; // it's a non-match (-1) or prefix (0)\n  }\n\n  // next, check it's a proper suffix\n  // e.g., \"a.b.c\".indexOf(\"b.c\") === 2\n  // 5 === 3+2\n  if (str.length !== domStr.length + idx) {\n    return false; // it's not a suffix\n  }\n\n  /* \"  * The last character of the string that is not included in the\n   * domain string is a %x2E (\".\") character.\" */\n  if (str.substr(idx - 1, 1) !== \".\") {\n    return false; // doesn't align on \".\"\n  }\n\n  /* \"  * The string is a host name (i.e., not an IP address).\" */\n  if (IP_REGEX_LOWERCASE.test(str)) {\n    return false; // it's an IP address\n  }\n\n  return true;\n}\n\n// RFC6265 S5.1.4 Paths and Path-Match\n\n/*\n * \"The user agent MUST use an algorithm equivalent to the following algorithm\n * to compute the default-path of a cookie:\"\n *\n * Assumption: the path (and not query part or absolute uri) is passed in.\n */\nfunction defaultPath(path) {\n  // \"2. If the uri-path is empty or if the first character of the uri-path is not\n  // a %x2F (\"/\") character, output %x2F (\"/\") and skip the remaining steps.\n  if (!path || path.substr(0, 1) !== \"/\") {\n    return \"/\";\n  }\n\n  // \"3. If the uri-path contains no more than one %x2F (\"/\") character, output\n  // %x2F (\"/\") and skip the remaining step.\"\n  if (path === \"/\") {\n    return path;\n  }\n\n  const rightSlash = path.lastIndexOf(\"/\");\n  if (rightSlash === 0) {\n    return \"/\";\n  }\n\n  // \"4. Output the characters of the uri-path from the first character up to,\n  // but not including, the right-most %x2F (\"/\").\"\n  return path.slice(0, rightSlash);\n}\n\nfunction trimTerminator(str) {\n  if (validators.isEmptyString(str)) return str;\n  for (let t = 0; t < TERMINATORS.length; t++) {\n    const terminatorIdx = str.indexOf(TERMINATORS[t]);\n    if (terminatorIdx !== -1) {\n      str = str.substr(0, terminatorIdx);\n    }\n  }\n\n  return str;\n}\n\nfunction parseCookiePair(cookiePair, looseMode) {\n  cookiePair = trimTerminator(cookiePair);\n  validators.validate(validators.isString(cookiePair), cookiePair);\n\n  let firstEq = cookiePair.indexOf(\"=\");\n  if (looseMode) {\n    if (firstEq === 0) {\n      // '=' is immediately at start\n      cookiePair = cookiePair.substr(1);\n      firstEq = cookiePair.indexOf(\"=\"); // might still need to split on '='\n    }\n  } else {\n    // non-loose mode\n    if (firstEq <= 0) {\n      // no '=' or is at start\n      return; // needs to have non-empty \"cookie-name\"\n    }\n  }\n\n  let cookieName, cookieValue;\n  if (firstEq <= 0) {\n    cookieName = \"\";\n    cookieValue = cookiePair.trim();\n  } else {\n    cookieName = cookiePair.substr(0, firstEq).trim();\n    cookieValue = cookiePair.substr(firstEq + 1).trim();\n  }\n\n  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {\n    return;\n  }\n\n  const c = new Cookie();\n  c.key = cookieName;\n  c.value = cookieValue;\n  return c;\n}\n\nfunction parse(str, options) {\n  if (!options || typeof options !== \"object\") {\n    options = {};\n  }\n\n  if (validators.isEmptyString(str) || !validators.isString(str)) {\n    return null;\n  }\n\n  str = str.trim();\n\n  // We use a regex to parse the \"name-value-pair\" part of S5.2\n  const firstSemi = str.indexOf(\";\"); // S5.2 step 1\n  const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);\n  const c = parseCookiePair(cookiePair, !!options.loose);\n  if (!c) {\n    return;\n  }\n\n  if (firstSemi === -1) {\n    return c;\n  }\n\n  // S5.2.3 \"unparsed-attributes consist of the remainder of the set-cookie-string\n  // (including the %x3B (\";\") in question).\" plus later on in the same section\n  // \"discard the first \";\" and trim\".\n  const unparsed = str.slice(firstSemi + 1).trim();\n\n  // \"If the unparsed-attributes string is empty, skip the rest of these\n  // steps.\"\n  if (unparsed.length === 0) {\n    return c;\n  }\n\n  /*\n   * S5.2 says that when looping over the items \"[p]rocess the attribute-name\n   * and attribute-value according to the requirements in the following\n   * subsections\" for every item.  Plus, for many of the individual attributes\n   * in S5.3 it says to use the \"attribute-value of the last attribute in the\n   * cookie-attribute-list\".  Therefore, in this implementation, we overwrite\n   * the previous value.\n   */\n  const cookie_avs = unparsed.split(\";\");\n  while (cookie_avs.length) {\n    const av = cookie_avs.shift().trim();\n    if (av.length === 0) {\n      // happens if \";;\" appears\n      continue;\n    }\n    const av_sep = av.indexOf(\"=\");\n    let av_key, av_value;\n\n    if (av_sep === -1) {\n      av_key = av;\n      av_value = null;\n    } else {\n      av_key = av.substr(0, av_sep);\n      av_value = av.substr(av_sep + 1);\n    }\n\n    av_key = av_key.trim().toLowerCase();\n\n    if (av_value) {\n      av_value = av_value.trim();\n    }\n\n    switch (av_key) {\n      case \"expires\": // S5.2.1\n        if (av_value) {\n          const exp = parseDate(av_value);\n          // \"If the attribute-value failed to parse as a cookie date, ignore the\n          // cookie-av.\"\n          if (exp) {\n            // over and underflow not realistically a concern: V8's getTime() seems to\n            // store something larger than a 32-bit time_t (even with 32-bit node)\n            c.expires = exp;\n          }\n        }\n        break;\n\n      case \"max-age\": // S5.2.2\n        if (av_value) {\n          // \"If the first character of the attribute-value is not a DIGIT or a \"-\"\n          // character ...[or]... If the remainder of attribute-value contains a\n          // non-DIGIT character, ignore the cookie-av.\"\n          if (/^-?[0-9]+$/.test(av_value)) {\n            const delta = parseInt(av_value, 10);\n            // \"If delta-seconds is less than or equal to zero (0), let expiry-time\n            // be the earliest representable date and time.\"\n            c.setMaxAge(delta);\n          }\n        }\n        break;\n\n      case \"domain\": // S5.2.3\n        // \"If the attribute-value is empty, the behavior is undefined.  However,\n        // the user agent SHOULD ignore the cookie-av entirely.\"\n        if (av_value) {\n          // S5.2.3 \"Let cookie-domain be the attribute-value without the leading %x2E\n          // (\".\") character.\"\n          const domain = av_value.trim().replace(/^\\./, \"\");\n          if (domain) {\n            // \"Convert the cookie-domain to lower case.\"\n            c.domain = domain.toLowerCase();\n          }\n        }\n        break;\n\n      case \"path\": // S5.2.4\n        /*\n         * \"If the attribute-value is empty or if the first character of the\n         * attribute-value is not %x2F (\"/\"):\n         *   Let cookie-path be the default-path.\n         * Otherwise:\n         *   Let cookie-path be the attribute-value.\"\n         *\n         * We'll represent the default-path as null since it depends on the\n         * context of the parsing.\n         */\n        c.path = av_value && av_value[0] === \"/\" ? av_value : null;\n        break;\n\n      case \"secure\": // S5.2.5\n        /*\n         * \"If the attribute-name case-insensitively matches the string \"Secure\",\n         * the user agent MUST append an attribute to the cookie-attribute-list\n         * with an attribute-name of Secure and an empty attribute-value.\"\n         */\n        c.secure = true;\n        break;\n\n      case \"httponly\": // S5.2.6 -- effectively the same as 'secure'\n        c.httpOnly = true;\n        break;\n\n      case \"samesite\": // RFC6265bis-02 S5.3.7\n        const enforcement = av_value ? av_value.toLowerCase() : \"\";\n        switch (enforcement) {\n          case \"strict\":\n            c.sameSite = \"strict\";\n            break;\n          case \"lax\":\n            c.sameSite = \"lax\";\n            break;\n          case \"none\":\n            c.sameSite = \"none\";\n            break;\n          default:\n            c.sameSite = undefined;\n            break;\n        }\n        break;\n\n      default:\n        c.extensions = c.extensions || [];\n        c.extensions.push(av);\n        break;\n    }\n  }\n\n  return c;\n}\n\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Secure-\", abort these steps and ignore the cookie\n *  entirely unless the cookie's secure-only-flag is true.\n * @param cookie\n * @returns boolean\n */\nfunction isSecurePrefixConditionMet(cookie) {\n  validators.validate(validators.isObject(cookie), cookie);\n  return !cookie.key.startsWith(\"__Secure-\") || cookie.secure;\n}\n\n/**\n *  If the cookie-name begins with a case-sensitive match for the\n *  string \"__Host-\", abort these steps and ignore the cookie\n *  entirely unless the cookie meets all the following criteria:\n *    1.  The cookie's secure-only-flag is true.\n *    2.  The cookie's host-only-flag is true.\n *    3.  The cookie-attribute-list contains an attribute with an\n *        attribute-name of \"Path\", and the cookie's path is \"/\".\n * @param cookie\n * @returns boolean\n */\nfunction isHostPrefixConditionMet(cookie) {\n  validators.validate(validators.isObject(cookie));\n  return (\n    !cookie.key.startsWith(\"__Host-\") ||\n    (cookie.secure &&\n      cookie.hostOnly &&\n      cookie.path != null &&\n      cookie.path === \"/\")\n  );\n}\n\n// avoid the V8 deoptimization monster!\nfunction jsonParse(str) {\n  let obj;\n  try {\n    obj = JSON.parse(str);\n  } catch (e) {\n    return e;\n  }\n  return obj;\n}\n\nfunction fromJSON(str) {\n  if (!str || validators.isEmptyString(str)) {\n    return null;\n  }\n\n  let obj;\n  if (typeof str === \"string\") {\n    obj = jsonParse(str);\n    if (obj instanceof Error) {\n      return null;\n    }\n  } else {\n    // assume it's an Object\n    obj = str;\n  }\n\n  const c = new Cookie();\n  for (let i = 0; i < Cookie.serializableProperties.length; i++) {\n    const prop = Cookie.serializableProperties[i];\n    if (obj[prop] === undefined || obj[prop] === cookieDefaults[prop]) {\n      continue; // leave as prototype default\n    }\n\n    if (prop === \"expires\" || prop === \"creation\" || prop === \"lastAccessed\") {\n      if (obj[prop] === null) {\n        c[prop] = null;\n      } else {\n        c[prop] = obj[prop] == \"Infinity\" ? \"Infinity\" : new Date(obj[prop]);\n      }\n    } else {\n      c[prop] = obj[prop];\n    }\n  }\n\n  return c;\n}\n\n/* Section 5.4 part 2:\n * \"*  Cookies with longer paths are listed before cookies with\n *     shorter paths.\n *\n *  *  Among cookies that have equal-length path fields, cookies with\n *     earlier creation-times are listed before cookies with later\n *     creation-times.\"\n */\n\nfunction cookieCompare(a, b) {\n  validators.validate(validators.isObject(a), a);\n  validators.validate(validators.isObject(b), b);\n  let cmp = 0;\n\n  // descending for length: b CMP a\n  const aPathLen = a.path ? a.path.length : 0;\n  const bPathLen = b.path ? b.path.length : 0;\n  cmp = bPathLen - aPathLen;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  // ascending for time: a CMP b\n  const aTime = a.creation ? a.creation.getTime() : MAX_TIME;\n  const bTime = b.creation ? b.creation.getTime() : MAX_TIME;\n  cmp = aTime - bTime;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  // break ties for the same millisecond (precision of JavaScript's clock)\n  cmp = a.creationIndex - b.creationIndex;\n\n  return cmp;\n}\n\n// Gives the permutation of all possible pathMatch()es of a given path. The\n// array is in longest-to-shortest order.  Handy for indexing.\nfunction permutePath(path) {\n  validators.validate(validators.isString(path));\n  if (path === \"/\") {\n    return [\"/\"];\n  }\n  const permutations = [path];\n  while (path.length > 1) {\n    const lindex = path.lastIndexOf(\"/\");\n    if (lindex === 0) {\n      break;\n    }\n    path = path.substr(0, lindex);\n    permutations.push(path);\n  }\n  permutations.push(\"/\");\n  return permutations;\n}\n\nfunction getCookieContext(url) {\n  if (url instanceof Object) {\n    return url;\n  }\n  // NOTE: decodeURI will throw on malformed URIs (see GH-32).\n  // Therefore, we will just skip decoding for such URIs.\n  try {\n    url = decodeURI(url);\n  } catch (err) {\n    // Silently swallow error\n  }\n\n  return urlParse(url);\n}\n\nconst cookieDefaults = {\n  // the order in which the RFC has them:\n  key: \"\",\n  value: \"\",\n  expires: \"Infinity\",\n  maxAge: null,\n  domain: null,\n  path: null,\n  secure: false,\n  httpOnly: false,\n  extensions: null,\n  // set by the CookieJar:\n  hostOnly: null,\n  pathIsDefault: null,\n  creation: null,\n  lastAccessed: null,\n  sameSite: undefined\n};\n\nclass Cookie {\n  constructor(options = {}) {\n    const customInspectSymbol = getCustomInspectSymbol();\n    if (customInspectSymbol) {\n      this[customInspectSymbol] = this.inspect;\n    }\n\n    Object.assign(this, cookieDefaults, options);\n    this.creation = this.creation || new Date();\n\n    // used to break creation ties in cookieCompare():\n    Object.defineProperty(this, \"creationIndex\", {\n      configurable: false,\n      enumerable: false, // important for assert.deepEqual checks\n      writable: true,\n      value: ++Cookie.cookiesCreated\n    });\n  }\n\n  inspect() {\n    const now = Date.now();\n    const hostOnly = this.hostOnly != null ? this.hostOnly : \"?\";\n    const createAge = this.creation\n      ? `${now - this.creation.getTime()}ms`\n      : \"?\";\n    const accessAge = this.lastAccessed\n      ? `${now - this.lastAccessed.getTime()}ms`\n      : \"?\";\n    return `Cookie=\"${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}\"`;\n  }\n\n  toJSON() {\n    const obj = {};\n\n    for (const prop of Cookie.serializableProperties) {\n      if (this[prop] === cookieDefaults[prop]) {\n        continue; // leave as prototype default\n      }\n\n      if (\n        prop === \"expires\" ||\n        prop === \"creation\" ||\n        prop === \"lastAccessed\"\n      ) {\n        if (this[prop] === null) {\n          obj[prop] = null;\n        } else {\n          obj[prop] =\n            this[prop] == \"Infinity\" // intentionally not ===\n              ? \"Infinity\"\n              : this[prop].toISOString();\n        }\n      } else if (prop === \"maxAge\") {\n        if (this[prop] !== null) {\n          // again, intentionally not ===\n          obj[prop] =\n            this[prop] == Infinity || this[prop] == -Infinity\n              ? this[prop].toString()\n              : this[prop];\n        }\n      } else {\n        if (this[prop] !== cookieDefaults[prop]) {\n          obj[prop] = this[prop];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  clone() {\n    return fromJSON(this.toJSON());\n  }\n\n  validate() {\n    if (!COOKIE_OCTETS.test(this.value)) {\n      return false;\n    }\n    if (\n      this.expires != Infinity &&\n      !(this.expires instanceof Date) &&\n      !parseDate(this.expires)\n    ) {\n      return false;\n    }\n    if (this.maxAge != null && this.maxAge <= 0) {\n      return false; // \"Max-Age=\" non-zero-digit *DIGIT\n    }\n    if (this.path != null && !PATH_VALUE.test(this.path)) {\n      return false;\n    }\n\n    const cdomain = this.cdomain();\n    if (cdomain) {\n      if (cdomain.match(/\\.$/)) {\n        return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this\n      }\n      const suffix = pubsuffix.getPublicSuffix(cdomain);\n      if (suffix == null) {\n        // it's a public suffix\n        return false;\n      }\n    }\n    return true;\n  }\n\n  setExpires(exp) {\n    if (exp instanceof Date) {\n      this.expires = exp;\n    } else {\n      this.expires = parseDate(exp) || \"Infinity\";\n    }\n  }\n\n  setMaxAge(age) {\n    if (age === Infinity || age === -Infinity) {\n      this.maxAge = age.toString(); // so JSON.stringify() works\n    } else {\n      this.maxAge = age;\n    }\n  }\n\n  cookieString() {\n    let val = this.value;\n    if (val == null) {\n      val = \"\";\n    }\n    if (this.key === \"\") {\n      return val;\n    }\n    return `${this.key}=${val}`;\n  }\n\n  // gives Set-Cookie header format\n  toString() {\n    let str = this.cookieString();\n\n    if (this.expires != Infinity) {\n      if (this.expires instanceof Date) {\n        str += `; Expires=${formatDate(this.expires)}`;\n      } else {\n        str += `; Expires=${this.expires}`;\n      }\n    }\n\n    if (this.maxAge != null && this.maxAge != Infinity) {\n      str += `; Max-Age=${this.maxAge}`;\n    }\n\n    if (this.domain && !this.hostOnly) {\n      str += `; Domain=${this.domain}`;\n    }\n    if (this.path) {\n      str += `; Path=${this.path}`;\n    }\n\n    if (this.secure) {\n      str += \"; Secure\";\n    }\n    if (this.httpOnly) {\n      str += \"; HttpOnly\";\n    }\n    if (this.sameSite && this.sameSite !== \"none\") {\n      const ssCanon = Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];\n      str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;\n    }\n    if (this.extensions) {\n      this.extensions.forEach(ext => {\n        str += `; ${ext}`;\n      });\n    }\n\n    return str;\n  }\n\n  // TTL() partially replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\n  // elsewhere)\n  // S5.3 says to give the \"latest representable date\" for which we use Infinity\n  // For \"expired\" we use 0\n  TTL(now) {\n    /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires\n     * attribute, the Max-Age attribute has precedence and controls the\n     * expiration date of the cookie.\n     * (Concurs with S5.3 step 3)\n     */\n    if (this.maxAge != null) {\n      return this.maxAge <= 0 ? 0 : this.maxAge * 1000;\n    }\n\n    let expires = this.expires;\n    if (expires != Infinity) {\n      if (!(expires instanceof Date)) {\n        expires = parseDate(expires) || Infinity;\n      }\n\n      if (expires == Infinity) {\n        return Infinity;\n      }\n\n      return expires.getTime() - (now || Date.now());\n    }\n\n    return Infinity;\n  }\n\n  // expiryTime() replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\n  // elsewhere)\n  expiryTime(now) {\n    if (this.maxAge != null) {\n      const relativeTo = now || this.creation || new Date();\n      const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1000;\n      return relativeTo.getTime() + age;\n    }\n\n    if (this.expires == Infinity) {\n      return Infinity;\n    }\n    return this.expires.getTime();\n  }\n\n  // expiryDate() replaces the \"expiry-time\" parts of S5.3 step 3 (setCookie()\n  // elsewhere), except it returns a Date\n  expiryDate(now) {\n    const millisec = this.expiryTime(now);\n    if (millisec == Infinity) {\n      return new Date(MAX_TIME);\n    } else if (millisec == -Infinity) {\n      return new Date(MIN_TIME);\n    } else {\n      return new Date(millisec);\n    }\n  }\n\n  // This replaces the \"persistent-flag\" parts of S5.3 step 3\n  isPersistent() {\n    return this.maxAge != null || this.expires != Infinity;\n  }\n\n  // Mostly S5.1.2 and S5.2.3:\n  canonicalizedDomain() {\n    if (this.domain == null) {\n      return null;\n    }\n    return canonicalDomain(this.domain);\n  }\n\n  cdomain() {\n    return this.canonicalizedDomain();\n  }\n}\n\nCookie.cookiesCreated = 0;\nCookie.parse = parse;\nCookie.fromJSON = fromJSON;\nCookie.serializableProperties = Object.keys(cookieDefaults);\nCookie.sameSiteLevel = {\n  strict: 3,\n  lax: 2,\n  none: 1\n};\n\nCookie.sameSiteCanonical = {\n  strict: \"Strict\",\n  lax: \"Lax\"\n};\n\nfunction getNormalizedPrefixSecurity(prefixSecurity) {\n  if (prefixSecurity != null) {\n    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();\n    /* The three supported options */\n    switch (normalizedPrefixSecurity) {\n      case PrefixSecurityEnum.STRICT:\n      case PrefixSecurityEnum.SILENT:\n      case PrefixSecurityEnum.DISABLED:\n        return normalizedPrefixSecurity;\n    }\n  }\n  /* Default is SILENT */\n  return PrefixSecurityEnum.SILENT;\n}\n\nclass CookieJar {\n  constructor(store, options = { rejectPublicSuffixes: true }) {\n    if (typeof options === \"boolean\") {\n      options = { rejectPublicSuffixes: options };\n    }\n    validators.validate(validators.isObject(options), options);\n    this.rejectPublicSuffixes = options.rejectPublicSuffixes;\n    this.enableLooseMode = !!options.looseMode;\n    this.allowSpecialUseDomain =\n      typeof options.allowSpecialUseDomain === \"boolean\"\n        ? options.allowSpecialUseDomain\n        : true;\n    this.store = store || new MemoryCookieStore();\n    this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);\n    this._cloneSync = syncWrap(\"clone\");\n    this._importCookiesSync = syncWrap(\"_importCookies\");\n    this.getCookiesSync = syncWrap(\"getCookies\");\n    this.getCookieStringSync = syncWrap(\"getCookieString\");\n    this.getSetCookieStringsSync = syncWrap(\"getSetCookieStrings\");\n    this.removeAllCookiesSync = syncWrap(\"removeAllCookies\");\n    this.setCookieSync = syncWrap(\"setCookie\");\n    this.serializeSync = syncWrap(\"serialize\");\n  }\n\n  setCookie(cookie, url, options, cb) {\n    validators.validate(validators.isUrlStringOrObject(url), cb, options);\n\n    let err;\n\n    if (validators.isFunction(url)) {\n      cb = url;\n      return cb(new Error(\"No URL was specified\"));\n    }\n\n    const context = getCookieContext(url);\n    if (validators.isFunction(options)) {\n      cb = options;\n      options = {};\n    }\n\n    validators.validate(validators.isFunction(cb), cb);\n\n    if (\n      !validators.isNonEmptyString(cookie) &&\n      !validators.isObject(cookie) &&\n      cookie instanceof String &&\n      cookie.length == 0\n    ) {\n      return cb(null);\n    }\n\n    const host = canonicalDomain(context.hostname);\n    const loose = options.loose || this.enableLooseMode;\n\n    let sameSiteContext = null;\n    if (options.sameSiteContext) {\n      sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      if (!sameSiteContext) {\n        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n\n    // S5.3 step 1\n    if (typeof cookie === \"string\" || cookie instanceof String) {\n      cookie = Cookie.parse(cookie, { loose: loose });\n      if (!cookie) {\n        err = new Error(\"Cookie failed to parse\");\n        return cb(options.ignoreError ? null : err);\n      }\n    } else if (!(cookie instanceof Cookie)) {\n      // If you're seeing this error, and are passing in a Cookie object,\n      // it *might* be a Cookie object from another loaded version of tough-cookie.\n      err = new Error(\n        \"First argument to setCookie must be a Cookie object or string\"\n      );\n      return cb(options.ignoreError ? null : err);\n    }\n\n    // S5.3 step 2\n    const now = options.now || new Date(); // will assign later to save effort in the face of errors\n\n    // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()\n\n    // S5.3 step 4: NOOP; domain is null by default\n\n    // S5.3 step 5: public suffixes\n    if (this.rejectPublicSuffixes && cookie.domain) {\n      const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {\n        allowSpecialUseDomain: this.allowSpecialUseDomain,\n        ignoreError: options.ignoreError\n      });\n      if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {\n        // e.g. \"com\"\n        err = new Error(\"Cookie has domain set to a public suffix\");\n        return cb(options.ignoreError ? null : err);\n      }\n    }\n\n    // S5.3 step 6:\n    if (cookie.domain) {\n      if (!domainMatch(host, cookie.cdomain(), false)) {\n        err = new Error(\n          `Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`\n        );\n        return cb(options.ignoreError ? null : err);\n      }\n\n      if (cookie.hostOnly == null) {\n        // don't reset if already set\n        cookie.hostOnly = false;\n      }\n    } else {\n      cookie.hostOnly = true;\n      cookie.domain = host;\n    }\n\n    //S5.2.4 If the attribute-value is empty or if the first character of the\n    //attribute-value is not %x2F (\"/\"):\n    //Let cookie-path be the default-path.\n    if (!cookie.path || cookie.path[0] !== \"/\") {\n      cookie.path = defaultPath(context.pathname);\n      cookie.pathIsDefault = true;\n    }\n\n    // S5.3 step 8: NOOP; secure attribute\n    // S5.3 step 9: NOOP; httpOnly attribute\n\n    // S5.3 step 10\n    if (options.http === false && cookie.httpOnly) {\n      err = new Error(\"Cookie is HttpOnly and this isn't an HTTP API\");\n      return cb(options.ignoreError ? null : err);\n    }\n\n    // 6252bis-02 S5.4 Step 13 & 14:\n    if (\n      cookie.sameSite !== \"none\" &&\n      cookie.sameSite !== undefined &&\n      sameSiteContext\n    ) {\n      // \"If the cookie's \"same-site-flag\" is not \"None\", and the cookie\n      //  is being set from a context whose \"site for cookies\" is not an\n      //  exact match for request-uri's host's registered domain, then\n      //  abort these steps and ignore the newly created cookie entirely.\"\n      if (sameSiteContext === \"none\") {\n        err = new Error(\n          \"Cookie is SameSite but this is a cross-origin request\"\n        );\n        return cb(options.ignoreError ? null : err);\n      }\n    }\n\n    /* 6265bis-02 S5.4 Steps 15 & 16 */\n    const ignoreErrorForPrefixSecurity =\n      this.prefixSecurity === PrefixSecurityEnum.SILENT;\n    const prefixSecurityDisabled =\n      this.prefixSecurity === PrefixSecurityEnum.DISABLED;\n    /* If prefix checking is not disabled ...*/\n    if (!prefixSecurityDisabled) {\n      let errorFound = false;\n      let errorMsg;\n      /* Check secure prefix condition */\n      if (!isSecurePrefixConditionMet(cookie)) {\n        errorFound = true;\n        errorMsg = \"Cookie has __Secure prefix but Secure attribute is not set\";\n      } else if (!isHostPrefixConditionMet(cookie)) {\n        /* Check host prefix condition */\n        errorFound = true;\n        errorMsg =\n          \"Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'\";\n      }\n      if (errorFound) {\n        return cb(\n          options.ignoreError || ignoreErrorForPrefixSecurity\n            ? null\n            : new Error(errorMsg)\n        );\n      }\n    }\n\n    const store = this.store;\n\n    if (!store.updateCookie) {\n      store.updateCookie = function(oldCookie, newCookie, cb) {\n        this.putCookie(newCookie, cb);\n      };\n    }\n\n    function withCookie(err, oldCookie) {\n      if (err) {\n        return cb(err);\n      }\n\n      const next = function(err) {\n        if (err) {\n          return cb(err);\n        } else {\n          cb(null, cookie);\n        }\n      };\n\n      if (oldCookie) {\n        // S5.3 step 11 - \"If the cookie store contains a cookie with the same name,\n        // domain, and path as the newly created cookie:\"\n        if (options.http === false && oldCookie.httpOnly) {\n          // step 11.2\n          err = new Error(\"old Cookie is HttpOnly and this isn't an HTTP API\");\n          return cb(options.ignoreError ? null : err);\n        }\n        cookie.creation = oldCookie.creation; // step 11.3\n        cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker\n        cookie.lastAccessed = now;\n        // Step 11.4 (delete cookie) is implied by just setting the new one:\n        store.updateCookie(oldCookie, cookie, next); // step 12\n      } else {\n        cookie.creation = cookie.lastAccessed = now;\n        store.putCookie(cookie, next); // step 12\n      }\n    }\n\n    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);\n  }\n\n  // RFC6365 S5.4\n  getCookies(url, options, cb) {\n    validators.validate(validators.isUrlStringOrObject(url), cb, url);\n\n    const context = getCookieContext(url);\n    if (validators.isFunction(options)) {\n      cb = options;\n      options = {};\n    }\n    validators.validate(validators.isObject(options), cb, options);\n    validators.validate(validators.isFunction(cb), cb);\n\n    const host = canonicalDomain(context.hostname);\n    const path = context.pathname || \"/\";\n\n    let secure = options.secure;\n    if (\n      secure == null &&\n      context.protocol &&\n      (context.protocol == \"https:\" || context.protocol == \"wss:\")\n    ) {\n      secure = true;\n    }\n\n    let sameSiteLevel = 0;\n    if (options.sameSiteContext) {\n      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);\n      sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];\n      if (!sameSiteLevel) {\n        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));\n      }\n    }\n\n    let http = options.http;\n    if (http == null) {\n      http = true;\n    }\n\n    const now = options.now || Date.now();\n    const expireCheck = options.expire !== false;\n    const allPaths = !!options.allPaths;\n    const store = this.store;\n\n    function matchingCookie(c) {\n      // \"Either:\n      //   The cookie's host-only-flag is true and the canonicalized\n      //   request-host is identical to the cookie's domain.\n      // Or:\n      //   The cookie's host-only-flag is false and the canonicalized\n      //   request-host domain-matches the cookie's domain.\"\n      if (c.hostOnly) {\n        if (c.domain != host) {\n          return false;\n        }\n      } else {\n        if (!domainMatch(host, c.domain, false)) {\n          return false;\n        }\n      }\n\n      // \"The request-uri's path path-matches the cookie's path.\"\n      if (!allPaths && !pathMatch(path, c.path)) {\n        return false;\n      }\n\n      // \"If the cookie's secure-only-flag is true, then the request-uri's\n      // scheme must denote a \"secure\" protocol\"\n      if (c.secure && !secure) {\n        return false;\n      }\n\n      // \"If the cookie's http-only-flag is true, then exclude the cookie if the\n      // cookie-string is being generated for a \"non-HTTP\" API\"\n      if (c.httpOnly && !http) {\n        return false;\n      }\n\n      // RFC6265bis-02 S5.3.7\n      if (sameSiteLevel) {\n        const cookieLevel = Cookie.sameSiteLevel[c.sameSite || \"none\"];\n        if (cookieLevel > sameSiteLevel) {\n          // only allow cookies at or below the request level\n          return false;\n        }\n      }\n\n      // deferred from S5.3\n      // non-RFC: allow retention of expired cookies by choice\n      if (expireCheck && c.expiryTime() <= now) {\n        store.removeCookie(c.domain, c.path, c.key, () => {}); // result ignored\n        return false;\n      }\n\n      return true;\n    }\n\n    store.findCookies(\n      host,\n      allPaths ? null : path,\n      this.allowSpecialUseDomain,\n      (err, cookies) => {\n        if (err) {\n          return cb(err);\n        }\n\n        cookies = cookies.filter(matchingCookie);\n\n        // sorting of S5.4 part 2\n        if (options.sort !== false) {\n          cookies = cookies.sort(cookieCompare);\n        }\n\n        // S5.4 part 3\n        const now = new Date();\n        for (const cookie of cookies) {\n          cookie.lastAccessed = now;\n        }\n        // TODO persist lastAccessed\n\n        cb(null, cookies);\n      }\n    );\n  }\n\n  getCookieString(...args) {\n    const cb = args.pop();\n    validators.validate(validators.isFunction(cb), cb);\n    const next = function(err, cookies) {\n      if (err) {\n        cb(err);\n      } else {\n        cb(\n          null,\n          cookies\n            .sort(cookieCompare)\n            .map(c => c.cookieString())\n            .join(\"; \")\n        );\n      }\n    };\n    args.push(next);\n    this.getCookies.apply(this, args);\n  }\n\n  getSetCookieStrings(...args) {\n    const cb = args.pop();\n    validators.validate(validators.isFunction(cb), cb);\n    const next = function(err, cookies) {\n      if (err) {\n        cb(err);\n      } else {\n        cb(\n          null,\n          cookies.map(c => {\n            return c.toString();\n          })\n        );\n      }\n    };\n    args.push(next);\n    this.getCookies.apply(this, args);\n  }\n\n  serialize(cb) {\n    validators.validate(validators.isFunction(cb), cb);\n    let type = this.store.constructor.name;\n    if (validators.isObject(type)) {\n      type = null;\n    }\n\n    // update README.md \"Serialization Format\" if you change this, please!\n    const serialized = {\n      // The version of tough-cookie that serialized this jar. Generally a good\n      // practice since future versions can make data import decisions based on\n      // known past behavior. When/if this matters, use `semver`.\n      version: `tough-cookie@${VERSION}`,\n\n      // add the store type, to make humans happy:\n      storeType: type,\n\n      // CookieJar configuration:\n      rejectPublicSuffixes: !!this.rejectPublicSuffixes,\n      enableLooseMode: !!this.enableLooseMode,\n      allowSpecialUseDomain: !!this.allowSpecialUseDomain,\n      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),\n\n      // this gets filled from getAllCookies:\n      cookies: []\n    };\n\n    if (\n      !(\n        this.store.getAllCookies &&\n        typeof this.store.getAllCookies === \"function\"\n      )\n    ) {\n      return cb(\n        new Error(\n          \"store does not support getAllCookies and cannot be serialized\"\n        )\n      );\n    }\n\n    this.store.getAllCookies((err, cookies) => {\n      if (err) {\n        return cb(err);\n      }\n\n      serialized.cookies = cookies.map(cookie => {\n        // convert to serialized 'raw' cookies\n        cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;\n\n        // Remove the index so new ones get assigned during deserialization\n        delete cookie.creationIndex;\n\n        return cookie;\n      });\n\n      return cb(null, serialized);\n    });\n  }\n\n  toJSON() {\n    return this.serializeSync();\n  }\n\n  // use the class method CookieJar.deserialize instead of calling this directly\n  _importCookies(serialized, cb) {\n    let cookies = serialized.cookies;\n    if (!cookies || !Array.isArray(cookies)) {\n      return cb(new Error(\"serialized jar has no cookies array\"));\n    }\n    cookies = cookies.slice(); // do not modify the original\n\n    const putNext = err => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!cookies.length) {\n        return cb(err, this);\n      }\n\n      let cookie;\n      try {\n        cookie = fromJSON(cookies.shift());\n      } catch (e) {\n        return cb(e);\n      }\n\n      if (cookie === null) {\n        return putNext(null); // skip this cookie\n      }\n\n      this.store.putCookie(cookie, putNext);\n    };\n\n    putNext();\n  }\n\n  clone(newStore, cb) {\n    if (arguments.length === 1) {\n      cb = newStore;\n      newStore = null;\n    }\n\n    this.serialize((err, serialized) => {\n      if (err) {\n        return cb(err);\n      }\n      CookieJar.deserialize(serialized, newStore, cb);\n    });\n  }\n\n  cloneSync(newStore) {\n    if (arguments.length === 0) {\n      return this._cloneSync();\n    }\n    if (!newStore.synchronous) {\n      throw new Error(\n        \"CookieJar clone destination store is not synchronous; use async API instead.\"\n      );\n    }\n    return this._cloneSync(newStore);\n  }\n\n  removeAllCookies(cb) {\n    validators.validate(validators.isFunction(cb), cb);\n    const store = this.store;\n\n    // Check that the store implements its own removeAllCookies(). The default\n    // implementation in Store will immediately call the callback with a \"not\n    // implemented\" Error.\n    if (\n      typeof store.removeAllCookies === \"function\" &&\n      store.removeAllCookies !== Store.prototype.removeAllCookies\n    ) {\n      return store.removeAllCookies(cb);\n    }\n\n    store.getAllCookies((err, cookies) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (cookies.length === 0) {\n        return cb(null);\n      }\n\n      let completedCount = 0;\n      const removeErrors = [];\n\n      function removeCookieCb(removeErr) {\n        if (removeErr) {\n          removeErrors.push(removeErr);\n        }\n\n        completedCount++;\n\n        if (completedCount === cookies.length) {\n          return cb(removeErrors.length ? removeErrors[0] : null);\n        }\n      }\n\n      cookies.forEach(cookie => {\n        store.removeCookie(\n          cookie.domain,\n          cookie.path,\n          cookie.key,\n          removeCookieCb\n        );\n      });\n    });\n  }\n\n  static deserialize(strOrObj, store, cb) {\n    if (arguments.length !== 3) {\n      // store is optional\n      cb = store;\n      store = null;\n    }\n    validators.validate(validators.isFunction(cb), cb);\n\n    let serialized;\n    if (typeof strOrObj === \"string\") {\n      serialized = jsonParse(strOrObj);\n      if (serialized instanceof Error) {\n        return cb(serialized);\n      }\n    } else {\n      serialized = strOrObj;\n    }\n\n    const jar = new CookieJar(store, {\n      rejectPublicSuffixes: serialized.rejectPublicSuffixes,\n      looseMode: serialized.enableLooseMode,\n      allowSpecialUseDomain: serialized.allowSpecialUseDomain,\n      prefixSecurity: serialized.prefixSecurity\n    });\n    jar._importCookies(serialized, err => {\n      if (err) {\n        return cb(err);\n      }\n      cb(null, jar);\n    });\n  }\n\n  static deserializeSync(strOrObj, store) {\n    const serialized =\n      typeof strOrObj === \"string\" ? JSON.parse(strOrObj) : strOrObj;\n    const jar = new CookieJar(store, {\n      rejectPublicSuffixes: serialized.rejectPublicSuffixes,\n      looseMode: serialized.enableLooseMode\n    });\n\n    // catch this mistake early:\n    if (!jar.store.synchronous) {\n      throw new Error(\n        \"CookieJar store is not synchronous; use async API instead.\"\n      );\n    }\n\n    jar._importCookiesSync(serialized);\n    return jar;\n  }\n}\nCookieJar.fromJSON = CookieJar.deserializeSync;\n\n[\n  \"_importCookies\",\n  \"clone\",\n  \"getCookies\",\n  \"getCookieString\",\n  \"getSetCookieStrings\",\n  \"removeAllCookies\",\n  \"serialize\",\n  \"setCookie\"\n].forEach(name => {\n  CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);\n});\nCookieJar.deserialize = fromCallback(CookieJar.deserialize);\n\n// Use a closure to provide a true imperative API for synchronous stores.\nfunction syncWrap(method) {\n  return function(...args) {\n    if (!this.store.synchronous) {\n      throw new Error(\n        \"CookieJar store is not synchronous; use async API instead.\"\n      );\n    }\n\n    let syncErr, syncResult;\n    this[method](...args, (err, result) => {\n      syncErr = err;\n      syncResult = result;\n    });\n\n    if (syncErr) {\n      throw syncErr;\n    }\n    return syncResult;\n  };\n}\n\nexports.version = VERSION;\nexports.CookieJar = CookieJar;\nexports.Cookie = Cookie;\nexports.Store = Store;\nexports.MemoryCookieStore = MemoryCookieStore;\nexports.parseDate = parseDate;\nexports.formatDate = formatDate;\nexports.parse = parse;\nexports.fromJSON = fromJSON;\nexports.domainMatch = domainMatch;\nexports.defaultPath = defaultPath;\nexports.pathMatch = pathMatch;\nexports.getPublicSuffix = pubsuffix.getPublicSuffix;\nexports.cookieCompare = cookieCompare;\nexports.permuteDomain = __webpack_require__(/*! ./permuteDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/permuteDomain.js\").permuteDomain;\nexports.permutePath = permutePath;\nexports.canonicalDomain = canonicalDomain;\nexports.PrefixSecurityEnum = PrefixSecurityEnum;\nexports.ParameterError = validators.ParameterError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL2Nvb2tpZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFXO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFXO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLDZGQUFpQjtBQUMzQyxjQUFjLDBHQUF3QjtBQUN0QywwQkFBMEIsNEhBQXVDO0FBQ2pFLGtCQUFrQixzSEFBZ0M7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsMEZBQWlCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLGlGQUFXO0FBQ25DLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsd0dBQWM7QUFDL0MsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLHVGQUFjOztBQUV6RDtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUU7QUFDbkUsVUFBVTtBQUNWOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDLG9CQUFvQjtBQUNwQjtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILEVBQUUscUJBQXFCLElBQUksR0FBRyxF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMENBQTBDO0FBQzVEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0Esc0JBQXNCLGtCQUFrQixXQUFXLFdBQVcsT0FBTyxZQUFZLE9BQU8sVUFBVTtBQUNsRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRyxJQUFJO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVUseUJBQXlCO0FBQ3JELFFBQVE7QUFDUixrQkFBa0IsVUFBVSxhQUFhO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVSxZQUFZO0FBQ3RDOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVMsWUFBWTtBQUNyQztBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sVUFBVTtBQUNqQzs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRSxJQUFJO0FBQ3hCLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDLDBCQUEwQjs7QUFFMUIsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0IsVUFBVSxLQUFLO0FBQ3ZGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELFFBQVE7QUFDUjtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEdBQUc7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZixpQkFBaUI7QUFDakIsY0FBYztBQUNkLGFBQWE7QUFDYix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsd0pBQWdFO0FBQ2hFLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9jb29raWUuanM/Nzc2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDIwLCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBwdW55Y29kZSA9IHJlcXVpcmUoXCJwdW55Y29kZS9cIik7XG5jb25zdCB1cmxQYXJzZSA9IHJlcXVpcmUoXCJ1cmwtcGFyc2VcIik7XG5jb25zdCBwdWJzdWZmaXggPSByZXF1aXJlKFwiLi9wdWJzdWZmaXgtcHNsXCIpO1xuY29uc3QgU3RvcmUgPSByZXF1aXJlKFwiLi9zdG9yZVwiKS5TdG9yZTtcbmNvbnN0IE1lbW9yeUNvb2tpZVN0b3JlID0gcmVxdWlyZShcIi4vbWVtc3RvcmVcIikuTWVtb3J5Q29va2llU3RvcmU7XG5jb25zdCBwYXRoTWF0Y2ggPSByZXF1aXJlKFwiLi9wYXRoTWF0Y2hcIikucGF0aE1hdGNoO1xuY29uc3QgdmFsaWRhdG9ycyA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMuanNcIik7XG5jb25zdCBWRVJTSU9OID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbmNvbnN0IHsgZnJvbUNhbGxiYWNrIH0gPSByZXF1aXJlKFwidW5pdmVyc2FsaWZ5XCIpO1xuY29uc3QgeyBnZXRDdXN0b21JbnNwZWN0U3ltYm9sIH0gPSByZXF1aXJlKFwiLi91dGlsSGVscGVyXCIpO1xuXG4vLyBGcm9tIFJGQzYyNjUgUzQuMS4xXG4vLyBub3RlIHRoYXQgaXQgZXhjbHVkZXMgXFx4M0IgXCI7XCJcbmNvbnN0IENPT0tJRV9PQ1RFVFMgPSAvXltcXHgyMVxceDIzLVxceDJCXFx4MkQtXFx4M0FcXHgzQy1cXHg1QlxceDVELVxceDdFXSskLztcblxuY29uc3QgQ09OVFJPTF9DSEFSUyA9IC9bXFx4MDAtXFx4MUZdLztcblxuLy8gRnJvbSBDaHJvbWl1bSAvLyAnXFxyJywgJ1xcbicgYW5kICdcXDAnIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdGVybWluYXRvciBpblxuLy8gdGhlIFwicmVsYXhlZFwiIG1vZGUsIHNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9DaHJvbWl1bVdlYkFwcHMvY2hyb21pdW0vYmxvYi9iM2QzYjRkYThiYjk0YzFiMmUwNjE2MDBkZjEwNmQ1OTBmZGEzNjIwL25ldC9jb29raWVzL3BhcnNlZF9jb29raWUuY2MjTDYwXG5jb25zdCBURVJNSU5BVE9SUyA9IFtcIlxcblwiLCBcIlxcclwiLCBcIlxcMFwiXTtcblxuLy8gUkZDNjI2NSBTNC4xLjEgZGVmaW5lcyBwYXRoIHZhbHVlIGFzICdhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIidcbi8vIE5vdGUgJzsnIGlzIFxceDNCXG5jb25zdCBQQVRIX1ZBTFVFID0gL1tcXHgyMC1cXHgzQVxceDNDLVxceDdFXSsvO1xuXG4vLyBkYXRlLXRpbWUgcGFyc2luZyBjb25zdGFudHMgKFJGQzYyNjUgUzUuMS4xKVxuXG5jb25zdCBEQVRFX0RFTElNID0gL1tcXHgwOVxceDIwLVxceDJGXFx4M0ItXFx4NDBcXHg1Qi1cXHg2MFxceDdCLVxceDdFXS87XG5cbmNvbnN0IE1PTlRIX1RPX05VTSA9IHtcbiAgamFuOiAwLFxuICBmZWI6IDEsXG4gIG1hcjogMixcbiAgYXByOiAzLFxuICBtYXk6IDQsXG4gIGp1bjogNSxcbiAganVsOiA2LFxuICBhdWc6IDcsXG4gIHNlcDogOCxcbiAgb2N0OiA5LFxuICBub3Y6IDEwLFxuICBkZWM6IDExXG59O1xuXG5jb25zdCBNQVhfVElNRSA9IDIxNDc0ODM2NDcwMDA7IC8vIDMxLWJpdCBtYXhcbmNvbnN0IE1JTl9USU1FID0gMDsgLy8gMzEtYml0IG1pblxuY29uc3QgU0FNRV9TSVRFX0NPTlRFWFRfVkFMX0VSUiA9XG4gICdJbnZhbGlkIHNhbWVTaXRlQ29udGV4dCBvcHRpb24gZm9yIGdldENvb2tpZXMoKTsgZXhwZWN0ZWQgb25lIG9mIFwic3RyaWN0XCIsIFwibGF4XCIsIG9yIFwibm9uZVwiJztcblxuZnVuY3Rpb24gY2hlY2tTYW1lU2l0ZUNvbnRleHQodmFsdWUpIHtcbiAgdmFsaWRhdG9ycy52YWxpZGF0ZSh2YWxpZGF0b3JzLmlzTm9uRW1wdHlTdHJpbmcodmFsdWUpLCB2YWx1ZSk7XG4gIGNvbnN0IGNvbnRleHQgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChjb250ZXh0ID09PSBcIm5vbmVcIiB8fCBjb250ZXh0ID09PSBcImxheFwiIHx8IGNvbnRleHQgPT09IFwic3RyaWN0XCIpIHtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBQcmVmaXhTZWN1cml0eUVudW0gPSBPYmplY3QuZnJlZXplKHtcbiAgU0lMRU5UOiBcInNpbGVudFwiLFxuICBTVFJJQ1Q6IFwic3RyaWN0XCIsXG4gIERJU0FCTEVEOiBcInVuc2FmZS1kaXNhYmxlZFwiXG59KTtcblxuLy8gRHVtcGVkIGZyb20gaXAtcmVnZXhANC4wLjAsIHdpdGggdGhlIGZvbGxvd2luZyBjaGFuZ2VzOlxuLy8gKiBhbGwgY2FwdHVyaW5nIGdyb3VwcyBjb252ZXJ0ZWQgdG8gbm9uLWNhcHR1cmluZyAtLSBcIig/OilcIlxuLy8gKiBzdXBwb3J0IGZvciBJUHY2IFNjb3BlZCBMaXRlcmFsIChcIiVldGgxXCIpIHJlbW92ZWRcbi8vICogbG93ZXJjYXNlIGhleGFkZWNpbWFsIG9ubHlcbmNvbnN0IElQX1JFR0VYX0xPV0VSQ0FTRSA9IC8oPzpeKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfSQpfCg/Ol4oPzooPzpbYS1mXFxkXXsxLDR9Oil7N30oPzpbYS1mXFxkXXsxLDR9fDopfCg/OlthLWZcXGRdezEsNH06KXs2fSg/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318OlthLWZcXGRdezEsNH18Oil8KD86W2EtZlxcZF17MSw0fTopezV9KD86Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsMn18Oil8KD86W2EtZlxcZF17MSw0fTopezR9KD86KD86OlthLWZcXGRdezEsNH0pezAsMX06KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXwoPzo6W2EtZlxcZF17MSw0fSl7MSwzfXw6KXwoPzpbYS1mXFxkXXsxLDR9Oil7M30oPzooPzo6W2EtZlxcZF17MSw0fSl7MCwyfTooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldXFxkfFxcZCkpezN9fCg/OjpbYS1mXFxkXXsxLDR9KXsxLDR9fDopfCg/OlthLWZcXGRdezEsNH06KXsyfSg/Oig/OjpbYS1mXFxkXXsxLDR9KXswLDN9Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV1cXGR8XFxkKSl7M318KD86OlthLWZcXGRdezEsNH0pezEsNX18Oil8KD86W2EtZlxcZF17MSw0fTopezF9KD86KD86OlthLWZcXGRdezEsNH0pezAsNH06KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXwoPzo6W2EtZlxcZF17MSw0fSl7MSw2fXw6KXwoPzo6KD86KD86OlthLWZcXGRdezEsNH0pezAsNX06KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XVxcZHxcXGQpKXszfXwoPzo6W2EtZlxcZF17MSw0fSl7MSw3fXw6KSkpJCkvO1xuY29uc3QgSVBfVjZfUkVHRVggPSBgXG5cXFxcWz8oPzpcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezd9KD86W2EtZkEtRlxcXFxkXXsxLDR9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7Nn0oPzooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXw6W2EtZkEtRlxcXFxkXXsxLDR9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7NX0oPzo6KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSwyfXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezR9KD86KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MCwxfTooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDN9fDopfFxuKD86W2EtZkEtRlxcXFxkXXsxLDR9Oil7M30oPzooPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXswLDJ9Oig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkoPzpcXFxcLig/OjI1WzAtNV18MlswLTRdXFxcXGR8MVxcXFxkXFxcXGR8WzEtOV1cXFxcZHxcXFxcZCkpezN9fCg/OjpbYS1mQS1GXFxcXGRdezEsNH0pezEsNH18Oil8XG4oPzpbYS1mQS1GXFxcXGRdezEsNH06KXsyfSg/Oig/OjpbYS1mQS1GXFxcXGRdezEsNH0pezAsM306KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSw1fXw6KXxcbig/OlthLWZBLUZcXFxcZF17MSw0fTopezF9KD86KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MCw0fTooPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKD86XFxcXC4oPzoyNVswLTVdfDJbMC00XVxcXFxkfDFcXFxcZFxcXFxkfFsxLTldXFxcXGR8XFxcXGQpKXszfXwoPzo6W2EtZkEtRlxcXFxkXXsxLDR9KXsxLDZ9fDopfFxuKD86Oig/Oig/OjpbYS1mQS1GXFxcXGRdezEsNH0pezAsNX06KD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSg/OlxcXFwuKD86MjVbMC01XXwyWzAtNF1cXFxcZHwxXFxcXGRcXFxcZHxbMS05XVxcXFxkfFxcXFxkKSl7M318KD86OlthLWZBLUZcXFxcZF17MSw0fSl7MSw3fXw6KSlcbikoPzolWzAtOWEtekEtWl17MSx9KT9cXFxcXT9cbmBcbiAgLnJlcGxhY2UoL1xccypcXC9cXC8uKiQvZ20sIFwiXCIpXG4gIC5yZXBsYWNlKC9cXG4vZywgXCJcIilcbiAgLnRyaW0oKTtcbmNvbnN0IElQX1Y2X1JFR0VYX09CSkVDVCA9IG5ldyBSZWdFeHAoYF4ke0lQX1Y2X1JFR0VYfSRgKTtcblxuLypcbiAqIFBhcnNlcyBhIE5hdHVyYWwgbnVtYmVyIChpLmUuLCBub24tbmVnYXRpdmUgaW50ZWdlcikgd2l0aCBlaXRoZXIgdGhlXG4gKiAgICA8bWluPio8bWF4PkRJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXG4gKiBvclxuICogICAgPG1pbj4qPG1heD5ESUdJVFxuICogZ3JhbW1hciAoUkZDNjI2NSBTNS4xLjEpLlxuICpcbiAqIFRoZSBcInRyYWlsaW5nT0tcIiBib29sZWFuIGNvbnRyb2xzIGlmIHRoZSBncmFtbWFyIGFjY2VwdHMgYVxuICogXCIoIG5vbi1kaWdpdCAqT0NURVQgKVwiIHRyYWlsZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGlnaXRzKHRva2VuLCBtaW5EaWdpdHMsIG1heERpZ2l0cywgdHJhaWxpbmdPSykge1xuICBsZXQgY291bnQgPSAwO1xuICB3aGlsZSAoY291bnQgPCB0b2tlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBjID0gdG9rZW4uY2hhckNvZGVBdChjb3VudCk7XG4gICAgLy8gXCJub24tZGlnaXQgPSAleDAwLTJGIC8gJXgzQS1GRlwiXG4gICAgaWYgKGMgPD0gMHgyZiB8fCBjID49IDB4M2EpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb3VudCsrO1xuICB9XG5cbiAgLy8gY29uc3RyYWluIHRvIGEgbWluaW11bSBhbmQgbWF4aW11bSBudW1iZXIgb2YgZGlnaXRzLlxuICBpZiAoY291bnQgPCBtaW5EaWdpdHMgfHwgY291bnQgPiBtYXhEaWdpdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghdHJhaWxpbmdPSyAmJiBjb3VudCAhPSB0b2tlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh0b2tlbi5zdWJzdHIoMCwgY291bnQpLCAxMCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZSh0b2tlbikge1xuICBjb25zdCBwYXJ0cyA9IHRva2VuLnNwbGl0KFwiOlwiKTtcbiAgY29uc3QgcmVzdWx0ID0gWzAsIDAsIDBdO1xuXG4gIC8qIFJGNjI1NiBTNS4xLjE6XG4gICAqICAgICAgdGltZSAgICAgICAgICAgID0gaG1zLXRpbWUgKCBub24tZGlnaXQgKk9DVEVUIClcbiAgICogICAgICBobXMtdGltZSAgICAgICAgPSB0aW1lLWZpZWxkIFwiOlwiIHRpbWUtZmllbGQgXCI6XCIgdGltZS1maWVsZFxuICAgKiAgICAgIHRpbWUtZmllbGQgICAgICA9IDEqMkRJR0lUXG4gICAqL1xuXG4gIGlmIChwYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgLy8gXCJ0aW1lLWZpZWxkXCIgbXVzdCBiZSBzdHJpY3RseSBcIjEqMkRJR0lUXCIsIEhPV0VWRVIsIFwiaG1zLXRpbWVcIiBjYW4gYmVcbiAgICAvLyBmb2xsb3dlZCBieSBcIiggbm9uLWRpZ2l0ICpPQ1RFVCApXCIgc28gdGhlcmVmb3JlIHRoZSBsYXN0IHRpbWUtZmllbGQgY2FuXG4gICAgLy8gaGF2ZSBhIHRyYWlsZXJcbiAgICBjb25zdCB0cmFpbGluZ09LID0gaSA9PSAyO1xuICAgIGNvbnN0IG51bSA9IHBhcnNlRGlnaXRzKHBhcnRzW2ldLCAxLCAyLCB0cmFpbGluZ09LKTtcbiAgICBpZiAobnVtID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0W2ldID0gbnVtO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aCh0b2tlbikge1xuICB0b2tlbiA9IFN0cmluZyh0b2tlbilcbiAgICAuc3Vic3RyKDAsIDMpXG4gICAgLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG51bSA9IE1PTlRIX1RPX05VTVt0b2tlbl07XG4gIHJldHVybiBudW0gPj0gMCA/IG51bSA6IG51bGw7XG59XG5cbi8qXG4gKiBSRkM2MjY1IFM1LjEuMSBkYXRlIHBhcnNlciAoc2VlIFJGQyBmb3IgZnVsbCBncmFtbWFyKVxuICovXG5mdW5jdGlvbiBwYXJzZURhdGUoc3RyKSB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogUkZDNjI2NSBTNS4xLjE6XG4gICAqIDIuIFByb2Nlc3MgZWFjaCBkYXRlLXRva2VuIHNlcXVlbnRpYWxseSBpbiB0aGUgb3JkZXIgdGhlIGRhdGUtdG9rZW5zXG4gICAqIGFwcGVhciBpbiB0aGUgY29va2llLWRhdGVcbiAgICovXG4gIGNvbnN0IHRva2VucyA9IHN0ci5zcGxpdChEQVRFX0RFTElNKTtcbiAgaWYgKCF0b2tlbnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaG91ciA9IG51bGw7XG4gIGxldCBtaW51dGUgPSBudWxsO1xuICBsZXQgc2Vjb25kID0gbnVsbDtcbiAgbGV0IGRheU9mTW9udGggPSBudWxsO1xuICBsZXQgbW9udGggPSBudWxsO1xuICBsZXQgeWVhciA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXS50cmltKCk7XG4gICAgaWYgKCF0b2tlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICAvKiAyLjEuIElmIHRoZSBmb3VuZC10aW1lIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIHRva2VuIG1hdGNoZXMgdGhlIHRpbWVcbiAgICAgKiBwcm9kdWN0aW9uLCBzZXQgdGhlIGZvdW5kLXRpbWUgZmxhZyBhbmQgc2V0IHRoZSBob3VyLSB2YWx1ZSxcbiAgICAgKiBtaW51dGUtdmFsdWUsIGFuZCBzZWNvbmQtdmFsdWUgdG8gdGhlIG51bWJlcnMgZGVub3RlZCBieSB0aGUgZGlnaXRzIGluXG4gICAgICogdGhlIGRhdGUtdG9rZW4sIHJlc3BlY3RpdmVseS4gIFNraXAgdGhlIHJlbWFpbmluZyBzdWItc3RlcHMgYW5kIGNvbnRpbnVlXG4gICAgICogdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgKi9cbiAgICBpZiAoc2Vjb25kID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBwYXJzZVRpbWUodG9rZW4pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBob3VyID0gcmVzdWx0WzBdO1xuICAgICAgICBtaW51dGUgPSByZXN1bHRbMV07XG4gICAgICAgIHNlY29uZCA9IHJlc3VsdFsyXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMi4yLiBJZiB0aGUgZm91bmQtZGF5LW9mLW1vbnRoIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW4gbWF0Y2hlc1xuICAgICAqIHRoZSBkYXktb2YtbW9udGggcHJvZHVjdGlvbiwgc2V0IHRoZSBmb3VuZC1kYXktb2YtIG1vbnRoIGZsYWcgYW5kIHNldFxuICAgICAqIHRoZSBkYXktb2YtbW9udGgtdmFsdWUgdG8gdGhlIG51bWJlciBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcFxuICAgICAqIHRoZSByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZCBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmIChkYXlPZk1vbnRoID09PSBudWxsKSB7XG4gICAgICAvLyBcImRheS1vZi1tb250aCA9IDEqMkRJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXCJcbiAgICAgIHJlc3VsdCA9IHBhcnNlRGlnaXRzKHRva2VuLCAxLCAyLCB0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZNb250aCA9IHJlc3VsdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMi4zLiBJZiB0aGUgZm91bmQtbW9udGggZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgZGF0ZS10b2tlbiBtYXRjaGVzIHRoZVxuICAgICAqIG1vbnRoIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtbW9udGggZmxhZyBhbmQgc2V0IHRoZSBtb250aC12YWx1ZSB0b1xuICAgICAqIHRoZSBtb250aCBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmRcbiAgICAgKiBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmIChtb250aCA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGFyc2VNb250aCh0b2tlbik7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIG1vbnRoID0gcmVzdWx0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAyLjQuIElmIHRoZSBmb3VuZC15ZWFyIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW4gbWF0Y2hlcyB0aGVcbiAgICAgKiB5ZWFyIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQteWVhciBmbGFnIGFuZCBzZXQgdGhlIHllYXItdmFsdWUgdG8gdGhlXG4gICAgICogbnVtYmVyIGRlbm90ZWQgYnkgdGhlIGRhdGUtdG9rZW4uICBTa2lwIHRoZSByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZFxuICAgICAqIGNvbnRpbnVlIHRvIHRoZSBuZXh0IGRhdGUtdG9rZW4uXG4gICAgICovXG4gICAgaWYgKHllYXIgPT09IG51bGwpIHtcbiAgICAgIC8vIFwieWVhciA9IDIqNERJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXCJcbiAgICAgIHJlc3VsdCA9IHBhcnNlRGlnaXRzKHRva2VuLCAyLCA0LCB0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgeWVhciA9IHJlc3VsdDtcbiAgICAgICAgLyogRnJvbSBTNS4xLjE6XG4gICAgICAgICAqIDMuICBJZiB0aGUgeWVhci12YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gNzAgYW5kIGxlc3NcbiAgICAgICAgICogdGhhbiBvciBlcXVhbCB0byA5OSwgaW5jcmVtZW50IHRoZSB5ZWFyLXZhbHVlIGJ5IDE5MDAuXG4gICAgICAgICAqIDQuICBJZiB0aGUgeWVhci12YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzc1xuICAgICAgICAgKiB0aGFuIG9yIGVxdWFsIHRvIDY5LCBpbmNyZW1lbnQgdGhlIHllYXItdmFsdWUgYnkgMjAwMC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh5ZWFyID49IDcwICYmIHllYXIgPD0gOTkpIHtcbiAgICAgICAgICB5ZWFyICs9IDE5MDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA+PSAwICYmIHllYXIgPD0gNjkpIHtcbiAgICAgICAgICB5ZWFyICs9IDIwMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBSRkMgNjI2NSBTNS4xLjFcbiAgICogXCI1LiBBYm9ydCB0aGVzZSBzdGVwcyBhbmQgZmFpbCB0byBwYXJzZSB0aGUgY29va2llLWRhdGUgaWY6XG4gICAqICAgICAqICBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvdW5kLWRheS1vZi1tb250aCwgZm91bmQtbW9udGgsIGZvdW5kLVxuICAgKiAgICAgICAgeWVhciwgb3IgZm91bmQtdGltZSBmbGFncyBpcyBub3Qgc2V0LFxuICAgKiAgICAgKiAgdGhlIGRheS1vZi1tb250aC12YWx1ZSBpcyBsZXNzIHRoYW4gMSBvciBncmVhdGVyIHRoYW4gMzEsXG4gICAqICAgICAqICB0aGUgeWVhci12YWx1ZSBpcyBsZXNzIHRoYW4gMTYwMSxcbiAgICogICAgICogIHRoZSBob3VyLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiAyMyxcbiAgICogICAgICogIHRoZSBtaW51dGUtdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDU5LCBvclxuICAgKiAgICAgKiAgdGhlIHNlY29uZC12YWx1ZSBpcyBncmVhdGVyIHRoYW4gNTkuXG4gICAqICAgICAoTm90ZSB0aGF0IGxlYXAgc2Vjb25kcyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gdGhpcyBzeW50YXguKVwiXG4gICAqXG4gICAqIFNvLCBpbiBvcmRlciBhcyBhYm92ZTpcbiAgICovXG4gIGlmIChcbiAgICBkYXlPZk1vbnRoID09PSBudWxsIHx8XG4gICAgbW9udGggPT09IG51bGwgfHxcbiAgICB5ZWFyID09PSBudWxsIHx8XG4gICAgc2Vjb25kID09PSBudWxsIHx8XG4gICAgZGF5T2ZNb250aCA8IDEgfHxcbiAgICBkYXlPZk1vbnRoID4gMzEgfHxcbiAgICB5ZWFyIDwgMTYwMSB8fFxuICAgIGhvdXIgPiAyMyB8fFxuICAgIG1pbnV0ZSA+IDU5IHx8XG4gICAgc2Vjb25kID4gNTlcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgdmFsaWRhdG9ycy52YWxpZGF0ZSh2YWxpZGF0b3JzLmlzRGF0ZShkYXRlKSwgZGF0ZSk7XG4gIHJldHVybiBkYXRlLnRvVVRDU3RyaW5nKCk7XG59XG5cbi8vIFM1LjEuMiBDYW5vbmljYWxpemVkIEhvc3QgTmFtZXNcbmZ1bmN0aW9uIGNhbm9uaWNhbERvbWFpbihzdHIpIHtcbiAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9eXFwuLywgXCJcIik7IC8vIFM0LjEuMi4zICYgUzUuMi4zOiBpZ25vcmUgbGVhZGluZyAuXG5cbiAgaWYgKElQX1Y2X1JFR0VYX09CSkVDVC50ZXN0KHN0cikpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShcIltcIiwgXCJcIikucmVwbGFjZShcIl1cIiwgXCJcIik7XG4gIH1cblxuICAvLyBjb252ZXJ0IHRvIElETiBpZiBhbnkgbm9uLUFTQ0lJIGNoYXJhY3RlcnNcbiAgaWYgKHB1bnljb2RlICYmIC9bXlxcdTAwMDEtXFx1MDA3Zl0vLnRlc3Qoc3RyKSkge1xuICAgIHN0ciA9IHB1bnljb2RlLnRvQVNDSUkoc3RyKTtcbiAgfVxuXG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gUzUuMS4zIERvbWFpbiBNYXRjaGluZ1xuZnVuY3Rpb24gZG9tYWluTWF0Y2goc3RyLCBkb21TdHIsIGNhbm9uaWNhbGl6ZSkge1xuICBpZiAoc3RyID09IG51bGwgfHwgZG9tU3RyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY2Fub25pY2FsaXplICE9PSBmYWxzZSkge1xuICAgIHN0ciA9IGNhbm9uaWNhbERvbWFpbihzdHIpO1xuICAgIGRvbVN0ciA9IGNhbm9uaWNhbERvbWFpbihkb21TdHIpO1xuICB9XG5cbiAgLypcbiAgICogUzUuMS4zOlxuICAgKiBcIkEgc3RyaW5nIGRvbWFpbi1tYXRjaGVzIGEgZ2l2ZW4gZG9tYWluIHN0cmluZyBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlXG4gICAqIGZvbGxvd2luZyBjb25kaXRpb25zIGhvbGQ6XCJcbiAgICpcbiAgICogXCIgbyBUaGUgZG9tYWluIHN0cmluZyBhbmQgdGhlIHN0cmluZyBhcmUgaWRlbnRpY2FsLiAoTm90ZSB0aGF0IGJvdGggdGhlXG4gICAqIGRvbWFpbiBzdHJpbmcgYW5kIHRoZSBzdHJpbmcgd2lsbCBoYXZlIGJlZW4gY2Fub25pY2FsaXplZCB0byBsb3dlciBjYXNlIGF0XG4gICAqIHRoaXMgcG9pbnQpXCJcbiAgICovXG4gIGlmIChzdHIgPT0gZG9tU3RyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiBcIiBvIEFsbCBvZiB0aGUgZm9sbG93aW5nIFt0aHJlZV0gY29uZGl0aW9ucyBob2xkOlwiICovXG5cbiAgLyogXCIqIFRoZSBkb21haW4gc3RyaW5nIGlzIGEgc3VmZml4IG9mIHRoZSBzdHJpbmdcIiAqL1xuICBjb25zdCBpZHggPSBzdHIubGFzdEluZGV4T2YoZG9tU3RyKTtcbiAgaWYgKGlkeCA8PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBpdCdzIGEgbm9uLW1hdGNoICgtMSkgb3IgcHJlZml4ICgwKVxuICB9XG5cbiAgLy8gbmV4dCwgY2hlY2sgaXQncyBhIHByb3BlciBzdWZmaXhcbiAgLy8gZS5nLiwgXCJhLmIuY1wiLmluZGV4T2YoXCJiLmNcIikgPT09IDJcbiAgLy8gNSA9PT0gMysyXG4gIGlmIChzdHIubGVuZ3RoICE9PSBkb21TdHIubGVuZ3RoICsgaWR4KSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBpdCdzIG5vdCBhIHN1ZmZpeFxuICB9XG5cbiAgLyogXCIgICogVGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgdGhhdCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlXG4gICAqIGRvbWFpbiBzdHJpbmcgaXMgYSAleDJFIChcIi5cIikgY2hhcmFjdGVyLlwiICovXG4gIGlmIChzdHIuc3Vic3RyKGlkeCAtIDEsIDEpICE9PSBcIi5cIikge1xuICAgIHJldHVybiBmYWxzZTsgLy8gZG9lc24ndCBhbGlnbiBvbiBcIi5cIlxuICB9XG5cbiAgLyogXCIgICogVGhlIHN0cmluZyBpcyBhIGhvc3QgbmFtZSAoaS5lLiwgbm90IGFuIElQIGFkZHJlc3MpLlwiICovXG4gIGlmIChJUF9SRUdFWF9MT1dFUkNBU0UudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBpdCdzIGFuIElQIGFkZHJlc3NcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBSRkM2MjY1IFM1LjEuNCBQYXRocyBhbmQgUGF0aC1NYXRjaFxuXG4vKlxuICogXCJUaGUgdXNlciBhZ2VudCBNVVNUIHVzZSBhbiBhbGdvcml0aG0gZXF1aXZhbGVudCB0byB0aGUgZm9sbG93aW5nIGFsZ29yaXRobVxuICogdG8gY29tcHV0ZSB0aGUgZGVmYXVsdC1wYXRoIG9mIGEgY29va2llOlwiXG4gKlxuICogQXNzdW1wdGlvbjogdGhlIHBhdGggKGFuZCBub3QgcXVlcnkgcGFydCBvciBhYnNvbHV0ZSB1cmkpIGlzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFBhdGgocGF0aCkge1xuICAvLyBcIjIuIElmIHRoZSB1cmktcGF0aCBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSB1cmktcGF0aCBpcyBub3RcbiAgLy8gYSAleDJGIChcIi9cIikgY2hhcmFjdGVyLCBvdXRwdXQgJXgyRiAoXCIvXCIpIGFuZCBza2lwIHRoZSByZW1haW5pbmcgc3RlcHMuXG4gIGlmICghcGF0aCB8fCBwYXRoLnN1YnN0cigwLCAxKSAhPT0gXCIvXCIpIHtcbiAgICByZXR1cm4gXCIvXCI7XG4gIH1cblxuICAvLyBcIjMuIElmIHRoZSB1cmktcGF0aCBjb250YWlucyBubyBtb3JlIHRoYW4gb25lICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIsIG91dHB1dFxuICAvLyAleDJGIChcIi9cIikgYW5kIHNraXAgdGhlIHJlbWFpbmluZyBzdGVwLlwiXG4gIGlmIChwYXRoID09PSBcIi9cIikge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgY29uc3QgcmlnaHRTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICBpZiAocmlnaHRTbGFzaCA9PT0gMCkge1xuICAgIHJldHVybiBcIi9cIjtcbiAgfVxuXG4gIC8vIFwiNC4gT3V0cHV0IHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1cmktcGF0aCBmcm9tIHRoZSBmaXJzdCBjaGFyYWN0ZXIgdXAgdG8sXG4gIC8vIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgcmlnaHQtbW9zdCAleDJGIChcIi9cIikuXCJcbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgcmlnaHRTbGFzaCk7XG59XG5cbmZ1bmN0aW9uIHRyaW1UZXJtaW5hdG9yKHN0cikge1xuICBpZiAodmFsaWRhdG9ycy5pc0VtcHR5U3RyaW5nKHN0cikpIHJldHVybiBzdHI7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgVEVSTUlOQVRPUlMubGVuZ3RoOyB0KyspIHtcbiAgICBjb25zdCB0ZXJtaW5hdG9ySWR4ID0gc3RyLmluZGV4T2YoVEVSTUlOQVRPUlNbdF0pO1xuICAgIGlmICh0ZXJtaW5hdG9ySWR4ICE9PSAtMSkge1xuICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCB0ZXJtaW5hdG9ySWR4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNvb2tpZVBhaXIoY29va2llUGFpciwgbG9vc2VNb2RlKSB7XG4gIGNvb2tpZVBhaXIgPSB0cmltVGVybWluYXRvcihjb29raWVQYWlyKTtcbiAgdmFsaWRhdG9ycy52YWxpZGF0ZSh2YWxpZGF0b3JzLmlzU3RyaW5nKGNvb2tpZVBhaXIpLCBjb29raWVQYWlyKTtcblxuICBsZXQgZmlyc3RFcSA9IGNvb2tpZVBhaXIuaW5kZXhPZihcIj1cIik7XG4gIGlmIChsb29zZU1vZGUpIHtcbiAgICBpZiAoZmlyc3RFcSA9PT0gMCkge1xuICAgICAgLy8gJz0nIGlzIGltbWVkaWF0ZWx5IGF0IHN0YXJ0XG4gICAgICBjb29raWVQYWlyID0gY29va2llUGFpci5zdWJzdHIoMSk7XG4gICAgICBmaXJzdEVxID0gY29va2llUGFpci5pbmRleE9mKFwiPVwiKTsgLy8gbWlnaHQgc3RpbGwgbmVlZCB0byBzcGxpdCBvbiAnPSdcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uLWxvb3NlIG1vZGVcbiAgICBpZiAoZmlyc3RFcSA8PSAwKSB7XG4gICAgICAvLyBubyAnPScgb3IgaXMgYXQgc3RhcnRcbiAgICAgIHJldHVybjsgLy8gbmVlZHMgdG8gaGF2ZSBub24tZW1wdHkgXCJjb29raWUtbmFtZVwiXG4gICAgfVxuICB9XG5cbiAgbGV0IGNvb2tpZU5hbWUsIGNvb2tpZVZhbHVlO1xuICBpZiAoZmlyc3RFcSA8PSAwKSB7XG4gICAgY29va2llTmFtZSA9IFwiXCI7XG4gICAgY29va2llVmFsdWUgPSBjb29raWVQYWlyLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICBjb29raWVOYW1lID0gY29va2llUGFpci5zdWJzdHIoMCwgZmlyc3RFcSkudHJpbSgpO1xuICAgIGNvb2tpZVZhbHVlID0gY29va2llUGFpci5zdWJzdHIoZmlyc3RFcSArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIGlmIChDT05UUk9MX0NIQVJTLnRlc3QoY29va2llTmFtZSkgfHwgQ09OVFJPTF9DSEFSUy50ZXN0KGNvb2tpZVZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGMgPSBuZXcgQ29va2llKCk7XG4gIGMua2V5ID0gY29va2llTmFtZTtcbiAgYy52YWx1ZSA9IGNvb2tpZVZhbHVlO1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIikge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGlmICh2YWxpZGF0b3JzLmlzRW1wdHlTdHJpbmcoc3RyKSB8fCAhdmFsaWRhdG9ycy5pc1N0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdHIgPSBzdHIudHJpbSgpO1xuXG4gIC8vIFdlIHVzZSBhIHJlZ2V4IHRvIHBhcnNlIHRoZSBcIm5hbWUtdmFsdWUtcGFpclwiIHBhcnQgb2YgUzUuMlxuICBjb25zdCBmaXJzdFNlbWkgPSBzdHIuaW5kZXhPZihcIjtcIik7IC8vIFM1LjIgc3RlcCAxXG4gIGNvbnN0IGNvb2tpZVBhaXIgPSBmaXJzdFNlbWkgPT09IC0xID8gc3RyIDogc3RyLnN1YnN0cigwLCBmaXJzdFNlbWkpO1xuICBjb25zdCBjID0gcGFyc2VDb29raWVQYWlyKGNvb2tpZVBhaXIsICEhb3B0aW9ucy5sb29zZSk7XG4gIGlmICghYykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmaXJzdFNlbWkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvLyBTNS4yLjMgXCJ1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnNpc3Qgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmdcbiAgLy8gKGluY2x1ZGluZyB0aGUgJXgzQiAoXCI7XCIpIGluIHF1ZXN0aW9uKS5cIiBwbHVzIGxhdGVyIG9uIGluIHRoZSBzYW1lIHNlY3Rpb25cbiAgLy8gXCJkaXNjYXJkIHRoZSBmaXJzdCBcIjtcIiBhbmQgdHJpbVwiLlxuICBjb25zdCB1bnBhcnNlZCA9IHN0ci5zbGljZShmaXJzdFNlbWkgKyAxKS50cmltKCk7XG5cbiAgLy8gXCJJZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyBzdHJpbmcgaXMgZW1wdHksIHNraXAgdGhlIHJlc3Qgb2YgdGhlc2VcbiAgLy8gc3RlcHMuXCJcbiAgaWYgKHVucGFyc2VkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLypcbiAgICogUzUuMiBzYXlzIHRoYXQgd2hlbiBsb29waW5nIG92ZXIgdGhlIGl0ZW1zIFwiW3Bdcm9jZXNzIHRoZSBhdHRyaWJ1dGUtbmFtZVxuICAgKiBhbmQgYXR0cmlidXRlLXZhbHVlIGFjY29yZGluZyB0byB0aGUgcmVxdWlyZW1lbnRzIGluIHRoZSBmb2xsb3dpbmdcbiAgICogc3Vic2VjdGlvbnNcIiBmb3IgZXZlcnkgaXRlbS4gIFBsdXMsIGZvciBtYW55IG9mIHRoZSBpbmRpdmlkdWFsIGF0dHJpYnV0ZXNcbiAgICogaW4gUzUuMyBpdCBzYXlzIHRvIHVzZSB0aGUgXCJhdHRyaWJ1dGUtdmFsdWUgb2YgdGhlIGxhc3QgYXR0cmlidXRlIGluIHRoZVxuICAgKiBjb29raWUtYXR0cmlidXRlLWxpc3RcIi4gIFRoZXJlZm9yZSwgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbiwgd2Ugb3ZlcndyaXRlXG4gICAqIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICovXG4gIGNvbnN0IGNvb2tpZV9hdnMgPSB1bnBhcnNlZC5zcGxpdChcIjtcIik7XG4gIHdoaWxlIChjb29raWVfYXZzLmxlbmd0aCkge1xuICAgIGNvbnN0IGF2ID0gY29va2llX2F2cy5zaGlmdCgpLnRyaW0oKTtcbiAgICBpZiAoYXYubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBoYXBwZW5zIGlmIFwiOztcIiBhcHBlYXJzXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYXZfc2VwID0gYXYuaW5kZXhPZihcIj1cIik7XG4gICAgbGV0IGF2X2tleSwgYXZfdmFsdWU7XG5cbiAgICBpZiAoYXZfc2VwID09PSAtMSkge1xuICAgICAgYXZfa2V5ID0gYXY7XG4gICAgICBhdl92YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF2X2tleSA9IGF2LnN1YnN0cigwLCBhdl9zZXApO1xuICAgICAgYXZfdmFsdWUgPSBhdi5zdWJzdHIoYXZfc2VwICsgMSk7XG4gICAgfVxuXG4gICAgYXZfa2V5ID0gYXZfa2V5LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICBhdl92YWx1ZSA9IGF2X3ZhbHVlLnRyaW0oKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGF2X2tleSkge1xuICAgICAgY2FzZSBcImV4cGlyZXNcIjogLy8gUzUuMi4xXG4gICAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGV4cCA9IHBhcnNlRGF0ZShhdl92YWx1ZSk7XG4gICAgICAgICAgLy8gXCJJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGZhaWxlZCB0byBwYXJzZSBhcyBhIGNvb2tpZSBkYXRlLCBpZ25vcmUgdGhlXG4gICAgICAgICAgLy8gY29va2llLWF2LlwiXG4gICAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgLy8gb3ZlciBhbmQgdW5kZXJmbG93IG5vdCByZWFsaXN0aWNhbGx5IGEgY29uY2VybjogVjgncyBnZXRUaW1lKCkgc2VlbXMgdG9cbiAgICAgICAgICAgIC8vIHN0b3JlIHNvbWV0aGluZyBsYXJnZXIgdGhhbiBhIDMyLWJpdCB0aW1lX3QgKGV2ZW4gd2l0aCAzMi1iaXQgbm9kZSlcbiAgICAgICAgICAgIGMuZXhwaXJlcyA9IGV4cDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJtYXgtYWdlXCI6IC8vIFM1LjIuMlxuICAgICAgICBpZiAoYXZfdmFsdWUpIHtcbiAgICAgICAgICAvLyBcIklmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgYSBESUdJVCBvciBhIFwiLVwiXG4gICAgICAgICAgLy8gY2hhcmFjdGVyIC4uLltvcl0uLi4gSWYgdGhlIHJlbWFpbmRlciBvZiBhdHRyaWJ1dGUtdmFsdWUgY29udGFpbnMgYVxuICAgICAgICAgIC8vIG5vbi1ESUdJVCBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlwiXG4gICAgICAgICAgaWYgKC9eLT9bMC05XSskLy50ZXN0KGF2X3ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBwYXJzZUludChhdl92YWx1ZSwgMTApO1xuICAgICAgICAgICAgLy8gXCJJZiBkZWx0YS1zZWNvbmRzIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvICgwKSwgbGV0IGV4cGlyeS10aW1lXG4gICAgICAgICAgICAvLyBiZSB0aGUgZWFybGllc3QgcmVwcmVzZW50YWJsZSBkYXRlIGFuZCB0aW1lLlwiXG4gICAgICAgICAgICBjLnNldE1heEFnZShkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiZG9tYWluXCI6IC8vIFM1LjIuM1xuICAgICAgICAvLyBcIklmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgZW1wdHksIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuICBIb3dldmVyLFxuICAgICAgICAvLyB0aGUgdXNlciBhZ2VudCBTSE9VTEQgaWdub3JlIHRoZSBjb29raWUtYXYgZW50aXJlbHkuXCJcbiAgICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgICAgLy8gUzUuMi4zIFwiTGV0IGNvb2tpZS1kb21haW4gYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZSB3aXRob3V0IHRoZSBsZWFkaW5nICV4MkVcbiAgICAgICAgICAvLyAoXCIuXCIpIGNoYXJhY3Rlci5cIlxuICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGF2X3ZhbHVlLnRyaW0oKS5yZXBsYWNlKC9eXFwuLywgXCJcIik7XG4gICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgLy8gXCJDb252ZXJ0IHRoZSBjb29raWUtZG9tYWluIHRvIGxvd2VyIGNhc2UuXCJcbiAgICAgICAgICAgIGMuZG9tYWluID0gZG9tYWluLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicGF0aFwiOiAvLyBTNS4yLjRcbiAgICAgICAgLypcbiAgICAgICAgICogXCJJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gICAgICAgICAqIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgJXgyRiAoXCIvXCIpOlxuICAgICAgICAgKiAgIExldCBjb29raWUtcGF0aCBiZSB0aGUgZGVmYXVsdC1wYXRoLlxuICAgICAgICAgKiBPdGhlcndpc2U6XG4gICAgICAgICAqICAgTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXCJcbiAgICAgICAgICpcbiAgICAgICAgICogV2UnbGwgcmVwcmVzZW50IHRoZSBkZWZhdWx0LXBhdGggYXMgbnVsbCBzaW5jZSBpdCBkZXBlbmRzIG9uIHRoZVxuICAgICAgICAgKiBjb250ZXh0IG9mIHRoZSBwYXJzaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYy5wYXRoID0gYXZfdmFsdWUgJiYgYXZfdmFsdWVbMF0gPT09IFwiL1wiID8gYXZfdmFsdWUgOiBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInNlY3VyZVwiOiAvLyBTNS4yLjVcbiAgICAgICAgLypcbiAgICAgICAgICogXCJJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlNlY3VyZVwiLFxuICAgICAgICAgKiB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdFxuICAgICAgICAgKiB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIFNlY3VyZSBhbmQgYW4gZW1wdHkgYXR0cmlidXRlLXZhbHVlLlwiXG4gICAgICAgICAqL1xuICAgICAgICBjLnNlY3VyZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiaHR0cG9ubHlcIjogLy8gUzUuMi42IC0tIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzICdzZWN1cmUnXG4gICAgICAgIGMuaHR0cE9ubHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInNhbWVzaXRlXCI6IC8vIFJGQzYyNjViaXMtMDIgUzUuMy43XG4gICAgICAgIGNvbnN0IGVuZm9yY2VtZW50ID0gYXZfdmFsdWUgPyBhdl92YWx1ZS50b0xvd2VyQ2FzZSgpIDogXCJcIjtcbiAgICAgICAgc3dpdGNoIChlbmZvcmNlbWVudCkge1xuICAgICAgICAgIGNhc2UgXCJzdHJpY3RcIjpcbiAgICAgICAgICAgIGMuc2FtZVNpdGUgPSBcInN0cmljdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxheFwiOlxuICAgICAgICAgICAgYy5zYW1lU2l0ZSA9IFwibGF4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgYy5zYW1lU2l0ZSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGMuc2FtZVNpdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYy5leHRlbnNpb25zID0gYy5leHRlbnNpb25zIHx8IFtdO1xuICAgICAgICBjLmV4dGVuc2lvbnMucHVzaChhdik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG4vKipcbiAqICBJZiB0aGUgY29va2llLW5hbWUgYmVnaW5zIHdpdGggYSBjYXNlLXNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlXG4gKiAgc3RyaW5nIFwiX19TZWN1cmUtXCIsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIGNvb2tpZVxuICogIGVudGlyZWx5IHVubGVzcyB0aGUgY29va2llJ3Mgc2VjdXJlLW9ubHktZmxhZyBpcyB0cnVlLlxuICogQHBhcmFtIGNvb2tpZVxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5mdW5jdGlvbiBpc1NlY3VyZVByZWZpeENvbmRpdGlvbk1ldChjb29raWUpIHtcbiAgdmFsaWRhdG9ycy52YWxpZGF0ZSh2YWxpZGF0b3JzLmlzT2JqZWN0KGNvb2tpZSksIGNvb2tpZSk7XG4gIHJldHVybiAhY29va2llLmtleS5zdGFydHNXaXRoKFwiX19TZWN1cmUtXCIpIHx8IGNvb2tpZS5zZWN1cmU7XG59XG5cbi8qKlxuICogIElmIHRoZSBjb29raWUtbmFtZSBiZWdpbnMgd2l0aCBhIGNhc2Utc2Vuc2l0aXZlIG1hdGNoIGZvciB0aGVcbiAqICBzdHJpbmcgXCJfX0hvc3QtXCIsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIGNvb2tpZVxuICogIGVudGlyZWx5IHVubGVzcyB0aGUgY29va2llIG1lZXRzIGFsbCB0aGUgZm9sbG93aW5nIGNyaXRlcmlhOlxuICogICAgMS4gIFRoZSBjb29raWUncyBzZWN1cmUtb25seS1mbGFnIGlzIHRydWUuXG4gKiAgICAyLiAgVGhlIGNvb2tpZSdzIGhvc3Qtb25seS1mbGFnIGlzIHRydWUuXG4gKiAgICAzLiAgVGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCBjb250YWlucyBhbiBhdHRyaWJ1dGUgd2l0aCBhblxuICogICAgICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFwiUGF0aFwiLCBhbmQgdGhlIGNvb2tpZSdzIHBhdGggaXMgXCIvXCIuXG4gKiBAcGFyYW0gY29va2llXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdFByZWZpeENvbmRpdGlvbk1ldChjb29raWUpIHtcbiAgdmFsaWRhdG9ycy52YWxpZGF0ZSh2YWxpZGF0b3JzLmlzT2JqZWN0KGNvb2tpZSkpO1xuICByZXR1cm4gKFxuICAgICFjb29raWUua2V5LnN0YXJ0c1dpdGgoXCJfX0hvc3QtXCIpIHx8XG4gICAgKGNvb2tpZS5zZWN1cmUgJiZcbiAgICAgIGNvb2tpZS5ob3N0T25seSAmJlxuICAgICAgY29va2llLnBhdGggIT0gbnVsbCAmJlxuICAgICAgY29va2llLnBhdGggPT09IFwiL1wiKVxuICApO1xufVxuXG4vLyBhdm9pZCB0aGUgVjggZGVvcHRpbWl6YXRpb24gbW9uc3RlciFcbmZ1bmN0aW9uIGpzb25QYXJzZShzdHIpIHtcbiAgbGV0IG9iajtcbiAgdHJ5IHtcbiAgICBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBmcm9tSlNPTihzdHIpIHtcbiAgaWYgKCFzdHIgfHwgdmFsaWRhdG9ycy5pc0VtcHR5U3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBvYmo7XG4gIGlmICh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKSB7XG4gICAgb2JqID0ganNvblBhcnNlKHN0cik7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gYXNzdW1lIGl0J3MgYW4gT2JqZWN0XG4gICAgb2JqID0gc3RyO1xuICB9XG5cbiAgY29uc3QgYyA9IG5ldyBDb29raWUoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSBDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllc1tpXTtcbiAgICBpZiAob2JqW3Byb3BdID09PSB1bmRlZmluZWQgfHwgb2JqW3Byb3BdID09PSBjb29raWVEZWZhdWx0c1twcm9wXSkge1xuICAgICAgY29udGludWU7IC8vIGxlYXZlIGFzIHByb3RvdHlwZSBkZWZhdWx0XG4gICAgfVxuXG4gICAgaWYgKHByb3AgPT09IFwiZXhwaXJlc1wiIHx8IHByb3AgPT09IFwiY3JlYXRpb25cIiB8fCBwcm9wID09PSBcImxhc3RBY2Nlc3NlZFwiKSB7XG4gICAgICBpZiAob2JqW3Byb3BdID09PSBudWxsKSB7XG4gICAgICAgIGNbcHJvcF0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY1twcm9wXSA9IG9ialtwcm9wXSA9PSBcIkluZmluaXR5XCIgPyBcIkluZmluaXR5XCIgOiBuZXcgRGF0ZShvYmpbcHJvcF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG4vKiBTZWN0aW9uIDUuNCBwYXJ0IDI6XG4gKiBcIiogIENvb2tpZXMgd2l0aCBsb25nZXIgcGF0aHMgYXJlIGxpc3RlZCBiZWZvcmUgY29va2llcyB3aXRoXG4gKiAgICAgc2hvcnRlciBwYXRocy5cbiAqXG4gKiAgKiAgQW1vbmcgY29va2llcyB0aGF0IGhhdmUgZXF1YWwtbGVuZ3RoIHBhdGggZmllbGRzLCBjb29raWVzIHdpdGhcbiAqICAgICBlYXJsaWVyIGNyZWF0aW9uLXRpbWVzIGFyZSBsaXN0ZWQgYmVmb3JlIGNvb2tpZXMgd2l0aCBsYXRlclxuICogICAgIGNyZWF0aW9uLXRpbWVzLlwiXG4gKi9cblxuZnVuY3Rpb24gY29va2llQ29tcGFyZShhLCBiKSB7XG4gIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc09iamVjdChhKSwgYSk7XG4gIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc09iamVjdChiKSwgYik7XG4gIGxldCBjbXAgPSAwO1xuXG4gIC8vIGRlc2NlbmRpbmcgZm9yIGxlbmd0aDogYiBDTVAgYVxuICBjb25zdCBhUGF0aExlbiA9IGEucGF0aCA/IGEucGF0aC5sZW5ndGggOiAwO1xuICBjb25zdCBiUGF0aExlbiA9IGIucGF0aCA/IGIucGF0aC5sZW5ndGggOiAwO1xuICBjbXAgPSBiUGF0aExlbiAtIGFQYXRoTGVuO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIC8vIGFzY2VuZGluZyBmb3IgdGltZTogYSBDTVAgYlxuICBjb25zdCBhVGltZSA9IGEuY3JlYXRpb24gPyBhLmNyZWF0aW9uLmdldFRpbWUoKSA6IE1BWF9USU1FO1xuICBjb25zdCBiVGltZSA9IGIuY3JlYXRpb24gPyBiLmNyZWF0aW9uLmdldFRpbWUoKSA6IE1BWF9USU1FO1xuICBjbXAgPSBhVGltZSAtIGJUaW1lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIC8vIGJyZWFrIHRpZXMgZm9yIHRoZSBzYW1lIG1pbGxpc2Vjb25kIChwcmVjaXNpb24gb2YgSmF2YVNjcmlwdCdzIGNsb2NrKVxuICBjbXAgPSBhLmNyZWF0aW9uSW5kZXggLSBiLmNyZWF0aW9uSW5kZXg7XG5cbiAgcmV0dXJuIGNtcDtcbn1cblxuLy8gR2l2ZXMgdGhlIHBlcm11dGF0aW9uIG9mIGFsbCBwb3NzaWJsZSBwYXRoTWF0Y2goKWVzIG9mIGEgZ2l2ZW4gcGF0aC4gVGhlXG4vLyBhcnJheSBpcyBpbiBsb25nZXN0LXRvLXNob3J0ZXN0IG9yZGVyLiAgSGFuZHkgZm9yIGluZGV4aW5nLlxuZnVuY3Rpb24gcGVybXV0ZVBhdGgocGF0aCkge1xuICB2YWxpZGF0b3JzLnZhbGlkYXRlKHZhbGlkYXRvcnMuaXNTdHJpbmcocGF0aCkpO1xuICBpZiAocGF0aCA9PT0gXCIvXCIpIHtcbiAgICByZXR1cm4gW1wiL1wiXTtcbiAgfVxuICBjb25zdCBwZXJtdXRhdGlvbnMgPSBbcGF0aF07XG4gIHdoaWxlIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBsaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAobGluZGV4ID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGxpbmRleCk7XG4gICAgcGVybXV0YXRpb25zLnB1c2gocGF0aCk7XG4gIH1cbiAgcGVybXV0YXRpb25zLnB1c2goXCIvXCIpO1xuICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuXG5mdW5jdGlvbiBnZXRDb29raWVDb250ZXh0KHVybCkge1xuICBpZiAodXJsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICAvLyBOT1RFOiBkZWNvZGVVUkkgd2lsbCB0aHJvdyBvbiBtYWxmb3JtZWQgVVJJcyAoc2VlIEdILTMyKS5cbiAgLy8gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3Qgc2tpcCBkZWNvZGluZyBmb3Igc3VjaCBVUklzLlxuICB0cnkge1xuICAgIHVybCA9IGRlY29kZVVSSSh1cmwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBTaWxlbnRseSBzd2FsbG93IGVycm9yXG4gIH1cblxuICByZXR1cm4gdXJsUGFyc2UodXJsKTtcbn1cblxuY29uc3QgY29va2llRGVmYXVsdHMgPSB7XG4gIC8vIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgUkZDIGhhcyB0aGVtOlxuICBrZXk6IFwiXCIsXG4gIHZhbHVlOiBcIlwiLFxuICBleHBpcmVzOiBcIkluZmluaXR5XCIsXG4gIG1heEFnZTogbnVsbCxcbiAgZG9tYWluOiBudWxsLFxuICBwYXRoOiBudWxsLFxuICBzZWN1cmU6IGZhbHNlLFxuICBodHRwT25seTogZmFsc2UsXG4gIGV4dGVuc2lvbnM6IG51bGwsXG4gIC8vIHNldCBieSB0aGUgQ29va2llSmFyOlxuICBob3N0T25seTogbnVsbCxcbiAgcGF0aElzRGVmYXVsdDogbnVsbCxcbiAgY3JlYXRpb246IG51bGwsXG4gIGxhc3RBY2Nlc3NlZDogbnVsbCxcbiAgc2FtZVNpdGU6IHVuZGVmaW5lZFxufTtcblxuY2xhc3MgQ29va2llIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IGdldEN1c3RvbUluc3BlY3RTeW1ib2woKTtcbiAgICBpZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICAgICAgdGhpc1tjdXN0b21JbnNwZWN0U3ltYm9sXSA9IHRoaXMuaW5zcGVjdDtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvb2tpZURlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB0aGlzLmNyZWF0aW9uID0gdGhpcy5jcmVhdGlvbiB8fCBuZXcgRGF0ZSgpO1xuXG4gICAgLy8gdXNlZCB0byBicmVhayBjcmVhdGlvbiB0aWVzIGluIGNvb2tpZUNvbXBhcmUoKTpcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjcmVhdGlvbkluZGV4XCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgLy8gaW1wb3J0YW50IGZvciBhc3NlcnQuZGVlcEVxdWFsIGNoZWNrc1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogKytDb29raWUuY29va2llc0NyZWF0ZWRcbiAgICB9KTtcbiAgfVxuXG4gIGluc3BlY3QoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBob3N0T25seSA9IHRoaXMuaG9zdE9ubHkgIT0gbnVsbCA/IHRoaXMuaG9zdE9ubHkgOiBcIj9cIjtcbiAgICBjb25zdCBjcmVhdGVBZ2UgPSB0aGlzLmNyZWF0aW9uXG4gICAgICA/IGAke25vdyAtIHRoaXMuY3JlYXRpb24uZ2V0VGltZSgpfW1zYFxuICAgICAgOiBcIj9cIjtcbiAgICBjb25zdCBhY2Nlc3NBZ2UgPSB0aGlzLmxhc3RBY2Nlc3NlZFxuICAgICAgPyBgJHtub3cgLSB0aGlzLmxhc3RBY2Nlc3NlZC5nZXRUaW1lKCl9bXNgXG4gICAgICA6IFwiP1wiO1xuICAgIHJldHVybiBgQ29va2llPVwiJHt0aGlzLnRvU3RyaW5nKCl9OyBob3N0T25seT0ke2hvc3RPbmx5fTsgYUFnZT0ke2FjY2Vzc0FnZX07IGNBZ2U9JHtjcmVhdGVBZ2V9XCJgO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIENvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodGhpc1twcm9wXSA9PT0gY29va2llRGVmYXVsdHNbcHJvcF0pIHtcbiAgICAgICAgY29udGludWU7IC8vIGxlYXZlIGFzIHByb3RvdHlwZSBkZWZhdWx0XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvcCA9PT0gXCJleHBpcmVzXCIgfHxcbiAgICAgICAgcHJvcCA9PT0gXCJjcmVhdGlvblwiIHx8XG4gICAgICAgIHByb3AgPT09IFwibGFzdEFjY2Vzc2VkXCJcbiAgICAgICkge1xuICAgICAgICBpZiAodGhpc1twcm9wXSA9PT0gbnVsbCkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqW3Byb3BdID1cbiAgICAgICAgICAgIHRoaXNbcHJvcF0gPT0gXCJJbmZpbml0eVwiIC8vIGludGVudGlvbmFsbHkgbm90ID09PVxuICAgICAgICAgICAgICA/IFwiSW5maW5pdHlcIlxuICAgICAgICAgICAgICA6IHRoaXNbcHJvcF0udG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcIm1heEFnZVwiKSB7XG4gICAgICAgIGlmICh0aGlzW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gYWdhaW4sIGludGVudGlvbmFsbHkgbm90ID09PVxuICAgICAgICAgIG9ialtwcm9wXSA9XG4gICAgICAgICAgICB0aGlzW3Byb3BdID09IEluZmluaXR5IHx8IHRoaXNbcHJvcF0gPT0gLUluZmluaXR5XG4gICAgICAgICAgICAgID8gdGhpc1twcm9wXS50b1N0cmluZygpXG4gICAgICAgICAgICAgIDogdGhpc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IGNvb2tpZURlZmF1bHRzW3Byb3BdKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gZnJvbUpTT04odGhpcy50b0pTT04oKSk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAoIUNPT0tJRV9PQ1RFVFMudGVzdCh0aGlzLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0aGlzLmV4cGlyZXMgIT0gSW5maW5pdHkgJiZcbiAgICAgICEodGhpcy5leHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICFwYXJzZURhdGUodGhpcy5leHBpcmVzKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCAmJiB0aGlzLm1heEFnZSA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIFwiTWF4LUFnZT1cIiBub24temVyby1kaWdpdCAqRElHSVRcbiAgICB9XG4gICAgaWYgKHRoaXMucGF0aCAhPSBudWxsICYmICFQQVRIX1ZBTFVFLnRlc3QodGhpcy5wYXRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNkb21haW4gPSB0aGlzLmNkb21haW4oKTtcbiAgICBpZiAoY2RvbWFpbikge1xuICAgICAgaWYgKGNkb21haW4ubWF0Y2goL1xcLiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFM0LjEuMi4zIHN1Z2dlc3RzIHRoYXQgdGhpcyBpcyBiYWQuIGRvbWFpbk1hdGNoKCkgdGVzdHMgY29uZmlybSB0aGlzXG4gICAgICB9XG4gICAgICBjb25zdCBzdWZmaXggPSBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4KGNkb21haW4pO1xuICAgICAgaWYgKHN1ZmZpeCA9PSBudWxsKSB7XG4gICAgICAgIC8vIGl0J3MgYSBwdWJsaWMgc3VmZml4XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzZXRFeHBpcmVzKGV4cCkge1xuICAgIGlmIChleHAgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICB0aGlzLmV4cGlyZXMgPSBleHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwaXJlcyA9IHBhcnNlRGF0ZShleHApIHx8IFwiSW5maW5pdHlcIjtcbiAgICB9XG4gIH1cblxuICBzZXRNYXhBZ2UoYWdlKSB7XG4gICAgaWYgKGFnZSA9PT0gSW5maW5pdHkgfHwgYWdlID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHRoaXMubWF4QWdlID0gYWdlLnRvU3RyaW5nKCk7IC8vIHNvIEpTT04uc3RyaW5naWZ5KCkgd29ya3NcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXhBZ2UgPSBhZ2U7XG4gICAgfVxuICB9XG5cbiAgY29va2llU3RyaW5nKCkge1xuICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdmFsID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2V5ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5rZXl9PSR7dmFsfWA7XG4gIH1cblxuICAvLyBnaXZlcyBTZXQtQ29va2llIGhlYWRlciBmb3JtYXRcbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IHN0ciA9IHRoaXMuY29va2llU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5leHBpcmVzICE9IEluZmluaXR5KSB7XG4gICAgICBpZiAodGhpcy5leHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBzdHIgKz0gYDsgRXhwaXJlcz0ke2Zvcm1hdERhdGUodGhpcy5leHBpcmVzKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGA7IEV4cGlyZXM9JHt0aGlzLmV4cGlyZXN9YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCAmJiB0aGlzLm1heEFnZSAhPSBJbmZpbml0eSkge1xuICAgICAgc3RyICs9IGA7IE1heC1BZ2U9JHt0aGlzLm1heEFnZX1gO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRvbWFpbiAmJiAhdGhpcy5ob3N0T25seSkge1xuICAgICAgc3RyICs9IGA7IERvbWFpbj0ke3RoaXMuZG9tYWlufWA7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgIHN0ciArPSBgOyBQYXRoPSR7dGhpcy5wYXRofWA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VjdXJlKSB7XG4gICAgICBzdHIgKz0gXCI7IFNlY3VyZVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5odHRwT25seSkge1xuICAgICAgc3RyICs9IFwiOyBIdHRwT25seVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5zYW1lU2l0ZSAmJiB0aGlzLnNhbWVTaXRlICE9PSBcIm5vbmVcIikge1xuICAgICAgY29uc3Qgc3NDYW5vbiA9IENvb2tpZS5zYW1lU2l0ZUNhbm9uaWNhbFt0aGlzLnNhbWVTaXRlLnRvTG93ZXJDYXNlKCldO1xuICAgICAgc3RyICs9IGA7IFNhbWVTaXRlPSR7c3NDYW5vbiA/IHNzQ2Fub24gOiB0aGlzLnNhbWVTaXRlfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmV4dGVuc2lvbnMpIHtcbiAgICAgIHRoaXMuZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dCA9PiB7XG4gICAgICAgIHN0ciArPSBgOyAke2V4dH1gO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8vIFRUTCgpIHBhcnRpYWxseSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuICAvLyBlbHNld2hlcmUpXG4gIC8vIFM1LjMgc2F5cyB0byBnaXZlIHRoZSBcImxhdGVzdCByZXByZXNlbnRhYmxlIGRhdGVcIiBmb3Igd2hpY2ggd2UgdXNlIEluZmluaXR5XG4gIC8vIEZvciBcImV4cGlyZWRcIiB3ZSB1c2UgMFxuICBUVEwobm93KSB7XG4gICAgLyogUkZDNjI2NSBTNC4xLjIuMiBJZiBhIGNvb2tpZSBoYXMgYm90aCB0aGUgTWF4LUFnZSBhbmQgdGhlIEV4cGlyZXNcbiAgICAgKiBhdHRyaWJ1dGUsIHRoZSBNYXgtQWdlIGF0dHJpYnV0ZSBoYXMgcHJlY2VkZW5jZSBhbmQgY29udHJvbHMgdGhlXG4gICAgICogZXhwaXJhdGlvbiBkYXRlIG9mIHRoZSBjb29raWUuXG4gICAgICogKENvbmN1cnMgd2l0aCBTNS4zIHN0ZXAgMylcbiAgICAgKi9cbiAgICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF4QWdlIDw9IDAgPyAwIDogdGhpcy5tYXhBZ2UgKiAxMDAwO1xuICAgIH1cblxuICAgIGxldCBleHBpcmVzID0gdGhpcy5leHBpcmVzO1xuICAgIGlmIChleHBpcmVzICE9IEluZmluaXR5KSB7XG4gICAgICBpZiAoIShleHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgZXhwaXJlcyA9IHBhcnNlRGF0ZShleHBpcmVzKSB8fCBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cGlyZXMgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwaXJlcy5nZXRUaW1lKCkgLSAobm93IHx8IERhdGUubm93KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIC8vIGV4cGlyeVRpbWUoKSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuICAvLyBlbHNld2hlcmUpXG4gIGV4cGlyeVRpbWUobm93KSB7XG4gICAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBub3cgfHwgdGhpcy5jcmVhdGlvbiB8fCBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgYWdlID0gdGhpcy5tYXhBZ2UgPD0gMCA/IC1JbmZpbml0eSA6IHRoaXMubWF4QWdlICogMTAwMDtcbiAgICAgIHJldHVybiByZWxhdGl2ZVRvLmdldFRpbWUoKSArIGFnZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBpcmVzID09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4cGlyZXMuZ2V0VGltZSgpO1xuICB9XG5cbiAgLy8gZXhwaXJ5RGF0ZSgpIHJlcGxhY2VzIHRoZSBcImV4cGlyeS10aW1lXCIgcGFydHMgb2YgUzUuMyBzdGVwIDMgKHNldENvb2tpZSgpXG4gIC8vIGVsc2V3aGVyZSksIGV4Y2VwdCBpdCByZXR1cm5zIGEgRGF0ZVxuICBleHBpcnlEYXRlKG5vdykge1xuICAgIGNvbnN0IG1pbGxpc2VjID0gdGhpcy5leHBpcnlUaW1lKG5vdyk7XG4gICAgaWYgKG1pbGxpc2VjID09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTUFYX1RJTUUpO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWMgPT0gLUluZmluaXR5KSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTUlOX1RJTUUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzZWMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgcmVwbGFjZXMgdGhlIFwicGVyc2lzdGVudC1mbGFnXCIgcGFydHMgb2YgUzUuMyBzdGVwIDNcbiAgaXNQZXJzaXN0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLm1heEFnZSAhPSBudWxsIHx8IHRoaXMuZXhwaXJlcyAhPSBJbmZpbml0eTtcbiAgfVxuXG4gIC8vIE1vc3RseSBTNS4xLjIgYW5kIFM1LjIuMzpcbiAgY2Fub25pY2FsaXplZERvbWFpbigpIHtcbiAgICBpZiAodGhpcy5kb21haW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjYW5vbmljYWxEb21haW4odGhpcy5kb21haW4pO1xuICB9XG5cbiAgY2RvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxpemVkRG9tYWluKCk7XG4gIH1cbn1cblxuQ29va2llLmNvb2tpZXNDcmVhdGVkID0gMDtcbkNvb2tpZS5wYXJzZSA9IHBhcnNlO1xuQ29va2llLmZyb21KU09OID0gZnJvbUpTT047XG5Db29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGNvb2tpZURlZmF1bHRzKTtcbkNvb2tpZS5zYW1lU2l0ZUxldmVsID0ge1xuICBzdHJpY3Q6IDMsXG4gIGxheDogMixcbiAgbm9uZTogMVxufTtcblxuQ29va2llLnNhbWVTaXRlQ2Fub25pY2FsID0ge1xuICBzdHJpY3Q6IFwiU3RyaWN0XCIsXG4gIGxheDogXCJMYXhcIlxufTtcblxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFByZWZpeFNlY3VyaXR5KHByZWZpeFNlY3VyaXR5KSB7XG4gIGlmIChwcmVmaXhTZWN1cml0eSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFByZWZpeFNlY3VyaXR5ID0gcHJlZml4U2VjdXJpdHkudG9Mb3dlckNhc2UoKTtcbiAgICAvKiBUaGUgdGhyZWUgc3VwcG9ydGVkIG9wdGlvbnMgKi9cbiAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRQcmVmaXhTZWN1cml0eSkge1xuICAgICAgY2FzZSBQcmVmaXhTZWN1cml0eUVudW0uU1RSSUNUOlxuICAgICAgY2FzZSBQcmVmaXhTZWN1cml0eUVudW0uU0lMRU5UOlxuICAgICAgY2FzZSBQcmVmaXhTZWN1cml0eUVudW0uRElTQUJMRUQ6XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkUHJlZml4U2VjdXJpdHk7XG4gICAgfVxuICB9XG4gIC8qIERlZmF1bHQgaXMgU0lMRU5UICovXG4gIHJldHVybiBQcmVmaXhTZWN1cml0eUVudW0uU0lMRU5UO1xufVxuXG5jbGFzcyBDb29raWVKYXIge1xuICBjb25zdHJ1Y3RvcihzdG9yZSwgb3B0aW9ucyA9IHsgcmVqZWN0UHVibGljU3VmZml4ZXM6IHRydWUgfSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7IHJlamVjdFB1YmxpY1N1ZmZpeGVzOiBvcHRpb25zIH07XG4gICAgfVxuICAgIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc09iamVjdChvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyA9IG9wdGlvbnMucmVqZWN0UHVibGljU3VmZml4ZXM7XG4gICAgdGhpcy5lbmFibGVMb29zZU1vZGUgPSAhIW9wdGlvbnMubG9vc2VNb2RlO1xuICAgIHRoaXMuYWxsb3dTcGVjaWFsVXNlRG9tYWluID1cbiAgICAgIHR5cGVvZiBvcHRpb25zLmFsbG93U3BlY2lhbFVzZURvbWFpbiA9PT0gXCJib29sZWFuXCJcbiAgICAgICAgPyBvcHRpb25zLmFsbG93U3BlY2lhbFVzZURvbWFpblxuICAgICAgICA6IHRydWU7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlIHx8IG5ldyBNZW1vcnlDb29raWVTdG9yZSgpO1xuICAgIHRoaXMucHJlZml4U2VjdXJpdHkgPSBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkob3B0aW9ucy5wcmVmaXhTZWN1cml0eSk7XG4gICAgdGhpcy5fY2xvbmVTeW5jID0gc3luY1dyYXAoXCJjbG9uZVwiKTtcbiAgICB0aGlzLl9pbXBvcnRDb29raWVzU3luYyA9IHN5bmNXcmFwKFwiX2ltcG9ydENvb2tpZXNcIik7XG4gICAgdGhpcy5nZXRDb29raWVzU3luYyA9IHN5bmNXcmFwKFwiZ2V0Q29va2llc1wiKTtcbiAgICB0aGlzLmdldENvb2tpZVN0cmluZ1N5bmMgPSBzeW5jV3JhcChcImdldENvb2tpZVN0cmluZ1wiKTtcbiAgICB0aGlzLmdldFNldENvb2tpZVN0cmluZ3NTeW5jID0gc3luY1dyYXAoXCJnZXRTZXRDb29raWVTdHJpbmdzXCIpO1xuICAgIHRoaXMucmVtb3ZlQWxsQ29va2llc1N5bmMgPSBzeW5jV3JhcChcInJlbW92ZUFsbENvb2tpZXNcIik7XG4gICAgdGhpcy5zZXRDb29raWVTeW5jID0gc3luY1dyYXAoXCJzZXRDb29raWVcIik7XG4gICAgdGhpcy5zZXJpYWxpemVTeW5jID0gc3luY1dyYXAoXCJzZXJpYWxpemVcIik7XG4gIH1cblxuICBzZXRDb29raWUoY29va2llLCB1cmwsIG9wdGlvbnMsIGNiKSB7XG4gICAgdmFsaWRhdG9ycy52YWxpZGF0ZSh2YWxpZGF0b3JzLmlzVXJsU3RyaW5nT3JPYmplY3QodXJsKSwgY2IsIG9wdGlvbnMpO1xuXG4gICAgbGV0IGVycjtcblxuICAgIGlmICh2YWxpZGF0b3JzLmlzRnVuY3Rpb24odXJsKSkge1xuICAgICAgY2IgPSB1cmw7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKFwiTm8gVVJMIHdhcyBzcGVjaWZpZWRcIikpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQgPSBnZXRDb29raWVDb250ZXh0KHVybCk7XG4gICAgaWYgKHZhbGlkYXRvcnMuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc0Z1bmN0aW9uKGNiKSwgY2IpO1xuXG4gICAgaWYgKFxuICAgICAgIXZhbGlkYXRvcnMuaXNOb25FbXB0eVN0cmluZyhjb29raWUpICYmXG4gICAgICAhdmFsaWRhdG9ycy5pc09iamVjdChjb29raWUpICYmXG4gICAgICBjb29raWUgaW5zdGFuY2VvZiBTdHJpbmcgJiZcbiAgICAgIGNvb2tpZS5sZW5ndGggPT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIGNiKG51bGwpO1xuICAgIH1cblxuICAgIGNvbnN0IGhvc3QgPSBjYW5vbmljYWxEb21haW4oY29udGV4dC5ob3N0bmFtZSk7XG4gICAgY29uc3QgbG9vc2UgPSBvcHRpb25zLmxvb3NlIHx8IHRoaXMuZW5hYmxlTG9vc2VNb2RlO1xuXG4gICAgbGV0IHNhbWVTaXRlQ29udGV4dCA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuc2FtZVNpdGVDb250ZXh0KSB7XG4gICAgICBzYW1lU2l0ZUNvbnRleHQgPSBjaGVja1NhbWVTaXRlQ29udGV4dChvcHRpb25zLnNhbWVTaXRlQ29udGV4dCk7XG4gICAgICBpZiAoIXNhbWVTaXRlQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKFNBTUVfU0lURV9DT05URVhUX1ZBTF9FUlIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTNS4zIHN0ZXAgMVxuICAgIGlmICh0eXBlb2YgY29va2llID09PSBcInN0cmluZ1wiIHx8IGNvb2tpZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgY29va2llID0gQ29va2llLnBhcnNlKGNvb2tpZSwgeyBsb29zZTogbG9vc2UgfSk7XG4gICAgICBpZiAoIWNvb2tpZSkge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJDb29raWUgZmFpbGVkIHRvIHBhcnNlXCIpO1xuICAgICAgICByZXR1cm4gY2Iob3B0aW9ucy5pZ25vcmVFcnJvciA/IG51bGwgOiBlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShjb29raWUgaW5zdGFuY2VvZiBDb29raWUpKSB7XG4gICAgICAvLyBJZiB5b3UncmUgc2VlaW5nIHRoaXMgZXJyb3IsIGFuZCBhcmUgcGFzc2luZyBpbiBhIENvb2tpZSBvYmplY3QsXG4gICAgICAvLyBpdCAqbWlnaHQqIGJlIGEgQ29va2llIG9iamVjdCBmcm9tIGFub3RoZXIgbG9hZGVkIHZlcnNpb24gb2YgdG91Z2gtY29va2llLlxuICAgICAgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICBcIkZpcnN0IGFyZ3VtZW50IHRvIHNldENvb2tpZSBtdXN0IGJlIGEgQ29va2llIG9iamVjdCBvciBzdHJpbmdcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgfVxuXG4gICAgLy8gUzUuMyBzdGVwIDJcbiAgICBjb25zdCBub3cgPSBvcHRpb25zLm5vdyB8fCBuZXcgRGF0ZSgpOyAvLyB3aWxsIGFzc2lnbiBsYXRlciB0byBzYXZlIGVmZm9ydCBpbiB0aGUgZmFjZSBvZiBlcnJvcnNcblxuICAgIC8vIFM1LjMgc3RlcCAzOiBOT09QOyBwZXJzaXN0ZW50LWZsYWcgYW5kIGV4cGlyeS10aW1lIGlzIGhhbmRsZWQgYnkgZ2V0Q29va2llKClcblxuICAgIC8vIFM1LjMgc3RlcCA0OiBOT09QOyBkb21haW4gaXMgbnVsbCBieSBkZWZhdWx0XG5cbiAgICAvLyBTNS4zIHN0ZXAgNTogcHVibGljIHN1ZmZpeGVzXG4gICAgaWYgKHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMgJiYgY29va2llLmRvbWFpbikge1xuICAgICAgY29uc3Qgc3VmZml4ID0gcHVic3VmZml4LmdldFB1YmxpY1N1ZmZpeChjb29raWUuY2RvbWFpbigpLCB7XG4gICAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogdGhpcy5hbGxvd1NwZWNpYWxVc2VEb21haW4sXG4gICAgICAgIGlnbm9yZUVycm9yOiBvcHRpb25zLmlnbm9yZUVycm9yXG4gICAgICB9KTtcbiAgICAgIGlmIChzdWZmaXggPT0gbnVsbCAmJiAhSVBfVjZfUkVHRVhfT0JKRUNULnRlc3QoY29va2llLmRvbWFpbikpIHtcbiAgICAgICAgLy8gZS5nLiBcImNvbVwiXG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkNvb2tpZSBoYXMgZG9tYWluIHNldCB0byBhIHB1YmxpYyBzdWZmaXhcIik7XG4gICAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUzUuMyBzdGVwIDY6XG4gICAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICAgIGlmICghZG9tYWluTWF0Y2goaG9zdCwgY29va2llLmNkb21haW4oKSwgZmFsc2UpKSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ29va2llIG5vdCBpbiB0aGlzIGhvc3QncyBkb21haW4uIENvb2tpZToke2Nvb2tpZS5jZG9tYWluKCl9IFJlcXVlc3Q6JHtob3N0fWBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGNiKG9wdGlvbnMuaWdub3JlRXJyb3IgPyBudWxsIDogZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvb2tpZS5ob3N0T25seSA9PSBudWxsKSB7XG4gICAgICAgIC8vIGRvbid0IHJlc2V0IGlmIGFscmVhZHkgc2V0XG4gICAgICAgIGNvb2tpZS5ob3N0T25seSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb29raWUuaG9zdE9ubHkgPSB0cnVlO1xuICAgICAgY29va2llLmRvbWFpbiA9IGhvc3Q7XG4gICAgfVxuXG4gICAgLy9TNS4yLjQgSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAgIC8vYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gICAgLy9MZXQgY29va2llLXBhdGggYmUgdGhlIGRlZmF1bHQtcGF0aC5cbiAgICBpZiAoIWNvb2tpZS5wYXRoIHx8IGNvb2tpZS5wYXRoWzBdICE9PSBcIi9cIikge1xuICAgICAgY29va2llLnBhdGggPSBkZWZhdWx0UGF0aChjb250ZXh0LnBhdGhuYW1lKTtcbiAgICAgIGNvb2tpZS5wYXRoSXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTNS4zIHN0ZXAgODogTk9PUDsgc2VjdXJlIGF0dHJpYnV0ZVxuICAgIC8vIFM1LjMgc3RlcCA5OiBOT09QOyBodHRwT25seSBhdHRyaWJ1dGVcblxuICAgIC8vIFM1LjMgc3RlcCAxMFxuICAgIGlmIChvcHRpb25zLmh0dHAgPT09IGZhbHNlICYmIGNvb2tpZS5odHRwT25seSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgICAgcmV0dXJuIGNiKG9wdGlvbnMuaWdub3JlRXJyb3IgPyBudWxsIDogZXJyKTtcbiAgICB9XG5cbiAgICAvLyA2MjUyYmlzLTAyIFM1LjQgU3RlcCAxMyAmIDE0OlxuICAgIGlmIChcbiAgICAgIGNvb2tpZS5zYW1lU2l0ZSAhPT0gXCJub25lXCIgJiZcbiAgICAgIGNvb2tpZS5zYW1lU2l0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBzYW1lU2l0ZUNvbnRleHRcbiAgICApIHtcbiAgICAgIC8vIFwiSWYgdGhlIGNvb2tpZSdzIFwic2FtZS1zaXRlLWZsYWdcIiBpcyBub3QgXCJOb25lXCIsIGFuZCB0aGUgY29va2llXG4gICAgICAvLyAgaXMgYmVpbmcgc2V0IGZyb20gYSBjb250ZXh0IHdob3NlIFwic2l0ZSBmb3IgY29va2llc1wiIGlzIG5vdCBhblxuICAgICAgLy8gIGV4YWN0IG1hdGNoIGZvciByZXF1ZXN0LXVyaSdzIGhvc3QncyByZWdpc3RlcmVkIGRvbWFpbiwgdGhlblxuICAgICAgLy8gIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIG5ld2x5IGNyZWF0ZWQgY29va2llIGVudGlyZWx5LlwiXG4gICAgICBpZiAoc2FtZVNpdGVDb250ZXh0ID09PSBcIm5vbmVcIikge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDb29raWUgaXMgU2FtZVNpdGUgYnV0IHRoaXMgaXMgYSBjcm9zcy1vcmlnaW4gcmVxdWVzdFwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogNjI2NWJpcy0wMiBTNS40IFN0ZXBzIDE1ICYgMTYgKi9cbiAgICBjb25zdCBpZ25vcmVFcnJvckZvclByZWZpeFNlY3VyaXR5ID1cbiAgICAgIHRoaXMucHJlZml4U2VjdXJpdHkgPT09IFByZWZpeFNlY3VyaXR5RW51bS5TSUxFTlQ7XG4gICAgY29uc3QgcHJlZml4U2VjdXJpdHlEaXNhYmxlZCA9XG4gICAgICB0aGlzLnByZWZpeFNlY3VyaXR5ID09PSBQcmVmaXhTZWN1cml0eUVudW0uRElTQUJMRUQ7XG4gICAgLyogSWYgcHJlZml4IGNoZWNraW5nIGlzIG5vdCBkaXNhYmxlZCAuLi4qL1xuICAgIGlmICghcHJlZml4U2VjdXJpdHlEaXNhYmxlZCkge1xuICAgICAgbGV0IGVycm9yRm91bmQgPSBmYWxzZTtcbiAgICAgIGxldCBlcnJvck1zZztcbiAgICAgIC8qIENoZWNrIHNlY3VyZSBwcmVmaXggY29uZGl0aW9uICovXG4gICAgICBpZiAoIWlzU2VjdXJlUHJlZml4Q29uZGl0aW9uTWV0KGNvb2tpZSkpIHtcbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIGVycm9yTXNnID0gXCJDb29raWUgaGFzIF9fU2VjdXJlIHByZWZpeCBidXQgU2VjdXJlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0XCI7XG4gICAgICB9IGVsc2UgaWYgKCFpc0hvc3RQcmVmaXhDb25kaXRpb25NZXQoY29va2llKSkge1xuICAgICAgICAvKiBDaGVjayBob3N0IHByZWZpeCBjb25kaXRpb24gKi9cbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICAgIGVycm9yTXNnID1cbiAgICAgICAgICBcIkNvb2tpZSBoYXMgX19Ib3N0IHByZWZpeCBidXQgZWl0aGVyIFNlY3VyZSBvciBIb3N0T25seSBhdHRyaWJ1dGUgaXMgbm90IHNldCBvciBQYXRoIGlzIG5vdCAnLydcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvckZvdW5kKSB7XG4gICAgICAgIHJldHVybiBjYihcbiAgICAgICAgICBvcHRpb25zLmlnbm9yZUVycm9yIHx8IGlnbm9yZUVycm9yRm9yUHJlZml4U2VjdXJpdHlcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBuZXcgRXJyb3IoZXJyb3JNc2cpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzLnN0b3JlO1xuXG4gICAgaWYgKCFzdG9yZS51cGRhdGVDb29raWUpIHtcbiAgICAgIHN0b3JlLnVwZGF0ZUNvb2tpZSA9IGZ1bmN0aW9uKG9sZENvb2tpZSwgbmV3Q29va2llLCBjYikge1xuICAgICAgICB0aGlzLnB1dENvb2tpZShuZXdDb29raWUsIGNiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2l0aENvb2tpZShlcnIsIG9sZENvb2tpZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dCA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgY29va2llKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG9sZENvb2tpZSkge1xuICAgICAgICAvLyBTNS4zIHN0ZXAgMTEgLSBcIklmIHRoZSBjb29raWUgc3RvcmUgY29udGFpbnMgYSBjb29raWUgd2l0aCB0aGUgc2FtZSBuYW1lLFxuICAgICAgICAvLyBkb21haW4sIGFuZCBwYXRoIGFzIHRoZSBuZXdseSBjcmVhdGVkIGNvb2tpZTpcIlxuICAgICAgICBpZiAob3B0aW9ucy5odHRwID09PSBmYWxzZSAmJiBvbGRDb29raWUuaHR0cE9ubHkpIHtcbiAgICAgICAgICAvLyBzdGVwIDExLjJcbiAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJvbGQgQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgICAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY29va2llLmNyZWF0aW9uID0gb2xkQ29va2llLmNyZWF0aW9uOyAvLyBzdGVwIDExLjNcbiAgICAgICAgY29va2llLmNyZWF0aW9uSW5kZXggPSBvbGRDb29raWUuY3JlYXRpb25JbmRleDsgLy8gcHJlc2VydmUgdGllLWJyZWFrZXJcbiAgICAgICAgY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgICAgLy8gU3RlcCAxMS40IChkZWxldGUgY29va2llKSBpcyBpbXBsaWVkIGJ5IGp1c3Qgc2V0dGluZyB0aGUgbmV3IG9uZTpcbiAgICAgICAgc3RvcmUudXBkYXRlQ29va2llKG9sZENvb2tpZSwgY29va2llLCBuZXh0KTsgLy8gc3RlcCAxMlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29va2llLmNyZWF0aW9uID0gY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgICAgc3RvcmUucHV0Q29va2llKGNvb2tpZSwgbmV4dCk7IC8vIHN0ZXAgMTJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9yZS5maW5kQ29va2llKGNvb2tpZS5kb21haW4sIGNvb2tpZS5wYXRoLCBjb29raWUua2V5LCB3aXRoQ29va2llKTtcbiAgfVxuXG4gIC8vIFJGQzYzNjUgUzUuNFxuICBnZXRDb29raWVzKHVybCwgb3B0aW9ucywgY2IpIHtcbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlKHZhbGlkYXRvcnMuaXNVcmxTdHJpbmdPck9iamVjdCh1cmwpLCBjYiwgdXJsKTtcblxuICAgIGNvbnN0IGNvbnRleHQgPSBnZXRDb29raWVDb250ZXh0KHVybCk7XG4gICAgaWYgKHZhbGlkYXRvcnMuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlKHZhbGlkYXRvcnMuaXNPYmplY3Qob3B0aW9ucyksIGNiLCBvcHRpb25zKTtcbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlKHZhbGlkYXRvcnMuaXNGdW5jdGlvbihjYiksIGNiKTtcblxuICAgIGNvbnN0IGhvc3QgPSBjYW5vbmljYWxEb21haW4oY29udGV4dC5ob3N0bmFtZSk7XG4gICAgY29uc3QgcGF0aCA9IGNvbnRleHQucGF0aG5hbWUgfHwgXCIvXCI7XG5cbiAgICBsZXQgc2VjdXJlID0gb3B0aW9ucy5zZWN1cmU7XG4gICAgaWYgKFxuICAgICAgc2VjdXJlID09IG51bGwgJiZcbiAgICAgIGNvbnRleHQucHJvdG9jb2wgJiZcbiAgICAgIChjb250ZXh0LnByb3RvY29sID09IFwiaHR0cHM6XCIgfHwgY29udGV4dC5wcm90b2NvbCA9PSBcIndzczpcIilcbiAgICApIHtcbiAgICAgIHNlY3VyZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHNhbWVTaXRlTGV2ZWwgPSAwO1xuICAgIGlmIChvcHRpb25zLnNhbWVTaXRlQ29udGV4dCkge1xuICAgICAgY29uc3Qgc2FtZVNpdGVDb250ZXh0ID0gY2hlY2tTYW1lU2l0ZUNvbnRleHQob3B0aW9ucy5zYW1lU2l0ZUNvbnRleHQpO1xuICAgICAgc2FtZVNpdGVMZXZlbCA9IENvb2tpZS5zYW1lU2l0ZUxldmVsW3NhbWVTaXRlQ29udGV4dF07XG4gICAgICBpZiAoIXNhbWVTaXRlTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihTQU1FX1NJVEVfQ09OVEVYVF9WQUxfRVJSKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGh0dHAgPSBvcHRpb25zLmh0dHA7XG4gICAgaWYgKGh0dHAgPT0gbnVsbCkge1xuICAgICAgaHR0cCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gb3B0aW9ucy5ub3cgfHwgRGF0ZS5ub3coKTtcbiAgICBjb25zdCBleHBpcmVDaGVjayA9IG9wdGlvbnMuZXhwaXJlICE9PSBmYWxzZTtcbiAgICBjb25zdCBhbGxQYXRocyA9ICEhb3B0aW9ucy5hbGxQYXRocztcbiAgICBjb25zdCBzdG9yZSA9IHRoaXMuc3RvcmU7XG5cbiAgICBmdW5jdGlvbiBtYXRjaGluZ0Nvb2tpZShjKSB7XG4gICAgICAvLyBcIkVpdGhlcjpcbiAgICAgIC8vICAgVGhlIGNvb2tpZSdzIGhvc3Qtb25seS1mbGFnIGlzIHRydWUgYW5kIHRoZSBjYW5vbmljYWxpemVkXG4gICAgICAvLyAgIHJlcXVlc3QtaG9zdCBpcyBpZGVudGljYWwgdG8gdGhlIGNvb2tpZSdzIGRvbWFpbi5cbiAgICAgIC8vIE9yOlxuICAgICAgLy8gICBUaGUgY29va2llJ3MgaG9zdC1vbmx5LWZsYWcgaXMgZmFsc2UgYW5kIHRoZSBjYW5vbmljYWxpemVkXG4gICAgICAvLyAgIHJlcXVlc3QtaG9zdCBkb21haW4tbWF0Y2hlcyB0aGUgY29va2llJ3MgZG9tYWluLlwiXG4gICAgICBpZiAoYy5ob3N0T25seSkge1xuICAgICAgICBpZiAoYy5kb21haW4gIT0gaG9zdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkb21haW5NYXRjaChob3N0LCBjLmRvbWFpbiwgZmFsc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFwiVGhlIHJlcXVlc3QtdXJpJ3MgcGF0aCBwYXRoLW1hdGNoZXMgdGhlIGNvb2tpZSdzIHBhdGguXCJcbiAgICAgIGlmICghYWxsUGF0aHMgJiYgIXBhdGhNYXRjaChwYXRoLCBjLnBhdGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJJZiB0aGUgY29va2llJ3Mgc2VjdXJlLW9ubHktZmxhZyBpcyB0cnVlLCB0aGVuIHRoZSByZXF1ZXN0LXVyaSdzXG4gICAgICAvLyBzY2hlbWUgbXVzdCBkZW5vdGUgYSBcInNlY3VyZVwiIHByb3RvY29sXCJcbiAgICAgIGlmIChjLnNlY3VyZSAmJiAhc2VjdXJlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJJZiB0aGUgY29va2llJ3MgaHR0cC1vbmx5LWZsYWcgaXMgdHJ1ZSwgdGhlbiBleGNsdWRlIHRoZSBjb29raWUgaWYgdGhlXG4gICAgICAvLyBjb29raWUtc3RyaW5nIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IgYSBcIm5vbi1IVFRQXCIgQVBJXCJcbiAgICAgIGlmIChjLmh0dHBPbmx5ICYmICFodHRwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gUkZDNjI2NWJpcy0wMiBTNS4zLjdcbiAgICAgIGlmIChzYW1lU2l0ZUxldmVsKSB7XG4gICAgICAgIGNvbnN0IGNvb2tpZUxldmVsID0gQ29va2llLnNhbWVTaXRlTGV2ZWxbYy5zYW1lU2l0ZSB8fCBcIm5vbmVcIl07XG4gICAgICAgIGlmIChjb29raWVMZXZlbCA+IHNhbWVTaXRlTGV2ZWwpIHtcbiAgICAgICAgICAvLyBvbmx5IGFsbG93IGNvb2tpZXMgYXQgb3IgYmVsb3cgdGhlIHJlcXVlc3QgbGV2ZWxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVmZXJyZWQgZnJvbSBTNS4zXG4gICAgICAvLyBub24tUkZDOiBhbGxvdyByZXRlbnRpb24gb2YgZXhwaXJlZCBjb29raWVzIGJ5IGNob2ljZVxuICAgICAgaWYgKGV4cGlyZUNoZWNrICYmIGMuZXhwaXJ5VGltZSgpIDw9IG5vdykge1xuICAgICAgICBzdG9yZS5yZW1vdmVDb29raWUoYy5kb21haW4sIGMucGF0aCwgYy5rZXksICgpID0+IHt9KTsgLy8gcmVzdWx0IGlnbm9yZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzdG9yZS5maW5kQ29va2llcyhcbiAgICAgIGhvc3QsXG4gICAgICBhbGxQYXRocyA/IG51bGwgOiBwYXRoLFxuICAgICAgdGhpcy5hbGxvd1NwZWNpYWxVc2VEb21haW4sXG4gICAgICAoZXJyLCBjb29raWVzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvb2tpZXMgPSBjb29raWVzLmZpbHRlcihtYXRjaGluZ0Nvb2tpZSk7XG5cbiAgICAgICAgLy8gc29ydGluZyBvZiBTNS40IHBhcnQgMlxuICAgICAgICBpZiAob3B0aW9ucy5zb3J0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNvb2tpZXMgPSBjb29raWVzLnNvcnQoY29va2llQ29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTNS40IHBhcnQgM1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiBjb29raWVzKSB7XG4gICAgICAgICAgY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIHBlcnNpc3QgbGFzdEFjY2Vzc2VkXG5cbiAgICAgICAgY2IobnVsbCwgY29va2llcyk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGdldENvb2tpZVN0cmluZyguLi5hcmdzKSB7XG4gICAgY29uc3QgY2IgPSBhcmdzLnBvcCgpO1xuICAgIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc0Z1bmN0aW9uKGNiKSwgY2IpO1xuICAgIGNvbnN0IG5leHQgPSBmdW5jdGlvbihlcnIsIGNvb2tpZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgY29va2llc1xuICAgICAgICAgICAgLnNvcnQoY29va2llQ29tcGFyZSlcbiAgICAgICAgICAgIC5tYXAoYyA9PiBjLmNvb2tpZVN0cmluZygpKVxuICAgICAgICAgICAgLmpvaW4oXCI7IFwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgYXJncy5wdXNoKG5leHQpO1xuICAgIHRoaXMuZ2V0Q29va2llcy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIGdldFNldENvb2tpZVN0cmluZ3MoLi4uYXJncykge1xuICAgIGNvbnN0IGNiID0gYXJncy5wb3AoKTtcbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlKHZhbGlkYXRvcnMuaXNGdW5jdGlvbihjYiksIGNiKTtcbiAgICBjb25zdCBuZXh0ID0gZnVuY3Rpb24oZXJyLCBjb29raWVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGNvb2tpZXMubWFwKGMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgYXJncy5wdXNoKG5leHQpO1xuICAgIHRoaXMuZ2V0Q29va2llcy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZShjYikge1xuICAgIHZhbGlkYXRvcnMudmFsaWRhdGUodmFsaWRhdG9ycy5pc0Z1bmN0aW9uKGNiKSwgY2IpO1xuICAgIGxldCB0eXBlID0gdGhpcy5zdG9yZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmICh2YWxpZGF0b3JzLmlzT2JqZWN0KHR5cGUpKSB7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgUkVBRE1FLm1kIFwiU2VyaWFsaXphdGlvbiBGb3JtYXRcIiBpZiB5b3UgY2hhbmdlIHRoaXMsIHBsZWFzZSFcbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgLy8gVGhlIHZlcnNpb24gb2YgdG91Z2gtY29va2llIHRoYXQgc2VyaWFsaXplZCB0aGlzIGphci4gR2VuZXJhbGx5IGEgZ29vZFxuICAgICAgLy8gcHJhY3RpY2Ugc2luY2UgZnV0dXJlIHZlcnNpb25zIGNhbiBtYWtlIGRhdGEgaW1wb3J0IGRlY2lzaW9ucyBiYXNlZCBvblxuICAgICAgLy8ga25vd24gcGFzdCBiZWhhdmlvci4gV2hlbi9pZiB0aGlzIG1hdHRlcnMsIHVzZSBgc2VtdmVyYC5cbiAgICAgIHZlcnNpb246IGB0b3VnaC1jb29raWVAJHtWRVJTSU9OfWAsXG5cbiAgICAgIC8vIGFkZCB0aGUgc3RvcmUgdHlwZSwgdG8gbWFrZSBodW1hbnMgaGFwcHk6XG4gICAgICBzdG9yZVR5cGU6IHR5cGUsXG5cbiAgICAgIC8vIENvb2tpZUphciBjb25maWd1cmF0aW9uOlxuICAgICAgcmVqZWN0UHVibGljU3VmZml4ZXM6ICEhdGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyxcbiAgICAgIGVuYWJsZUxvb3NlTW9kZTogISF0aGlzLmVuYWJsZUxvb3NlTW9kZSxcbiAgICAgIGFsbG93U3BlY2lhbFVzZURvbWFpbjogISF0aGlzLmFsbG93U3BlY2lhbFVzZURvbWFpbixcbiAgICAgIHByZWZpeFNlY3VyaXR5OiBnZXROb3JtYWxpemVkUHJlZml4U2VjdXJpdHkodGhpcy5wcmVmaXhTZWN1cml0eSksXG5cbiAgICAgIC8vIHRoaXMgZ2V0cyBmaWxsZWQgZnJvbSBnZXRBbGxDb29raWVzOlxuICAgICAgY29va2llczogW11cbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgdGhpcy5zdG9yZS5nZXRBbGxDb29raWVzICYmXG4gICAgICAgIHR5cGVvZiB0aGlzLnN0b3JlLmdldEFsbENvb2tpZXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNiKFxuICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJzdG9yZSBkb2VzIG5vdCBzdXBwb3J0IGdldEFsbENvb2tpZXMgYW5kIGNhbm5vdCBiZSBzZXJpYWxpemVkXCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JlLmdldEFsbENvb2tpZXMoKGVyciwgY29va2llcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgc2VyaWFsaXplZC5jb29raWVzID0gY29va2llcy5tYXAoY29va2llID0+IHtcbiAgICAgICAgLy8gY29udmVydCB0byBzZXJpYWxpemVkICdyYXcnIGNvb2tpZXNcbiAgICAgICAgY29va2llID0gY29va2llIGluc3RhbmNlb2YgQ29va2llID8gY29va2llLnRvSlNPTigpIDogY29va2llO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaW5kZXggc28gbmV3IG9uZXMgZ2V0IGFzc2lnbmVkIGR1cmluZyBkZXNlcmlhbGl6YXRpb25cbiAgICAgICAgZGVsZXRlIGNvb2tpZS5jcmVhdGlvbkluZGV4O1xuXG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGNiKG51bGwsIHNlcmlhbGl6ZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVN5bmMoKTtcbiAgfVxuXG4gIC8vIHVzZSB0aGUgY2xhc3MgbWV0aG9kIENvb2tpZUphci5kZXNlcmlhbGl6ZSBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseVxuICBfaW1wb3J0Q29va2llcyhzZXJpYWxpemVkLCBjYikge1xuICAgIGxldCBjb29raWVzID0gc2VyaWFsaXplZC5jb29raWVzO1xuICAgIGlmICghY29va2llcyB8fCAhQXJyYXkuaXNBcnJheShjb29raWVzKSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihcInNlcmlhbGl6ZWQgamFyIGhhcyBubyBjb29raWVzIGFycmF5XCIpKTtcbiAgICB9XG4gICAgY29va2llcyA9IGNvb2tpZXMuc2xpY2UoKTsgLy8gZG8gbm90IG1vZGlmeSB0aGUgb3JpZ2luYWxcblxuICAgIGNvbnN0IHB1dE5leHQgPSBlcnIgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb29raWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2IoZXJyLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNvb2tpZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvb2tpZSA9IGZyb21KU09OKGNvb2tpZXMuc2hpZnQoKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYihlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvb2tpZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcHV0TmV4dChudWxsKTsgLy8gc2tpcCB0aGlzIGNvb2tpZVxuICAgICAgfVxuXG4gICAgICB0aGlzLnN0b3JlLnB1dENvb2tpZShjb29raWUsIHB1dE5leHQpO1xuICAgIH07XG5cbiAgICBwdXROZXh0KCk7XG4gIH1cblxuICBjbG9uZShuZXdTdG9yZSwgY2IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2IgPSBuZXdTdG9yZTtcbiAgICAgIG5ld1N0b3JlID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnNlcmlhbGl6ZSgoZXJyLCBzZXJpYWxpemVkKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfVxuICAgICAgQ29va2llSmFyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWQsIG5ld1N0b3JlLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICBjbG9uZVN5bmMobmV3U3RvcmUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lU3luYygpO1xuICAgIH1cbiAgICBpZiAoIW5ld1N0b3JlLnN5bmNocm9ub3VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llSmFyIGNsb25lIGRlc3RpbmF0aW9uIHN0b3JlIGlzIG5vdCBzeW5jaHJvbm91czsgdXNlIGFzeW5jIEFQSSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xvbmVTeW5jKG5ld1N0b3JlKTtcbiAgfVxuXG4gIHJlbW92ZUFsbENvb2tpZXMoY2IpIHtcbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlKHZhbGlkYXRvcnMuaXNGdW5jdGlvbihjYiksIGNiKTtcbiAgICBjb25zdCBzdG9yZSA9IHRoaXMuc3RvcmU7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBzdG9yZSBpbXBsZW1lbnRzIGl0cyBvd24gcmVtb3ZlQWxsQ29va2llcygpLiBUaGUgZGVmYXVsdFxuICAgIC8vIGltcGxlbWVudGF0aW9uIGluIFN0b3JlIHdpbGwgaW1tZWRpYXRlbHkgY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCBhIFwibm90XG4gICAgLy8gaW1wbGVtZW50ZWRcIiBFcnJvci5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygc3RvcmUucmVtb3ZlQWxsQ29va2llcyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICBzdG9yZS5yZW1vdmVBbGxDb29raWVzICE9PSBTdG9yZS5wcm90b3R5cGUucmVtb3ZlQWxsQ29va2llc1xuICAgICkge1xuICAgICAgcmV0dXJuIHN0b3JlLnJlbW92ZUFsbENvb2tpZXMoY2IpO1xuICAgIH1cblxuICAgIHN0b3JlLmdldEFsbENvb2tpZXMoKGVyciwgY29va2llcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvb2tpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjYihudWxsKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNvbXBsZXRlZENvdW50ID0gMDtcbiAgICAgIGNvbnN0IHJlbW92ZUVycm9ycyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiByZW1vdmVDb29raWVDYihyZW1vdmVFcnIpIHtcbiAgICAgICAgaWYgKHJlbW92ZUVycikge1xuICAgICAgICAgIHJlbW92ZUVycm9ycy5wdXNoKHJlbW92ZUVycik7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZWRDb3VudCsrO1xuXG4gICAgICAgIGlmIChjb21wbGV0ZWRDb3VudCA9PT0gY29va2llcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY2IocmVtb3ZlRXJyb3JzLmxlbmd0aCA/IHJlbW92ZUVycm9yc1swXSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvb2tpZXMuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgICBzdG9yZS5yZW1vdmVDb29raWUoXG4gICAgICAgICAgY29va2llLmRvbWFpbixcbiAgICAgICAgICBjb29raWUucGF0aCxcbiAgICAgICAgICBjb29raWUua2V5LFxuICAgICAgICAgIHJlbW92ZUNvb2tpZUNiXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzdHJPck9iaiwgc3RvcmUsIGNiKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcbiAgICAgIC8vIHN0b3JlIGlzIG9wdGlvbmFsXG4gICAgICBjYiA9IHN0b3JlO1xuICAgICAgc3RvcmUgPSBudWxsO1xuICAgIH1cbiAgICB2YWxpZGF0b3JzLnZhbGlkYXRlKHZhbGlkYXRvcnMuaXNGdW5jdGlvbihjYiksIGNiKTtcblxuICAgIGxldCBzZXJpYWxpemVkO1xuICAgIGlmICh0eXBlb2Ygc3RyT3JPYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHNlcmlhbGl6ZWQgPSBqc29uUGFyc2Uoc3RyT3JPYmopO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gY2Ioc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQgPSBzdHJPck9iajtcbiAgICB9XG5cbiAgICBjb25zdCBqYXIgPSBuZXcgQ29va2llSmFyKHN0b3JlLCB7XG4gICAgICByZWplY3RQdWJsaWNTdWZmaXhlczogc2VyaWFsaXplZC5yZWplY3RQdWJsaWNTdWZmaXhlcyxcbiAgICAgIGxvb3NlTW9kZTogc2VyaWFsaXplZC5lbmFibGVMb29zZU1vZGUsXG4gICAgICBhbGxvd1NwZWNpYWxVc2VEb21haW46IHNlcmlhbGl6ZWQuYWxsb3dTcGVjaWFsVXNlRG9tYWluLFxuICAgICAgcHJlZml4U2VjdXJpdHk6IHNlcmlhbGl6ZWQucHJlZml4U2VjdXJpdHlcbiAgICB9KTtcbiAgICBqYXIuX2ltcG9ydENvb2tpZXMoc2VyaWFsaXplZCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9XG4gICAgICBjYihudWxsLCBqYXIpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGRlc2VyaWFsaXplU3luYyhzdHJPck9iaiwgc3RvcmUpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID1cbiAgICAgIHR5cGVvZiBzdHJPck9iaiA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uoc3RyT3JPYmopIDogc3RyT3JPYmo7XG4gICAgY29uc3QgamFyID0gbmV3IENvb2tpZUphcihzdG9yZSwge1xuICAgICAgcmVqZWN0UHVibGljU3VmZml4ZXM6IHNlcmlhbGl6ZWQucmVqZWN0UHVibGljU3VmZml4ZXMsXG4gICAgICBsb29zZU1vZGU6IHNlcmlhbGl6ZWQuZW5hYmxlTG9vc2VNb2RlXG4gICAgfSk7XG5cbiAgICAvLyBjYXRjaCB0aGlzIG1pc3Rha2UgZWFybHk6XG4gICAgaWYgKCFqYXIuc3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVKYXIgc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgamFyLl9pbXBvcnRDb29raWVzU3luYyhzZXJpYWxpemVkKTtcbiAgICByZXR1cm4gamFyO1xuICB9XG59XG5Db29raWVKYXIuZnJvbUpTT04gPSBDb29raWVKYXIuZGVzZXJpYWxpemVTeW5jO1xuXG5bXG4gIFwiX2ltcG9ydENvb2tpZXNcIixcbiAgXCJjbG9uZVwiLFxuICBcImdldENvb2tpZXNcIixcbiAgXCJnZXRDb29raWVTdHJpbmdcIixcbiAgXCJnZXRTZXRDb29raWVTdHJpbmdzXCIsXG4gIFwicmVtb3ZlQWxsQ29va2llc1wiLFxuICBcInNlcmlhbGl6ZVwiLFxuICBcInNldENvb2tpZVwiXG5dLmZvckVhY2gobmFtZSA9PiB7XG4gIENvb2tpZUphci5wcm90b3R5cGVbbmFtZV0gPSBmcm9tQ2FsbGJhY2soQ29va2llSmFyLnByb3RvdHlwZVtuYW1lXSk7XG59KTtcbkNvb2tpZUphci5kZXNlcmlhbGl6ZSA9IGZyb21DYWxsYmFjayhDb29raWVKYXIuZGVzZXJpYWxpemUpO1xuXG4vLyBVc2UgYSBjbG9zdXJlIHRvIHByb3ZpZGUgYSB0cnVlIGltcGVyYXRpdmUgQVBJIGZvciBzeW5jaHJvbm91cyBzdG9yZXMuXG5mdW5jdGlvbiBzeW5jV3JhcChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuc3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVKYXIgc3RvcmUgaXMgbm90IHN5bmNocm9ub3VzOyB1c2UgYXN5bmMgQVBJIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHN5bmNFcnIsIHN5bmNSZXN1bHQ7XG4gICAgdGhpc1ttZXRob2RdKC4uLmFyZ3MsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgc3luY0VyciA9IGVycjtcbiAgICAgIHN5bmNSZXN1bHQgPSByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBpZiAoc3luY0Vycikge1xuICAgICAgdGhyb3cgc3luY0VycjtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gIH07XG59XG5cbmV4cG9ydHMudmVyc2lvbiA9IFZFUlNJT047XG5leHBvcnRzLkNvb2tpZUphciA9IENvb2tpZUphcjtcbmV4cG9ydHMuQ29va2llID0gQ29va2llO1xuZXhwb3J0cy5TdG9yZSA9IFN0b3JlO1xuZXhwb3J0cy5NZW1vcnlDb29raWVTdG9yZSA9IE1lbW9yeUNvb2tpZVN0b3JlO1xuZXhwb3J0cy5wYXJzZURhdGUgPSBwYXJzZURhdGU7XG5leHBvcnRzLmZvcm1hdERhdGUgPSBmb3JtYXREYXRlO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5mcm9tSlNPTiA9IGZyb21KU09OO1xuZXhwb3J0cy5kb21haW5NYXRjaCA9IGRvbWFpbk1hdGNoO1xuZXhwb3J0cy5kZWZhdWx0UGF0aCA9IGRlZmF1bHRQYXRoO1xuZXhwb3J0cy5wYXRoTWF0Y2ggPSBwYXRoTWF0Y2g7XG5leHBvcnRzLmdldFB1YmxpY1N1ZmZpeCA9IHB1YnN1ZmZpeC5nZXRQdWJsaWNTdWZmaXg7XG5leHBvcnRzLmNvb2tpZUNvbXBhcmUgPSBjb29raWVDb21wYXJlO1xuZXhwb3J0cy5wZXJtdXRlRG9tYWluID0gcmVxdWlyZShcIi4vcGVybXV0ZURvbWFpblwiKS5wZXJtdXRlRG9tYWluO1xuZXhwb3J0cy5wZXJtdXRlUGF0aCA9IHBlcm11dGVQYXRoO1xuZXhwb3J0cy5jYW5vbmljYWxEb21haW4gPSBjYW5vbmljYWxEb21haW47XG5leHBvcnRzLlByZWZpeFNlY3VyaXR5RW51bSA9IFByZWZpeFNlY3VyaXR5RW51bTtcbmV4cG9ydHMuUGFyYW1ldGVyRXJyb3IgPSB2YWxpZGF0b3JzLlBhcmFtZXRlckVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/cookie.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/memstore.js":
/*!***************************************************!*\
  !*** ./node_modules/tough-cookie/lib/memstore.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst { fromCallback } = __webpack_require__(/*! universalify */ \"(app-pages-browser)/./node_modules/tough-cookie/node_modules/universalify/index.js\");\nconst Store = (__webpack_require__(/*! ./store */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/store.js\").Store);\nconst permuteDomain = (__webpack_require__(/*! ./permuteDomain */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/permuteDomain.js\").permuteDomain);\nconst pathMatch = (__webpack_require__(/*! ./pathMatch */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/pathMatch.js\").pathMatch);\nconst { getCustomInspectSymbol, getUtilInspect } = __webpack_require__(/*! ./utilHelper */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/utilHelper.js\");\n\nclass MemoryCookieStore extends Store {\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = Object.create(null);\n    const customInspectSymbol = getCustomInspectSymbol();\n    if (customInspectSymbol) {\n      this[customInspectSymbol] = this.inspect;\n    }\n  }\n\n  inspect() {\n    const util = { inspect: getUtilInspect(inspectFallback) };\n    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;\n  }\n\n  findCookie(domain, path, key, cb) {\n    if (!this.idx[domain]) {\n      return cb(null, undefined);\n    }\n    if (!this.idx[domain][path]) {\n      return cb(null, undefined);\n    }\n    return cb(null, this.idx[domain][path][key] || null);\n  }\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    const results = [];\n    if (typeof allowSpecialUseDomain === \"function\") {\n      cb = allowSpecialUseDomain;\n      allowSpecialUseDomain = true;\n    }\n    if (!domain) {\n      return cb(null, []);\n    }\n\n    let pathMatcher;\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        Object.keys(domainIndex).forEach(cookiePath => {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        });\n      };\n    }\n\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n\n    cb(null, results);\n  }\n\n  putCookie(cookie, cb) {\n    if (!this.idx[cookie.domain]) {\n      this.idx[cookie.domain] = Object.create(null);\n    }\n    if (!this.idx[cookie.domain][cookie.path]) {\n      this.idx[cookie.domain][cookie.path] = Object.create(null);\n    }\n    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n    cb(null);\n  }\n  updateCookie(oldCookie, newCookie, cb) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    this.putCookie(newCookie, cb);\n  }\n  removeCookie(domain, path, key, cb) {\n    if (\n      this.idx[domain] &&\n      this.idx[domain][path] &&\n      this.idx[domain][path][key]\n    ) {\n      delete this.idx[domain][path][key];\n    }\n    cb(null);\n  }\n  removeCookies(domain, path, cb) {\n    if (this.idx[domain]) {\n      if (path) {\n        delete this.idx[domain][path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n    return cb(null);\n  }\n  removeAllCookies(cb) {\n    this.idx = Object.create(null);\n    return cb(null);\n  }\n  getAllCookies(cb) {\n    const cookies = [];\n    const idx = this.idx;\n\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const paths = Object.keys(idx[domain]);\n      paths.forEach(path => {\n        const keys = Object.keys(idx[domain][path]);\n        keys.forEach(key => {\n          if (key !== null) {\n            cookies.push(idx[domain][path][key]);\n          }\n        });\n      });\n    });\n\n    // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n\n    cb(null, cookies);\n  }\n}\n\n[\n  \"findCookie\",\n  \"findCookies\",\n  \"putCookie\",\n  \"updateCookie\",\n  \"removeCookie\",\n  \"removeCookies\",\n  \"removeAllCookies\",\n  \"getAllCookies\"\n].forEach(name => {\n  MemoryCookieStore.prototype[name] = fromCallback(\n    MemoryCookieStore.prototype[name]\n  );\n});\n\nexports.MemoryCookieStore = MemoryCookieStore;\n\nfunction inspectFallback(val) {\n  const domains = Object.keys(val);\n  if (domains.length === 0) {\n    return \"[Object: null prototype] {}\";\n  }\n  let result = \"[Object: null prototype] {\\n\";\n  Object.keys(val).forEach((domain, i) => {\n    result += formatDomain(domain, val[domain]);\n    if (i < domains.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += \"}\";\n  return result;\n}\n\nfunction formatDomain(domainName, domainValue) {\n  const indent = \"  \";\n  let result = `${indent}'${domainName}': [Object: null prototype] {\\n`;\n  Object.keys(domainValue).forEach((path, i, paths) => {\n    result += formatPath(path, domainValue[path]);\n    if (i < paths.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nfunction formatPath(pathName, pathValue) {\n  const indent = \"    \";\n  let result = `${indent}'${pathName}': [Object: null prototype] {\\n`;\n  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {\n    const cookie = pathValue[cookieName];\n    result += `      ${cookieName}: ${cookie.inspect()}`;\n    if (i < cookieNames.length - 1) {\n      result += \",\";\n    }\n    result += \"\\n\";\n  });\n  result += `${indent}}`;\n  return result;\n}\n\nexports.inspectFallback = inspectFallback;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL21lbXN0b3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx3R0FBYztBQUMvQyxjQUFjLDBHQUF3QjtBQUN0QyxzQkFBc0Isa0lBQXdDO0FBQzlELGtCQUFrQixzSEFBZ0M7QUFDbEQsUUFBUSx5Q0FBeUMsRUFBRSxtQkFBTyxDQUFDLHVGQUFjOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQixjQUFjLE9BQU8sbUNBQW1DO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPLEdBQUcsV0FBVyw2QkFBNkI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTyxHQUFHLFNBQVMsNkJBQTZCO0FBQ2xFO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxJQUFJLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvbWVtc3RvcmUuanM/NTFiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuY29uc3QgeyBmcm9tQ2FsbGJhY2sgfSA9IHJlcXVpcmUoXCJ1bml2ZXJzYWxpZnlcIik7XG5jb25zdCBTdG9yZSA9IHJlcXVpcmUoXCIuL3N0b3JlXCIpLlN0b3JlO1xuY29uc3QgcGVybXV0ZURvbWFpbiA9IHJlcXVpcmUoXCIuL3Blcm11dGVEb21haW5cIikucGVybXV0ZURvbWFpbjtcbmNvbnN0IHBhdGhNYXRjaCA9IHJlcXVpcmUoXCIuL3BhdGhNYXRjaFwiKS5wYXRoTWF0Y2g7XG5jb25zdCB7IGdldEN1c3RvbUluc3BlY3RTeW1ib2wsIGdldFV0aWxJbnNwZWN0IH0gPSByZXF1aXJlKFwiLi91dGlsSGVscGVyXCIpO1xuXG5jbGFzcyBNZW1vcnlDb29raWVTdG9yZSBleHRlbmRzIFN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB0aGlzLmlkeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9IGdldEN1c3RvbUluc3BlY3RTeW1ib2woKTtcbiAgICBpZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICAgICAgdGhpc1tjdXN0b21JbnNwZWN0U3ltYm9sXSA9IHRoaXMuaW5zcGVjdDtcbiAgICB9XG4gIH1cblxuICBpbnNwZWN0KCkge1xuICAgIGNvbnN0IHV0aWwgPSB7IGluc3BlY3Q6IGdldFV0aWxJbnNwZWN0KGluc3BlY3RGYWxsYmFjaykgfTtcbiAgICByZXR1cm4gYHsgaWR4OiAke3V0aWwuaW5zcGVjdCh0aGlzLmlkeCwgZmFsc2UsIDIpfSB9YDtcbiAgfVxuXG4gIGZpbmRDb29raWUoZG9tYWluLCBwYXRoLCBrZXksIGNiKSB7XG4gICAgaWYgKCF0aGlzLmlkeFtkb21haW5dKSB7XG4gICAgICByZXR1cm4gY2IobnVsbCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlkeFtkb21haW5dW3BhdGhdKSB7XG4gICAgICByZXR1cm4gY2IobnVsbCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNiKG51bGwsIHRoaXMuaWR4W2RvbWFpbl1bcGF0aF1ba2V5XSB8fCBudWxsKTtcbiAgfVxuICBmaW5kQ29va2llcyhkb21haW4sIHBhdGgsIGFsbG93U3BlY2lhbFVzZURvbWFpbiwgY2IpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgaWYgKHR5cGVvZiBhbGxvd1NwZWNpYWxVc2VEb21haW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBhbGxvd1NwZWNpYWxVc2VEb21haW47XG4gICAgICBhbGxvd1NwZWNpYWxVc2VEb21haW4gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWRvbWFpbikge1xuICAgICAgcmV0dXJuIGNiKG51bGwsIFtdKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aE1hdGNoZXI7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAvLyBudWxsIG1lYW5zIFwiYWxsIHBhdGhzXCJcbiAgICAgIHBhdGhNYXRjaGVyID0gZnVuY3Rpb24gbWF0Y2hBbGwoZG9tYWluSW5kZXgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjdXJQYXRoIGluIGRvbWFpbkluZGV4KSB7XG4gICAgICAgICAgY29uc3QgcGF0aEluZGV4ID0gZG9tYWluSW5kZXhbY3VyUGF0aF07XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocGF0aEluZGV4W2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aE1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaFJGQyhkb21haW5JbmRleCkge1xuICAgICAgICAvL05PVEU6IHdlIHNob3VsZCB1c2UgcGF0aC1tYXRjaCBhbGdvcml0aG0gZnJvbSBTNS4xLjQgaGVyZVxuICAgICAgICAvLyhzZWUgOiBodHRwczovL2dpdGh1Yi5jb20vQ2hyb21pdW1XZWJBcHBzL2Nocm9taXVtL2Jsb2IvYjNkM2I0ZGE4YmI5NGMxYjJlMDYxNjAwZGYxMDZkNTkwZmRhMzYyMC9uZXQvY29va2llcy9jYW5vbmljYWxfY29va2llLmNjI0wyOTkpXG4gICAgICAgIE9iamVjdC5rZXlzKGRvbWFpbkluZGV4KS5mb3JFYWNoKGNvb2tpZVBhdGggPT4ge1xuICAgICAgICAgIGlmIChwYXRoTWF0Y2gocGF0aCwgY29va2llUGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJbmRleCA9IGRvbWFpbkluZGV4W2Nvb2tpZVBhdGhdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXRoSW5kZXhba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZG9tYWlucyA9IHBlcm11dGVEb21haW4oZG9tYWluLCBhbGxvd1NwZWNpYWxVc2VEb21haW4pIHx8IFtkb21haW5dO1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuaWR4O1xuICAgIGRvbWFpbnMuZm9yRWFjaChjdXJEb21haW4gPT4ge1xuICAgICAgY29uc3QgZG9tYWluSW5kZXggPSBpZHhbY3VyRG9tYWluXTtcbiAgICAgIGlmICghZG9tYWluSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGF0aE1hdGNoZXIoZG9tYWluSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgY2IobnVsbCwgcmVzdWx0cyk7XG4gIH1cblxuICBwdXRDb29raWUoY29va2llLCBjYikge1xuICAgIGlmICghdGhpcy5pZHhbY29va2llLmRvbWFpbl0pIHtcbiAgICAgIHRoaXMuaWR4W2Nvb2tpZS5kb21haW5dID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlkeFtjb29raWUuZG9tYWluXVtjb29raWUucGF0aF0pIHtcbiAgICAgIHRoaXMuaWR4W2Nvb2tpZS5kb21haW5dW2Nvb2tpZS5wYXRoXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIHRoaXMuaWR4W2Nvb2tpZS5kb21haW5dW2Nvb2tpZS5wYXRoXVtjb29raWUua2V5XSA9IGNvb2tpZTtcbiAgICBjYihudWxsKTtcbiAgfVxuICB1cGRhdGVDb29raWUob2xkQ29va2llLCBuZXdDb29raWUsIGNiKSB7XG4gICAgLy8gdXBkYXRlQ29va2llKCkgbWF5IGF2b2lkIHVwZGF0aW5nIGNvb2tpZXMgdGhhdCBhcmUgaWRlbnRpY2FsLiAgRm9yIGV4YW1wbGUsXG4gICAgLy8gbGFzdEFjY2Vzc2VkIG1heSBub3QgYmUgaW1wb3J0YW50IHRvIHNvbWUgc3RvcmVzIGFuZCBhbiBlcXVhbGl0eVxuICAgIC8vIGNvbXBhcmlzb24gY291bGQgZXhjbHVkZSB0aGF0IGZpZWxkLlxuICAgIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSwgY2IpO1xuICB9XG4gIHJlbW92ZUNvb2tpZShkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmlkeFtkb21haW5dICYmXG4gICAgICB0aGlzLmlkeFtkb21haW5dW3BhdGhdICYmXG4gICAgICB0aGlzLmlkeFtkb21haW5dW3BhdGhdW2tleV1cbiAgICApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkeFtkb21haW5dW3BhdGhdW2tleV07XG4gICAgfVxuICAgIGNiKG51bGwpO1xuICB9XG4gIHJlbW92ZUNvb2tpZXMoZG9tYWluLCBwYXRoLCBjYikge1xuICAgIGlmICh0aGlzLmlkeFtkb21haW5dKSB7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXVtwYXRoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlkeFtkb21haW5dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2IobnVsbCk7XG4gIH1cbiAgcmVtb3ZlQWxsQ29va2llcyhjYikge1xuICAgIHRoaXMuaWR4ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gY2IobnVsbCk7XG4gIH1cbiAgZ2V0QWxsQ29va2llcyhjYikge1xuICAgIGNvbnN0IGNvb2tpZXMgPSBbXTtcbiAgICBjb25zdCBpZHggPSB0aGlzLmlkeDtcblxuICAgIGNvbnN0IGRvbWFpbnMgPSBPYmplY3Qua2V5cyhpZHgpO1xuICAgIGRvbWFpbnMuZm9yRWFjaChkb21haW4gPT4ge1xuICAgICAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhpZHhbZG9tYWluXSk7XG4gICAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaWR4W2RvbWFpbl1bcGF0aF0pO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb29raWVzLnB1c2goaWR4W2RvbWFpbl1bcGF0aF1ba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gU29ydCBieSBjcmVhdGlvbkluZGV4IHNvIGRlc2VyaWFsaXppbmcgcmV0YWlucyB0aGUgY3JlYXRpb24gb3JkZXIuXG4gICAgLy8gV2hlbiBpbXBsZW1lbnRpbmcgeW91ciBvd24gc3RvcmUsIHRoaXMgU0hPVUxEIHJldGFpbiB0aGUgb3JkZXIgdG9vXG4gICAgY29va2llcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gKGEuY3JlYXRpb25JbmRleCB8fCAwKSAtIChiLmNyZWF0aW9uSW5kZXggfHwgMCk7XG4gICAgfSk7XG5cbiAgICBjYihudWxsLCBjb29raWVzKTtcbiAgfVxufVxuXG5bXG4gIFwiZmluZENvb2tpZVwiLFxuICBcImZpbmRDb29raWVzXCIsXG4gIFwicHV0Q29va2llXCIsXG4gIFwidXBkYXRlQ29va2llXCIsXG4gIFwicmVtb3ZlQ29va2llXCIsXG4gIFwicmVtb3ZlQ29va2llc1wiLFxuICBcInJlbW92ZUFsbENvb2tpZXNcIixcbiAgXCJnZXRBbGxDb29raWVzXCJcbl0uZm9yRWFjaChuYW1lID0+IHtcbiAgTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlW25hbWVdID0gZnJvbUNhbGxiYWNrKFxuICAgIE1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZVtuYW1lXVxuICApO1xufSk7XG5cbmV4cG9ydHMuTWVtb3J5Q29va2llU3RvcmUgPSBNZW1vcnlDb29raWVTdG9yZTtcblxuZnVuY3Rpb24gaW5zcGVjdEZhbGxiYWNrKHZhbCkge1xuICBjb25zdCBkb21haW5zID0gT2JqZWN0LmtleXModmFsKTtcbiAgaWYgKGRvbWFpbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiW09iamVjdDogbnVsbCBwcm90b3R5cGVdIHt9XCI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IFwiW09iamVjdDogbnVsbCBwcm90b3R5cGVdIHtcXG5cIjtcbiAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKChkb21haW4sIGkpID0+IHtcbiAgICByZXN1bHQgKz0gZm9ybWF0RG9tYWluKGRvbWFpbiwgdmFsW2RvbWFpbl0pO1xuICAgIGlmIChpIDwgZG9tYWlucy5sZW5ndGggLSAxKSB7XG4gICAgICByZXN1bHQgKz0gXCIsXCI7XG4gICAgfVxuICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICB9KTtcbiAgcmVzdWx0ICs9IFwifVwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXREb21haW4oZG9tYWluTmFtZSwgZG9tYWluVmFsdWUpIHtcbiAgY29uc3QgaW5kZW50ID0gXCIgIFwiO1xuICBsZXQgcmVzdWx0ID0gYCR7aW5kZW50fScke2RvbWFpbk5hbWV9JzogW09iamVjdDogbnVsbCBwcm90b3R5cGVdIHtcXG5gO1xuICBPYmplY3Qua2V5cyhkb21haW5WYWx1ZSkuZm9yRWFjaCgocGF0aCwgaSwgcGF0aHMpID0+IHtcbiAgICByZXN1bHQgKz0gZm9ybWF0UGF0aChwYXRoLCBkb21haW5WYWx1ZVtwYXRoXSk7XG4gICAgaWYgKGkgPCBwYXRocy5sZW5ndGggLSAxKSB7XG4gICAgICByZXN1bHQgKz0gXCIsXCI7XG4gICAgfVxuICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICB9KTtcbiAgcmVzdWx0ICs9IGAke2luZGVudH19YDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UGF0aChwYXRoTmFtZSwgcGF0aFZhbHVlKSB7XG4gIGNvbnN0IGluZGVudCA9IFwiICAgIFwiO1xuICBsZXQgcmVzdWx0ID0gYCR7aW5kZW50fScke3BhdGhOYW1lfSc6IFtPYmplY3Q6IG51bGwgcHJvdG90eXBlXSB7XFxuYDtcbiAgT2JqZWN0LmtleXMocGF0aFZhbHVlKS5mb3JFYWNoKChjb29raWVOYW1lLCBpLCBjb29raWVOYW1lcykgPT4ge1xuICAgIGNvbnN0IGNvb2tpZSA9IHBhdGhWYWx1ZVtjb29raWVOYW1lXTtcbiAgICByZXN1bHQgKz0gYCAgICAgICR7Y29va2llTmFtZX06ICR7Y29va2llLmluc3BlY3QoKX1gO1xuICAgIGlmIChpIDwgY29va2llTmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmVzdWx0ICs9IFwiLFwiO1xuICAgIH1cbiAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgfSk7XG4gIHJlc3VsdCArPSBgJHtpbmRlbnR9fWA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuaW5zcGVjdEZhbGxiYWNrID0gaW5zcGVjdEZhbGxiYWNrO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/memstore.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/pathMatch.js":
/*!****************************************************!*\
  !*** ./node_modules/tough-cookie/lib/pathMatch.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * \"A request-path path-matches a given cookie-path if at least one of the\n * following conditions holds:\"\n */\nfunction pathMatch(reqPath, cookiePath) {\n  // \"o  The cookie-path and the request-path are identical.\"\n  if (cookiePath === reqPath) {\n    return true;\n  }\n\n  const idx = reqPath.indexOf(cookiePath);\n  if (idx === 0) {\n    // \"o  The cookie-path is a prefix of the request-path, and the last\n    // character of the cookie-path is %x2F (\"/\").\"\n    if (cookiePath.substr(-1) === \"/\") {\n      return true;\n    }\n\n    // \" o  The cookie-path is a prefix of the request-path, and the first\n    // character of the request-path that is not included in the cookie- path\n    // is a %x2F (\"/\") character.\"\n    if (reqPath.substr(cookiePath.length, 1) === \"/\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.pathMatch = pathMatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3BhdGhNYXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wYXRoTWF0Y2guanM/NDBkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuLypcbiAqIFwiQSByZXF1ZXN0LXBhdGggcGF0aC1tYXRjaGVzIGEgZ2l2ZW4gY29va2llLXBhdGggaWYgYXQgbGVhc3Qgb25lIG9mIHRoZVxuICogZm9sbG93aW5nIGNvbmRpdGlvbnMgaG9sZHM6XCJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoKHJlcVBhdGgsIGNvb2tpZVBhdGgpIHtcbiAgLy8gXCJvICBUaGUgY29va2llLXBhdGggYW5kIHRoZSByZXF1ZXN0LXBhdGggYXJlIGlkZW50aWNhbC5cIlxuICBpZiAoY29va2llUGF0aCA9PT0gcmVxUGF0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgaWR4ID0gcmVxUGF0aC5pbmRleE9mKGNvb2tpZVBhdGgpO1xuICBpZiAoaWR4ID09PSAwKSB7XG4gICAgLy8gXCJvICBUaGUgY29va2llLXBhdGggaXMgYSBwcmVmaXggb2YgdGhlIHJlcXVlc3QtcGF0aCwgYW5kIHRoZSBsYXN0XG4gICAgLy8gY2hhcmFjdGVyIG9mIHRoZSBjb29raWUtcGF0aCBpcyAleDJGIChcIi9cIikuXCJcbiAgICBpZiAoY29va2llUGF0aC5zdWJzdHIoLTEpID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gXCIgbyAgVGhlIGNvb2tpZS1wYXRoIGlzIGEgcHJlZml4IG9mIHRoZSByZXF1ZXN0LXBhdGgsIGFuZCB0aGUgZmlyc3RcbiAgICAvLyBjaGFyYWN0ZXIgb2YgdGhlIHJlcXVlc3QtcGF0aCB0aGF0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgY29va2llLSBwYXRoXG4gICAgLy8gaXMgYSAleDJGIChcIi9cIikgY2hhcmFjdGVyLlwiXG4gICAgaWYgKHJlcVBhdGguc3Vic3RyKGNvb2tpZVBhdGgubGVuZ3RoLCAxKSA9PT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0cy5wYXRoTWF0Y2ggPSBwYXRoTWF0Y2g7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/pathMatch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/permuteDomain.js":
/*!********************************************************!*\
  !*** ./node_modules/tough-cookie/lib/permuteDomain.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst pubsuffix = __webpack_require__(/*! ./pubsuffix-psl */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/pubsuffix-psl.js\");\n\n// Gives the permutation of all possible domainMatch()es of a given domain. The\n// array is in shortest-to-longest order.  Handy for indexing.\n\nfunction permuteDomain(domain, allowSpecialUseDomain) {\n  const pubSuf = pubsuffix.getPublicSuffix(domain, {\n    allowSpecialUseDomain: allowSpecialUseDomain\n  });\n\n  if (!pubSuf) {\n    return null;\n  }\n  if (pubSuf == domain) {\n    return [domain];\n  }\n\n  // Nuke trailing dot\n  if (domain.slice(-1) == \".\") {\n    domain = domain.slice(0, -1);\n  }\n\n  const prefix = domain.slice(0, -(pubSuf.length + 1)); // \".example.com\"\n  const parts = prefix.split(\".\").reverse();\n  let cur = pubSuf;\n  const permutations = [cur];\n  while (parts.length) {\n    cur = `${parts.shift()}.${cur}`;\n    permutations.push(cur);\n  }\n  return permutations;\n}\n\nexports.permuteDomain = permuteDomain;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3Blcm11dGVEb21haW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixrQkFBa0IsbUJBQU8sQ0FBQyw2RkFBaUI7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjLEdBQUcsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvcGVybXV0ZURvbWFpbi5qcz84ODg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBwdWJzdWZmaXggPSByZXF1aXJlKFwiLi9wdWJzdWZmaXgtcHNsXCIpO1xuXG4vLyBHaXZlcyB0aGUgcGVybXV0YXRpb24gb2YgYWxsIHBvc3NpYmxlIGRvbWFpbk1hdGNoKCllcyBvZiBhIGdpdmVuIGRvbWFpbi4gVGhlXG4vLyBhcnJheSBpcyBpbiBzaG9ydGVzdC10by1sb25nZXN0IG9yZGVyLiAgSGFuZHkgZm9yIGluZGV4aW5nLlxuXG5mdW5jdGlvbiBwZXJtdXRlRG9tYWluKGRvbWFpbiwgYWxsb3dTcGVjaWFsVXNlRG9tYWluKSB7XG4gIGNvbnN0IHB1YlN1ZiA9IHB1YnN1ZmZpeC5nZXRQdWJsaWNTdWZmaXgoZG9tYWluLCB7XG4gICAgYWxsb3dTcGVjaWFsVXNlRG9tYWluOiBhbGxvd1NwZWNpYWxVc2VEb21haW5cbiAgfSk7XG5cbiAgaWYgKCFwdWJTdWYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocHViU3VmID09IGRvbWFpbikge1xuICAgIHJldHVybiBbZG9tYWluXTtcbiAgfVxuXG4gIC8vIE51a2UgdHJhaWxpbmcgZG90XG4gIGlmIChkb21haW4uc2xpY2UoLTEpID09IFwiLlwiKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKDAsIC0xKTtcbiAgfVxuXG4gIGNvbnN0IHByZWZpeCA9IGRvbWFpbi5zbGljZSgwLCAtKHB1YlN1Zi5sZW5ndGggKyAxKSk7IC8vIFwiLmV4YW1wbGUuY29tXCJcbiAgY29uc3QgcGFydHMgPSBwcmVmaXguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgbGV0IGN1ciA9IHB1YlN1ZjtcbiAgY29uc3QgcGVybXV0YXRpb25zID0gW2N1cl07XG4gIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICBjdXIgPSBgJHtwYXJ0cy5zaGlmdCgpfS4ke2N1cn1gO1xuICAgIHBlcm11dGF0aW9ucy5wdXNoKGN1cik7XG4gIH1cbiAgcmV0dXJuIHBlcm11dGF0aW9ucztcbn1cblxuZXhwb3J0cy5wZXJtdXRlRG9tYWluID0gcGVybXV0ZURvbWFpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/permuteDomain.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/pubsuffix-psl.js":
/*!********************************************************!*\
  !*** ./node_modules/tough-cookie/lib/pubsuffix-psl.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * Copyright (c) 2018, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst psl = __webpack_require__(/*! psl */ \"(app-pages-browser)/./node_modules/psl/index.js\");\n\n// RFC 6761\nconst SPECIAL_USE_DOMAINS = [\n  \"local\",\n  \"example\",\n  \"invalid\",\n  \"localhost\",\n  \"test\"\n];\n\nconst SPECIAL_TREATMENT_DOMAINS = [\"localhost\", \"invalid\"];\n\nfunction getPublicSuffix(domain, options = {}) {\n  const domainParts = domain.split(\".\");\n  const topLevelDomain = domainParts[domainParts.length - 1];\n  const allowSpecialUseDomain = !!options.allowSpecialUseDomain;\n  const ignoreError = !!options.ignoreError;\n\n  if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n    if (domainParts.length > 1) {\n      const secondLevelDomain = domainParts[domainParts.length - 2];\n      // In aforementioned example, the eTLD/pubSuf will be apple.localhost\n      return `${secondLevelDomain}.${topLevelDomain}`;\n    } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {\n      // For a single word special use domain, e.g. 'localhost' or 'invalid', per RFC 6761,\n      // \"Application software MAY recognize {localhost/invalid} names as special, or\n      // MAY pass them to name resolution APIs as they would for other domain names.\"\n      return `${topLevelDomain}`;\n    }\n  }\n\n  if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {\n    throw new Error(\n      `Cookie has domain set to the public suffix \"${topLevelDomain}\" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`\n    );\n  }\n\n  return psl.get(domain);\n}\n\nexports.getPublicSuffix = getPublicSuffix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3B1YnN1ZmZpeC1wc2wuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLCtCQUErQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixZQUFZLG1CQUFPLENBQUMsNERBQUs7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQixHQUFHLGVBQWU7QUFDcEQsTUFBTTtBQUNOO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxlQUFlLCtFQUErRSx3REFBd0Q7QUFDM007QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wdWJzdWZmaXgtcHNsLmpzPzY0ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgsIFNhbGVzZm9yY2UuY29tLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIFNhbGVzZm9yY2UuY29tIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbiAqIGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cInVzZSBzdHJpY3RcIjtcbmNvbnN0IHBzbCA9IHJlcXVpcmUoXCJwc2xcIik7XG5cbi8vIFJGQyA2NzYxXG5jb25zdCBTUEVDSUFMX1VTRV9ET01BSU5TID0gW1xuICBcImxvY2FsXCIsXG4gIFwiZXhhbXBsZVwiLFxuICBcImludmFsaWRcIixcbiAgXCJsb2NhbGhvc3RcIixcbiAgXCJ0ZXN0XCJcbl07XG5cbmNvbnN0IFNQRUNJQUxfVFJFQVRNRU5UX0RPTUFJTlMgPSBbXCJsb2NhbGhvc3RcIiwgXCJpbnZhbGlkXCJdO1xuXG5mdW5jdGlvbiBnZXRQdWJsaWNTdWZmaXgoZG9tYWluLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZG9tYWluUGFydHMgPSBkb21haW4uc3BsaXQoXCIuXCIpO1xuICBjb25zdCB0b3BMZXZlbERvbWFpbiA9IGRvbWFpblBhcnRzW2RvbWFpblBhcnRzLmxlbmd0aCAtIDFdO1xuICBjb25zdCBhbGxvd1NwZWNpYWxVc2VEb21haW4gPSAhIW9wdGlvbnMuYWxsb3dTcGVjaWFsVXNlRG9tYWluO1xuICBjb25zdCBpZ25vcmVFcnJvciA9ICEhb3B0aW9ucy5pZ25vcmVFcnJvcjtcblxuICBpZiAoYWxsb3dTcGVjaWFsVXNlRG9tYWluICYmIFNQRUNJQUxfVVNFX0RPTUFJTlMuaW5jbHVkZXModG9wTGV2ZWxEb21haW4pKSB7XG4gICAgaWYgKGRvbWFpblBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHNlY29uZExldmVsRG9tYWluID0gZG9tYWluUGFydHNbZG9tYWluUGFydHMubGVuZ3RoIC0gMl07XG4gICAgICAvLyBJbiBhZm9yZW1lbnRpb25lZCBleGFtcGxlLCB0aGUgZVRMRC9wdWJTdWYgd2lsbCBiZSBhcHBsZS5sb2NhbGhvc3RcbiAgICAgIHJldHVybiBgJHtzZWNvbmRMZXZlbERvbWFpbn0uJHt0b3BMZXZlbERvbWFpbn1gO1xuICAgIH0gZWxzZSBpZiAoU1BFQ0lBTF9UUkVBVE1FTlRfRE9NQUlOUy5pbmNsdWRlcyh0b3BMZXZlbERvbWFpbikpIHtcbiAgICAgIC8vIEZvciBhIHNpbmdsZSB3b3JkIHNwZWNpYWwgdXNlIGRvbWFpbiwgZS5nLiAnbG9jYWxob3N0JyBvciAnaW52YWxpZCcsIHBlciBSRkMgNjc2MSxcbiAgICAgIC8vIFwiQXBwbGljYXRpb24gc29mdHdhcmUgTUFZIHJlY29nbml6ZSB7bG9jYWxob3N0L2ludmFsaWR9IG5hbWVzIGFzIHNwZWNpYWwsIG9yXG4gICAgICAvLyBNQVkgcGFzcyB0aGVtIHRvIG5hbWUgcmVzb2x1dGlvbiBBUElzIGFzIHRoZXkgd291bGQgZm9yIG90aGVyIGRvbWFpbiBuYW1lcy5cIlxuICAgICAgcmV0dXJuIGAke3RvcExldmVsRG9tYWlufWA7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpZ25vcmVFcnJvciAmJiBTUEVDSUFMX1VTRV9ET01BSU5TLmluY2x1ZGVzKHRvcExldmVsRG9tYWluKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDb29raWUgaGFzIGRvbWFpbiBzZXQgdG8gdGhlIHB1YmxpYyBzdWZmaXggXCIke3RvcExldmVsRG9tYWlufVwiIHdoaWNoIGlzIGEgc3BlY2lhbCB1c2UgZG9tYWluLiBUbyBhbGxvdyB0aGlzLCBjb25maWd1cmUgeW91ciBDb29raWVKYXIgd2l0aCB7YWxsb3dTcGVjaWFsVXNlRG9tYWluOnRydWUsIHJlamVjdFB1YmxpY1N1ZmZpeGVzOiBmYWxzZX0uYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcHNsLmdldChkb21haW4pO1xufVxuXG5leHBvcnRzLmdldFB1YmxpY1N1ZmZpeCA9IGdldFB1YmxpY1N1ZmZpeDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/pubsuffix-psl.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/store.js":
/*!************************************************!*\
  !*** ./node_modules/tough-cookie/lib/store.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*jshint unused:false */\n\nclass Store {\n  constructor() {\n    this.synchronous = false;\n  }\n\n  findCookie(domain, path, key, cb) {\n    throw new Error(\"findCookie is not implemented\");\n  }\n\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    throw new Error(\"findCookies is not implemented\");\n  }\n\n  putCookie(cookie, cb) {\n    throw new Error(\"putCookie is not implemented\");\n  }\n\n  updateCookie(oldCookie, newCookie, cb) {\n    // recommended default implementation:\n    // return this.putCookie(newCookie, cb);\n    throw new Error(\"updateCookie is not implemented\");\n  }\n\n  removeCookie(domain, path, key, cb) {\n    throw new Error(\"removeCookie is not implemented\");\n  }\n\n  removeCookies(domain, path, cb) {\n    throw new Error(\"removeCookies is not implemented\");\n  }\n\n  removeAllCookies(cb) {\n    throw new Error(\"removeAllCookies is not implemented\");\n  }\n\n  getAllCookies(cb) {\n    throw new Error(\n      \"getAllCookies is not implemented (therefore jar cannot be serialized)\"\n    );\n  }\n}\n\nexports.Store = Store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3N0b3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9zdG9yZS5qcz9iMWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG4vKmpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cblxuY2xhc3MgU3RvcmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN5bmNocm9ub3VzID0gZmFsc2U7XG4gIH1cblxuICBmaW5kQ29va2llKGRvbWFpbiwgcGF0aCwga2V5LCBjYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpbmRDb29raWUgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG5cbiAgZmluZENvb2tpZXMoZG9tYWluLCBwYXRoLCBhbGxvd1NwZWNpYWxVc2VEb21haW4sIGNiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmluZENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG5cbiAgcHV0Q29va2llKGNvb2tpZSwgY2IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwdXRDb29raWUgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG5cbiAgdXBkYXRlQ29va2llKG9sZENvb2tpZSwgbmV3Q29va2llLCBjYikge1xuICAgIC8vIHJlY29tbWVuZGVkIGRlZmF1bHQgaW1wbGVtZW50YXRpb246XG4gICAgLy8gcmV0dXJuIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSwgY2IpO1xuICAgIHRocm93IG5ldyBFcnJvcihcInVwZGF0ZUNvb2tpZSBpcyBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cblxuICByZW1vdmVDb29raWUoZG9tYWluLCBwYXRoLCBrZXksIGNiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVtb3ZlQ29va2llIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuXG4gIHJlbW92ZUNvb2tpZXMoZG9tYWluLCBwYXRoLCBjYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZUNvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG5cbiAgcmVtb3ZlQWxsQ29va2llcyhjYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInJlbW92ZUFsbENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG5cbiAgZ2V0QWxsQ29va2llcyhjYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiZ2V0QWxsQ29va2llcyBpcyBub3QgaW1wbGVtZW50ZWQgKHRoZXJlZm9yZSBqYXIgY2Fubm90IGJlIHNlcmlhbGl6ZWQpXCJcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydHMuU3RvcmUgPSBTdG9yZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/store.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/utilHelper.js":
/*!*****************************************************!*\
  !*** ./node_modules/tough-cookie/lib/utilHelper.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("function requireUtil() {\n  try {\n    // eslint-disable-next-line no-restricted-modules\n    return __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n  } catch (e) {\n    return null;\n  }\n}\n\n// for v10.12.0+\nfunction lookupCustomInspectSymbol() {\n  return Symbol.for(\"nodejs.util.inspect.custom\");\n}\n\n// for older node environments\nfunction tryReadingCustomSymbolFromUtilInspect(options) {\n  const _requireUtil = options.requireUtil || requireUtil;\n  const util = _requireUtil();\n  return util ? util.inspect.custom : null;\n}\n\nexports.getUtilInspect = function getUtilInspect(fallback, options = {}) {\n  const _requireUtil = options.requireUtil || requireUtil;\n  const util = _requireUtil();\n  return function inspect(value, showHidden, depth) {\n    return util ? util.inspect(value, showHidden, depth) : fallback(value);\n  };\n};\n\nexports.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {\n  const _lookupCustomInspectSymbol =\n    options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;\n\n  // get custom inspect symbol for node environments\n  return (\n    _lookupCustomInspectSymbol() ||\n    tryReadingCustomSymbolFromUtilInspect(options)\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3V0aWxIZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdGQUFNO0FBQ3pCLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpREFBaUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QiwrQ0FBK0M7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvdXRpbEhlbHBlci5qcz80YmM3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHJlcXVpcmVVdGlsKCkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLW1vZHVsZXNcbiAgICByZXR1cm4gcmVxdWlyZShcInV0aWxcIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBmb3IgdjEwLjEyLjArXG5mdW5jdGlvbiBsb29rdXBDdXN0b21JbnNwZWN0U3ltYm9sKCkge1xuICByZXR1cm4gU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpO1xufVxuXG4vLyBmb3Igb2xkZXIgbm9kZSBlbnZpcm9ubWVudHNcbmZ1bmN0aW9uIHRyeVJlYWRpbmdDdXN0b21TeW1ib2xGcm9tVXRpbEluc3BlY3Qob3B0aW9ucykge1xuICBjb25zdCBfcmVxdWlyZVV0aWwgPSBvcHRpb25zLnJlcXVpcmVVdGlsIHx8IHJlcXVpcmVVdGlsO1xuICBjb25zdCB1dGlsID0gX3JlcXVpcmVVdGlsKCk7XG4gIHJldHVybiB1dGlsID8gdXRpbC5pbnNwZWN0LmN1c3RvbSA6IG51bGw7XG59XG5cbmV4cG9ydHMuZ2V0VXRpbEluc3BlY3QgPSBmdW5jdGlvbiBnZXRVdGlsSW5zcGVjdChmYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IF9yZXF1aXJlVXRpbCA9IG9wdGlvbnMucmVxdWlyZVV0aWwgfHwgcmVxdWlyZVV0aWw7XG4gIGNvbnN0IHV0aWwgPSBfcmVxdWlyZVV0aWwoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluc3BlY3QodmFsdWUsIHNob3dIaWRkZW4sIGRlcHRoKSB7XG4gICAgcmV0dXJuIHV0aWwgPyB1dGlsLmluc3BlY3QodmFsdWUsIHNob3dIaWRkZW4sIGRlcHRoKSA6IGZhbGxiYWNrKHZhbHVlKTtcbiAgfTtcbn07XG5cbmV4cG9ydHMuZ2V0Q3VzdG9tSW5zcGVjdFN5bWJvbCA9IGZ1bmN0aW9uIGdldEN1c3RvbUluc3BlY3RTeW1ib2wob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IF9sb29rdXBDdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgICBvcHRpb25zLmxvb2t1cEN1c3RvbUluc3BlY3RTeW1ib2wgfHwgbG9va3VwQ3VzdG9tSW5zcGVjdFN5bWJvbDtcblxuICAvLyBnZXQgY3VzdG9tIGluc3BlY3Qgc3ltYm9sIGZvciBub2RlIGVudmlyb25tZW50c1xuICByZXR1cm4gKFxuICAgIF9sb29rdXBDdXN0b21JbnNwZWN0U3ltYm9sKCkgfHxcbiAgICB0cnlSZWFkaW5nQ3VzdG9tU3ltYm9sRnJvbVV0aWxJbnNwZWN0KG9wdGlvbnMpXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/utilHelper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/validators.js":
/*!*****************************************************!*\
  !*** ./node_modules/tough-cookie/lib/validators.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* ************************************************************************************\nExtracted from check-types.js\nhttps://gitlab.com/philbooth/check-types.js\n\nMIT License\n\nCopyright (c) 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 Phil Booth\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n************************************************************************************ */\n\n\n/* Validation functions copied from check-types package - https://www.npmjs.com/package/check-types */\n\nconst toString = Object.prototype.toString;\n\nfunction isFunction(data) {\n  return typeof data === \"function\";\n}\n\nfunction isNonEmptyString(data) {\n  return isString(data) && data !== \"\";\n}\n\nfunction isDate(data) {\n  return isInstanceStrict(data, Date) && isInteger(data.getTime());\n}\n\nfunction isEmptyString(data) {\n  return data === \"\" || (data instanceof String && data.toString() === \"\");\n}\n\nfunction isString(data) {\n  return typeof data === \"string\" || data instanceof String;\n}\n\nfunction isObject(data) {\n  return toString.call(data) === \"[object Object]\";\n}\nfunction isInstanceStrict(data, prototype) {\n  try {\n    return data instanceof prototype;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction isUrlStringOrObject(data) {\n  return (\n    isNonEmptyString(data) ||\n    (isObject(data) &&\n      \"hostname\" in data &&\n      \"pathname\" in data &&\n      \"protocol\" in data) ||\n    isInstanceStrict(data, URL)\n  );\n}\n\nfunction isInteger(data) {\n  return typeof data === \"number\" && data % 1 === 0;\n}\n/* End validation functions */\n\nfunction validate(bool, cb, options) {\n  if (!isFunction(cb)) {\n    options = cb;\n    cb = null;\n  }\n  if (!isObject(options)) options = { Error: \"Failed Check\" };\n  if (!bool) {\n    if (cb) {\n      cb(new ParameterError(options));\n    } else {\n      throw new ParameterError(options);\n    }\n  }\n}\n\nclass ParameterError extends Error {\n  constructor(...params) {\n    super(...params);\n  }\n}\n\nexports.ParameterError = ParameterError;\nexports.isFunction = isFunction;\nexports.isNonEmptyString = isNonEmptyString;\nexports.isDate = isDate;\nexports.isEmptyString = isEmptyString;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isUrlStringOrObject = isUrlStringOrObject;\nexports.validate = validate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3ZhbGlkYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2E7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLDJCQUEyQjtBQUMzQixnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvdmFsaWRhdG9ycy5qcz85ODgxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuRXh0cmFjdGVkIGZyb20gY2hlY2stdHlwZXMuanNcbmh0dHBzOi8vZ2l0bGFiLmNvbS9waGlsYm9vdGgvY2hlY2stdHlwZXMuanNcblxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDEyLCAyMDEzLCAyMDE0LCAyMDE1LCAyMDE2LCAyMDE3LCAyMDE4LCAyMDE5IFBoaWwgQm9vdGhcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblwidXNlIHN0cmljdFwiO1xuXG4vKiBWYWxpZGF0aW9uIGZ1bmN0aW9ucyBjb3BpZWQgZnJvbSBjaGVjay10eXBlcyBwYWNrYWdlIC0gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY2hlY2stdHlwZXMgKi9cblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoZGF0YSkge1xuICByZXR1cm4gaXNTdHJpbmcoZGF0YSkgJiYgZGF0YSAhPT0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGRhdGEpIHtcbiAgcmV0dXJuIGlzSW5zdGFuY2VTdHJpY3QoZGF0YSwgRGF0ZSkgJiYgaXNJbnRlZ2VyKGRhdGEuZ2V0VGltZSgpKTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVN0cmluZyhkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBcIlwiIHx8IChkYXRhIGluc3RhbmNlb2YgU3RyaW5nICYmIGRhdGEudG9TdHJpbmcoKSA9PT0gXCJcIik7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGRhdGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IGRhdGEgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc0luc3RhbmNlU3RyaWN0KGRhdGEsIHByb3RvdHlwZSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgcHJvdG90eXBlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VybFN0cmluZ09yT2JqZWN0KGRhdGEpIHtcbiAgcmV0dXJuIChcbiAgICBpc05vbkVtcHR5U3RyaW5nKGRhdGEpIHx8XG4gICAgKGlzT2JqZWN0KGRhdGEpICYmXG4gICAgICBcImhvc3RuYW1lXCIgaW4gZGF0YSAmJlxuICAgICAgXCJwYXRobmFtZVwiIGluIGRhdGEgJiZcbiAgICAgIFwicHJvdG9jb2xcIiBpbiBkYXRhKSB8fFxuICAgIGlzSW5zdGFuY2VTdHJpY3QoZGF0YSwgVVJMKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIoZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIgJiYgZGF0YSAlIDEgPT09IDA7XG59XG4vKiBFbmQgdmFsaWRhdGlvbiBmdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGUoYm9vbCwgY2IsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGNiKSkge1xuICAgIG9wdGlvbnMgPSBjYjtcbiAgICBjYiA9IG51bGw7XG4gIH1cbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkgb3B0aW9ucyA9IHsgRXJyb3I6IFwiRmFpbGVkIENoZWNrXCIgfTtcbiAgaWYgKCFib29sKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihuZXcgUGFyYW1ldGVyRXJyb3Iob3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyYW1ldGVyRXJyb3Iob3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFBhcmFtZXRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciguLi5wYXJhbXMpIHtcbiAgICBzdXBlciguLi5wYXJhbXMpO1xuICB9XG59XG5cbmV4cG9ydHMuUGFyYW1ldGVyRXJyb3IgPSBQYXJhbWV0ZXJFcnJvcjtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTm9uRW1wdHlTdHJpbmcgPSBpc05vbkVtcHR5U3RyaW5nO1xuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLmlzRW1wdHlTdHJpbmcgPSBpc0VtcHR5U3RyaW5nO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc1VybFN0cmluZ09yT2JqZWN0ID0gaXNVcmxTdHJpbmdPck9iamVjdDtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/validators.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/lib/version.js":
/*!**************************************************!*\
  !*** ./node_modules/tough-cookie/lib/version.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// generated by genversion\nmodule.exports = '4.1.4'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi92ZXJzaW9uLmpzPzk2Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2VuZXJhdGVkIGJ5IGdlbnZlcnNpb25cbm1vZHVsZS5leHBvcnRzID0gJzQuMS40J1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tough-cookie/node_modules/universalify/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/tough-cookie/node_modules/universalify/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else {\n      delete arguments[arguments.length - 1]\n      arguments.length--\n      fn.apply(this, arguments).then(r => cb(null, r), cb)\n    }\n  }, 'name', { value: fn.name })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHLFlBQVksZ0JBQWdCO0FBQy9COztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxZQUFZLGdCQUFnQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL25vZGVfbW9kdWxlcy91bml2ZXJzYWxpZnkvaW5kZXguanM/MjJhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5mcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aF0gPSAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgICAgfVxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoKytcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuXG5leHBvcnRzLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSB7XG4gICAgICBkZWxldGUgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuICAgICAgYXJndW1lbnRzLmxlbmd0aC0tXG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4ociA9PiBjYihudWxsLCByKSwgY2IpXG4gICAgfVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tough-cookie/node_modules/universalify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ts-mixer/dist/esm/index.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-mixer/dist/esm/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mixin: function() { return /* binding */ Mixin; },\n/* harmony export */   decorate: function() { return /* binding */ decorate; },\n/* harmony export */   hasMixin: function() { return /* binding */ hasMixin; },\n/* harmony export */   mix: function() { return /* binding */ mix; },\n/* harmony export */   settings: function() { return /* binding */ settings; }\n/* harmony export */ });\n/**\n * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives\n * the option to exclude properties by name.\n */\nconst copyProps = (dest, src, exclude = []) => {\n    const props = Object.getOwnPropertyDescriptors(src);\n    for (let prop of exclude)\n        delete props[prop];\n    Object.defineProperties(dest, props);\n};\n/**\n * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will\n * be closest to farthest in the chain.\n */\nconst protoChain = (obj, currentChain = [obj]) => {\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null)\n        return currentChain;\n    return protoChain(proto, [...currentChain, proto]);\n};\n/**\n * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated\n * objects, this function should return Object.prototype.\n */\nconst nearestCommonProto = (...objs) => {\n    if (objs.length === 0)\n        return undefined;\n    let commonProto = undefined;\n    const protoChains = objs.map(obj => protoChain(obj));\n    while (protoChains.every(protoChain => protoChain.length > 0)) {\n        const protos = protoChains.map(protoChain => protoChain.pop());\n        const potentialCommonProto = protos[0];\n        if (protos.every(proto => proto === potentialCommonProto))\n            commonProto = potentialCommonProto;\n        else\n            break;\n    }\n    return commonProto;\n};\n/**\n * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first\n * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods\n * downstream of this prototype (ONLY downstream) are copied into the new object.\n *\n * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as\n * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may\n * want to use that instead.\n */\nconst hardMixProtos = (ingredients, constructor, exclude = []) => {\n    var _a;\n    const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;\n    const mixedProto = Object.create(base);\n    // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the\n    // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in\n    // when they will already be accessible via prototype access.\n    const visitedProtos = protoChain(base);\n    for (let prototype of ingredients) {\n        let protos = protoChain(prototype);\n        // Apply the prototype chain in reverse order so that old methods don't override newer ones.\n        for (let i = protos.length - 1; i >= 0; i--) {\n            let newProto = protos[i];\n            if (visitedProtos.indexOf(newProto) === -1) {\n                copyProps(mixedProto, newProto, ['constructor', ...exclude]);\n                visitedProtos.push(newProto);\n            }\n        }\n    }\n    mixedProto.constructor = constructor;\n    return mixedProto;\n};\nconst unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);\n\n/**\n * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient\n * prototypes is required.\n */\nconst getIngredientWithProp = (prop, ingredients) => {\n    const protoChains = ingredients.map(ingredient => protoChain(ingredient));\n    // since we search breadth-first, we need to keep track of our depth in the prototype chains\n    let protoDepth = 0;\n    // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'\n    // prototype chains has an object at this depth\n    let protosAreLeftToSearch = true;\n    while (protosAreLeftToSearch) {\n        // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains\n        protosAreLeftToSearch = false;\n        // scan through the ingredients right to left\n        for (let i = ingredients.length - 1; i >= 0; i--) {\n            const searchTarget = protoChains[i][protoDepth];\n            if (searchTarget !== undefined && searchTarget !== null) {\n                // if we find something, this is proof that this horizontal slice potentially more objects to search\n                protosAreLeftToSearch = true;\n                // eureka, we found it\n                if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {\n                    return protoChains[i][0];\n                }\n            }\n        }\n        protoDepth++;\n    }\n    return undefined;\n};\n/**\n * \"Mixes\" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit\n * downstream of an existing prototype chain.  Note that \"properties\" cannot be added, deleted, or modified.\n */\nconst proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {\n    getPrototypeOf() {\n        return prototype;\n    },\n    setPrototypeOf() {\n        throw Error('Cannot set prototype of Proxies created by ts-mixer');\n    },\n    getOwnPropertyDescriptor(_, prop) {\n        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);\n    },\n    defineProperty() {\n        throw new Error('Cannot define new properties on Proxies created by ts-mixer');\n    },\n    has(_, prop) {\n        return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;\n    },\n    get(_, prop) {\n        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];\n    },\n    set(_, prop, val) {\n        const ingredientWithProp = getIngredientWithProp(prop, ingredients);\n        if (ingredientWithProp === undefined)\n            throw new Error('Cannot set new properties on Proxies created by ts-mixer');\n        ingredientWithProp[prop] = val;\n        return true;\n    },\n    deleteProperty() {\n        throw new Error('Cannot delete properties on Proxies created by ts-mixer');\n    },\n    ownKeys() {\n        return ingredients\n            .map(Object.getOwnPropertyNames)\n            .reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));\n    },\n});\n/**\n * Creates a new proxy-prototype object that is a \"soft\" mixture of the given prototypes.  The mixing is achieved by\n * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any\n * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.\n */\nconst softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);\n\nconst settings = {\n    initFunction: null,\n    staticsStrategy: 'copy',\n    prototypeStrategy: 'copy',\n    decoratorInheritance: 'deep',\n};\n\n// Keeps track of constituent classes for every mixin class created by ts-mixer.\nconst mixins = new WeakMap();\nconst getMixinsForClass = (clazz) => mixins.get(clazz);\nconst registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);\nconst hasMixin = (instance, mixin) => {\n    if (instance instanceof mixin)\n        return true;\n    const constructor = instance.constructor;\n    const visited = new Set();\n    let frontier = new Set();\n    frontier.add(constructor);\n    while (frontier.size > 0) {\n        // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier\n        if (frontier.has(mixin))\n            return true;\n        frontier.forEach((item) => visited.add(item));\n        // build a new frontier based on the associated mixin classes and prototype chains of each frontier item\n        const newFrontier = new Set();\n        frontier.forEach((item) => {\n            var _a;\n            const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype)\n                .map((proto) => proto.constructor)\n                .filter((item) => item !== null);\n            if (itemConstituents)\n                itemConstituents.forEach((constituent) => {\n                    if (!visited.has(constituent) && !frontier.has(constituent))\n                        newFrontier.add(constituent);\n                });\n        });\n        // we have a new frontier, now search again\n        frontier = newFrontier;\n    }\n    // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes\n    return false;\n};\n\nconst mergeObjectsOfDecorators = (o1, o2) => {\n    var _a, _b;\n    const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);\n    const mergedObject = {};\n    for (let key of allKeys)\n        mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);\n    return mergedObject;\n};\nconst mergePropertyAndMethodDecorators = (d1, d2) => {\n    var _a, _b, _c, _d;\n    return ({\n        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),\n        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {}),\n    });\n};\nconst mergeDecorators = (d1, d2) => {\n    var _a, _b, _c, _d, _e, _f;\n    return ({\n        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),\n        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),\n        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {}),\n    });\n};\nconst decorators = new Map();\nconst findAllConstituentClasses = (...classes) => {\n    var _a;\n    const allClasses = new Set();\n    const frontier = new Set([...classes]);\n    while (frontier.size > 0) {\n        for (let clazz of frontier) {\n            const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);\n            const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];\n            const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];\n            const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));\n            for (let newClass of newClasses)\n                frontier.add(newClass);\n            allClasses.add(clazz);\n            frontier.delete(clazz);\n        }\n    }\n    return [...allClasses];\n};\nconst deepDecoratorSearch = (...classes) => {\n    const decoratorsForClassChain = findAllConstituentClasses(...classes)\n        .map(clazz => decorators.get(clazz))\n        .filter(decorators => !!decorators);\n    if (decoratorsForClassChain.length == 0)\n        return {};\n    if (decoratorsForClassChain.length == 1)\n        return decoratorsForClassChain[0];\n    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst directDecoratorSearch = (...classes) => {\n    const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));\n    if (classDecorators.length === 0)\n        return {};\n    if (classDecorators.length === 1)\n        return classDecorators[0];\n    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));\n};\nconst getDecoratorsForClass = (clazz) => {\n    let decoratorsForClass = decorators.get(clazz);\n    if (!decoratorsForClass) {\n        decoratorsForClass = {};\n        decorators.set(clazz, decoratorsForClass);\n    }\n    return decoratorsForClass;\n};\nconst decorateClass = (decorator) => ((clazz) => {\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    let classDecorators = decoratorsForClass.class;\n    if (!classDecorators) {\n        classDecorators = [];\n        decoratorsForClass.class = classDecorators;\n    }\n    classDecorators.push(decorator);\n    return decorator(clazz);\n});\nconst decorateMember = (decorator) => ((object, key, ...otherArgs) => {\n    var _a, _b, _c;\n    const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';\n    const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';\n    const clazz = decoratorTargetType === 'static' ? object : object.constructor;\n    const decoratorsForClass = getDecoratorsForClass(clazz);\n    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};\n    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;\n    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};\n    decoratorsForTargetType[decoratorType] = decoratorsForType;\n    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];\n    decoratorsForType[key] = decoratorsForKey;\n    // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine\n    decoratorsForKey.push(decorator);\n    // @ts-ignore\n    return decorator(object, key, ...otherArgs);\n});\nconst decorate = (decorator) => ((...args) => {\n    if (args.length === 1)\n        return decorateClass(decorator)(args[0]);\n    return decorateMember(decorator)(...args);\n});\n\nfunction Mixin(...constructors) {\n    var _a, _b, _c;\n    const prototypes = constructors.map(constructor => constructor.prototype);\n    // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and\n    // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix\n    // similarly to constructors -- not methods, which simply override each other.\n    const initFunctionName = settings.initFunction;\n    if (initFunctionName !== null) {\n        const initFunctions = prototypes\n            .map(proto => proto[initFunctionName])\n            .filter(func => typeof func === 'function');\n        const combinedInitFunction = function (...args) {\n            for (let initFunction of initFunctions)\n                initFunction.apply(this, args);\n        };\n        const extraProto = { [initFunctionName]: combinedInitFunction };\n        prototypes.push(extraProto);\n    }\n    function MixedClass(...args) {\n        for (const constructor of constructors)\n            // @ts-ignore: potentially abstract class\n            copyProps(this, new constructor(...args));\n        if (initFunctionName !== null && typeof this[initFunctionName] === 'function')\n            this[initFunctionName].apply(this, args);\n    }\n    MixedClass.prototype = settings.prototypeStrategy === 'copy'\n        ? hardMixProtos(prototypes, MixedClass)\n        : softMixProtos(prototypes, MixedClass);\n    Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy'\n        ? hardMixProtos(constructors, null, ['prototype'])\n        : proxyMix(constructors, Function.prototype));\n    let DecoratedMixedClass = MixedClass;\n    if (settings.decoratorInheritance !== 'none') {\n        const classDecorators = settings.decoratorInheritance === 'deep'\n            ? deepDecoratorSearch(...constructors)\n            : directDecoratorSearch(...constructors);\n        for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {\n            const result = decorator(DecoratedMixedClass);\n            if (result) {\n                DecoratedMixedClass = result;\n            }\n        }\n        applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);\n        applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);\n    }\n    registerMixins(DecoratedMixedClass, constructors);\n    return DecoratedMixedClass;\n}\nconst applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {\n    const propDecorators = propAndMethodDecorators.property;\n    const methodDecorators = propAndMethodDecorators.method;\n    if (propDecorators)\n        for (let key in propDecorators)\n            for (let decorator of propDecorators[key])\n                decorator(target, key);\n    if (methodDecorators)\n        for (let key in methodDecorators)\n            for (let decorator of methodDecorators[key])\n                decorator(target, key, Object.getOwnPropertyDescriptor(target, key));\n};\n/**\n * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.\n */\nconst mix = (...ingredients) => decoratedClass => {\n    // @ts-ignore\n    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));\n    Object.defineProperty(mixedClass, 'name', {\n        value: decoratedClass.name,\n        writable: false,\n    });\n    return mixedClass;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cy1taXhlci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2RkFBNkY7QUFDN0YsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGFBQWE7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUlBQXlJLGdHQUFnRztBQUN6TyxxSUFBcUksOEZBQThGO0FBQ25PLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNklBQTZJLDhGQUE4RjtBQUMzTyxpSkFBaUosZ0dBQWdHO0FBQ2pQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3S0FBd0s7QUFDeEssMEtBQTBLO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90cy1taXhlci9kaXN0L2VzbS9pbmRleC5qcz82MDk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IHdvcmtzIGxpa2UgYE9iamVjdC5hcHBseWAsIGJ1dCBjb3BpZXMgZ2V0dGVycyBhbmQgc2V0dGVycyBwcm9wZXJseSBhcyB3ZWxsLiAgQWRkaXRpb25hbGx5IGdpdmVzXG4gKiB0aGUgb3B0aW9uIHRvIGV4Y2x1ZGUgcHJvcGVydGllcyBieSBuYW1lLlxuICovXG5jb25zdCBjb3B5UHJvcHMgPSAoZGVzdCwgc3JjLCBleGNsdWRlID0gW10pID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNyYyk7XG4gICAgZm9yIChsZXQgcHJvcCBvZiBleGNsdWRlKVxuICAgICAgICBkZWxldGUgcHJvcHNbcHJvcF07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZGVzdCwgcHJvcHMpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBjaGFpbiBvZiBwcm90b3R5cGVzIHVwIHVudGlsIE9iamVjdC5wcm90b3R5cGUgZ2l2ZW4gYSBzdGFydGluZyBvYmplY3QuICBUaGUgb3JkZXIgb2YgcHJvdG90eXBlcyB3aWxsXG4gKiBiZSBjbG9zZXN0IHRvIGZhcnRoZXN0IGluIHRoZSBjaGFpbi5cbiAqL1xuY29uc3QgcHJvdG9DaGFpbiA9IChvYmosIGN1cnJlbnRDaGFpbiA9IFtvYmpdKSA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXG4gICAgICAgIHJldHVybiBjdXJyZW50Q2hhaW47XG4gICAgcmV0dXJuIHByb3RvQ2hhaW4ocHJvdG8sIFsuLi5jdXJyZW50Q2hhaW4sIHByb3RvXSk7XG59O1xuLyoqXG4gKiBJZGVudGlmaWVzIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGNvbW1vbiB0byBhbGwgdGhlIGdpdmVuIG9iamVjdHMgaW4gdGhlaXIgcHJvdG90eXBlIGNoYWlucy4gIEZvciBtb3N0IHVucmVsYXRlZFxuICogb2JqZWN0cywgdGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuXG4gKi9cbmNvbnN0IG5lYXJlc3RDb21tb25Qcm90byA9ICguLi5vYmpzKSA9PiB7XG4gICAgaWYgKG9ianMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBjb21tb25Qcm90byA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm90b0NoYWlucyA9IG9ianMubWFwKG9iaiA9PiBwcm90b0NoYWluKG9iaikpO1xuICAgIHdoaWxlIChwcm90b0NoYWlucy5ldmVyeShwcm90b0NoYWluID0+IHByb3RvQ2hhaW4ubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgY29uc3QgcHJvdG9zID0gcHJvdG9DaGFpbnMubWFwKHByb3RvQ2hhaW4gPT4gcHJvdG9DaGFpbi5wb3AoKSk7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbENvbW1vblByb3RvID0gcHJvdG9zWzBdO1xuICAgICAgICBpZiAocHJvdG9zLmV2ZXJ5KHByb3RvID0+IHByb3RvID09PSBwb3RlbnRpYWxDb21tb25Qcm90bykpXG4gICAgICAgICAgICBjb21tb25Qcm90byA9IHBvdGVudGlhbENvbW1vblByb3RvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vblByb3RvO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwcm90b3R5cGUgb2JqZWN0IHRoYXQgaXMgYSBtaXh0dXJlIG9mIHRoZSBnaXZlbiBwcm90b3R5cGVzLiAgVGhlIG1peGluZyBpcyBhY2hpZXZlZCBieSBmaXJzdFxuICogaWRlbnRpZnlpbmcgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGFuZCB1c2luZyBpdCBhcyB0aGUgcHJvdG90eXBlIGZvciBhIG5ldyBvYmplY3QuICBUaGVuIGFsbCBwcm9wZXJ0aWVzL21ldGhvZHNcbiAqIGRvd25zdHJlYW0gb2YgdGhpcyBwcm90b3R5cGUgKE9OTFkgZG93bnN0cmVhbSkgYXJlIGNvcGllZCBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuICpcbiAqIFRoZSByZXN1bHRpbmcgcHJvdG90eXBlIGlzIG1vcmUgcGVyZm9ybWFudCB0aGFuIHNvZnRNaXhQcm90b3MoLi4uKSwgYXMgd2VsbCBhcyBFUzUgY29tcGF0aWJsZS4gIEhvd2V2ZXIsIGl0J3Mgbm90IGFzXG4gKiBmbGV4aWJsZSBhcyB1cGRhdGVzIHRvIHRoZSBzb3VyY2UgcHJvdG90eXBlcyBhcmVuJ3QgY2FwdHVyZWQgYnkgdGhlIG1peGVkIHJlc3VsdC4gIFNlZSBzb2Z0TWl4UHJvdG9zIGZvciB3aHkgeW91IG1heVxuICogd2FudCB0byB1c2UgdGhhdCBpbnN0ZWFkLlxuICovXG5jb25zdCBoYXJkTWl4UHJvdG9zID0gKGluZ3JlZGllbnRzLCBjb25zdHJ1Y3RvciwgZXhjbHVkZSA9IFtdKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGJhc2UgPSAoX2EgPSBuZWFyZXN0Q29tbW9uUHJvdG8oLi4uaW5ncmVkaWVudHMpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBPYmplY3QucHJvdG90eXBlO1xuICAgIGNvbnN0IG1peGVkUHJvdG8gPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIC8vIEtlZXBzIHRyYWNrIG9mIHByb3RvdHlwZXMgd2UndmUgYWxyZWFkeSB2aXNpdGVkIHRvIGF2b2lkIGNvcHlpbmcgdGhlIHNhbWUgcHJvcGVydGllcyBtdWx0aXBsZSB0aW1lcy4gIFdlIGluaXQgdGhlXG4gICAgLy8gbGlzdCB3aXRoIHRoZSBwcm90byBjaGFpbiBiZWxvdyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGFueSBvZiB0aG9zZSBtZXRob2RzIG1peGVkIGluXG4gICAgLy8gd2hlbiB0aGV5IHdpbGwgYWxyZWFkeSBiZSBhY2Nlc3NpYmxlIHZpYSBwcm90b3R5cGUgYWNjZXNzLlxuICAgIGNvbnN0IHZpc2l0ZWRQcm90b3MgPSBwcm90b0NoYWluKGJhc2UpO1xuICAgIGZvciAobGV0IHByb3RvdHlwZSBvZiBpbmdyZWRpZW50cykge1xuICAgICAgICBsZXQgcHJvdG9zID0gcHJvdG9DaGFpbihwcm90b3R5cGUpO1xuICAgICAgICAvLyBBcHBseSB0aGUgcHJvdG90eXBlIGNoYWluIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCBvbGQgbWV0aG9kcyBkb24ndCBvdmVycmlkZSBuZXdlciBvbmVzLlxuICAgICAgICBmb3IgKGxldCBpID0gcHJvdG9zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbmV3UHJvdG8gPSBwcm90b3NbaV07XG4gICAgICAgICAgICBpZiAodmlzaXRlZFByb3Rvcy5pbmRleE9mKG5ld1Byb3RvKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb3B5UHJvcHMobWl4ZWRQcm90bywgbmV3UHJvdG8sIFsnY29uc3RydWN0b3InLCAuLi5leGNsdWRlXSk7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFByb3Rvcy5wdXNoKG5ld1Byb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtaXhlZFByb3RvLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG1peGVkUHJvdG87XG59O1xuY29uc3QgdW5pcXVlID0gKGFycikgPT4gYXJyLmZpbHRlcigoZSwgaSkgPT4gYXJyLmluZGV4T2YoZSkgPT0gaSk7XG5cbi8qKlxuICogRmluZHMgdGhlIGluZ3JlZGllbnQgd2l0aCB0aGUgZ2l2ZW4gcHJvcCwgc2VhcmNoaW5nIGluIHJldmVyc2Ugb3JkZXIgYW5kIGJyZWFkdGgtZmlyc3QgaWYgc2VhcmNoaW5nIGluZ3JlZGllbnRcbiAqIHByb3RvdHlwZXMgaXMgcmVxdWlyZWQuXG4gKi9cbmNvbnN0IGdldEluZ3JlZGllbnRXaXRoUHJvcCA9IChwcm9wLCBpbmdyZWRpZW50cykgPT4ge1xuICAgIGNvbnN0IHByb3RvQ2hhaW5zID0gaW5ncmVkaWVudHMubWFwKGluZ3JlZGllbnQgPT4gcHJvdG9DaGFpbihpbmdyZWRpZW50KSk7XG4gICAgLy8gc2luY2Ugd2Ugc2VhcmNoIGJyZWFkdGgtZmlyc3QsIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBvdXIgZGVwdGggaW4gdGhlIHByb3RvdHlwZSBjaGFpbnNcbiAgICBsZXQgcHJvdG9EZXB0aCA9IDA7XG4gICAgLy8gbm90IGFsbCBwcm90b3R5cGUgY2hhaW5zIGFyZSB0aGUgc2FtZSBkZXB0aCwgc28gdGhpcyByZW1haW5zIHRydWUgYXMgbG9uZyBhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGluZ3JlZGllbnRzJ1xuICAgIC8vIHByb3RvdHlwZSBjaGFpbnMgaGFzIGFuIG9iamVjdCBhdCB0aGlzIGRlcHRoXG4gICAgbGV0IHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IHRydWU7XG4gICAgd2hpbGUgKHByb3Rvc0FyZUxlZnRUb1NlYXJjaCkge1xuICAgICAgICAvLyB3aXRoIHRoZSBzdGFydCBvZiBlYWNoIGhvcml6b250YWwgc2xpY2UsIHdlIGFzc3VtZSB0aGlzIGlzIHRoZSBvbmUgdGhhdCdzIGRlZXBlciB0aGFuIGFueSBvZiB0aGUgcHJvdG8gY2hhaW5zXG4gICAgICAgIHByb3Rvc0FyZUxlZnRUb1NlYXJjaCA9IGZhbHNlO1xuICAgICAgICAvLyBzY2FuIHRocm91Z2ggdGhlIGluZ3JlZGllbnRzIHJpZ2h0IHRvIGxlZnRcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZ3JlZGllbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hUYXJnZXQgPSBwcm90b0NoYWluc1tpXVtwcm90b0RlcHRoXTtcbiAgICAgICAgICAgIGlmIChzZWFyY2hUYXJnZXQgIT09IHVuZGVmaW5lZCAmJiBzZWFyY2hUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIHNvbWV0aGluZywgdGhpcyBpcyBwcm9vZiB0aGF0IHRoaXMgaG9yaXpvbnRhbCBzbGljZSBwb3RlbnRpYWxseSBtb3JlIG9iamVjdHMgdG8gc2VhcmNoXG4gICAgICAgICAgICAgICAgcHJvdG9zQXJlTGVmdFRvU2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBldXJla2EsIHdlIGZvdW5kIGl0XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VhcmNoVGFyZ2V0LCBwcm9wKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvQ2hhaW5zW2ldWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm90b0RlcHRoKys7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLyoqXG4gKiBcIk1peGVzXCIgaW5ncmVkaWVudHMgYnkgd3JhcHBpbmcgdGhlbSBpbiBhIFByb3h5LiAgVGhlIG9wdGlvbmFsIHByb3RvdHlwZSBhcmd1bWVudCBhbGxvd3MgdGhlIG1peGVkIG9iamVjdCB0byBzaXRcbiAqIGRvd25zdHJlYW0gb2YgYW4gZXhpc3RpbmcgcHJvdG90eXBlIGNoYWluLiAgTm90ZSB0aGF0IFwicHJvcGVydGllc1wiIGNhbm5vdCBiZSBhZGRlZCwgZGVsZXRlZCwgb3IgbW9kaWZpZWQuXG4gKi9cbmNvbnN0IHByb3h5TWl4ID0gKGluZ3JlZGllbnRzLCBwcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlKSA9PiBuZXcgUHJveHkoe30sIHtcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZTtcbiAgICB9LFxuICAgIHNldFByb3RvdHlwZU9mKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHNldCBwcm90b3R5cGUgb2YgUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXywgcHJvcCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpIHx8IHt9LCBwcm9wKTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWZpbmUgbmV3IHByb3BlcnRpZXMgb24gUHJveGllcyBjcmVhdGVkIGJ5IHRzLW1peGVyJyk7XG4gICAgfSxcbiAgICBoYXMoXywgcHJvcCkge1xuICAgICAgICByZXR1cm4gZ2V0SW5ncmVkaWVudFdpdGhQcm9wKHByb3AsIGluZ3JlZGllbnRzKSAhPT0gdW5kZWZpbmVkIHx8IHByb3RvdHlwZVtwcm9wXSAhPT0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZ2V0KF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIChnZXRJbmdyZWRpZW50V2l0aFByb3AocHJvcCwgaW5ncmVkaWVudHMpIHx8IHByb3RvdHlwZSlbcHJvcF07XG4gICAgfSxcbiAgICBzZXQoXywgcHJvcCwgdmFsKSB7XG4gICAgICAgIGNvbnN0IGluZ3JlZGllbnRXaXRoUHJvcCA9IGdldEluZ3JlZGllbnRXaXRoUHJvcChwcm9wLCBpbmdyZWRpZW50cyk7XG4gICAgICAgIGlmIChpbmdyZWRpZW50V2l0aFByb3AgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBuZXcgcHJvcGVydGllcyBvbiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICAgICAgaW5ncmVkaWVudFdpdGhQcm9wW3Byb3BdID0gdmFsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWxldGUgcHJvcGVydGllcyBvbiBQcm94aWVzIGNyZWF0ZWQgYnkgdHMtbWl4ZXInKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICAgIHJldHVybiBpbmdyZWRpZW50c1xuICAgICAgICAgICAgLm1hcChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcylcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IGN1cnIuY29uY2F0KHByZXYuZmlsdGVyKGtleSA9PiBjdXJyLmluZGV4T2Yoa2V5KSA8IDApKSk7XG4gICAgfSxcbn0pO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHByb3h5LXByb3RvdHlwZSBvYmplY3QgdGhhdCBpcyBhIFwic29mdFwiIG1peHR1cmUgb2YgdGhlIGdpdmVuIHByb3RvdHlwZXMuICBUaGUgbWl4aW5nIGlzIGFjaGlldmVkIGJ5XG4gKiBwcm94eWluZyBhbGwgcHJvcGVydHkgYWNjZXNzIHRvIHRoZSBpbmdyZWRpZW50cy4gIFRoaXMgaXMgbm90IEVTNSBjb21wYXRpYmxlIGFuZCBsZXNzIHBlcmZvcm1hbnQuICBIb3dldmVyLCBhbnlcbiAqIGNoYW5nZXMgbWFkZSB0byB0aGUgc291cmNlIHByb3RvdHlwZXMgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlIHByb3h5LXByb3RvdHlwZSwgd2hpY2ggbWF5IGJlIGRlc2lyYWJsZS5cbiAqL1xuY29uc3Qgc29mdE1peFByb3RvcyA9IChpbmdyZWRpZW50cywgY29uc3RydWN0b3IpID0+IHByb3h5TWl4KFsuLi5pbmdyZWRpZW50cywgeyBjb25zdHJ1Y3RvciB9XSk7XG5cbmNvbnN0IHNldHRpbmdzID0ge1xuICAgIGluaXRGdW5jdGlvbjogbnVsbCxcbiAgICBzdGF0aWNzU3RyYXRlZ3k6ICdjb3B5JyxcbiAgICBwcm90b3R5cGVTdHJhdGVneTogJ2NvcHknLFxuICAgIGRlY29yYXRvckluaGVyaXRhbmNlOiAnZGVlcCcsXG59O1xuXG4vLyBLZWVwcyB0cmFjayBvZiBjb25zdGl0dWVudCBjbGFzc2VzIGZvciBldmVyeSBtaXhpbiBjbGFzcyBjcmVhdGVkIGJ5IHRzLW1peGVyLlxuY29uc3QgbWl4aW5zID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldE1peGluc0ZvckNsYXNzID0gKGNsYXp6KSA9PiBtaXhpbnMuZ2V0KGNsYXp6KTtcbmNvbnN0IHJlZ2lzdGVyTWl4aW5zID0gKG1peGVkQ2xhc3MsIGNvbnN0aXR1ZW50cykgPT4gbWl4aW5zLnNldChtaXhlZENsYXNzLCBjb25zdGl0dWVudHMpO1xuY29uc3QgaGFzTWl4aW4gPSAoaW5zdGFuY2UsIG1peGluKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgbWl4aW4pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZnJvbnRpZXIgPSBuZXcgU2V0KCk7XG4gICAgZnJvbnRpZXIuYWRkKGNvbnN0cnVjdG9yKTtcbiAgICB3aGlsZSAoZnJvbnRpZXIuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZyb250aWVyIGhhcyB0aGUgbWl4aW4gd2UncmUgbG9va2luZyBmb3IuICBpZiBub3QsIHdlIGNhbiBzYXkgd2UgdmlzaXRlZCBldmVyeSBpdGVtIGluIHRoZSBmcm9udGllclxuICAgICAgICBpZiAoZnJvbnRpZXIuaGFzKG1peGluKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmcm9udGllci5mb3JFYWNoKChpdGVtKSA9PiB2aXNpdGVkLmFkZChpdGVtKSk7XG4gICAgICAgIC8vIGJ1aWxkIGEgbmV3IGZyb250aWVyIGJhc2VkIG9uIHRoZSBhc3NvY2lhdGVkIG1peGluIGNsYXNzZXMgYW5kIHByb3RvdHlwZSBjaGFpbnMgb2YgZWFjaCBmcm9udGllciBpdGVtXG4gICAgICAgIGNvbnN0IG5ld0Zyb250aWVyID0gbmV3IFNldCgpO1xuICAgICAgICBmcm9udGllci5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBpdGVtQ29uc3RpdHVlbnRzID0gKF9hID0gbWl4aW5zLmdldChpdGVtKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvdG9DaGFpbihpdGVtLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICAubWFwKChwcm90bykgPT4gcHJvdG8uY29uc3RydWN0b3IpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoaXRlbUNvbnN0aXR1ZW50cylcbiAgICAgICAgICAgICAgICBpdGVtQ29uc3RpdHVlbnRzLmZvckVhY2goKGNvbnN0aXR1ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoY29uc3RpdHVlbnQpICYmICFmcm9udGllci5oYXMoY29uc3RpdHVlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RnJvbnRpZXIuYWRkKGNvbnN0aXR1ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdlIGhhdmUgYSBuZXcgZnJvbnRpZXIsIG5vdyBzZWFyY2ggYWdhaW5cbiAgICAgICAgZnJvbnRpZXIgPSBuZXdGcm9udGllcjtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ2V0IGhlcmUsIHdlIGNvdWxkbid0IGZpbmQgdGhlIG1peGluIGFueXdoZXJlIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb3IgYXNzb2NpYXRlZCBtaXhpbiBjbGFzc2VzXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzID0gKG8xLCBvMikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgYWxsS2V5cyA9IHVuaXF1ZShbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobzEpLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvMildKTtcbiAgICBjb25zdCBtZXJnZWRPYmplY3QgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgb2YgYWxsS2V5cylcbiAgICAgICAgbWVyZ2VkT2JqZWN0W2tleV0gPSB1bmlxdWUoWy4uLigoX2EgPSBvMSA9PT0gbnVsbCB8fCBvMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbzFba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLCAuLi4oKF9iID0gbzIgPT09IG51bGwgfHwgbzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8yW2tleV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKV0pO1xuICAgIHJldHVybiBtZXJnZWRPYmplY3Q7XG59O1xuY29uc3QgbWVyZ2VQcm9wZXJ0eUFuZE1ldGhvZERlY29yYXRvcnMgPSAoZDEsIGQyKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiAoe1xuICAgICAgICBwcm9wZXJ0eTogbWVyZ2VPYmplY3RzT2ZEZWNvcmF0b3JzKChfYSA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5wcm9wZXJ0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sIChfYiA9IGQyID09PSBudWxsIHx8IGQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMi5wcm9wZXJ0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30pLFxuICAgICAgICBtZXRob2Q6IG1lcmdlT2JqZWN0c09mRGVjb3JhdG9ycygoX2MgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEubWV0aG9kKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSwgKF9kID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLm1ldGhvZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30pLFxuICAgIH0pO1xufTtcbmNvbnN0IG1lcmdlRGVjb3JhdG9ycyA9IChkMSwgZDIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICByZXR1cm4gKHtcbiAgICAgICAgY2xhc3M6IHVuaXF1ZShbLi4uKF9hID0gZDEgPT09IG51bGwgfHwgZDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQxLmNsYXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgLi4uKF9iID0gZDIgPT09IG51bGwgfHwgZDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQyLmNsYXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXV0pLFxuICAgICAgICBzdGF0aWM6IG1lcmdlUHJvcGVydHlBbmRNZXRob2REZWNvcmF0b3JzKChfYyA9IGQxID09PSBudWxsIHx8IGQxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkMS5zdGF0aWMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCAoX2QgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuc3RhdGljKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fSksXG4gICAgICAgIGluc3RhbmNlOiBtZXJnZVByb3BlcnR5QW5kTWV0aG9kRGVjb3JhdG9ycygoX2UgPSBkMSA9PT0gbnVsbCB8fCBkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDEuaW5zdGFuY2UpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHt9LCAoX2YgPSBkMiA9PT0gbnVsbCB8fCBkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZDIuaW5zdGFuY2UpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHt9KSxcbiAgICB9KTtcbn07XG5jb25zdCBkZWNvcmF0b3JzID0gbmV3IE1hcCgpO1xuY29uc3QgZmluZEFsbENvbnN0aXR1ZW50Q2xhc3NlcyA9ICguLi5jbGFzc2VzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZnJvbnRpZXIgPSBuZXcgU2V0KFsuLi5jbGFzc2VzXSk7XG4gICAgd2hpbGUgKGZyb250aWVyLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGNsYXp6IG9mIGZyb250aWVyKSB7XG4gICAgICAgICAgICBjb25zdCBwcm90b0NoYWluQ2xhc3NlcyA9IHByb3RvQ2hhaW4oY2xhenoucHJvdG90eXBlKS5tYXAocHJvdG8gPT4gcHJvdG8uY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgbWl4aW5DbGFzc2VzID0gKF9hID0gZ2V0TWl4aW5zRm9yQ2xhc3MoY2xhenopKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbGx5TmV3Q2xhc3NlcyA9IFsuLi5wcm90b0NoYWluQ2xhc3NlcywgLi4ubWl4aW5DbGFzc2VzXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBwb3RlbnRpYWxseU5ld0NsYXNzZXMuZmlsdGVyKGMgPT4gIWFsbENsYXNzZXMuaGFzKGMpKTtcbiAgICAgICAgICAgIGZvciAobGV0IG5ld0NsYXNzIG9mIG5ld0NsYXNzZXMpXG4gICAgICAgICAgICAgICAgZnJvbnRpZXIuYWRkKG5ld0NsYXNzKTtcbiAgICAgICAgICAgIGFsbENsYXNzZXMuYWRkKGNsYXp6KTtcbiAgICAgICAgICAgIGZyb250aWVyLmRlbGV0ZShjbGF6eik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5hbGxDbGFzc2VzXTtcbn07XG5jb25zdCBkZWVwRGVjb3JhdG9yU2VhcmNoID0gKC4uLmNsYXNzZXMpID0+IHtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbiA9IGZpbmRBbGxDb25zdGl0dWVudENsYXNzZXMoLi4uY2xhc3NlcylcbiAgICAgICAgLm1hcChjbGF6eiA9PiBkZWNvcmF0b3JzLmdldChjbGF6eikpXG4gICAgICAgIC5maWx0ZXIoZGVjb3JhdG9ycyA9PiAhIWRlY29yYXRvcnMpO1xuICAgIGlmIChkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5sZW5ndGggPT0gMSlcbiAgICAgICAgcmV0dXJuIGRlY29yYXRvcnNGb3JDbGFzc0NoYWluWzBdO1xuICAgIHJldHVybiBkZWNvcmF0b3JzRm9yQ2xhc3NDaGFpbi5yZWR1Y2UoKGQxLCBkMikgPT4gbWVyZ2VEZWNvcmF0b3JzKGQxLCBkMikpO1xufTtcbmNvbnN0IGRpcmVjdERlY29yYXRvclNlYXJjaCA9ICguLi5jbGFzc2VzKSA9PiB7XG4gICAgY29uc3QgY2xhc3NEZWNvcmF0b3JzID0gY2xhc3Nlcy5tYXAoY2xhenogPT4gZ2V0RGVjb3JhdG9yc0ZvckNsYXNzKGNsYXp6KSk7XG4gICAgaWYgKGNsYXNzRGVjb3JhdG9ycy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoY2xhc3NEZWNvcmF0b3JzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGNsYXNzRGVjb3JhdG9yc1swXTtcbiAgICByZXR1cm4gY2xhc3NEZWNvcmF0b3JzLnJlZHVjZSgoZDEsIGQyKSA9PiBtZXJnZURlY29yYXRvcnMoZDEsIGQyKSk7XG59O1xuY29uc3QgZ2V0RGVjb3JhdG9yc0ZvckNsYXNzID0gKGNsYXp6KSA9PiB7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JDbGFzcyA9IGRlY29yYXRvcnMuZ2V0KGNsYXp6KTtcbiAgICBpZiAoIWRlY29yYXRvcnNGb3JDbGFzcykge1xuICAgICAgICBkZWNvcmF0b3JzRm9yQ2xhc3MgPSB7fTtcbiAgICAgICAgZGVjb3JhdG9ycy5zZXQoY2xhenosIGRlY29yYXRvcnNGb3JDbGFzcyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0b3JzRm9yQ2xhc3M7XG59O1xuY29uc3QgZGVjb3JhdGVDbGFzcyA9IChkZWNvcmF0b3IpID0+ICgoY2xhenopID0+IHtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yQ2xhc3MgPSBnZXREZWNvcmF0b3JzRm9yQ2xhc3MoY2xhenopO1xuICAgIGxldCBjbGFzc0RlY29yYXRvcnMgPSBkZWNvcmF0b3JzRm9yQ2xhc3MuY2xhc3M7XG4gICAgaWYgKCFjbGFzc0RlY29yYXRvcnMpIHtcbiAgICAgICAgY2xhc3NEZWNvcmF0b3JzID0gW107XG4gICAgICAgIGRlY29yYXRvcnNGb3JDbGFzcy5jbGFzcyA9IGNsYXNzRGVjb3JhdG9ycztcbiAgICB9XG4gICAgY2xhc3NEZWNvcmF0b3JzLnB1c2goZGVjb3JhdG9yKTtcbiAgICByZXR1cm4gZGVjb3JhdG9yKGNsYXp6KTtcbn0pO1xuY29uc3QgZGVjb3JhdGVNZW1iZXIgPSAoZGVjb3JhdG9yKSA9PiAoKG9iamVjdCwga2V5LCAuLi5vdGhlckFyZ3MpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBkZWNvcmF0b3JUYXJnZXRUeXBlID0gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJyA/ICdzdGF0aWMnIDogJ2luc3RhbmNlJztcbiAgICBjb25zdCBkZWNvcmF0b3JUeXBlID0gdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nID8gJ21ldGhvZCcgOiAncHJvcGVydHknO1xuICAgIGNvbnN0IGNsYXp6ID0gZGVjb3JhdG9yVGFyZ2V0VHlwZSA9PT0gJ3N0YXRpYycgPyBvYmplY3QgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgY29uc3QgZGVjb3JhdG9yc0ZvckNsYXNzID0gZ2V0RGVjb3JhdG9yc0ZvckNsYXNzKGNsYXp6KTtcbiAgICBjb25zdCBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZSA9IChfYSA9IGRlY29yYXRvcnNGb3JDbGFzcyA9PT0gbnVsbCB8fCBkZWNvcmF0b3JzRm9yQ2xhc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JDbGFzc1tkZWNvcmF0b3JUYXJnZXRUeXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgZGVjb3JhdG9yc0ZvckNsYXNzW2RlY29yYXRvclRhcmdldFR5cGVdID0gZGVjb3JhdG9yc0ZvclRhcmdldFR5cGU7XG4gICAgbGV0IGRlY29yYXRvcnNGb3JUeXBlID0gKF9iID0gZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUgPT09IG51bGwgfHwgZGVjb3JhdG9yc0ZvclRhcmdldFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JUYXJnZXRUeXBlW2RlY29yYXRvclR5cGVdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICBkZWNvcmF0b3JzRm9yVGFyZ2V0VHlwZVtkZWNvcmF0b3JUeXBlXSA9IGRlY29yYXRvcnNGb3JUeXBlO1xuICAgIGxldCBkZWNvcmF0b3JzRm9yS2V5ID0gKF9jID0gZGVjb3JhdG9yc0ZvclR5cGUgPT09IG51bGwgfHwgZGVjb3JhdG9yc0ZvclR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY29yYXRvcnNGb3JUeXBlW2tleV0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgIGRlY29yYXRvcnNGb3JUeXBlW2tleV0gPSBkZWNvcmF0b3JzRm9yS2V5O1xuICAgIC8vIEB0cy1pZ25vcmU6IGFycmF5IGlzIHR5cGUgYEFbXSB8IEJbXWAgYW5kIGl0ZW0gaXMgdHlwZSBgQSB8IEJgLCBzbyB0ZWNobmljYWxseSBhIHR5cGUgZXJyb3IsIGJ1dCBpdCdzIGZpbmVcbiAgICBkZWNvcmF0b3JzRm9yS2V5LnB1c2goZGVjb3JhdG9yKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIGRlY29yYXRvcihvYmplY3QsIGtleSwgLi4ub3RoZXJBcmdzKTtcbn0pO1xuY29uc3QgZGVjb3JhdGUgPSAoZGVjb3JhdG9yKSA9PiAoKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBkZWNvcmF0ZUNsYXNzKGRlY29yYXRvcikoYXJnc1swXSk7XG4gICAgcmV0dXJuIGRlY29yYXRlTWVtYmVyKGRlY29yYXRvcikoLi4uYXJncyk7XG59KTtcblxuZnVuY3Rpb24gTWl4aW4oLi4uY29uc3RydWN0b3JzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgcHJvdG90eXBlcyA9IGNvbnN0cnVjdG9ycy5tYXAoY29uc3RydWN0b3IgPT4gY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAvLyBIZXJlIHdlIGdhdGhlciB1cCB0aGUgaW5pdCBmdW5jdGlvbnMgb2YgdGhlIGluZ3JlZGllbnQgcHJvdG90eXBlcywgY29tYmluZSB0aGVtIGludG8gb25lIGluaXQgZnVuY3Rpb24sIGFuZFxuICAgIC8vIGF0dGFjaCBpdCB0byB0aGUgbWl4ZWQgY2xhc3MgcHJvdG90eXBlLiAgVGhlIHJlYXNvbiB3ZSBkbyB0aGlzIGlzIGJlY2F1c2Ugd2Ugd2FudCB0aGUgaW5pdCBmdW5jdGlvbnMgdG8gbWl4XG4gICAgLy8gc2ltaWxhcmx5IHRvIGNvbnN0cnVjdG9ycyAtLSBub3QgbWV0aG9kcywgd2hpY2ggc2ltcGx5IG92ZXJyaWRlIGVhY2ggb3RoZXIuXG4gICAgY29uc3QgaW5pdEZ1bmN0aW9uTmFtZSA9IHNldHRpbmdzLmluaXRGdW5jdGlvbjtcbiAgICBpZiAoaW5pdEZ1bmN0aW9uTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpbml0RnVuY3Rpb25zID0gcHJvdG90eXBlc1xuICAgICAgICAgICAgLm1hcChwcm90byA9PiBwcm90b1tpbml0RnVuY3Rpb25OYW1lXSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuYyA9PiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkSW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGluaXRGdW5jdGlvbiBvZiBpbml0RnVuY3Rpb25zKVxuICAgICAgICAgICAgICAgIGluaXRGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXh0cmFQcm90byA9IHsgW2luaXRGdW5jdGlvbk5hbWVdOiBjb21iaW5lZEluaXRGdW5jdGlvbiB9O1xuICAgICAgICBwcm90b3R5cGVzLnB1c2goZXh0cmFQcm90byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1peGVkQ2xhc3MoLi4uYXJncykge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnN0cnVjdG9yIG9mIGNvbnN0cnVjdG9ycylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IHBvdGVudGlhbGx5IGFic3RyYWN0IGNsYXNzXG4gICAgICAgICAgICBjb3B5UHJvcHModGhpcywgbmV3IGNvbnN0cnVjdG9yKC4uLmFyZ3MpKTtcbiAgICAgICAgaWYgKGluaXRGdW5jdGlvbk5hbWUgIT09IG51bGwgJiYgdHlwZW9mIHRoaXNbaW5pdEZ1bmN0aW9uTmFtZV0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aGlzW2luaXRGdW5jdGlvbk5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBNaXhlZENsYXNzLnByb3RvdHlwZSA9IHNldHRpbmdzLnByb3RvdHlwZVN0cmF0ZWd5ID09PSAnY29weSdcbiAgICAgICAgPyBoYXJkTWl4UHJvdG9zKHByb3RvdHlwZXMsIE1peGVkQ2xhc3MpXG4gICAgICAgIDogc29mdE1peFByb3Rvcyhwcm90b3R5cGVzLCBNaXhlZENsYXNzKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoTWl4ZWRDbGFzcywgc2V0dGluZ3Muc3RhdGljc1N0cmF0ZWd5ID09PSAnY29weSdcbiAgICAgICAgPyBoYXJkTWl4UHJvdG9zKGNvbnN0cnVjdG9ycywgbnVsbCwgWydwcm90b3R5cGUnXSlcbiAgICAgICAgOiBwcm94eU1peChjb25zdHJ1Y3RvcnMsIEZ1bmN0aW9uLnByb3RvdHlwZSkpO1xuICAgIGxldCBEZWNvcmF0ZWRNaXhlZENsYXNzID0gTWl4ZWRDbGFzcztcbiAgICBpZiAoc2V0dGluZ3MuZGVjb3JhdG9ySW5oZXJpdGFuY2UgIT09ICdub25lJykge1xuICAgICAgICBjb25zdCBjbGFzc0RlY29yYXRvcnMgPSBzZXR0aW5ncy5kZWNvcmF0b3JJbmhlcml0YW5jZSA9PT0gJ2RlZXAnXG4gICAgICAgICAgICA/IGRlZXBEZWNvcmF0b3JTZWFyY2goLi4uY29uc3RydWN0b3JzKVxuICAgICAgICAgICAgOiBkaXJlY3REZWNvcmF0b3JTZWFyY2goLi4uY29uc3RydWN0b3JzKTtcbiAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIChfYSA9IGNsYXNzRGVjb3JhdG9ycyA9PT0gbnVsbCB8fCBjbGFzc0RlY29yYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsYXNzRGVjb3JhdG9ycy5jbGFzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29yYXRvcihEZWNvcmF0ZWRNaXhlZENsYXNzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBEZWNvcmF0ZWRNaXhlZENsYXNzID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMoKF9iID0gY2xhc3NEZWNvcmF0b3JzID09PSBudWxsIHx8IGNsYXNzRGVjb3JhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xhc3NEZWNvcmF0b3JzLnN0YXRpYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sIERlY29yYXRlZE1peGVkQ2xhc3MpO1xuICAgICAgICBhcHBseVByb3BBbmRNZXRob2REZWNvcmF0b3JzKChfYyA9IGNsYXNzRGVjb3JhdG9ycyA9PT0gbnVsbCB8fCBjbGFzc0RlY29yYXRvcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsYXNzRGVjb3JhdG9ycy5pbnN0YW5jZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIERlY29yYXRlZE1peGVkQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJNaXhpbnMoRGVjb3JhdGVkTWl4ZWRDbGFzcywgY29uc3RydWN0b3JzKTtcbiAgICByZXR1cm4gRGVjb3JhdGVkTWl4ZWRDbGFzcztcbn1cbmNvbnN0IGFwcGx5UHJvcEFuZE1ldGhvZERlY29yYXRvcnMgPSAocHJvcEFuZE1ldGhvZERlY29yYXRvcnMsIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHByb3BEZWNvcmF0b3JzID0gcHJvcEFuZE1ldGhvZERlY29yYXRvcnMucHJvcGVydHk7XG4gICAgY29uc3QgbWV0aG9kRGVjb3JhdG9ycyA9IHByb3BBbmRNZXRob2REZWNvcmF0b3JzLm1ldGhvZDtcbiAgICBpZiAocHJvcERlY29yYXRvcnMpXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBwcm9wRGVjb3JhdG9ycylcbiAgICAgICAgICAgIGZvciAobGV0IGRlY29yYXRvciBvZiBwcm9wRGVjb3JhdG9yc1trZXldKVxuICAgICAgICAgICAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSk7XG4gICAgaWYgKG1ldGhvZERlY29yYXRvcnMpXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBtZXRob2REZWNvcmF0b3JzKVxuICAgICAgICAgICAgZm9yIChsZXQgZGVjb3JhdG9yIG9mIG1ldGhvZERlY29yYXRvcnNba2V5XSlcbiAgICAgICAgICAgICAgICBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpKTtcbn07XG4vKipcbiAqIEEgZGVjb3JhdG9yIHZlcnNpb24gb2YgdGhlIGBNaXhpbmAgZnVuY3Rpb24uICBZb3UnbGwgd2FudCB0byB1c2UgdGhpcyBpbnN0ZWFkIG9mIGBNaXhpbmAgZm9yIG1peGluZyBnZW5lcmljIGNsYXNzZXMuXG4gKi9cbmNvbnN0IG1peCA9ICguLi5pbmdyZWRpZW50cykgPT4gZGVjb3JhdGVkQ2xhc3MgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBtaXhlZENsYXNzID0gTWl4aW4oLi4uaW5ncmVkaWVudHMuY29uY2F0KFtkZWNvcmF0ZWRDbGFzc10pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWl4ZWRDbGFzcywgJ25hbWUnLCB7XG4gICAgICAgIHZhbHVlOiBkZWNvcmF0ZWRDbGFzcy5uYW1lLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1peGVkQ2xhc3M7XG59O1xuXG5leHBvcnQgeyBNaXhpbiwgZGVjb3JhdGUsIGhhc01peGluLCBtaXgsIHNldHRpbmdzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ts-mixer/dist/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/url-join/lib/url-join.js":
/*!***********************************************!*\
  !*** ./node_modules/url-join/lib/url-join.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (name, context, definition) {\n  if ( true && module.exports) module.exports = definition();\n  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  else {}\n})('urljoin', this, function () {\n\n  function normalize (strArray) {\n    var resultArray = [];\n    if (strArray.length === 0) { return ''; }\n\n    if (typeof strArray[0] !== 'string') {\n      throw new TypeError('Url must be a string. Received ' + strArray[0]);\n    }\n\n    // If the first part is a plain protocol, we combine it with the next part.\n    if (strArray[0].match(/^[^/:]+:\\/*$/) && strArray.length > 1) {\n      var first = strArray.shift();\n      strArray[0] = first + strArray[0];\n    }\n\n    // There must be two or three slashes in the file protocol, two slashes in anything else.\n    if (strArray[0].match(/^file:\\/\\/\\//)) {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1:///');\n    } else {\n      strArray[0] = strArray[0].replace(/^([^/:]+):\\/*/, '$1://');\n    }\n\n    for (var i = 0; i < strArray.length; i++) {\n      var component = strArray[i];\n\n      if (typeof component !== 'string') {\n        throw new TypeError('Url must be a string. Received ' + component);\n      }\n\n      if (component === '') { continue; }\n\n      if (i > 0) {\n        // Removing the starting slashes for each component but the first.\n        component = component.replace(/^[\\/]+/, '');\n      }\n      if (i < strArray.length - 1) {\n        // Removing the ending slashes for each component but the last.\n        component = component.replace(/[\\/]+$/, '');\n      } else {\n        // For the last component we will combine multiple slashes to a single one.\n        component = component.replace(/[\\/]+$/, '/');\n      }\n\n      resultArray.push(component);\n\n    }\n\n    var str = resultArray.join('/');\n    // Each input component is now separated by a single slash except the possible first plain protocol part.\n\n    // remove trailing slash before parameters or hash\n    str = str.replace(/\\/(\\?|&|#[^!])/g, '$1');\n\n    // replace ? in parameters with &\n    var parts = str.split('?');\n    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');\n\n    return str;\n  }\n\n  return function () {\n    var input;\n\n    if (typeof arguments[0] === 'object') {\n      input = arguments[0];\n    } else {\n      input = [].slice.call(arguments);\n    }\n\n    return normalize(input);\n  };\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91cmwtam9pbi9saWIvdXJsLWpvaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNLEtBQTZCO0FBQ25DLFdBQVcsSUFBMEMsRUFBRSxvQ0FBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDekUsT0FBTyxFQUE2QjtBQUNwQyxDQUFDOztBQUVEO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VybC1qb2luL2xpYi91cmwtam9pbi5qcz85MDk4Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShkZWZpbml0aW9uKTtcbiAgZWxzZSBjb250ZXh0W25hbWVdID0gZGVmaW5pdGlvbigpO1xufSkoJ3VybGpvaW4nLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplIChzdHJBcnJheSkge1xuICAgIHZhciByZXN1bHRBcnJheSA9IFtdO1xuICAgIGlmIChzdHJBcnJheS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG5cbiAgICBpZiAodHlwZW9mIHN0ckFycmF5WzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVXJsIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBzdHJBcnJheVswXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGZpcnN0IHBhcnQgaXMgYSBwbGFpbiBwcm90b2NvbCwgd2UgY29tYmluZSBpdCB3aXRoIHRoZSBuZXh0IHBhcnQuXG4gICAgaWYgKHN0ckFycmF5WzBdLm1hdGNoKC9eW14vOl0rOlxcLyokLykgJiYgc3RyQXJyYXkubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGZpcnN0ID0gc3RyQXJyYXkuc2hpZnQoKTtcbiAgICAgIHN0ckFycmF5WzBdID0gZmlyc3QgKyBzdHJBcnJheVswXTtcbiAgICB9XG5cbiAgICAvLyBUaGVyZSBtdXN0IGJlIHR3byBvciB0aHJlZSBzbGFzaGVzIGluIHRoZSBmaWxlIHByb3RvY29sLCB0d28gc2xhc2hlcyBpbiBhbnl0aGluZyBlbHNlLlxuICAgIGlmIChzdHJBcnJheVswXS5tYXRjaCgvXmZpbGU6XFwvXFwvXFwvLykpIHtcbiAgICAgIHN0ckFycmF5WzBdID0gc3RyQXJyYXlbMF0ucmVwbGFjZSgvXihbXi86XSspOlxcLyovLCAnJDE6Ly8vJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ckFycmF5WzBdID0gc3RyQXJyYXlbMF0ucmVwbGFjZSgvXihbXi86XSspOlxcLyovLCAnJDE6Ly8nKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ckFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gc3RyQXJyYXlbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVcmwgbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIGNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQgPT09ICcnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAvLyBSZW1vdmluZyB0aGUgc3RhcnRpbmcgc2xhc2hlcyBmb3IgZWFjaCBjb21wb25lbnQgYnV0IHRoZSBmaXJzdC5cbiAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoL15bXFwvXSsvLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IHN0ckFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gUmVtb3ZpbmcgdGhlIGVuZGluZyBzbGFzaGVzIGZvciBlYWNoIGNvbXBvbmVudCBidXQgdGhlIGxhc3QuXG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudC5yZXBsYWNlKC9bXFwvXSskLywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIHRoZSBsYXN0IGNvbXBvbmVudCB3ZSB3aWxsIGNvbWJpbmUgbXVsdGlwbGUgc2xhc2hlcyB0byBhIHNpbmdsZSBvbmUuXG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudC5yZXBsYWNlKC9bXFwvXSskLywgJy8nKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0QXJyYXkucHVzaChjb21wb25lbnQpO1xuXG4gICAgfVxuXG4gICAgdmFyIHN0ciA9IHJlc3VsdEFycmF5LmpvaW4oJy8nKTtcbiAgICAvLyBFYWNoIGlucHV0IGNvbXBvbmVudCBpcyBub3cgc2VwYXJhdGVkIGJ5IGEgc2luZ2xlIHNsYXNoIGV4Y2VwdCB0aGUgcG9zc2libGUgZmlyc3QgcGxhaW4gcHJvdG9jb2wgcGFydC5cblxuICAgIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaCBiZWZvcmUgcGFyYW1ldGVycyBvciBoYXNoXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcLyhcXD98JnwjW14hXSkvZywgJyQxJyk7XG5cbiAgICAvLyByZXBsYWNlID8gaW4gcGFyYW1ldGVycyB3aXRoICZcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoJz8nKTtcbiAgICBzdHIgPSBwYXJ0cy5zaGlmdCgpICsgKHBhcnRzLmxlbmd0aCA+IDAgPyAnPyc6ICcnKSArIHBhcnRzLmpvaW4oJyYnKTtcblxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnB1dDtcblxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5wdXQgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemUoaW5wdXQpO1xuICB9O1xuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/url-join/lib/url-join.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar required = __webpack_require__(/*! requires-port */ \"(app-pages-browser)/./node_modules/requires-port/index.js\")\n  , qs = __webpack_require__(/*! querystringify */ \"(app-pages-browser)/./node_modules/querystringify/index.js\")\n  , controlOrWhitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/\n  , CRHTLF = /[\\n\\r\\t]/g\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , port = /:\\d+$/\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n  , windowsDriveLetter = /^[a-zA-Z]:/;\n\n/**\n * Remove control characters and whitespace from the beginning of a string.\n *\n * @param {Object|String} str String to trim.\n * @returns {String} A new string representing `str` stripped of control\n *     characters and whitespace from its beginning.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(controlOrWhitespace, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d*)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof __webpack_require__.g !== 'undefined') globalVar = __webpack_require__.g;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4]\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      index = parse === '@'\n        ? address.lastIndexOf(parse)\n        : address.indexOf(parse);\n\n      if (~index) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n\n  if (url.auth) {\n    index = url.auth.indexOf(':');\n\n    if (~index) {\n      url.username = url.auth.slice(0, index);\n      url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n      url.password = url.auth.slice(index + 1);\n      url.password = encodeURIComponent(decodeURIComponent(url.password))\n    } else {\n      url.username = encodeURIComponent(decodeURIComponent(url.auth));\n    }\n\n    url.auth = url.password ? url.username +':'+ url.password : url.username;\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (port.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    case 'username':\n    case 'password':\n      url[part] = encodeURIComponent(value);\n      break;\n\n    case 'auth':\n      var index = value.indexOf(':');\n\n      if (~index) {\n        url.username = value.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n        url.password = value.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(value));\n      }\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.auth = url.password ? url.username +':'+ url.password : url.username;\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , host = url.host\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result =\n    protocol +\n    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  } else if (url.password) {\n    result += ':'+ url.password;\n    result += '@';\n  } else if (\n    url.protocol !== 'file:' &&\n    isSpecial(url.protocol) &&\n    !host &&\n    url.pathname !== '/'\n  ) {\n    //\n    // Add back the empty userinfo, otherwise the original invalid URL\n    // might be transformed into a valid one with `url.pathname` as host.\n    //\n    result += '@';\n  }\n\n  //\n  // Trailing colon is removed from `url.host` when it is parsed. If it still\n  // ends with a colon, then add back the trailing colon that was removed. This\n  // prevents an invalid URL from being transformed into a valid one.\n  //\n  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {\n    host += ':';\n  }\n\n  result += host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLGdGQUFlO0FBQ3RDLFNBQVMsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixxQkFBTSw4QkFBOEIscUJBQU07QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJO0FBQ0osc0NBQXNDO0FBQ3RDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyx5QkFBeUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzPzdlYmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBjb250cm9sT3JXaGl0ZXNwYWNlID0gL15bXFx4MDAtXFx4MjBcXHUwMGEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0rL1xuICAsIENSSFRMRiA9IC9bXFxuXFxyXFx0XS9nXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvL1xuICAsIHBvcnQgPSAvOlxcZCskL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxcXC9dKyk/KFtcXFNcXHNdKikvaVxuICAsIHdpbmRvd3NEcml2ZUxldHRlciA9IC9eW2EtekEtWl06LztcblxuLyoqXG4gKiBSZW1vdmUgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB3aGl0ZXNwYWNlIGZyb20gdGhlIGJlZ2lubmluZyBvZiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHN0ciBTdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgbmV3IHN0cmluZyByZXByZXNlbnRpbmcgYHN0cmAgc3RyaXBwZWQgb2YgY29udHJvbFxuICogICAgIGNoYXJhY3RlcnMgYW5kIHdoaXRlc3BhY2UgZnJvbSBpdHMgYmVnaW5uaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0cmltTGVmdChzdHIpIHtcbiAgcmV0dXJuIChzdHIgPyBzdHIgOiAnJykudG9TdHJpbmcoKS5yZXBsYWNlKGNvbnRyb2xPcldoaXRlc3BhY2UsICcnKTtcbn1cblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcywgdXJsKSB7ICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgPyBhZGRyZXNzLnJlcGxhY2UoL1xcXFwvZywgJy8nKSA6IGFkZHJlc3M7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCopJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgZ2xvYmFsVmFyO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gd2luZG93O1xuICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gZ2xvYmFsO1xuICBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHNlbGY7XG4gIGVsc2UgZ2xvYmFsVmFyID0ge307XG5cbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsVmFyLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHByb3RvY29sIHNjaGVtZSBpcyBzcGVjaWFsLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgcHJvdG9jb2wgc2NoZW1lIG9mIHRoZSBVUkxcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTcGVjaWFsKHNjaGVtZSkge1xuICByZXR1cm4gKFxuICAgIHNjaGVtZSA9PT0gJ2ZpbGU6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ2Z0cDonIHx8XG4gICAgc2NoZW1lID09PSAnaHR0cDonIHx8XG4gICAgc2NoZW1lID09PSAnaHR0cHM6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzOicgfHxcbiAgICBzY2hlbWUgPT09ICd3c3M6J1xuICApO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzLCBsb2NhdGlvbikge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG4gIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoQ1JIVExGLCAnJyk7XG4gIGxvY2F0aW9uID0gbG9jYXRpb24gfHwge307XG5cbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuICB2YXIgcHJvdG9jb2wgPSBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgdmFyIGZvcndhcmRTbGFzaGVzID0gISFtYXRjaFsyXTtcbiAgdmFyIG90aGVyU2xhc2hlcyA9ICEhbWF0Y2hbM107XG4gIHZhciBzbGFzaGVzQ291bnQgPSAwO1xuICB2YXIgcmVzdDtcblxuICBpZiAoZm9yd2FyZFNsYXNoZXMpIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoICsgbWF0Y2hbM10ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0ID0gbWF0Y2hbMl0gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzJdLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG90aGVyU2xhc2hlcykge1xuICAgICAgcmVzdCA9IG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFs0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgIGlmIChzbGFzaGVzQ291bnQgPj0gMikge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU3BlY2lhbChwcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH0gZWxzZSBpZiAocHJvdG9jb2wpIHtcbiAgICBpZiAoZm9yd2FyZFNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzbGFzaGVzQ291bnQgPj0gMiAmJiBpc1NwZWNpYWwobG9jYXRpb24ucHJvdG9jb2wpKSB7XG4gICAgcmVzdCA9IG1hdGNoWzRdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgc2xhc2hlczogZm9yd2FyZFNsYXNoZXMgfHwgaXNTcGVjaWFsKHByb3RvY29sKSxcbiAgICBzbGFzaGVzQ291bnQ6IHNsYXNoZXNDb3VudCxcbiAgICByZXN0OiByZXN0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICBpZiAocmVsYXRpdmUgPT09ICcnKSByZXR1cm4gYmFzZTtcblxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2xvY2F0aW9uXSBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShDUkhUTEYsICcnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJywgbG9jYXRpb24pO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKFxuICAgIGV4dHJhY3RlZC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiAoXG4gICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50ICE9PSAyIHx8IHdpbmRvd3NEcml2ZUxldHRlci50ZXN0KGFkZHJlc3MpKSB8fFxuICAgICghZXh0cmFjdGVkLnNsYXNoZXMgJiZcbiAgICAgIChleHRyYWN0ZWQucHJvdG9jb2wgfHxcbiAgICAgICAgZXh0cmFjdGVkLnNsYXNoZXNDb3VudCA8IDIgfHxcbiAgICAgICAgIWlzU3BlY2lhbCh1cmwucHJvdG9jb2wpKSlcbiAgKSB7XG4gICAgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG4gIH1cblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MsIHVybCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaW5kZXggPSBwYXJzZSA9PT0gJ0AnXG4gICAgICAgID8gYWRkcmVzcy5sYXN0SW5kZXhPZihwYXJzZSlcbiAgICAgICAgOiBhZGRyZXNzLmluZGV4T2YocGFyc2UpO1xuXG4gICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIERlZmF1bHQgdG8gYSAvIGZvciBwYXRobmFtZSBpZiBub25lIGV4aXN0cy4gVGhpcyBub3JtYWxpemVzIHRoZSBVUkxcbiAgLy8gdG8gYWx3YXlzIGhhdmUgYSAvXG4gIC8vXG4gIGlmICh1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnLycgKyB1cmwucGF0aG5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcblxuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbmRleCA9IHVybC5hdXRoLmluZGV4T2YoJzonKTtcblxuICAgIGlmICh+aW5kZXgpIHtcbiAgICAgIHVybC51c2VybmFtZSA9IHVybC5hdXRoLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnVzZXJuYW1lKSk7XG5cbiAgICAgIHVybC5wYXNzd29yZCA9IHVybC5hdXRoLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgICB1cmwucGFzc3dvcmQgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC5wYXNzd29yZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLmF1dGgpKTtcbiAgICB9XG5cbiAgICB1cmwuYXV0aCA9IHVybC5wYXNzd29yZCA/IHVybC51c2VybmFtZSArJzonKyB1cmwucGFzc3dvcmQgOiB1cmwudXNlcm5hbWU7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmIHVybC5ob3N0XG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmIChwb3J0LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1c2VybmFtZSc6XG4gICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgdXJsW3BhcnRdID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0aCc6XG4gICAgICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKCc6Jyk7XG5cbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgdXJsLnVzZXJuYW1lID0gdmFsdWUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC51c2VybmFtZSkpO1xuXG4gICAgICAgIHVybC5wYXNzd29yZCA9IHZhbHVlLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgICAgIHVybC5wYXNzd29yZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnBhc3N3b3JkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLmF1dGggPSB1cmwucGFzc3dvcmQgPyB1cmwudXNlcm5hbWUgKyc6JysgdXJsLnBhc3N3b3JkIDogdXJsLnVzZXJuYW1lO1xuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiYgdXJsLmhvc3RcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBob3N0ID0gdXJsLmhvc3RcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPVxuICAgIHByb3RvY29sICtcbiAgICAoKHVybC5wcm90b2NvbCAmJiB1cmwuc2xhc2hlcykgfHwgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9IGVsc2UgaWYgKHVybC5wYXNzd29yZCkge1xuICAgIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9IGVsc2UgaWYgKFxuICAgIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJlxuICAgIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmXG4gICAgIWhvc3QgJiZcbiAgICB1cmwucGF0aG5hbWUgIT09ICcvJ1xuICApIHtcbiAgICAvL1xuICAgIC8vIEFkZCBiYWNrIHRoZSBlbXB0eSB1c2VyaW5mbywgb3RoZXJ3aXNlIHRoZSBvcmlnaW5hbCBpbnZhbGlkIFVSTFxuICAgIC8vIG1pZ2h0IGJlIHRyYW5zZm9ybWVkIGludG8gYSB2YWxpZCBvbmUgd2l0aCBgdXJsLnBhdGhuYW1lYCBhcyBob3N0LlxuICAgIC8vXG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIC8vXG4gIC8vIFRyYWlsaW5nIGNvbG9uIGlzIHJlbW92ZWQgZnJvbSBgdXJsLmhvc3RgIHdoZW4gaXQgaXMgcGFyc2VkLiBJZiBpdCBzdGlsbFxuICAvLyBlbmRzIHdpdGggYSBjb2xvbiwgdGhlbiBhZGQgYmFjayB0aGUgdHJhaWxpbmcgY29sb24gdGhhdCB3YXMgcmVtb3ZlZC4gVGhpc1xuICAvLyBwcmV2ZW50cyBhbiBpbnZhbGlkIFVSTCBmcm9tIGJlaW5nIHRyYW5zZm9ybWVkIGludG8gYSB2YWxpZCBvbmUuXG4gIC8vXG4gIGlmIChob3N0W2hvc3QubGVuZ3RoIC0gMV0gPT09ICc6JyB8fCAocG9ydC50ZXN0KHVybC5ob3N0bmFtZSkgJiYgIXVybC5wb3J0KSkge1xuICAgIGhvc3QgKz0gJzonO1xuICB9XG5cbiAgcmVzdWx0ICs9IGhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/url-parse/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/app-dynamic.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/app-dynamic.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return dynamic;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/next/node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _loadable = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./lazy-dynamic/loadable */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js\"));\nfunction dynamic(dynamicOptions, options) {\n    var _mergedOptions_loadableGenerated;\n    let loadableOptions = {\n        // A loading component is not required, so we default it\n        loading: (param)=>{\n            let { error, isLoading, pastDelay } = param;\n            if (!pastDelay) return null;\n            if (true) {\n                if (isLoading) {\n                    return null;\n                }\n                if (error) {\n                    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"p\", {\n                        children: [\n                            error.message,\n                            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"br\", {}),\n                            error.stack\n                        ]\n                    });\n                }\n            }\n            return null;\n        }\n    };\n    if (typeof dynamicOptions === \"function\") {\n        loadableOptions.loader = dynamicOptions;\n    }\n    const mergedOptions = {\n        ...loadableOptions,\n        ...options\n    };\n    return (0, _loadable.default)({\n        ...mergedOptions,\n        modules: (_mergedOptions_loadableGenerated = mergedOptions.loadableGenerated) == null ? void 0 : _mergedOptions_loadableGenerated.modules\n    });\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hcHAtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiOzs7OzJDQWlDQTs7O2VBQXdCQTs7Ozs7NEVBakNOOytFQUNHO0FBZ0NOLFNBQVNBLFFBQ3RCQyxjQUE2QyxFQUM3Q0MsT0FBMkI7UUFtQ2hCQztJQWpDWCxJQUFJQyxrQkFBc0M7UUFDeEMsd0RBQXdEO1FBQ3hEQyxTQUFTLENBQUFDO2dCQUFDLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUUsR0FBQUg7WUFDdkMsSUFBSSxDQUFDRyxXQUFXLE9BQU87WUFDdkIsSUFBSUMsSUFBeUIsRUFBYztnQkFDekMsSUFBSUYsV0FBVztvQkFDYixPQUFPO2dCQUNUO2dCQUNBLElBQUlELE9BQU87b0JBQ1QsT0FDRSxXQURGLEdBQ0UsSUFBQUksWUFBQUMsSUFBQSxFQUFDQyxLQUFBQTs7NEJBQ0VOLE1BQU1PLE9BQU87MENBQ2QsSUFBQUgsWUFBQUksR0FBQSxFQUFDQyxNQUFBQSxDQUFBQTs0QkFDQVQsTUFBTVUsS0FBSzs7O2dCQUdsQjtZQUNGO1lBQ0EsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJLE9BQU9oQixtQkFBbUIsWUFBWTtRQUN4Q0csZ0JBQWdCYyxNQUFNLEdBQUdqQjtJQUMzQjtJQUVBLE1BQU1FLGdCQUFnQjtRQUNwQixHQUFHQyxlQUFlO1FBQ2xCLEdBQUdGLE9BQU87SUFDWjtJQUVBLE9BQU9pQixDQUFBQSxHQUFBQSxVQUFBQSxPQUFRLEVBQUM7UUFDZCxHQUFHaEIsYUFBYTtRQUNoQmlCLFNBQU8sQ0FBRWpCLG1DQUFBQSxjQUFja0IsaUJBQWlCLHFCQUEvQmxCLGlDQUFpQ2lCLE9BQU87SUFDbkQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvYXBwLWR5bmFtaWMudHN4P2M1NjUiXSwibmFtZXMiOlsiZHluYW1pYyIsImR5bmFtaWNPcHRpb25zIiwib3B0aW9ucyIsIm1lcmdlZE9wdGlvbnMiLCJsb2FkYWJsZU9wdGlvbnMiLCJsb2FkaW5nIiwicGFyYW0iLCJlcnJvciIsImlzTG9hZGluZyIsInBhc3REZWxheSIsInByb2Nlc3MiLCJfanN4cnVudGltZSIsImpzeHMiLCJwIiwibWVzc2FnZSIsImpzeCIsImJyIiwic3RhY2siLCJsb2FkZXIiLCJMb2FkYWJsZSIsIm1vZHVsZXMiLCJsb2FkYWJsZUdlbmVyYXRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/app-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"BailoutToCSR\", ({\n    enumerable: true,\n    get: function() {\n        return BailoutToCSR;\n    }\n}));\nconst _bailouttocsr = __webpack_require__(/*! ./bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nfunction BailoutToCSR(param) {\n    let { reason, children } = param;\n    if (typeof window === \"undefined\") {\n        throw new _bailouttocsr.BailoutToCSRError(reason);\n    }\n    return children;\n} //# sourceMappingURL=dynamic-bailout-to-csr.js.map\n_c = BailoutToCSR;\nvar _c;\n$RefreshReg$(_c, \"BailoutToCSR\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvZHluYW1pYy1iYWlsb3V0LXRvLWNzci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBY08sTUFBQUEsZ0JBQXNCQyxtQkFBQUEsQ0FBdUM7U0FBdkNDLGFBQVVDLEtBQVE7SUFDN0MsSUFBSSxFQUFBQyxNQUFPQyxFQUFBQSxRQUFXLEtBQUFDO1FBQ3BCLE9BQU1ELFdBQUlFLGFBQUFBO1FBQ1osVUFBQVAsY0FBQU8saUJBQUEsQ0FBQUg7SUFFQTtJQUNGLE9BQUFEOztLQU42QkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2xhenktZHluYW1pYy9keW5hbWljLWJhaWxvdXQtdG8tY3NyLnRzeD80ZmY0Il0sIm5hbWVzIjpbIl9iYWlsb3V0dG9jc3IiLCJyZXF1aXJlIiwiQmFpbG91dFRvQ1NSIiwiY2hpbGRyZW4iLCJyZWFzb24iLCJ3aW5kb3ciLCJwYXJhbSIsIkJhaWxvdXRUb0NTUkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _dynamicbailouttocsr = __webpack_require__(/*! ./dynamic-bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js\");\nconst _preloadcss = __webpack_require__(/*! ./preload-css */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js\");\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule(mod) {\n    // Check \"default\" prop before accessing it, as it could be client reference proxy that could break it reference.\n    // Cases:\n    // mod: { default: Component }\n    // mod: Component\n    // mod: { $$typeof, default: proxy(Component) }\n    // mod: proxy(Component)\n    const hasDefault = mod && \"default\" in mod;\n    return {\n        default: hasDefault ? mod.default : mod\n    };\n}\nconst defaultOptions = {\n    loader: ()=>Promise.resolve(convertModule(()=>null)),\n    loading: null,\n    ssr: true\n};\nfunction Loadable(options) {\n    const opts = {\n        ...defaultOptions,\n        ...options\n    };\n    const Lazy = /*#__PURE__*/ (0, _react.lazy)(()=>opts.loader().then(convertModule));\n    const Loading = opts.loading;\n    function LoadableComponent(props) {\n        const fallbackElement = Loading ? /*#__PURE__*/ (0, _jsxruntime.jsx)(Loading, {\n            isLoading: true,\n            pastDelay: true,\n            error: null\n        }) : null;\n        const children = opts.ssr ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n            children: [\n                typeof window === \"undefined\" ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_preloadcss.PreloadCss, {\n                    moduleIds: opts.modules\n                }) : null,\n                /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, {\n                    ...props\n                })\n            ]\n        }) : /*#__PURE__*/ (0, _jsxruntime.jsx)(_dynamicbailouttocsr.BailoutToCSR, {\n            reason: \"next/dynamic\",\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, {\n                ...props\n            })\n        });\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            fallback: fallbackElement,\n            children: children\n        });\n    }\n    LoadableComponent.displayName = \"LoadableComponent\";\n    return LoadableComponent;\n}\n_c = Loadable;\nconst _default = Loadable; //# sourceMappingURL=loadable.js.map\nvar _c;\n$RefreshReg$(_c, \"Loadable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvbG9hZGFibGUuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F3RUE7OztlQUFBQTs7OzttQ0F4RStCO2lEQUNGO3dDQUVGO0FBRTNCLHlGQUF5RjtBQUN6RixxR0FBcUc7QUFDckcscUVBQXFFO0FBQ3JFLFNBQVNDLGNBQ1BDLEdBQTREO0lBSTVELGlIQUFpSDtJQUNqSCxTQUFTO0lBQ1QsOEJBQThCO0lBQzlCLGlCQUFpQjtJQUNqQiwrQ0FBK0M7SUFDL0Msd0JBQXdCO0lBQ3hCLE1BQU1DLGFBQWFELE9BQU8sYUFBYUE7SUFDdkMsT0FBTztRQUNMRSxTQUFTRCxhQUNMRCxJQUE0QkUsT0FBTyxHQUNsQ0Y7SUFDUDtBQUNGO0FBRUEsTUFBTUcsaUJBQWlCO0lBQ3JCQyxRQUFRLElBQU1DLFFBQVFDLE9BQU8sQ0FBQ1AsY0FBYyxJQUFNO0lBQ2xEUSxTQUFTO0lBQ1RDLEtBQUs7QUFDUDtBQVNBLFNBQVNDLFNBQVNDLE9BQXdCO0lBQ3hDLE1BQU1DLE9BQU87UUFBRSxHQUFHUixjQUFjO1FBQUUsR0FBR08sT0FBTztJQUFDO0lBQzdDLE1BQU1FLE9BQU9DLFdBQVBELEdBQU9DLENBQUFBLEdBQUFBLE9BQUFBLElBQUksRUFBQyxJQUFNRixLQUFLUCxNQUFNLEdBQUdVLElBQUksQ0FBQ2Y7SUFDM0MsTUFBTWdCLFVBQVVKLEtBQUtKLE9BQU87SUFFNUIsU0FBU1Msa0JBQWtCQyxLQUFVO1FBQ25DLE1BQU1DLGtCQUFrQkgsVUFDdEIsV0FEc0JBLEdBQ3RCLElBQUFJLFlBQUFDLEdBQUEsRUFBQ0wsU0FBQUE7WUFBUU0sV0FBVztZQUFNQyxXQUFXO1lBQU1DLE9BQU87YUFDaEQ7UUFFSixNQUFNQyxXQUFXYixLQUFLSCxHQUFHLEdBQ3ZCLFdBRHVCLEdBQ3ZCLElBQUFXLFlBQUFNLElBQUEsRUFBQU4sWUFBQU8sUUFBQTs7Z0JBRUcsT0FBT0MsV0FBVyxjQUNqQixXQURpQixHQUNqQixJQUFBUixZQUFBQyxHQUFBLEVBQUNRLFlBQUFBLFVBQVU7b0JBQUNDLFdBQVdsQixLQUFLbUIsT0FBTztxQkFDakM7OEJBQ0osSUFBQVgsWUFBQUMsR0FBQSxFQUFDUixNQUFBQTtvQkFBTSxHQUFHSyxLQUFLOzs7YUFHakIsa0JBQUFFLFlBQUFDLEdBQUEsRUFBQ1cscUJBQUFBLFlBQVk7WUFBQ0MsUUFBTztzQkFDbkIsa0JBQUFiLFlBQUFDLEdBQUEsRUFBQ1IsTUFBQUE7Z0JBQU0sR0FBR0ssS0FBSzs7O1FBSW5CLE9BQU8sV0FBUCxHQUFPLElBQUFFLFlBQUFDLEdBQUEsRUFBQ2EsT0FBQUEsUUFBUTtZQUFDQyxVQUFVaEI7c0JBQWtCTTs7SUFDL0M7SUFFQVIsa0JBQWtCbUIsV0FBVyxHQUFHO0lBRWhDLE9BQU9uQjtBQUNUO0tBOUJTUDtNQWdDVFgsV0FBZVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2xhenktZHluYW1pYy9sb2FkYWJsZS50c3g/NjdmNCJdLCJuYW1lcyI6WyJfZGVmYXVsdCIsImNvbnZlcnRNb2R1bGUiLCJtb2QiLCJoYXNEZWZhdWx0IiwiZGVmYXVsdCIsImRlZmF1bHRPcHRpb25zIiwibG9hZGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkaW5nIiwic3NyIiwiTG9hZGFibGUiLCJvcHRpb25zIiwib3B0cyIsIkxhenkiLCJsYXp5IiwidGhlbiIsIkxvYWRpbmciLCJMb2FkYWJsZUNvbXBvbmVudCIsInByb3BzIiwiZmFsbGJhY2tFbGVtZW50IiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJpc0xvYWRpbmciLCJwYXN0RGVsYXkiLCJlcnJvciIsImNoaWxkcmVuIiwianN4cyIsIkZyYWdtZW50Iiwid2luZG93IiwiUHJlbG9hZENzcyIsIm1vZHVsZUlkcyIsIm1vZHVsZXMiLCJCYWlsb3V0VG9DU1IiLCJyZWFzb24iLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"PreloadCss\", ({\n    enumerable: true,\n    get: function() {\n        return PreloadCss;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _requestasyncstorageexternal = __webpack_require__(/*! ../../../client/components/request-async-storage.external */ \"(shared)/./node_modules/next/dist/client/components/request-async-storage.external.js\");\nfunction PreloadCss(param) {\n    let { moduleIds } = param;\n    // Early return in client compilation and only load requestStore on server side\n    if (typeof window !== \"undefined\") {\n        return null;\n    }\n    const requestStore = (0, _requestasyncstorageexternal.getExpectedRequestStore)(\"next/dynamic css\");\n    const allFiles = [];\n    // Search the current dynamic call unique key id in react loadable manifest,\n    // and find the corresponding CSS files to preload\n    if (requestStore.reactLoadableManifest && moduleIds) {\n        const manifest = requestStore.reactLoadableManifest;\n        for (const key of moduleIds){\n            if (!manifest[key]) continue;\n            const cssFiles = manifest[key].files.filter((file)=>file.endsWith(\".css\"));\n            allFiles.push(...cssFiles);\n        }\n    }\n    if (allFiles.length === 0) {\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: allFiles.map((file)=>{\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n                // @ts-ignore\n                precedence: \"dynamic\",\n                rel: \"stylesheet\",\n                href: requestStore.assetPrefix + \"/_next/\" + encodeURI(file),\n                as: \"style\"\n            }, file);\n        })\n    });\n} //# sourceMappingURL=preload-css.js.map\n_c = PreloadCss;\nvar _c;\n$RefreshReg$(_c, \"PreloadCss\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sYXp5LWR5bmFtaWMvcHJlbG9hZC1jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFJTyxNQUFBQSwrQkFBc0VDLG1CQUFBQSxDQUFBO1NBQWxEQyxXQUFXQyxLQUFYO0lBQ3pCLE1BQUFDLFNBQUEsS0FBQUQ7SUFDQSwrRUFBbUM7UUFDakMsT0FBT0UsV0FBQTtRQUNUO0lBRUE7SUFDQSxNQUFNQyxlQUFhLElBQUFOLDZCQUFBTyx1QkFBQTtJQUVuQixNQUFBRCxXQUFBO0lBQ0EsNEVBQWtEO0lBQ2xELGtEQUEwQ0Y7UUFDeENJLGFBQU1DLHFCQUF3QkMsSUFBQUEsV0FBQUE7UUFDOUIsTUFBS0QsV0FBTUUsYUFBa0JELHFCQUFBO2FBQzNCLE1BQUtELE9BQVNFLFVBQU07WUFDcEIsS0FBQUYsUUFBTUcsQ0FBQUEsSUFBV0gsRUFBQUE7WUFHakJILE1BQUFBLFdBQWlCTSxRQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxLQUFBQSxDQUFBQSxNQUFBQSxDQUFBQSxDQUFBQSxPQUFBQSxLQUFBQSxRQUFBQSxDQUFBQTtZQUNuQk4sU0FBQU8sSUFBQSxJQUFBRDtRQUNGO0lBRUE7UUFDRU4sU0FBT1EsTUFBQTtRQUNUO0lBRUE7V0FFS1IsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBU1MsWUFBS0MsR0FBQUEsRUFBQUEsWUFBQUEsUUFBQUEsRUFBQUE7a0JBQ2JWLFNBQUFTLEdBQUEsRUFBQUM7bUJBR2lCLGtCQUFBQyxZQUFBQyxHQUFBO2dCQUNiQyxhQUFZO2dCQUNaQyxZQUFJO2dCQUNKQyxLQUFBQTtnQkFDQUMsTUFBR2QsYUFBQWUsV0FBQSxlQUFBQyxVQUFBUjtnQkFMRUEsSUFBQUE7WUFRWCxHQUFBQTs7SUFHTjs7S0ExQzJCZCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL3ByZWxvYWQtY3NzLnRzeD9kZTVjIl0sIm5hbWVzIjpbIl9yZXF1ZXN0YXN5bmNzdG9yYWdlZXh0ZXJuYWwiLCJyZXF1aXJlIiwiUHJlbG9hZENzcyIsInBhcmFtIiwibW9kdWxlSWRzIiwid2luZG93IiwiYWxsRmlsZXMiLCJnZXRFeHBlY3RlZFJlcXVlc3RTdG9yZSIsInJlcXVlc3RTdG9yZSIsIm1hbmlmZXN0IiwicmVhY3RMb2FkYWJsZU1hbmlmZXN0Iiwia2V5IiwiY3NzRmlsZXMiLCJwdXNoIiwibGVuZ3RoIiwibWFwIiwiZmlsZSIsIl9qc3hydW50aW1lIiwianN4IiwicHJlY2VkZW5jZSIsInJlbCIsImhyZWYiLCJhcyIsImFzc2V0UHJlZml4IiwiZW5jb2RlVVJJIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/abis/abi.ts":
/*!*************************!*\
  !*** ./src/abis/abi.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ABI: function() { return /* binding */ ABI; }\n/* harmony export */ });\nconst ABI = [\n    {\n        type: \"impl\",\n        name: \"HelloStarknetImpl\",\n        interface_name: \"workshop_frontend::IHelloStarknet\"\n    },\n    {\n        type: \"struct\",\n        name: \"core::integer::u256\",\n        members: [\n            {\n                name: \"low\",\n                type: \"core::integer::u128\"\n            },\n            {\n                name: \"high\",\n                type: \"core::integer::u128\"\n            }\n        ]\n    },\n    {\n        type: \"interface\",\n        name: \"workshop_frontend::IHelloStarknet\",\n        items: [\n            {\n                type: \"function\",\n                name: \"increase_balance\",\n                inputs: [\n                    {\n                        name: \"amount\",\n                        type: \"core::integer::u256\"\n                    }\n                ],\n                outputs: [],\n                state_mutability: \"external\"\n            },\n            {\n                type: \"function\",\n                name: \"get_balance\",\n                inputs: [],\n                outputs: [\n                    {\n                        type: \"core::integer::u256\"\n                    }\n                ],\n                state_mutability: \"view\"\n            },\n            {\n                type: \"function\",\n                name: \"reset_balance\",\n                inputs: [],\n                outputs: [],\n                state_mutability: \"external\"\n            }\n        ]\n    },\n    {\n        type: \"event\",\n        name: \"workshop_frontend::HelloStarknet::BalanceIncreased\",\n        kind: \"struct\",\n        members: [\n            {\n                name: \"sender\",\n                type: \"core::starknet::contract_address::ContractAddress\",\n                kind: \"key\"\n            },\n            {\n                name: \"amount\",\n                type: \"core::integer::u256\",\n                kind: \"data\"\n            },\n            {\n                name: \"new_balance\",\n                type: \"core::integer::u256\",\n                kind: \"data\"\n            }\n        ]\n    },\n    {\n        type: \"event\",\n        name: \"workshop_frontend::HelloStarknet::Event\",\n        kind: \"enum\",\n        variants: [\n            {\n                name: \"BalanceIncreased\",\n                type: \"workshop_frontend::HelloStarknet::BalanceIncreased\",\n                kind: \"nested\"\n            }\n        ]\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hYmlzL2FiaS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsTUFBTTtJQUNqQjtRQUNFQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsZ0JBQWdCO0lBQ2xCO0lBQ0E7UUFDRUYsTUFBTTtRQUNOQyxNQUFNO1FBQ05FLFNBQVM7WUFDUDtnQkFBRUYsTUFBTTtnQkFBT0QsTUFBTTtZQUFzQjtZQUMzQztnQkFBRUMsTUFBTTtnQkFBUUQsTUFBTTtZQUFzQjtTQUM3QztJQUNIO0lBQ0E7UUFDRUEsTUFBTTtRQUNOQyxNQUFNO1FBQ05HLE9BQU87WUFDTDtnQkFDRUosTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkksUUFBUTtvQkFBQzt3QkFBRUosTUFBTTt3QkFBVUQsTUFBTTtvQkFBc0I7aUJBQUU7Z0JBQ3pETSxTQUFTLEVBQUU7Z0JBQ1hDLGtCQUFrQjtZQUNwQjtZQUNBO2dCQUNFUCxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOSSxRQUFRLEVBQUU7Z0JBQ1ZDLFNBQVM7b0JBQUM7d0JBQUVOLE1BQU07b0JBQXNCO2lCQUFFO2dCQUMxQ08sa0JBQWtCO1lBQ3BCO1lBQ0E7Z0JBQ0VQLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05JLFFBQVEsRUFBRTtnQkFDVkMsU0FBUyxFQUFFO2dCQUNYQyxrQkFBa0I7WUFDcEI7U0FDRDtJQUNIO0lBQ0E7UUFDRVAsTUFBTTtRQUNOQyxNQUFNO1FBQ05PLE1BQU07UUFDTkwsU0FBUztZQUNQO2dCQUNFRixNQUFNO2dCQUNORCxNQUFNO2dCQUNOUSxNQUFNO1lBQ1I7WUFDQTtnQkFBRVAsTUFBTTtnQkFBVUQsTUFBTTtnQkFBdUJRLE1BQU07WUFBTztZQUM1RDtnQkFBRVAsTUFBTTtnQkFBZUQsTUFBTTtnQkFBdUJRLE1BQU07WUFBTztTQUNsRTtJQUNIO0lBQ0E7UUFDRVIsTUFBTTtRQUNOQyxNQUFNO1FBQ05PLE1BQU07UUFDTkMsVUFBVTtZQUNSO2dCQUNFUixNQUFNO2dCQUNORCxNQUFNO2dCQUNOUSxNQUFNO1lBQ1I7U0FDRDtJQUNIO0NBQ0QsQ0FBVSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYWJpcy9hYmkudHM/MzVhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgQUJJID0gW1xuICB7XG4gICAgdHlwZTogXCJpbXBsXCIsXG4gICAgbmFtZTogXCJIZWxsb1N0YXJrbmV0SW1wbFwiLFxuICAgIGludGVyZmFjZV9uYW1lOiBcIndvcmtzaG9wX2Zyb250ZW5kOjpJSGVsbG9TdGFya25ldFwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgIG5hbWU6IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiLFxuICAgIG1lbWJlcnM6IFtcbiAgICAgIHsgbmFtZTogXCJsb3dcIiwgdHlwZTogXCJjb3JlOjppbnRlZ2VyOjp1MTI4XCIgfSxcbiAgICAgIHsgbmFtZTogXCJoaWdoXCIsIHR5cGU6IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImludGVyZmFjZVwiLFxuICAgIG5hbWU6IFwid29ya3Nob3BfZnJvbnRlbmQ6OklIZWxsb1N0YXJrbmV0XCIsXG4gICAgaXRlbXM6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcImluY3JlYXNlX2JhbGFuY2VcIixcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcImFtb3VudFwiLCB0eXBlOiBcImNvcmU6OmludGVnZXI6OnUyNTZcIiB9XSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlX211dGFiaWxpdHk6IFwiZXh0ZXJuYWxcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcImdldF9iYWxhbmNlXCIsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFt7IHR5cGU6IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIH1dLFxuICAgICAgICBzdGF0ZV9tdXRhYmlsaXR5OiBcInZpZXdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcInJlc2V0X2JhbGFuY2VcIixcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlX211dGFiaWxpdHk6IFwiZXh0ZXJuYWxcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICBuYW1lOiBcIndvcmtzaG9wX2Zyb250ZW5kOjpIZWxsb1N0YXJrbmV0OjpCYWxhbmNlSW5jcmVhc2VkXCIsXG4gICAga2luZDogXCJzdHJ1Y3RcIixcbiAgICBtZW1iZXJzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwic2VuZGVyXCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiLFxuICAgICAgICBraW5kOiBcImtleVwiXG4gICAgICB9LFxuICAgICAgeyBuYW1lOiBcImFtb3VudFwiLCB0eXBlOiBcImNvcmU6OmludGVnZXI6OnUyNTZcIiwga2luZDogXCJkYXRhXCIgfSxcbiAgICAgIHsgbmFtZTogXCJuZXdfYmFsYW5jZVwiLCB0eXBlOiBcImNvcmU6OmludGVnZXI6OnUyNTZcIiwga2luZDogXCJkYXRhXCIgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICBuYW1lOiBcIndvcmtzaG9wX2Zyb250ZW5kOjpIZWxsb1N0YXJrbmV0OjpFdmVudFwiLFxuICAgIGtpbmQ6IFwiZW51bVwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiQmFsYW5jZUluY3JlYXNlZFwiLFxuICAgICAgICB0eXBlOiBcIndvcmtzaG9wX2Zyb250ZW5kOjpIZWxsb1N0YXJrbmV0OjpCYWxhbmNlSW5jcmVhc2VkXCIsXG4gICAgICAgIGtpbmQ6IFwibmVzdGVkXCJcbiAgICAgIH1cbiAgICBdXG4gIH1cbl0gYXMgY29uc3Q7Il0sIm5hbWVzIjpbIkFCSSIsInR5cGUiLCJuYW1lIiwiaW50ZXJmYWNlX25hbWUiLCJtZW1iZXJzIiwiaXRlbXMiLCJpbnB1dHMiLCJvdXRwdXRzIiwic3RhdGVfbXV0YWJpbGl0eSIsImtpbmQiLCJ2YXJpYW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/abis/abi.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(app-pages-browser)/./node_modules/next/dist/api/app-dynamic.js\");\n/* harmony import */ var _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @starknet-react/core */ \"(app-pages-browser)/./node_modules/@starknet-react/core/dist/index.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! starknet */ \"(app-pages-browser)/./node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var _abis_abi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../abis/abi */ \"(app-pages-browser)/./src/abis/abi.ts\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./src/lib/utils.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst WalletBar = (0,next_dynamic__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(()=>__webpack_require__.e(/*! import() */ \"_app-pages-browser_src_components_WalletBar_tsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../components/WalletBar */ \"(app-pages-browser)/./src/components/WalletBar.tsx\")), {\n    loadableGenerated: {\n        modules: [\n            \"app/page.tsx -> \" + \"../components/WalletBar\"\n        ]\n    },\n    ssr: false\n});\n_c = WalletBar;\nconst Page = ()=>{\n    _s();\n    // Step 1 --> Read the latest block -- Start\n    const { data: blockNumberData, isLoading: blockNumberIsLoading, isError: blockNumberIsError } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useBlockNumber)({\n        blockIdentifier: \"latest\"\n    });\n    const workshopEnds = 580000;\n    // Step 1 --> Read the latest block -- End\n    // Step 2 --> Read your balance -- Start\n    const { address: userAddress } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useAccount)();\n    const { isLoading: balanceIsLoading, isError: balanceIsError, error: balanceError, data: balanceData } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useBalance)({\n        address: userAddress,\n        watch: true\n    });\n    // Step 2 --> Read your balance -- End\n    // Step 3 --> Read from a contract -- Start\n    const contractAddress = \"0x02072db323bc380ab601bad94eea12ed249af69a35aa945deb99950455ee31f5\";\n    const { data: readData, refetch: dataRefetch, isError: readIsError, isLoading: readIsLoading, error: readError } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useReadContract)({\n        functionName: \"get_balance\",\n        args: [],\n        abi: _abis_abi__WEBPACK_IMPORTED_MODULE_5__.ABI,\n        address: contractAddress,\n        watch: true,\n        refetchInterval: 1000\n    });\n    // Step 3 --> Read from a contract -- End\n    // Step 4 --> Write to a contract -- Start\n    const [amount, setAmount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const handleSubmit = async (event)=>{\n        event.preventDefault();\n        console.log(\"Form submitted with amount \", amount);\n        writeAsync();\n    };\n    const typedABI = _abis_abi__WEBPACK_IMPORTED_MODULE_5__.ABI;\n    const { contract } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useContract)({\n        abi: typedABI,\n        address: contractAddress\n    });\n    const calls = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!userAddress || !contract) return [];\n        const safeAmount = amount || 0;\n        return [\n            contract.populate(\"increase_balance\", [\n                safeAmount\n            ])\n        ];\n    }, [\n        contract,\n        userAddress,\n        amount\n    ]);\n    const { send: writeAsync, data: writeData, isPending: writeIsPending } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useSendTransaction)({\n        calls\n    });\n    const { data: waitData, status: waitStatus, isLoading: waitIsLoading, isError: waitIsError, error: waitError } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useTransactionReceipt)({\n        hash: writeData === null || writeData === void 0 ? void 0 : writeData.transaction_hash,\n        watch: true\n    });\n    const handleAmountChange = (event)=>{\n        const value = event.target.value;\n        setAmount(value === \"\" ? \"\" : Number(value));\n    };\n    const LoadingState = (param)=>{\n        let { message } = param;\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex items-center space-x-2\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"animate-spin\",\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                        className: \"h-5 w-5 text-gray-800\",\n                        xmlns: \"http://www.w3.org/2000/svg\",\n                        fill: \"none\",\n                        viewBox: \"0 0 24 24\",\n                        stroke: \"currentColor\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                            strokeLinecap: \"round\",\n                            strokeLinejoin: \"round\",\n                            strokeWidth: 2,\n                            d: \"M12 6v6m0 0v6m0-6h6m-6 0H6\"\n                        }, void 0, false, {\n                            fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                            lineNumber: 79,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                        lineNumber: 78,\n                        columnNumber: 9\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                    lineNumber: 77,\n                    columnNumber: 7\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    children: message\n                }, void 0, false, {\n                    fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                    lineNumber: 82,\n                    columnNumber: 7\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n            lineNumber: 76,\n            columnNumber: 5\n        }, undefined);\n    };\n    const buttonContent = ()=>{\n        if (writeIsPending) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(LoadingState, {\n                message: \"Send...\"\n            }, void 0, false, {\n                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                lineNumber: 87,\n                columnNumber: 14\n            }, undefined);\n        }\n        if (waitIsLoading) {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(LoadingState, {\n                message: \"Waiting for confirmation...\"\n            }, void 0, false, {\n                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                lineNumber: 91,\n                columnNumber: 14\n            }, undefined);\n        }\n        if (waitStatus === \"error\") {\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(LoadingState, {\n                message: \"Transaction rejected...\"\n            }, void 0, false, {\n                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                lineNumber: 95,\n                columnNumber: 14\n            }, undefined);\n        }\n        if (waitStatus === \"success\") {\n            return \"Transaction confirmed\";\n        }\n        return \"Send\";\n    };\n    // Step 4 --> Write to a contract -- End\n    // Step 5 --> Reset balance -- Start\n    const resetBalanceCall = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!contract) return undefined;\n        try {\n            return contract.populate(\"reset_balance\");\n        } catch (error) {\n            console.error(\"Error populating reset_balance call:\", error);\n            return undefined;\n        }\n    }, [\n        contract\n    ]);\n    const { send: resetBalance, isPending: resetIsPending, data: resetData } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useSendTransaction)({\n        calls: resetBalanceCall ? [\n            resetBalanceCall\n        ] : []\n    });\n    const provider = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new starknet__WEBPACK_IMPORTED_MODULE_4__.RpcProvider({\n            nodeUrl: process.env.NEXT_PUBLIC_RPC_URL\n        }), []);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const lastCheckedBlockRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const { data: blockNumber } = (0,_starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useBlockNumber)({\n        refetchInterval: 3000\n    });\n    const checkForEvents = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (contract, currentBlockNumber)=>{\n        if (currentBlockNumber <= lastCheckedBlockRef.current) {\n            return; // No new blocks, skip checking for events\n        }\n        try {\n            // Fetch events only for the new blocks\n            const fromBlock = lastCheckedBlockRef.current + 1;\n            const fetchedEvents = await provider.getEvents({\n                address: contract.address,\n                from_block: {\n                    block_number: fromBlock\n                },\n                to_block: {\n                    block_number: currentBlockNumber\n                },\n                chunk_size: 500\n            });\n            if (fetchedEvents && fetchedEvents.events) {\n                setEvents((prevEvents)=>[\n                        ...prevEvents,\n                        ...fetchedEvents.events\n                    ]);\n            }\n            lastCheckedBlockRef.current = currentBlockNumber;\n        } catch (error) {\n            console.error(\"Error checking for events:\", error);\n        }\n    }, [\n        provider\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (contract && blockNumber) {\n            checkForEvents(contract, blockNumber);\n        }\n    }, [\n        contract,\n        blockNumber,\n        checkForEvents\n    ]);\n    const lastFiveEvents = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return [\n            ...events\n        ].reverse().slice(0, 5);\n    }, [\n        events\n    ]);\n    // Step 6 --> Get events from a contract -- End\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-dark p-4 flex flex-col\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-3xl font-bold text-center mb-6\",\n                children: \"Intellectual Property @ Starknet\"\n            }, void 0, false, {\n                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                lineNumber: 171,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-wrap justify-center gap-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full max-w-md space-y-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-xl font-bold mb-2\",\n                                        children: \"Wallet Connection\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 177,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(WalletBar, {}, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 178,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                lineNumber: 176,\n                                columnNumber: 11\n                            }, undefined),\n                            !blockNumberIsLoading && !blockNumberIsError && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 border-black border \".concat(blockNumberData < workshopEnds ? \"bg-green-500\" : \"bg-red-500\"),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-lg font-bold mb-2\",\n                                        children: \"Read the Blockchain\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 184,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: [\n                                            \"Current Block: \",\n                                            blockNumberData\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 185,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: blockNumberData < workshopEnds ? \"Workshop is live\" : \"Workshop has ended\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 186,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                lineNumber: 183,\n                                columnNumber: 13\n                            }, undefined),\n                            !balanceIsLoading && !balanceIsError && userAddress && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 \",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-lg font-bold mb-2\",\n                                        children: \"Your Balance\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 198,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: [\n                                            \"Symbol: \",\n                                            balanceData === null || balanceData === void 0 ? void 0 : balanceData.symbol\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 199,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: [\n                                            \"Balance: \",\n                                            Number(balanceData === null || balanceData === void 0 ? void 0 : balanceData.formatted).toFixed(4)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 200,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                lineNumber: 197,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 \",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-lg font-bold mb-2\",\n                                        children: \"Reset Balance\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 212,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: ()=>resetBalance(),\n                                        disabled: resetIsPending || !resetBalanceCall || !userAddress,\n                                        className: \"mt-2 font-regular py-2 px-4 bg-blue-300 hover:bg-blue-500 disabled:bg-gray-300 disabled:cursor-not-allowed\",\n                                        children: resetIsPending ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(LoadingState, {\n                                            message: \"Resetting...\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                            lineNumber: 218,\n                                            columnNumber: 33\n                                        }, undefined) : \"Reset Balance\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 213,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    (resetData === null || resetData === void 0 ? void 0 : resetData.transaction_hash) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"mt-2 text-sm\",\n                                        children: [\n                                            \"Transaction sent: \",\n                                            resetData.transaction_hash\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 221,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                lineNumber: 211,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                        lineNumber: 175,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-full max-w-md space-y-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 \",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-lg font-bold mb-2\",\n                                        children: \"Contract Balance\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 247,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: [\n                                            \"Balance: \",\n                                            readData === null || readData === void 0 ? void 0 : readData.toString()\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 248,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        onClick: ()=>dataRefetch(),\n                                        className: \"mt-2 font-regular py-1 px-3 bg-blue-300 hover:bg-blue-500\",\n                                        children: \"Refresh\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 249,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                lineNumber: 246,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                                onSubmit: handleSubmit,\n                                className: \"p-4\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-lg font-bold mb-2\",\n                                        children: \"Write to Contract\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 270,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        htmlFor: \"amount\",\n                                        className: \"block text-sm font-medium text-gray-700\",\n                                        children: \"Amount:\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 271,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"number\",\n                                        id: \"amount\",\n                                        value: amount,\n                                        onChange: handleAmountChange,\n                                        className: \"block w-full px-3 py-2 text-sm leading-6 border-black focus:outline-none focus:border-yellow-300 black-border-p\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 272,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        type: \"submit\",\n                                        className: \"mt-3 font-regular py-2 px-4 bg-blue-300 hover:bg-blue-500 disabled:bg-gray-300 disabled:cursor-not-allowed\",\n                                        disabled: !userAddress || writeIsPending,\n                                        children: buttonContent()\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 279,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    (writeData === null || writeData === void 0 ? void 0 : writeData.transaction_hash) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"https://sepolia.voyager.online/tx/\".concat(writeData === null || writeData === void 0 ? void 0 : writeData.transaction_hash),\n                                        target: \"_blank\",\n                                        className: \"block mt-2 text-blue-500 hover:text-blue-700 underline\",\n                                        rel: \"noreferrer\",\n                                        children: \"Check TX on Sepolia\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 287,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                lineNumber: 269,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 \",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                        className: \"text-lg font-bold mb-2\",\n                                        children: [\n                                            \"Contract Events (\",\n                                            events.length,\n                                            \")\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 324,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"overflow-x-auto\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                                            className: \"w-full border-collapse\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"thead\", {\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                                className: \"border-b border-gray-300 text-left p-2 font-semibold\",\n                                                                children: \"Sender\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                                lineNumber: 331,\n                                                                columnNumber: 21\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                                className: \"border-b border-gray-300 text-right p-2 font-semibold\",\n                                                                children: \"Added\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                                lineNumber: 332,\n                                                                columnNumber: 21\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                                className: \"border-b border-gray-300 text-right p-2 font-semibold\",\n                                                                children: \"New Balance\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                                lineNumber: 333,\n                                                                columnNumber: 21\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                        lineNumber: 330,\n                                                        columnNumber: 19\n                                                    }, undefined)\n                                                }, void 0, false, {\n                                                    fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                    lineNumber: 329,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tbody\", {\n                                                    children: lastFiveEvents.map((event, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                                            className: index % 2 === 0 ? \"bg-gray-50\" : \"\",\n                                                            children: [\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                                    className: \"border-b border-gray-200 p-2\",\n                                                                    children: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_6__.shortenAddress)(event.keys[1])\n                                                                }, void 0, false, {\n                                                                    fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                                    lineNumber: 339,\n                                                                    columnNumber: 23\n                                                                }, undefined),\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                                    className: \"border-b border-gray-200 p-2 text-right\",\n                                                                    children: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_6__.formatAmount)(event.data[0])\n                                                                }, void 0, false, {\n                                                                    fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                                    lineNumber: 340,\n                                                                    columnNumber: 23\n                                                                }, undefined),\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                                    className: \"border-b border-gray-200 p-2 text-right\",\n                                                                    children: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_6__.formatAmount)(event.data[2])\n                                                                }, void 0, false, {\n                                                                    fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                                    lineNumber: 341,\n                                                                    columnNumber: 23\n                                                                }, undefined)\n                                                            ]\n                                                        }, index, true, {\n                                                            fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                            lineNumber: 338,\n                                                            columnNumber: 21\n                                                        }, undefined))\n                                                }, void 0, false, {\n                                                    fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                                    lineNumber: 336,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                            lineNumber: 328,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                        lineNumber: 327,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                                lineNumber: 323,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                        lineNumber: 243,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n                lineNumber: 173,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/pedrorosalba/mediolano-dapp/web/src/app/page.tsx\",\n        lineNumber: 170,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Page, \"VthsTeVPSPL2cMDwO8uC9A3Ce90=\", false, function() {\n    return [\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useBlockNumber,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useAccount,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useBalance,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useReadContract,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useContract,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useSendTransaction,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useTransactionReceipt,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useSendTransaction,\n        _starknet_react_core__WEBPACK_IMPORTED_MODULE_3__.useBlockNumber\n    ];\n});\n_c1 = Page;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Page);\nvar _c, _c1;\n$RefreshReg$(_c, \"WalletBar\");\n$RefreshReg$(_c1, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQzhFO0FBQzNDO0FBQ29IO0FBQ3pGO0FBQzVCO0FBRXlCO0FBRTNELE1BQU1pQixZQUFZWix3REFBT0EsQ0FBQyxJQUFNLGlPQUFPOzs7Ozs7SUFBOEJhLEtBQUs7O0tBQXBFRDtBQUNOLE1BQU1FLE9BQVc7O0lBRWYsNENBQTRDO0lBQzVDLE1BQU0sRUFBRUMsTUFBTUMsZUFBZSxFQUFFQyxXQUFXQyxvQkFBb0IsRUFBRUMsU0FBU0Msa0JBQWtCLEVBQUUsR0FBR2pCLG9FQUFjQSxDQUFDO1FBQzdHa0IsaUJBQWlCO0lBQ25CO0lBQ0EsTUFBTUMsZUFBZTtJQUNyQiwwQ0FBMEM7SUFFMUMsd0NBQXdDO0lBQ3hDLE1BQU0sRUFBRUMsU0FBU0MsV0FBVyxFQUFFLEdBQUd2QixnRUFBVUE7SUFDM0MsTUFBTSxFQUFFZ0IsV0FBV1EsZ0JBQWdCLEVBQUVOLFNBQVNPLGNBQWMsRUFBRUMsT0FBT0MsWUFBWSxFQUFFYixNQUFNYyxXQUFXLEVBQUUsR0FBRzNCLGdFQUFVQSxDQUFDO1FBQ2xIcUIsU0FBU0M7UUFDVE0sT0FBTztJQUNUO0lBQ0Esc0NBQXNDO0lBRXRDLDJDQUEyQztJQUMzQyxNQUFNQyxrQkFBa0I7SUFDeEIsTUFBTSxFQUFFaEIsTUFBTWlCLFFBQVEsRUFBRUMsU0FBU0MsV0FBVyxFQUFFZixTQUFTZ0IsV0FBVyxFQUFFbEIsV0FBV21CLGFBQWEsRUFBRVQsT0FBT1UsU0FBUyxFQUFFLEdBQUdoQyxxRUFBZUEsQ0FBQztRQUNqSWlDLGNBQWM7UUFDZEMsTUFBTSxFQUFFO1FBQ1JDLEtBQUsvQiwwQ0FBR0E7UUFDUmMsU0FBU1E7UUFDVEQsT0FBTztRQUNQVyxpQkFBaUI7SUFDbkI7SUFDQSx5Q0FBeUM7SUFFekMsMENBQTBDO0lBQzFDLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHNUMsK0NBQVFBLENBQWM7SUFDbEQsTUFBTTZDLGVBQWUsT0FBT0M7UUFDMUJBLE1BQU1DLGNBQWM7UUFDcEJDLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JOO1FBQzNDTztJQUNGO0lBQ0EsTUFBTUMsV0FBV3pDLDBDQUFHQTtJQUNwQixNQUFNLEVBQUUwQyxRQUFRLEVBQUUsR0FBRy9DLGlFQUFXQSxDQUFDO1FBQy9Cb0MsS0FBS1U7UUFDTDNCLFNBQVNRO0lBQ1g7SUFDQSxNQUFNcUIsUUFBUXZELDhDQUFPQSxDQUFDO1FBQ3BCLElBQUksQ0FBQzJCLGVBQWUsQ0FBQzJCLFVBQVUsT0FBTyxFQUFFO1FBQ3hDLE1BQU1FLGFBQWFYLFVBQVU7UUFDN0IsT0FBTztZQUFDUyxTQUFTRyxRQUFRLENBQUMsb0JBQW9CO2dCQUFDRDthQUFXO1NBQUU7SUFDOUQsR0FBRztRQUFDRjtRQUFVM0I7UUFBYWtCO0tBQU87SUFDbEMsTUFBTSxFQUNKYSxNQUFNTixVQUFVLEVBQ2hCbEMsTUFBTXlDLFNBQVMsRUFDZkMsV0FBV0MsY0FBYyxFQUMxQixHQUFHcEQsd0VBQWtCQSxDQUFDO1FBQ3JCOEM7SUFDRjtJQUNBLE1BQU0sRUFDSnJDLE1BQU00QyxRQUFRLEVBQ2RDLFFBQVFDLFVBQVUsRUFDbEI1QyxXQUFXNkMsYUFBYSxFQUN4QjNDLFNBQVM0QyxXQUFXLEVBQ3BCcEMsT0FBT3FDLFNBQVMsRUFDakIsR0FBR3pELDJFQUFxQkEsQ0FBQztRQUFFMEQsSUFBSSxFQUFFVCxzQkFBQUEsZ0NBQUFBLFVBQVdVLGdCQUFnQjtRQUFFcEMsT0FBTztJQUFLO0lBQzNFLE1BQU1xQyxxQkFBcUIsQ0FBQ3RCO1FBQzFCLE1BQU11QixRQUFRdkIsTUFBTXdCLE1BQU0sQ0FBQ0QsS0FBSztRQUNoQ3pCLFVBQVV5QixVQUFVLEtBQUssS0FBS0UsT0FBT0Y7SUFDdkM7SUFDQSxNQUFNRyxlQUFlO1lBQUMsRUFBRUMsT0FBTyxFQUF1Qjs2QkFDcEQsOERBQUNDO1lBQUlDLFdBQVU7OzhCQUNiLDhEQUFDRDtvQkFBSUMsV0FBVTs4QkFDYiw0RUFBQ0M7d0JBQUlELFdBQVU7d0JBQXdCRSxPQUFNO3dCQUE2QkMsTUFBSzt3QkFBT0MsU0FBUTt3QkFBWUMsUUFBTztrQ0FDL0csNEVBQUNDOzRCQUFLQyxlQUFjOzRCQUFRQyxnQkFBZTs0QkFBUUMsYUFBYTs0QkFBR0MsR0FBRTs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFHekUsOERBQUNDOzhCQUFNYjs7Ozs7Ozs7Ozs7OztJQUdYLE1BQU1jLGdCQUFnQjtRQUNwQixJQUFJNUIsZ0JBQWdCO1lBQ2xCLHFCQUFPLDhEQUFDYTtnQkFBYUMsU0FBUTs7Ozs7O1FBQy9CO1FBRUEsSUFBSVYsZUFBZTtZQUNqQixxQkFBTyw4REFBQ1M7Z0JBQWFDLFNBQVE7Ozs7OztRQUMvQjtRQUVBLElBQUlYLGVBQWUsU0FBUztZQUMxQixxQkFBTyw4REFBQ1U7Z0JBQWFDLFNBQVE7Ozs7OztRQUMvQjtRQUVBLElBQUlYLGVBQWUsV0FBVztZQUM1QixPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFDQSx3Q0FBd0M7SUFFeEMsb0NBQW9DO0lBQ3BDLE1BQU0wQixtQkFBbUIxRiw4Q0FBT0EsQ0FBQztRQUMvQixJQUFJLENBQUNzRCxVQUFVLE9BQU9xQztRQUN0QixJQUFJO1lBQ0YsT0FBT3JDLFNBQVNHLFFBQVEsQ0FBQztRQUMzQixFQUFFLE9BQU8zQixPQUFPO1lBQ2RvQixRQUFRcEIsS0FBSyxDQUFDLHdDQUF3Q0E7WUFDdEQsT0FBTzZEO1FBQ1Q7SUFDRixHQUFHO1FBQUNyQztLQUFTO0lBQ2IsTUFBTSxFQUNKSSxNQUFNa0MsWUFBWSxFQUNsQmhDLFdBQVdpQyxjQUFjLEVBQ3pCM0UsTUFBTTRFLFNBQVMsRUFDaEIsR0FBR3JGLHdFQUFrQkEsQ0FBQztRQUNyQjhDLE9BQU9tQyxtQkFBbUI7WUFBQ0E7U0FBaUIsR0FBRyxFQUFFO0lBQ25EO0lBU0EsTUFBTUssV0FBVy9GLDhDQUFPQSxDQUFDLElBQU0sSUFBSVcsaURBQVdBLENBQUM7WUFBRXFGLFNBQVNDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CO1FBQUMsSUFBSSxFQUFFO0lBQ2hHLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHbkcsK0NBQVFBLENBQWtCLEVBQUU7SUFDeEQsTUFBTW9HLHNCQUFzQnJHLDZDQUFNQSxDQUFDO0lBQ25DLE1BQU0sRUFBRWlCLE1BQU1xRixXQUFXLEVBQUUsR0FBR2pHLG9FQUFjQSxDQUFDO1FBQUVzQyxpQkFBaUI7SUFBSztJQUNyRSxNQUFNNEQsaUJBQWlCMUcsa0RBQVdBLENBQUMsT0FBT3dELFVBQW9CbUQ7UUFDNUQsSUFBSUEsc0JBQXNCSCxvQkFBb0JJLE9BQU8sRUFBRTtZQUNyRCxRQUFRLDBDQUEwQztRQUNwRDtRQUNBLElBQUk7WUFDRix1Q0FBdUM7WUFDdkMsTUFBTUMsWUFBWUwsb0JBQW9CSSxPQUFPLEdBQUc7WUFDaEQsTUFBTUUsZ0JBQWdCLE1BQU1iLFNBQVNjLFNBQVMsQ0FBQztnQkFDN0NuRixTQUFTNEIsU0FBUzVCLE9BQU87Z0JBQ3pCb0YsWUFBWTtvQkFBRUMsY0FBY0o7Z0JBQVU7Z0JBQ3RDSyxVQUFVO29CQUFFRCxjQUFjTjtnQkFBbUI7Z0JBQzdDUSxZQUFZO1lBQ2Q7WUFFQSxJQUFJTCxpQkFBaUJBLGNBQWNSLE1BQU0sRUFBRTtnQkFDekNDLFVBQVVhLENBQUFBLGFBQWM7MkJBQUlBOzJCQUFlTixjQUFjUixNQUFNO3FCQUFDO1lBQ2xFO1lBRUFFLG9CQUFvQkksT0FBTyxHQUFHRDtRQUNoQyxFQUFFLE9BQU8zRSxPQUFPO1lBQ2RvQixRQUFRcEIsS0FBSyxDQUFDLDhCQUE4QkE7UUFDOUM7SUFDRixHQUFHO1FBQUNpRTtLQUFTO0lBRWJoRyxnREFBU0EsQ0FBQztRQUNSLElBQUl1RCxZQUFZaUQsYUFBYTtZQUMzQkMsZUFBZWxELFVBQVVpRDtRQUMzQjtJQUNGLEdBQUc7UUFBQ2pEO1FBQVVpRDtRQUFhQztLQUFlO0lBQzFDLE1BQU1XLGlCQUFpQm5ILDhDQUFPQSxDQUFDO1FBQzdCLE9BQU87ZUFBSW9HO1NBQU8sQ0FBQ2dCLE9BQU8sR0FBR0MsS0FBSyxDQUFDLEdBQUc7SUFDeEMsR0FBRztRQUFDakI7S0FBTztJQUNYLCtDQUErQztJQUUvQyxxQkFDRSw4REFBQ3hCO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDeUM7Z0JBQUd6QyxXQUFVOzBCQUFzQzs7Ozs7OzBCQUVwRCw4REFBQ0Q7Z0JBQUlDLFdBQVU7O2tDQUViLDhEQUFDRDt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNEO2dDQUFJQyxXQUFVOztrREFDYiw4REFBQzBDO3dDQUFHMUMsV0FBVTtrREFBeUI7Ozs7OztrREFDdkMsOERBQUM5RDs7Ozs7Ozs7Ozs7NEJBSUYsQ0FBQ00sd0JBQXdCLENBQUNFLG9DQUN6Qiw4REFBQ3FEO2dDQUFJQyxXQUFXLDJCQUEyRixPQUFoRTFELGtCQUFtQk0sZUFBZSxpQkFBaUI7O2tEQUM1Riw4REFBQytGO3dDQUFHM0MsV0FBVTtrREFBeUI7Ozs7OztrREFDdkMsOERBQUM0Qzs7NENBQUU7NENBQWdCdEc7Ozs7Ozs7a0RBQ25CLDhEQUFDc0c7a0RBQUd0RyxrQkFBbUJNLGVBQWUscUJBQXFCOzs7Ozs7Ozs7Ozs7NEJBVTlELENBQUNHLG9CQUFvQixDQUFDQyxrQkFBa0JGLDZCQUN2Qyw4REFBQ2lEO2dDQUFJQyxXQUFVOztrREFDYiw4REFBQzJDO3dDQUFHM0MsV0FBVTtrREFBeUI7Ozs7OztrREFDdkMsOERBQUM0Qzs7NENBQUU7NENBQVN6Rix3QkFBQUEsa0NBQUFBLFlBQWEwRixNQUFNOzs7Ozs7O2tEQUMvQiw4REFBQ0Q7OzRDQUFFOzRDQUFVaEQsT0FBT3pDLHdCQUFBQSxrQ0FBQUEsWUFBYTJGLFNBQVMsRUFBRUMsT0FBTyxDQUFDOzs7Ozs7Ozs7Ozs7OzBDQVd4RCw4REFBQ2hEO2dDQUFJQyxXQUFVOztrREFDYiw4REFBQzJDO3dDQUFHM0MsV0FBVTtrREFBeUI7Ozs7OztrREFDdkMsOERBQUNnRDt3Q0FDQ0MsU0FBUyxJQUFNbEM7d0NBQ2ZtQyxVQUFVbEMsa0JBQWtCLENBQUNILG9CQUFvQixDQUFDL0Q7d0NBQ2xEa0QsV0FBVTtrREFFVGdCLCtCQUFpQiw4REFBQ25COzRDQUFhQyxTQUFROzs7Ozt3REFBb0I7Ozs7OztvQ0FFN0RtQixDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVd6QixnQkFBZ0IsbUJBQzFCLDhEQUFDb0Q7d0NBQUU1QyxXQUFVOzs0Q0FBZTs0Q0FDUGlCLFVBQVV6QixnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBcUJyRCw4REFBQ087d0JBQUlDLFdBQVU7OzBDQUdiLDhEQUFDRDtnQ0FBSUMsV0FBVTs7a0RBQ2IsOERBQUMyQzt3Q0FBRzNDLFdBQVU7a0RBQXlCOzs7Ozs7a0RBQ3ZDLDhEQUFDNEM7OzRDQUFFOzRDQUFVdEYscUJBQUFBLCtCQUFBQSxTQUFVNkYsUUFBUTs7Ozs7OztrREFDL0IsOERBQUNIO3dDQUNDQyxTQUFTLElBQU16Rjt3Q0FDZndDLFdBQVU7a0RBQ1g7Ozs7Ozs7Ozs7OzswQ0FpQkgsOERBQUNvRDtnQ0FBS0MsVUFBVW5GO2dDQUFjOEIsV0FBVTs7a0RBQ3RDLDhEQUFDMkM7d0NBQUczQyxXQUFVO2tEQUF5Qjs7Ozs7O2tEQUN2Qyw4REFBQ3NEO3dDQUFNQyxTQUFRO3dDQUFTdkQsV0FBVTtrREFBMEM7Ozs7OztrREFDNUUsOERBQUN3RDt3Q0FDQ0MsTUFBSzt3Q0FDTEMsSUFBRzt3Q0FDSGhFLE9BQU8xQjt3Q0FDUDJGLFVBQVVsRTt3Q0FDVk8sV0FBVTs7Ozs7O2tEQUVaLDhEQUFDZ0Q7d0NBQ0NTLE1BQUs7d0NBQ0x6RCxXQUFVO3dDQUNWa0QsVUFBVSxDQUFDcEcsZUFBZWtDO2tEQUV6QjRCOzs7Ozs7b0NBRUY5QixDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVdVLGdCQUFnQixtQkFDMUIsOERBQUNvRTt3Q0FDQ0MsTUFBTSxxQ0FBaUUsT0FBNUIvRSxzQkFBQUEsZ0NBQUFBLFVBQVdVLGdCQUFnQjt3Q0FDdEVHLFFBQU87d0NBQ1BLLFdBQVU7d0NBQ1Y4RCxLQUFJO2tEQUNMOzs7Ozs7Ozs7Ozs7MENBK0JMLDhEQUFDL0Q7Z0NBQUlDLFdBQVU7O2tEQUNiLDhEQUFDMkM7d0NBQUczQyxXQUFVOzs0Q0FBeUI7NENBQ25CdUIsT0FBT3dDLE1BQU07NENBQUM7Ozs7Ozs7a0RBRWxDLDhEQUFDaEU7d0NBQUlDLFdBQVU7a0RBQ2IsNEVBQUNnRTs0Q0FBTWhFLFdBQVU7OzhEQUNmLDhEQUFDaUU7OERBQ0MsNEVBQUNDOzswRUFDQyw4REFBQ0M7Z0VBQUduRSxXQUFVOzBFQUF1RDs7Ozs7OzBFQUNyRSw4REFBQ21FO2dFQUFHbkUsV0FBVTswRUFBd0Q7Ozs7OzswRUFDdEUsOERBQUNtRTtnRUFBR25FLFdBQVU7MEVBQXdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs4REFHMUUsOERBQUNvRTs4REFDRTlCLGVBQWUrQixHQUFHLENBQUMsQ0FBQ2xHLE9BQU9tRyxzQkFDMUIsOERBQUNKOzREQUFlbEUsV0FBV3NFLFFBQVEsTUFBTSxJQUFJLGVBQWU7OzhFQUMxRCw4REFBQ0M7b0VBQUd2RSxXQUFVOzhFQUFnQy9ELDBEQUFjQSxDQUFDa0MsTUFBTXFHLElBQUksQ0FBQyxFQUFFOzs7Ozs7OEVBQzFFLDhEQUFDRDtvRUFBR3ZFLFdBQVU7OEVBQTJDaEUsd0RBQVlBLENBQUNtQyxNQUFNOUIsSUFBSSxDQUFDLEVBQUU7Ozs7Ozs4RUFDbkYsOERBQUNrSTtvRUFBR3ZFLFdBQVU7OEVBQTJDaEUsd0RBQVlBLENBQUNtQyxNQUFNOUIsSUFBSSxDQUFDLEVBQUU7Ozs7Ozs7MkRBSDVFaUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDN0I7R0E5V01sSTs7UUFHNEZYLGdFQUFjQTtRQU83RUYsNERBQVVBO1FBQzhEQyw0REFBVUE7UUFRQUcsaUVBQWVBO1FBa0I3R0QsNkRBQVdBO1FBYTVCRSxvRUFBa0JBO1FBU2xCQyx1RUFBcUJBO1FBa0RyQkQsb0VBQWtCQTtRQWNRSCxnRUFBY0E7OztNQTNIeENXO0FBZ1hOLCtEQUFlQSxJQUFJQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvcGFnZS50c3g/ZjY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgeyBGQywgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYyc7XG5pbXBvcnQgeyB1c2VBY2NvdW50LCB1c2VCYWxhbmNlLCB1c2VCbG9ja051bWJlciwgdXNlQ29udHJhY3QsIHVzZVJlYWRDb250cmFjdCwgdXNlU2VuZFRyYW5zYWN0aW9uLCB1c2VUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICdAc3RhcmtuZXQtcmVhY3QvY29yZSc7XG5pbXBvcnQgeyBCbG9ja051bWJlciwgQ29udHJhY3QsIFJwY1Byb3ZpZGVyIH0gZnJvbSBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyBBQkkgfSBmcm9tIFwiLi4vYWJpcy9hYmlcIjtcbmltcG9ydCB7IHR5cGUgQWJpIH0gZnJvbSBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyBmb3JtYXRBbW91bnQsIHNob3J0ZW5BZGRyZXNzIH0gZnJvbSAnQC9saWIvdXRpbHMnO1xuXG5jb25zdCBXYWxsZXRCYXIgPSBkeW5hbWljKCgpID0+IGltcG9ydCgnLi4vY29tcG9uZW50cy9XYWxsZXRCYXInKSwgeyBzc3I6IGZhbHNlIH0pXG5jb25zdCBQYWdlOiBGQyA9ICgpID0+IHtcblxuICAvLyBTdGVwIDEgLS0+IFJlYWQgdGhlIGxhdGVzdCBibG9jayAtLSBTdGFydFxuICBjb25zdCB7IGRhdGE6IGJsb2NrTnVtYmVyRGF0YSwgaXNMb2FkaW5nOiBibG9ja051bWJlcklzTG9hZGluZywgaXNFcnJvcjogYmxvY2tOdW1iZXJJc0Vycm9yIH0gPSB1c2VCbG9ja051bWJlcih7XG4gICAgYmxvY2tJZGVudGlmaWVyOiAnbGF0ZXN0JyBhcyBCbG9ja051bWJlclxuICB9KTtcbiAgY29uc3Qgd29ya3Nob3BFbmRzID0gNTgwMDAwO1xuICAvLyBTdGVwIDEgLS0+IFJlYWQgdGhlIGxhdGVzdCBibG9jayAtLSBFbmRcblxuICAvLyBTdGVwIDIgLS0+IFJlYWQgeW91ciBiYWxhbmNlIC0tIFN0YXJ0XG4gIGNvbnN0IHsgYWRkcmVzczogdXNlckFkZHJlc3MgfSA9IHVzZUFjY291bnQoKTtcbiAgY29uc3QgeyBpc0xvYWRpbmc6IGJhbGFuY2VJc0xvYWRpbmcsIGlzRXJyb3I6IGJhbGFuY2VJc0Vycm9yLCBlcnJvcjogYmFsYW5jZUVycm9yLCBkYXRhOiBiYWxhbmNlRGF0YSB9ID0gdXNlQmFsYW5jZSh7XG4gICAgYWRkcmVzczogdXNlckFkZHJlc3MsXG4gICAgd2F0Y2g6IHRydWVcbiAgfSk7XG4gIC8vIFN0ZXAgMiAtLT4gUmVhZCB5b3VyIGJhbGFuY2UgLS0gRW5kXG5cbiAgLy8gU3RlcCAzIC0tPiBSZWFkIGZyb20gYSBjb250cmFjdCAtLSBTdGFydFxuICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBcIjB4MDIwNzJkYjMyM2JjMzgwYWI2MDFiYWQ5NGVlYTEyZWQyNDlhZjY5YTM1YWE5NDVkZWI5OTk1MDQ1NWVlMzFmNVwiO1xuICBjb25zdCB7IGRhdGE6IHJlYWREYXRhLCByZWZldGNoOiBkYXRhUmVmZXRjaCwgaXNFcnJvcjogcmVhZElzRXJyb3IsIGlzTG9hZGluZzogcmVhZElzTG9hZGluZywgZXJyb3I6IHJlYWRFcnJvciB9ID0gdXNlUmVhZENvbnRyYWN0KHtcbiAgICBmdW5jdGlvbk5hbWU6IFwiZ2V0X2JhbGFuY2VcIixcbiAgICBhcmdzOiBbXSxcbiAgICBhYmk6IEFCSSBhcyBBYmksXG4gICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgIHdhdGNoOiB0cnVlLFxuICAgIHJlZmV0Y2hJbnRlcnZhbDogMTAwMFxuICB9KTtcbiAgLy8gU3RlcCAzIC0tPiBSZWFkIGZyb20gYSBjb250cmFjdCAtLSBFbmRcblxuICAvLyBTdGVwIDQgLS0+IFdyaXRlIHRvIGEgY29udHJhY3QgLS0gU3RhcnRcbiAgY29uc3QgW2Ftb3VudCwgc2V0QW1vdW50XSA9IHVzZVN0YXRlPG51bWJlciB8ICcnPigwKTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKGV2ZW50OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc29sZS5sb2coXCJGb3JtIHN1Ym1pdHRlZCB3aXRoIGFtb3VudCBcIiwgYW1vdW50KTtcbiAgICB3cml0ZUFzeW5jKCk7XG4gIH07XG4gIGNvbnN0IHR5cGVkQUJJID0gQUJJIGFzIEFiaTtcbiAgY29uc3QgeyBjb250cmFjdCB9ID0gdXNlQ29udHJhY3Qoe1xuICAgIGFiaTogdHlwZWRBQkksXG4gICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICB9KTtcbiAgY29uc3QgY2FsbHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXVzZXJBZGRyZXNzIHx8ICFjb250cmFjdCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNhZmVBbW91bnQgPSBhbW91bnQgfHwgMDtcbiAgICByZXR1cm4gW2NvbnRyYWN0LnBvcHVsYXRlKFwiaW5jcmVhc2VfYmFsYW5jZVwiLCBbc2FmZUFtb3VudF0pXTtcbiAgfSwgW2NvbnRyYWN0LCB1c2VyQWRkcmVzcywgYW1vdW50XSk7XG4gIGNvbnN0IHtcbiAgICBzZW5kOiB3cml0ZUFzeW5jLFxuICAgIGRhdGE6IHdyaXRlRGF0YSxcbiAgICBpc1BlbmRpbmc6IHdyaXRlSXNQZW5kaW5nLFxuICB9ID0gdXNlU2VuZFRyYW5zYWN0aW9uKHtcbiAgICBjYWxscyxcbiAgfSk7XG4gIGNvbnN0IHtcbiAgICBkYXRhOiB3YWl0RGF0YSxcbiAgICBzdGF0dXM6IHdhaXRTdGF0dXMsXG4gICAgaXNMb2FkaW5nOiB3YWl0SXNMb2FkaW5nLFxuICAgIGlzRXJyb3I6IHdhaXRJc0Vycm9yLFxuICAgIGVycm9yOiB3YWl0RXJyb3JcbiAgfSA9IHVzZVRyYW5zYWN0aW9uUmVjZWlwdCh7IGhhc2g6IHdyaXRlRGF0YT8udHJhbnNhY3Rpb25faGFzaCwgd2F0Y2g6IHRydWUgfSlcbiAgY29uc3QgaGFuZGxlQW1vdW50Q2hhbmdlID0gKGV2ZW50OiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgIHNldEFtb3VudCh2YWx1ZSA9PT0gJycgPyAnJyA6IE51bWJlcih2YWx1ZSkpO1xuICB9O1xuICBjb25zdCBMb2FkaW5nU3RhdGUgPSAoeyBtZXNzYWdlIH06IHsgbWVzc2FnZTogc3RyaW5nIH0pID0+IChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXNwaW5cIj5cbiAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJoLTUgdy01IHRleHQtZ3JheS04MDBcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+XG4gICAgICAgICAgPHBhdGggc3Ryb2tlTGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZVdpZHRoPXsyfSBkPVwiTTEyIDZ2Nm0wIDB2Nm0wLTZoNm0tNiAwSDZcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvZGl2PlxuICAgICAgPHNwYW4+e21lc3NhZ2V9PC9zcGFuPlxuICAgIDwvZGl2PlxuICApO1xuICBjb25zdCBidXR0b25Db250ZW50ID0gKCkgPT4ge1xuICAgIGlmICh3cml0ZUlzUGVuZGluZykge1xuICAgICAgcmV0dXJuIDxMb2FkaW5nU3RhdGUgbWVzc2FnZT1cIlNlbmQuLi5cIiAvPjtcbiAgICB9XG5cbiAgICBpZiAod2FpdElzTG9hZGluZykge1xuICAgICAgcmV0dXJuIDxMb2FkaW5nU3RhdGUgbWVzc2FnZT1cIldhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbi4uLlwiIC8+O1xuICAgIH1cblxuICAgIGlmICh3YWl0U3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiA8TG9hZGluZ1N0YXRlIG1lc3NhZ2U9XCJUcmFuc2FjdGlvbiByZWplY3RlZC4uLlwiIC8+O1xuICAgIH1cblxuICAgIGlmICh3YWl0U3RhdHVzID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgcmV0dXJuIFwiVHJhbnNhY3Rpb24gY29uZmlybWVkXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiU2VuZFwiO1xuICB9O1xuICAvLyBTdGVwIDQgLS0+IFdyaXRlIHRvIGEgY29udHJhY3QgLS0gRW5kXG5cbiAgLy8gU3RlcCA1IC0tPiBSZXNldCBiYWxhbmNlIC0tIFN0YXJ0XG4gIGNvbnN0IHJlc2V0QmFsYW5jZUNhbGwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWNvbnRyYWN0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udHJhY3QucG9wdWxhdGUoXCJyZXNldF9iYWxhbmNlXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcG9wdWxhdGluZyByZXNldF9iYWxhbmNlIGNhbGw6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCBbY29udHJhY3RdKTtcbiAgY29uc3Qge1xuICAgIHNlbmQ6IHJlc2V0QmFsYW5jZSxcbiAgICBpc1BlbmRpbmc6IHJlc2V0SXNQZW5kaW5nLFxuICAgIGRhdGE6IHJlc2V0RGF0YSxcbiAgfSA9IHVzZVNlbmRUcmFuc2FjdGlvbih7XG4gICAgY2FsbHM6IHJlc2V0QmFsYW5jZUNhbGwgPyBbcmVzZXRCYWxhbmNlQ2FsbF0gOiBbXSxcbiAgfSk7XG4gIC8vIFN0ZXAgNSAtLT4gUmVzZXQgYmFsYW5jZSAtLSBFbmRcblxuICAvLyBTdGVwIDYgLS0+IEdldCBldmVudHMgZnJvbSBhIGNvbnRyYWN0IC0tIFN0YXJ0XG4gIHR5cGUgQ29udHJhY3RFdmVudCA9IHtcbiAgICBmcm9tX2FkZHJlc3M6IHN0cmluZztcbiAgICBrZXlzOiBzdHJpbmdbXTtcbiAgICBkYXRhOiBzdHJpbmdbXTtcbiAgfTtcbiAgY29uc3QgcHJvdmlkZXIgPSB1c2VNZW1vKCgpID0+IG5ldyBScGNQcm92aWRlcih7IG5vZGVVcmw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1JQQ19VUkwgfSksIFtdKTtcbiAgY29uc3QgW2V2ZW50cywgc2V0RXZlbnRzXSA9IHVzZVN0YXRlPENvbnRyYWN0RXZlbnRbXT4oW10pO1xuICBjb25zdCBsYXN0Q2hlY2tlZEJsb2NrUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCB7IGRhdGE6IGJsb2NrTnVtYmVyIH0gPSB1c2VCbG9ja051bWJlcih7IHJlZmV0Y2hJbnRlcnZhbDogMzAwMCB9KTtcbiAgY29uc3QgY2hlY2tGb3JFdmVudHMgPSB1c2VDYWxsYmFjayhhc3luYyAoY29udHJhY3Q6IENvbnRyYWN0LCBjdXJyZW50QmxvY2tOdW1iZXI6IG51bWJlcikgPT4ge1xuICAgIGlmIChjdXJyZW50QmxvY2tOdW1iZXIgPD0gbGFzdENoZWNrZWRCbG9ja1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47IC8vIE5vIG5ldyBibG9ja3MsIHNraXAgY2hlY2tpbmcgZm9yIGV2ZW50c1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gRmV0Y2ggZXZlbnRzIG9ubHkgZm9yIHRoZSBuZXcgYmxvY2tzXG4gICAgICBjb25zdCBmcm9tQmxvY2sgPSBsYXN0Q2hlY2tlZEJsb2NrUmVmLmN1cnJlbnQgKyAxO1xuICAgICAgY29uc3QgZmV0Y2hlZEV2ZW50cyA9IGF3YWl0IHByb3ZpZGVyLmdldEV2ZW50cyh7XG4gICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0LmFkZHJlc3MsXG4gICAgICAgIGZyb21fYmxvY2s6IHsgYmxvY2tfbnVtYmVyOiBmcm9tQmxvY2sgfSxcbiAgICAgICAgdG9fYmxvY2s6IHsgYmxvY2tfbnVtYmVyOiBjdXJyZW50QmxvY2tOdW1iZXIgfSxcbiAgICAgICAgY2h1bmtfc2l6ZTogNTAwLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmZXRjaGVkRXZlbnRzICYmIGZldGNoZWRFdmVudHMuZXZlbnRzKSB7XG4gICAgICAgIHNldEV2ZW50cyhwcmV2RXZlbnRzID0+IFsuLi5wcmV2RXZlbnRzLCAuLi5mZXRjaGVkRXZlbnRzLmV2ZW50c10pO1xuICAgICAgfVxuXG4gICAgICBsYXN0Q2hlY2tlZEJsb2NrUmVmLmN1cnJlbnQgPSBjdXJyZW50QmxvY2tOdW1iZXI7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGZvciBldmVudHM6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW3Byb3ZpZGVyXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29udHJhY3QgJiYgYmxvY2tOdW1iZXIpIHtcbiAgICAgIGNoZWNrRm9yRXZlbnRzKGNvbnRyYWN0LCBibG9ja051bWJlcik7XG4gICAgfVxuICB9LCBbY29udHJhY3QsIGJsb2NrTnVtYmVyLCBjaGVja0ZvckV2ZW50c10pO1xuICBjb25zdCBsYXN0Rml2ZUV2ZW50cyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBbLi4uZXZlbnRzXS5yZXZlcnNlKCkuc2xpY2UoMCwgNSk7XG4gIH0sIFtldmVudHNdKTtcbiAgLy8gU3RlcCA2IC0tPiBHZXQgZXZlbnRzIGZyb20gYSBjb250cmFjdCAtLSBFbmRcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIGJnLWRhcmsgcC00IGZsZXggZmxleC1jb2xcIj5cbiAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgdGV4dC1jZW50ZXIgbWItNlwiPkludGVsbGVjdHVhbCBQcm9wZXJ0eSBAIFN0YXJrbmV0PC9oMT5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBqdXN0aWZ5LWNlbnRlciBnYXAtNFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1heC13LW1kIHNwYWNlLXktNFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC00XCI+XG4gICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LWJvbGQgbWItMlwiPldhbGxldCBDb25uZWN0aW9uPC9oMj5cbiAgICAgICAgICAgIDxXYWxsZXRCYXIgLz5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBTdGVwIDEgLS0+IFJlYWQgdGhlIGxhdGVzdCBibG9jayAtLSBTdGFydCAqL31cbiAgICAgICAgICB7IWJsb2NrTnVtYmVySXNMb2FkaW5nICYmICFibG9ja051bWJlcklzRXJyb3IgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2BwLTQgYm9yZGVyLWJsYWNrIGJvcmRlciAke2Jsb2NrTnVtYmVyRGF0YSEgPCB3b3Jrc2hvcEVuZHMgPyBcImJnLWdyZWVuLTUwMFwiIDogXCJiZy1yZWQtNTAwXCJ9YH0+XG4gICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+UmVhZCB0aGUgQmxvY2tjaGFpbjwvaDM+XG4gICAgICAgICAgICAgIDxwPkN1cnJlbnQgQmxvY2s6IHtibG9ja051bWJlckRhdGF9PC9wPlxuICAgICAgICAgICAgICA8cD57YmxvY2tOdW1iZXJEYXRhISA8IHdvcmtzaG9wRW5kcyA/IFwiV29ya3Nob3AgaXMgbGl2ZVwiIDogXCJXb3Jrc2hvcCBoYXMgZW5kZWRcIn08L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICAgIHsvKiA8ZGl2IGNsYXNzTmFtZT17YHAtNCBib3JkZXItYmxhY2sgYm9yZGVyYH0+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlJlYWQgdGhlIEJsb2NrY2hhaW48L2gzPlxuICAgICAgICAgICAgPHA+Q3VycmVudCBCbG9jazogMDwvcD5cbiAgICAgICAgICA8L2Rpdj4gKi99XG4gICAgICAgICAgey8qIFN0ZXAgMSAtLT4gUmVhZCB0aGUgbGF0ZXN0IGJsb2NrIC0tIEVuZCAqL31cblxuICAgICAgICAgIHsvKiBTdGVwIDIgLS0+IFJlYWQgeW91ciBiYWxhbmNlIC0tIFN0YXJ0ICovfVxuICAgICAgICAgIHshYmFsYW5jZUlzTG9hZGluZyAmJiAhYmFsYW5jZUlzRXJyb3IgJiYgdXNlckFkZHJlc3MgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgXCI+XG4gICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+WW91ciBCYWxhbmNlPC9oMz5cbiAgICAgICAgICAgICAgPHA+U3ltYm9sOiB7YmFsYW5jZURhdGE/LnN5bWJvbH08L3A+XG4gICAgICAgICAgICAgIDxwPkJhbGFuY2U6IHtOdW1iZXIoYmFsYW5jZURhdGE/LmZvcm1hdHRlZCkudG9GaXhlZCg0KX08L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICAgIHsvKiA8ZGl2IGNsYXNzTmFtZT1cInAtNCBcIj5cbiAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yXCI+WW91ciBCYWxhbmNlPC9oMz5cbiAgICAgICAgICAgIDxwPlN5bWJvbDogWFlaPC9wPlxuICAgICAgICAgICAgPHA+QmFsYW5jZTogMTAwPC9wPlxuICAgICAgICAgIDwvZGl2PiAqL31cbiAgICAgICAgICB7LyogU3RlcCAyIC0tPiBSZWFkIHlvdXIgYmFsYW5jZSAtLSBFbmQgKi99XG5cbiAgICAgICAgICB7LyogU3RlcCA1IC0tPiBSZXNldCBiYWxhbmNlIGJ5IG93bmVyIG9ubHkgLS0gU3RhcnQgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgXCI+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlJlc2V0IEJhbGFuY2U8L2gzPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByZXNldEJhbGFuY2UoKX1cbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e3Jlc2V0SXNQZW5kaW5nIHx8ICFyZXNldEJhbGFuY2VDYWxsIHx8ICF1c2VyQWRkcmVzc31cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMiBmb250LXJlZ3VsYXIgcHktMiBweC00IGJnLWJsdWUtMzAwIGhvdmVyOmJnLWJsdWUtNTAwIGRpc2FibGVkOmJnLWdyYXktMzAwIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtyZXNldElzUGVuZGluZyA/IDxMb2FkaW5nU3RhdGUgbWVzc2FnZT1cIlJlc2V0dGluZy4uLlwiIC8+IDogXCJSZXNldCBCYWxhbmNlXCJ9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIHtyZXNldERhdGE/LnRyYW5zYWN0aW9uX2hhc2ggJiYgKFxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtdC0yIHRleHQtc21cIj5cbiAgICAgICAgICAgICAgICBUcmFuc2FjdGlvbiBzZW50OiB7cmVzZXREYXRhLnRyYW5zYWN0aW9uX2hhc2h9XG4gICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgey8qIDxkaXYgY2xhc3NOYW1lPVwicC00IFwiPlxuICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5SZXNldCBCYWxhbmNlPC9oMz5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gY29uc29sZS5sb2coXCJSZXNldHRpbmcuLi5cIil9XG4gICAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMiBmb250LXJlZ3VsYXIgcHktMiBweC00IGJnLWJsdWUtMzAwIGhvdmVyOmJnLWJsdWUtNTAwIGRpc2FibGVkOmJnLWdyYXktMzAwIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFJlc2V0IEJhbGFuY2VcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtMiB0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgIFRyYW5zYWN0aW9uIHNlbnQ6IHVybFxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgIDwvZGl2PiAqL31cbiAgICAgICAgICB7LyogU3RlcCA1IC0tPiBSZXNldCBiYWxhbmNlIGJ5IG93bmVyIG9ubHkgLS0gRW5kICovfVxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1heC13LW1kIHNwYWNlLXktNFwiPlxuXG4gICAgICAgICAgey8qIFN0ZXAgMyAtLT4gUmVhZCBmcm9tIGEgY29udHJhY3QgLS0gU3RhcnQgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgXCI+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPkNvbnRyYWN0IEJhbGFuY2U8L2gzPlxuICAgICAgICAgICAgPHA+QmFsYW5jZToge3JlYWREYXRhPy50b1N0cmluZygpfTwvcD5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZGF0YVJlZmV0Y2goKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMiBmb250LXJlZ3VsYXIgcHktMSBweC0zIGJnLWJsdWUtMzAwIGhvdmVyOmJnLWJsdWUtNTAwXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgUmVmcmVzaFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgey8qIDxkaXYgY2xhc3NOYW1lPVwicC00IFwiPlxuICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5Db250cmFjdCBCYWxhbmNlPC9oMz5cbiAgICAgICAgICAgIDxwPkJhbGFuY2U6IDA8L3A+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGNvbnNvbGUubG9nKFwiUmVmcmVzaGluZy4uLlwiKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMiBmb250LXJlZ3VsYXIgcHktMSBweC0zIGJnLWJsdWUtMzAwIGhvdmVyOmJnLWJsdWUtNTAwXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgUmVmcmVzaFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9kaXY+ICovfVxuICAgICAgICAgIHsvKiBTdGVwIDMgLS0+IFJlYWQgZnJvbSBhIGNvbnRyYWN0IC0tIEVuZCAqL31cblxuICAgICAgICAgIHsvKiBTdGVwIDQgLS0+IFdyaXRlIHRvIGEgY29udHJhY3QgLS0gU3RhcnQgKi99XG4gICAgICAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH0gY2xhc3NOYW1lPVwicC00XCI+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPldyaXRlIHRvIENvbnRyYWN0PC9oMz5cbiAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiYW1vdW50XCIgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNzAwXCI+QW1vdW50OjwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICAgIGlkPVwiYW1vdW50XCJcbiAgICAgICAgICAgICAgdmFsdWU9e2Ftb3VudH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUFtb3VudENoYW5nZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmxvY2sgdy1mdWxsIHB4LTMgcHktMiB0ZXh0LXNtIGxlYWRpbmctNiBib3JkZXItYmxhY2sgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOmJvcmRlci15ZWxsb3ctMzAwIGJsYWNrLWJvcmRlci1wXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIGZvbnQtcmVndWxhciBweS0yIHB4LTQgYmctYmx1ZS0zMDAgaG92ZXI6YmctYmx1ZS01MDAgZGlzYWJsZWQ6YmctZ3JheS0zMDAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkXCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9eyF1c2VyQWRkcmVzcyB8fCB3cml0ZUlzUGVuZGluZ31cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge2J1dHRvbkNvbnRlbnQoKX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAge3dyaXRlRGF0YT8udHJhbnNhY3Rpb25faGFzaCAmJiAoXG4gICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgaHJlZj17YGh0dHBzOi8vc2Vwb2xpYS52b3lhZ2VyLm9ubGluZS90eC8ke3dyaXRlRGF0YT8udHJhbnNhY3Rpb25faGFzaH1gfVxuICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmxvY2sgbXQtMiB0ZXh0LWJsdWUtNTAwIGhvdmVyOnRleHQtYmx1ZS03MDAgdW5kZXJsaW5lXCJcbiAgICAgICAgICAgICAgICByZWw9XCJub3JlZmVycmVyXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENoZWNrIFRYIG9uIFNlcG9saWFcbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgey8qIDxmb3JtIGNsYXNzTmFtZT1cImJnLXdoaXRlIHAtNCBib3JkZXItYmxhY2sgYm9yZGVyXCI+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPldyaXRlIHRvIENvbnRyYWN0PC9oMz5cbiAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiYW1vdW50XCIgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNzAwXCI+QW1vdW50OjwvbGFiZWw+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICAgIGlkPVwiYW1vdW50XCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmxvY2sgdy1mdWxsIHB4LTMgcHktMiB0ZXh0LXNtIGxlYWRpbmctNiBib3JkZXItYmxhY2sgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOmJvcmRlci15ZWxsb3ctMzAwIGJsYWNrLWJvcmRlci1wXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIGZvbnQtcmVndWxhciBweS0yIHB4LTQgYmctYmx1ZS0zMDAgaG92ZXI6YmctYmx1ZS01MDAgZGlzYWJsZWQ6YmctZ3JheS0zMDAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgU2VuZFxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBocmVmPXtgaHR0cHM6Ly9zZXBvbGlhLnZveWFnZXIub25saW5lL3R4L2B9XG4gICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJsb2NrIG10LTIgdGV4dC1ibHVlLTUwMCBob3Zlcjp0ZXh0LWJsdWUtNzAwIHVuZGVybGluZVwiXG4gICAgICAgICAgICAgIHJlbD1cIm5vcmVmZXJyZXJcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDaGVjayBUWCBvbiBTZXBvbGlhXG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPC9mb3JtPiAqL31cbiAgICAgICAgICB7LyogU3RlcCA0IC0tPiBXcml0ZSB0byBhIGNvbnRyYWN0IC0tIEVuZCAqL31cblxuICAgICAgICAgIHsvKiBTdGVwIDYgLS0+IEdldCBldmVudHMgZnJvbSBhIGNvbnRyYWN0IC0tIFN0YXJ0ICovfVxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC00IFwiPlxuICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIG1iLTJcIj5cbiAgICAgICAgICAgICAgQ29udHJhY3QgRXZlbnRzICh7ZXZlbnRzLmxlbmd0aH0pXG4gICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJvdmVyZmxvdy14LWF1dG9cIj5cbiAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInctZnVsbCBib3JkZXItY29sbGFwc2VcIj5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJib3JkZXItYiBib3JkZXItZ3JheS0zMDAgdGV4dC1sZWZ0IHAtMiBmb250LXNlbWlib2xkXCI+U2VuZGVyPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT1cImJvcmRlci1iIGJvcmRlci1ncmF5LTMwMCB0ZXh0LXJpZ2h0IHAtMiBmb250LXNlbWlib2xkXCI+QWRkZWQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwiYm9yZGVyLWIgYm9yZGVyLWdyYXktMzAwIHRleHQtcmlnaHQgcC0yIGZvbnQtc2VtaWJvbGRcIj5OZXcgQmFsYW5jZTwvdGg+XG4gICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAge2xhc3RGaXZlRXZlbnRzLm1hcCgoZXZlbnQsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDx0ciBrZXk9e2luZGV4fSBjbGFzc05hbWU9e2luZGV4ICUgMiA9PT0gMCA/ICdiZy1ncmF5LTUwJyA6ICcnfT5cbiAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwiYm9yZGVyLWIgYm9yZGVyLWdyYXktMjAwIHAtMlwiPntzaG9ydGVuQWRkcmVzcyhldmVudC5rZXlzWzFdKX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJib3JkZXItYiBib3JkZXItZ3JheS0yMDAgcC0yIHRleHQtcmlnaHRcIj57Zm9ybWF0QW1vdW50KGV2ZW50LmRhdGFbMF0pfTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cImJvcmRlci1iIGJvcmRlci1ncmF5LTIwMCBwLTIgdGV4dC1yaWdodFwiPntmb3JtYXRBbW91bnQoZXZlbnQuZGF0YVsyXSl9PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7LyogPGRpdiBjbGFzc05hbWU9XCJwLTQgXCI+XG4gICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMlwiPlxuICAgICAgICAgICAgICBDb250cmFjdCBFdmVudHMgKFgpXG4gICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJvdmVyZmxvdy14LWF1dG9cIj5cbiAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInctZnVsbCBib3JkZXItY29sbGFwc2VcIj5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJib3JkZXItYiBib3JkZXItZ3JheS0zMDAgdGV4dC1sZWZ0IHAtMiBmb250LXNlbWlib2xkXCI+U2VuZGVyPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzTmFtZT1cImJvcmRlci1iIGJvcmRlci1ncmF5LTMwMCB0ZXh0LXJpZ2h0IHAtMiBmb250LXNlbWlib2xkXCI+QWRkZWQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwiYm9yZGVyLWIgYm9yZGVyLWdyYXktMzAwIHRleHQtcmlnaHQgcC0yIGZvbnQtc2VtaWJvbGRcIj5OZXcgQmFsYW5jZTwvdGg+XG4gICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgPHRyIGtleT17MH0+XG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJib3JkZXItYiBib3JkZXItZ3JheS0yMDAgcC0yXCI+MHg8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwiYm9yZGVyLWIgYm9yZGVyLWdyYXktMjAwIHAtMiB0ZXh0LXJpZ2h0XCI+MTwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJib3JkZXItYiBib3JkZXItZ3JheS0yMDAgcC0yIHRleHQtcmlnaHRcIj4xPC90ZD5cbiAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PiAqL31cbiAgICAgICAgICB7LyogU3RlcCA2IC0tPiBHZXQgZXZlbnRzIGZyb20gYSBjb250cmFjdCAtLSBFbmQgKi99XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2RpdiA+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQYWdlOyJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImR5bmFtaWMiLCJ1c2VBY2NvdW50IiwidXNlQmFsYW5jZSIsInVzZUJsb2NrTnVtYmVyIiwidXNlQ29udHJhY3QiLCJ1c2VSZWFkQ29udHJhY3QiLCJ1c2VTZW5kVHJhbnNhY3Rpb24iLCJ1c2VUcmFuc2FjdGlvblJlY2VpcHQiLCJScGNQcm92aWRlciIsIkFCSSIsImZvcm1hdEFtb3VudCIsInNob3J0ZW5BZGRyZXNzIiwiV2FsbGV0QmFyIiwic3NyIiwiUGFnZSIsImRhdGEiLCJibG9ja051bWJlckRhdGEiLCJpc0xvYWRpbmciLCJibG9ja051bWJlcklzTG9hZGluZyIsImlzRXJyb3IiLCJibG9ja051bWJlcklzRXJyb3IiLCJibG9ja0lkZW50aWZpZXIiLCJ3b3Jrc2hvcEVuZHMiLCJhZGRyZXNzIiwidXNlckFkZHJlc3MiLCJiYWxhbmNlSXNMb2FkaW5nIiwiYmFsYW5jZUlzRXJyb3IiLCJlcnJvciIsImJhbGFuY2VFcnJvciIsImJhbGFuY2VEYXRhIiwid2F0Y2giLCJjb250cmFjdEFkZHJlc3MiLCJyZWFkRGF0YSIsInJlZmV0Y2giLCJkYXRhUmVmZXRjaCIsInJlYWRJc0Vycm9yIiwicmVhZElzTG9hZGluZyIsInJlYWRFcnJvciIsImZ1bmN0aW9uTmFtZSIsImFyZ3MiLCJhYmkiLCJyZWZldGNoSW50ZXJ2YWwiLCJhbW91bnQiLCJzZXRBbW91bnQiLCJoYW5kbGVTdWJtaXQiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiY29uc29sZSIsImxvZyIsIndyaXRlQXN5bmMiLCJ0eXBlZEFCSSIsImNvbnRyYWN0IiwiY2FsbHMiLCJzYWZlQW1vdW50IiwicG9wdWxhdGUiLCJzZW5kIiwid3JpdGVEYXRhIiwiaXNQZW5kaW5nIiwid3JpdGVJc1BlbmRpbmciLCJ3YWl0RGF0YSIsInN0YXR1cyIsIndhaXRTdGF0dXMiLCJ3YWl0SXNMb2FkaW5nIiwid2FpdElzRXJyb3IiLCJ3YWl0RXJyb3IiLCJoYXNoIiwidHJhbnNhY3Rpb25faGFzaCIsImhhbmRsZUFtb3VudENoYW5nZSIsInZhbHVlIiwidGFyZ2V0IiwiTnVtYmVyIiwiTG9hZGluZ1N0YXRlIiwibWVzc2FnZSIsImRpdiIsImNsYXNzTmFtZSIsInN2ZyIsInhtbG5zIiwiZmlsbCIsInZpZXdCb3giLCJzdHJva2UiLCJwYXRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3Ryb2tlV2lkdGgiLCJkIiwic3BhbiIsImJ1dHRvbkNvbnRlbnQiLCJyZXNldEJhbGFuY2VDYWxsIiwidW5kZWZpbmVkIiwicmVzZXRCYWxhbmNlIiwicmVzZXRJc1BlbmRpbmciLCJyZXNldERhdGEiLCJwcm92aWRlciIsIm5vZGVVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfUlBDX1VSTCIsImV2ZW50cyIsInNldEV2ZW50cyIsImxhc3RDaGVja2VkQmxvY2tSZWYiLCJibG9ja051bWJlciIsImNoZWNrRm9yRXZlbnRzIiwiY3VycmVudEJsb2NrTnVtYmVyIiwiY3VycmVudCIsImZyb21CbG9jayIsImZldGNoZWRFdmVudHMiLCJnZXRFdmVudHMiLCJmcm9tX2Jsb2NrIiwiYmxvY2tfbnVtYmVyIiwidG9fYmxvY2siLCJjaHVua19zaXplIiwicHJldkV2ZW50cyIsImxhc3RGaXZlRXZlbnRzIiwicmV2ZXJzZSIsInNsaWNlIiwiaDEiLCJoMiIsImgzIiwicCIsInN5bWJvbCIsImZvcm1hdHRlZCIsInRvRml4ZWQiLCJidXR0b24iLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJ0b1N0cmluZyIsImZvcm0iLCJvblN1Ym1pdCIsImxhYmVsIiwiaHRtbEZvciIsImlucHV0IiwidHlwZSIsImlkIiwib25DaGFuZ2UiLCJhIiwiaHJlZiIsInJlbCIsImxlbmd0aCIsInRhYmxlIiwidGhlYWQiLCJ0ciIsInRoIiwidGJvZHkiLCJtYXAiLCJpbmRleCIsInRkIiwia2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cn: function() { return /* binding */ cn; },\n/* harmony export */   formatAmount: function() { return /* binding */ formatAmount; },\n/* harmony export */   shortenAddress: function() { return /* binding */ shortenAddress; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ \"(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n// Helper function to shorten address\nconst shortenAddress = (address)=>{\n    return \"\".concat(address.slice(0, 6), \"...\").concat(address.slice(-4));\n};\n// Helper function to convert hex to decimal and format it\nconst formatAmount = (hex)=>{\n    const decimal = parseInt(hex, 16);\n    return decimal.toString();\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDSjtBQUVqQyxTQUFTRTtJQUFHO1FBQUdDLE9BQUgsdUJBQXVCOztJQUN4QyxPQUFPRix1REFBT0EsQ0FBQ0QsMENBQUlBLENBQUNHO0FBQ3RCO0FBR0EscUNBQXFDO0FBQzlCLE1BQU1DLGlCQUFpQixDQUFDQztJQUM3QixPQUFPLEdBQTRCQSxPQUF6QkEsUUFBUUMsS0FBSyxDQUFDLEdBQUcsSUFBRyxPQUF1QixPQUFsQkQsUUFBUUMsS0FBSyxDQUFDLENBQUM7QUFDcEQsRUFBRTtBQUVGLDBEQUEwRDtBQUNuRCxNQUFNQyxlQUFlLENBQUNDO0lBQzNCLE1BQU1DLFVBQVVDLFNBQVNGLEtBQUs7SUFDOUIsT0FBT0MsUUFBUUUsUUFBUTtBQUN6QixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvdXRpbHMudHM/N2MxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjbHN4LCB0eXBlIENsYXNzVmFsdWUgfSBmcm9tIFwiY2xzeFwiXG5pbXBvcnQgeyB0d01lcmdlIH0gZnJvbSBcInRhaWx3aW5kLW1lcmdlXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGNuKC4uLmlucHV0czogQ2xhc3NWYWx1ZVtdKSB7XG4gIHJldHVybiB0d01lcmdlKGNsc3goaW5wdXRzKSlcbn1cblxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2hvcnRlbiBhZGRyZXNzXG5leHBvcnQgY29uc3Qgc2hvcnRlbkFkZHJlc3MgPSAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBgJHthZGRyZXNzLnNsaWNlKDAsIDYpfS4uLiR7YWRkcmVzcy5zbGljZSgtNCl9YDtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IGhleCB0byBkZWNpbWFsIGFuZCBmb3JtYXQgaXRcbmV4cG9ydCBjb25zdCBmb3JtYXRBbW91bnQgPSAoaGV4OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgZGVjaW1hbCA9IHBhcnNlSW50KGhleCwgMTYpO1xuICByZXR1cm4gZGVjaW1hbC50b1N0cmluZygpO1xufTsiXSwibmFtZXMiOlsiY2xzeCIsInR3TWVyZ2UiLCJjbiIsImlucHV0cyIsInNob3J0ZW5BZGRyZXNzIiwiYWRkcmVzcyIsInNsaWNlIiwiZm9ybWF0QW1vdW50IiwiaGV4IiwiZGVjaW1hbCIsInBhcnNlSW50IiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8zMTU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/NTNhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDUDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyx3REFBSSxZQUFZLGdFQUFXO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ087QUFDUCw2QkFBNkIscUVBQVcsR0FBRywrQkFBK0I7QUFDMUUsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzP2IwMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNzRDtBQUNWO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWE7QUFDakIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzPzg1MTciXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0Y7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQyxJQUFJLGlEQUFNO0FBQ1Y7QUFDQSwyQ0FBMkMsc0RBQVc7QUFDdEQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixnREFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsR0FBRztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzPzA4ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFieXRlcywgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFudW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cywgZ290ICR7aX0gaW4gYXJyYXlgKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUoc2NhbGFycykpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNEJBQTRCO0FBQzVCLCtC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QUFvQyxPQUFPLDRCQUE0QixJQUFJO0FBQzNFLHVCQUF1QiwwREFBZSxRQUFRLDBEQUFlO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWUsc0JBQXNCLDBEQUFlO0FBQ3RFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/ZDdmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/poseidon.js":
/*!*************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/poseidon.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poseidon: function() { return /* binding */ poseidon; },\n/* harmony export */   splitConstants: function() { return /* binding */ splitConstants; },\n/* harmony export */   validateOpts: function() { return /* binding */ validateOpts; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Poseidon Hash: https://eprint.iacr.org/2019/458.pdf, https://www.poseidon-hash.info\n\nfunction validateOpts(opts) {\n    const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;\n    const { roundsFull, roundsPartial, sboxPower, t } = opts;\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(Fp);\n    for (const i of ['t', 'roundsFull', 'roundsPartial']) {\n        if (typeof opts[i] !== 'number' || !Number.isSafeInteger(opts[i]))\n            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);\n    }\n    // MDS is TxT matrix\n    if (!Array.isArray(mds) || mds.length !== t)\n        throw new Error('Poseidon: wrong MDS matrix');\n    const _mds = mds.map((mdsRow) => {\n        if (!Array.isArray(mdsRow) || mdsRow.length !== t)\n            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);\n        return mdsRow.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon MDS matrix value=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (rev !== undefined && typeof rev !== 'boolean')\n        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);\n    if (roundsFull % 2 !== 0)\n        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);\n    const rounds = roundsFull + roundsPartial;\n    if (!Array.isArray(rc) || rc.length !== rounds)\n        throw new Error('Poseidon: wrong round constants');\n    const roundConstants = rc.map((rc) => {\n        if (!Array.isArray(rc) || rc.length !== t)\n            throw new Error(`Poseidon wrong round constants: ${rc}`);\n        return rc.map((i) => {\n            if (typeof i !== 'bigint' || !Fp.isValid(i))\n                throw new Error(`Poseidon wrong round constant=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (!sboxPower || ![3, 5, 7].includes(sboxPower))\n        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);\n    const _sboxPower = BigInt(sboxPower);\n    let sboxFn = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow)(Fp, n, _sboxPower);\n    // Unwrapped sbox power for common cases (195->142μs)\n    if (sboxPower === 3)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);\n    else if (sboxPower === 5)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);\n    return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });\n}\nfunction splitConstants(rc, t) {\n    if (typeof t !== 'number')\n        throw new Error('poseidonSplitConstants: wrong t');\n    if (!Array.isArray(rc) || rc.length % t)\n        throw new Error('poseidonSplitConstants: wrong rc');\n    const res = [];\n    let tmp = [];\n    for (let i = 0; i < rc.length; i++) {\n        tmp.push(rc[i]);\n        if (tmp.length === t) {\n            res.push(tmp);\n            tmp = [];\n        }\n    }\n    return res;\n}\nfunction poseidon(opts) {\n    const _opts = validateOpts(opts);\n    const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;\n    const halfRoundsFull = _opts.roundsFull / 2;\n    const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;\n    const poseidonRound = (values, isFull, idx) => {\n        values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));\n        if (isFull)\n            values = values.map((i) => sboxFn(i));\n        else\n            values[partialIdx] = sboxFn(values[partialIdx]);\n        // Matrix multiplication\n        values = mds.map((i) => i.reduce((acc, i, j) => Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));\n        return values;\n    };\n    const poseidonHash = function poseidonHash(values) {\n        if (!Array.isArray(values) || values.length !== t)\n            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);\n        values = values.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);\n            return Fp.create(i);\n        });\n        let round = 0;\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        // Apply r_p partial rounds.\n        for (let i = 0; i < roundsPartial; i++)\n            values = poseidonRound(values, false, round++);\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        if (round !== rounds)\n            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);\n        return values;\n    };\n    // For verification in tests\n    poseidonHash.roundConstants = roundConstants;\n    return poseidonHash;\n}\n//# sourceMappingURL=poseidon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9wb3NlaWRvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNvRDtBQUM3QztBQUNQLFlBQVkseURBQXlEO0FBQ3JFLFlBQVksMENBQTBDO0FBQ3RELElBQUksMERBQWE7QUFDakI7QUFDQTtBQUNBLHVEQUF1RCxFQUFFLEdBQUcsU0FBUyxHQUFHLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHdFQUF3RSxJQUFJO0FBQzVFO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxHQUFHO0FBQ2xFO0FBQ0E7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBLHdCQUF3QixrREFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLDREQUE0RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLEVBQUU7QUFDL0Y7QUFDQTtBQUNBLHlEQUF5RCxHQUFHLEdBQUcsU0FBUztBQUN4RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsNEVBQTRFLE1BQU0sVUFBVSxPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9wb3NlaWRvbi5qcz8yZjBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFBvc2VpZG9uIEhhc2g6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTkvNDU4LnBkZiwgaHR0cHM6Ly93d3cucG9zZWlkb24taGFzaC5pbmZvXG5pbXBvcnQgeyBGcFBvdywgdmFsaWRhdGVGaWVsZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPcHRzKG9wdHMpIHtcbiAgICBjb25zdCB7IEZwLCBtZHMsIHJldmVyc2VQYXJ0aWFsUG93SWR4OiByZXYsIHJvdW5kQ29uc3RhbnRzOiByYyB9ID0gb3B0cztcbiAgICBjb25zdCB7IHJvdW5kc0Z1bGwsIHJvdW5kc1BhcnRpYWwsIHNib3hQb3dlciwgdCB9ID0gb3B0cztcbiAgICB2YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgWyd0JywgJ3JvdW5kc0Z1bGwnLCAncm91bmRzUGFydGlhbCddKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0c1tpXSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdHNbaV0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogaW52YWxpZCBwYXJhbSAke2l9PSR7b3B0c1tpXX0gKCR7dHlwZW9mIG9wdHNbaV19KWApO1xuICAgIH1cbiAgICAvLyBNRFMgaXMgVHhUIG1hdHJpeFxuICAgIGlmICghQXJyYXkuaXNBcnJheShtZHMpIHx8IG1kcy5sZW5ndGggIT09IHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zZWlkb246IHdyb25nIE1EUyBtYXRyaXgnKTtcbiAgICBjb25zdCBfbWRzID0gbWRzLm1hcCgobWRzUm93KSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZHNSb3cpIHx8IG1kc1Jvdy5sZW5ndGggIT09IHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIE1EUyBtYXRyaXggcm93OiAke21kc1Jvd31gKTtcbiAgICAgICAgcmV0dXJuIG1kc1Jvdy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiBNRFMgbWF0cml4IHZhbHVlPSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXYgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmV2ICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IGludmFsaWQgcGFyYW0gcmV2ZXJzZVBhcnRpYWxQb3dJZHg9JHtyZXZ9YCk7XG4gICAgaWYgKHJvdW5kc0Z1bGwgJSAyICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHJvdW5kc0Z1bGwgaXMgbm90IGV2ZW46ICR7cm91bmRzRnVsbH1gKTtcbiAgICBjb25zdCByb3VuZHMgPSByb3VuZHNGdWxsICsgcm91bmRzUGFydGlhbDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmMpIHx8IHJjLmxlbmd0aCAhPT0gcm91bmRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2VpZG9uOiB3cm9uZyByb3VuZCBjb25zdGFudHMnKTtcbiAgICBjb25zdCByb3VuZENvbnN0YW50cyA9IHJjLm1hcCgocmMpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJjKSB8fCByYy5sZW5ndGggIT09IHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHJvdW5kIGNvbnN0YW50czogJHtyY31gKTtcbiAgICAgICAgcmV0dXJuIHJjLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JyB8fCAhRnAuaXNWYWxpZChpKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uIHdyb25nIHJvdW5kIGNvbnN0YW50PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghc2JveFBvd2VyIHx8ICFbMywgNSwgN10uaW5jbHVkZXMoc2JveFBvd2VyKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiB3cm9uZyBzYm94UG93ZXI9JHtzYm94UG93ZXJ9YCk7XG4gICAgY29uc3QgX3Nib3hQb3dlciA9IEJpZ0ludChzYm94UG93ZXIpO1xuICAgIGxldCBzYm94Rm4gPSAobikgPT4gRnBQb3coRnAsIG4sIF9zYm94UG93ZXIpO1xuICAgIC8vIFVud3JhcHBlZCBzYm94IHBvd2VyIGZvciBjb21tb24gY2FzZXMgKDE5NS0+MTQyzrxzKVxuICAgIGlmIChzYm94UG93ZXIgPT09IDMpXG4gICAgICAgIHNib3hGbiA9IChuKSA9PiBGcC5tdWwoRnAuc3FyTihuKSwgbik7XG4gICAgZWxzZSBpZiAoc2JveFBvd2VyID09PSA1KVxuICAgICAgICBzYm94Rm4gPSAobikgPT4gRnAubXVsKEZwLnNxck4oRnAuc3FyTihuKSksIG4pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cywgcm91bmRzLCBzYm94Rm4sIHJvdW5kQ29uc3RhbnRzLCBtZHM6IF9tZHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRDb25zdGFudHMocmMsIHQpIHtcbiAgICBpZiAodHlwZW9mIHQgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2VpZG9uU3BsaXRDb25zdGFudHM6IHdyb25nIHQnKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmMpIHx8IHJjLmxlbmd0aCAlIHQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zZWlkb25TcGxpdENvbnN0YW50czogd3JvbmcgcmMnKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBsZXQgdG1wID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0bXAucHVzaChyY1tpXSk7XG4gICAgICAgIGlmICh0bXAubGVuZ3RoID09PSB0KSB7XG4gICAgICAgICAgICByZXMucHVzaCh0bXApO1xuICAgICAgICAgICAgdG1wID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbihvcHRzKSB7XG4gICAgY29uc3QgX29wdHMgPSB2YWxpZGF0ZU9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCwgbWRzLCByb3VuZENvbnN0YW50cywgcm91bmRzLCByb3VuZHNQYXJ0aWFsLCBzYm94Rm4sIHQgfSA9IF9vcHRzO1xuICAgIGNvbnN0IGhhbGZSb3VuZHNGdWxsID0gX29wdHMucm91bmRzRnVsbCAvIDI7XG4gICAgY29uc3QgcGFydGlhbElkeCA9IF9vcHRzLnJldmVyc2VQYXJ0aWFsUG93SWR4ID8gdCAtIDEgOiAwO1xuICAgIGNvbnN0IHBvc2VpZG9uUm91bmQgPSAodmFsdWVzLCBpc0Z1bGwsIGlkeCkgPT4ge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKChpLCBqKSA9PiBGcC5hZGQoaSwgcm91bmRDb25zdGFudHNbaWR4XVtqXSkpO1xuICAgICAgICBpZiAoaXNGdWxsKVxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSkgPT4gc2JveEZuKGkpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsdWVzW3BhcnRpYWxJZHhdID0gc2JveEZuKHZhbHVlc1twYXJ0aWFsSWR4XSk7XG4gICAgICAgIC8vIE1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgICAgICB2YWx1ZXMgPSBtZHMubWFwKChpKSA9PiBpLnJlZHVjZSgoYWNjLCBpLCBqKSA9PiBGcC5hZGQoYWNjLCBGcC5tdWxOKGksIHZhbHVlc1tqXSkpLCBGcC5aRVJPKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBjb25zdCBwb3NlaWRvbkhhc2ggPSBmdW5jdGlvbiBwb3NlaWRvbkhhc2godmFsdWVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGggIT09IHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiB3cm9uZyB2YWx1ZXMgKGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMgd2l0aCBsZW5ndGggJHt0fSlgKTtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiB3cm9uZyB2YWx1ZT0ke2l9ICgke3R5cGVvZiBpfSlgKTtcbiAgICAgICAgICAgIHJldHVybiBGcC5jcmVhdGUoaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcm91bmQgPSAwO1xuICAgICAgICAvLyBBcHBseSByX2YvMiBmdWxsIHJvdW5kcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYWxmUm91bmRzRnVsbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIHRydWUsIHJvdW5kKyspO1xuICAgICAgICAvLyBBcHBseSByX3AgcGFydGlhbCByb3VuZHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzUGFydGlhbDsgaSsrKVxuICAgICAgICAgICAgdmFsdWVzID0gcG9zZWlkb25Sb3VuZCh2YWx1ZXMsIGZhbHNlLCByb3VuZCsrKTtcbiAgICAgICAgLy8gQXBwbHkgcl9mLzIgZnVsbCByb3VuZHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFsZlJvdW5kc0Z1bGw7IGkrKylcbiAgICAgICAgICAgIHZhbHVlcyA9IHBvc2VpZG9uUm91bmQodmFsdWVzLCB0cnVlLCByb3VuZCsrKTtcbiAgICAgICAgaWYgKHJvdW5kICE9PSByb3VuZHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiB3cm9uZyBudW1iZXIgb2Ygcm91bmRzOiBsYXN0IHJvdW5kPSR7cm91bmR9LCB0b3RhbD0ke3JvdW5kc31gKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIC8vIEZvciB2ZXJpZmljYXRpb24gaW4gdGVzdHNcbiAgICBwb3NlaWRvbkhhc2gucm91bmRDb25zdGFudHMgPSByb3VuZENvbnN0YW50cztcbiAgICByZXR1cm4gcG9zZWlkb25IYXNoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9zZWlkb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/poseidon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: function() { return /* binding */ abytes; },\n/* harmony export */   bitGet: function() { return /* binding */ bitGet; },\n/* harmony export */   bitLen: function() { return /* binding */ bitLen; },\n/* harmony export */   bitMask: function() { return /* binding */ bitMask; },\n/* harmony export */   bitSet: function() { return /* binding */ bitSet; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   bytesToNumberBE: function() { return /* binding */ bytesToNumberBE; },\n/* harmony export */   bytesToNumberLE: function() { return /* binding */ bytesToNumberLE; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createHmacDrbg: function() { return /* binding */ createHmacDrbg; },\n/* harmony export */   ensureBytes: function() { return /* binding */ ensureBytes; },\n/* harmony export */   equalBytes: function() { return /* binding */ equalBytes; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   hexToNumber: function() { return /* binding */ hexToNumber; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   numberToBytesBE: function() { return /* binding */ numberToBytesBE; },\n/* harmony export */   numberToBytesLE: function() { return /* binding */ numberToBytesLE; },\n/* harmony export */   numberToHexUnpadded: function() { return /* binding */ numberToHexUnpadded; },\n/* harmony export */   numberToVarBytesBE: function() { return /* binding */ numberToVarBytesBE; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   validateObject: function() { return /* binding */ validateObject; }\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDTztBQUNQO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzPzk1Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDaUQ7QUFDYjtBQUNIO0FBQ1E7QUFDekM7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsUUFBUSx3Q0FBd0MsRUFBRSxzQ0FBRTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsUUFBUSw2Q0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLEtBQUssU0FBUztBQUMxQjtB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QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9iYjMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgeyB2YWxpZGF0ZUJhc2ljLCB3TkFGIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZykpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   schnorr: function() { return /* binding */ schnorr; },\n/* harmony export */   secp256k1: function() { return /* binding */ secp256k1; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUN3QztBQUNqQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBSyxxQ0FBcUMsZUFBZTtBQUM3RCxrQkFBa0IsNkRBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBTTtBQUMzQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDREQUFNLENBQUMsK0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlO0FBQ3ZDLG9CQUFvQix5REFBRztBQUN2QixvQkFBb0IseURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQVc7QUFDL0QsY0FBYywrREFBVztBQUN6QixZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsY0FBYywrREFBVywwQkFBMEI7QUFDbkQsMkJBQTJCLG1FQUFlLGlDQUFpQztBQUMzRSx3REFBd0Q7QUFDeEQsb0JBQW9CLG1FQUFlLFNBQVM7QUFDNUM7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSx1QkFBdUIsMkJBQTJCO0FBQzlELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFXO0FBQzNCLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLCtEQUFXO0FBQzNCO0FBQ0EseUJBQXlCLG1FQUFlLFFBQVEsd0JBQXdCO0FBQ3hFLGtCQUFrQixtRUFBZSx1QkFBdUIsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWUsd0JBQXdCLDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsc0NBQXNDLHNFQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLHdFQUFZO0FBQy9DLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcz9lZTdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVDdXJ2ZSB9IGZyb20gJy4vX3Nob3J0d191dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgRmllbGQsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KDcpLCAvLyBTZWVtIHRvIGJlIHJpZ2lkOiBiaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzVcbiAgICBGcCwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsMERBQTBELEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsK0RBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzPzdiNGQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIG5vdCAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLy8gY29waWVkIGZyb20gdXRpbHNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: function() { return /* binding */ Chi; },\n/* harmony export */   HashMD: function() { return /* binding */ HashMD; },\n/* harmony export */   Maj: function() { return /* binding */ Maj; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanM/YTgwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmV4cG9ydCBjb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuZXhwb3J0IGNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcz80ZjdiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzPzRhZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELHFDQUFxQywyQ0FBRztBQUN4QywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELGlDQUFpQywyQ0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzP2FhNjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1ELCBDaGksIE1haiB9IGZyb20gJy4vX21kLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZTpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   byteSwap: function() { return /* binding */ byteSwap; },\n/* harmony export */   byteSwap32: function() { return /* binding */ byteSwap32; },\n/* harmony export */   byteSwapIfBE: function() { return /* binding */ byteSwapIfBE; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotl: function() { return /* binding */ rotl; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDQztBQUMvQyxZQUFZLFVBQVU7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNUO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz8xOGNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCBieXRlU3dhcCA9ICh3b3JkKSA9PiAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4vLyBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm1cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBpc0xFID8gKG4pID0+IG4gOiAobikgPT4gYnl0ZVN3YXAobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsMERBQTBELEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsK0RBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzPzQ4NjMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIG5vdCAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLy8gY29waWVkIGZyb20gdXRpbHNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: function() { return /* binding */ Chi; },\n/* harmony export */   HashMD: function() { return /* binding */ HashMD; },\n/* harmony export */   Maj: function() { return /* binding */ Maj; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanM/ODg3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vKipcbiAqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbiAqL1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKlxuICogQ2hvaWNlOiBhID8gYiA6IGNcbiAqL1xuZXhwb3J0IGNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vKipcbiAqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWVcbiAqL1xuZXhwb3J0IGNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   add3H: function() { return /* binding */ add3H; },\n/* harmony export */   add3L: function() { return /* binding */ add3L; },\n/* harmony export */   add4H: function() { return /* binding */ add4H; },\n/* harmony export */   add4L: function() { return /* binding */ add4L; },\n/* harmony export */   add5H: function() { return /* binding */ add5H; },\n/* harmony export */   add5L: function() { return /* binding */ add5L; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   rotlBH: function() { return /* binding */ rotlBH; },\n/* harmony export */   rotlBL: function() { return /* binding */ rotlBL; },\n/* harmony export */   rotlSH: function() { return /* binding */ rotlSH; },\n/* harmony export */   rotlSL: function() { return /* binding */ rotlSL; },\n/* harmony export */   rotr32H: function() { return /* binding */ rotr32H; },\n/* harmony export */   rotr32L: function() { return /* binding */ rotr32L; },\n/* harmony export */   rotrBH: function() { return /* binding */ rotrBH; },\n/* harmony export */   rotrBL: function() { return /* binding */ rotrBL; },\n/* harmony export */   rotrSH: function() { return /* binding */ rotrSH; },\n/* harmony export */   rotrSL: function() { return /* binding */ rotrSL; },\n/* harmony export */   shrSH: function() { return /* binding */ shrSH; },\n/* harmony export */   shrSL: function() { return /* binding */ shrSL; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/MDRlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcz9iOTlhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA256: function() { return /* binding */ SHA256; },\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\n/**\n * SHA2-224 hash function\n */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMENBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxxQ0FBcUMsMkNBQUc7QUFDeEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxpQ0FBaUMsMkNBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz9lMmQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2hNRCwgQ2hpLCBNYWogfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGU6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5leHBvcnQgY2xhc3MgU0hBMjU2IGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: function() { return /* binding */ Keccak; },\n/* harmony export */   keccakP: function() { return /* binding */ keccakP; },\n/* harmony export */   keccak_224: function() { return /* binding */ keccak_224; },\n/* harmony export */   keccak_256: function() { return /* binding */ keccak_256; },\n/* harmony export */   keccak_384: function() { return /* binding */ keccak_384; },\n/* harmony export */   keccak_512: function() { return /* binding */ keccak_512; },\n/* harmony export */   sha3_224: function() { return /* binding */ sha3_224; },\n/* harmony export */   sha3_256: function() { return /* binding */ sha3_256; },\n/* harmony export */   sha3_384: function() { return /* binding */ sha3_384; },\n/* harmony export */   sha3_512: function() { return /* binding */ sha3_512; },\n/* harmony export */   shake128: function() { return /* binding */ shake128; },\n/* harmony export */   shake256: function() { return /* binding */ shake256; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RDtBQUNLO0FBQzhDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDhDQUFLO0FBQ3hEO0FBQ0EscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0QscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0Q7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwyQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBRztBQUMxQjtBQUNBO0FBQ0EsYUFBYSwyQ0FBSTtBQUNqQixZQUFZLHFEQUFVO0FBQ3RCO0FBQ0EsYUFBYSwyQ0FBSTtBQUNqQixZQUFZLHFEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQixrQkFBa0I7QUFDbEMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxpREFBSztBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQiw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwREFBZTtBQUNyRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQLGtEQUFrRCxxRUFBMEIsV0FBVztBQUNoRjtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanM/MDBjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBieXRlcywgZXhpc3RzLCBudW1iZXIsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHNwbGl0IH0gZnJvbSAnLi9fdTY0LmpzJztcbmltcG9ydCB7IEhhc2gsIHUzMiwgdG9CeXRlcywgd3JhcENvbnN0cnVjdG9yLCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cywgaXNMRSwgYnl0ZVN3YXAzMiwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTMgKGtlY2NhaykgaXMgYmFzZWQgb24gYSBuZXcgZGVzaWduOiBiYXNpY2FsbHksIHRoZSBpbnRlcm5hbCBzdGF0ZSBpcyBiaWdnZXIgdGhhbiBvdXRwdXQgc2l6ZS5cbi8vIEl0J3MgY2FsbGVkIGEgc3BvbmdlIGZ1bmN0aW9uLlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgU0hBM19QSSA9IFtdO1xuY29uc3QgU0hBM19ST1RMID0gW107XG5jb25zdCBfU0hBM19JT1RBID0gW107XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5jb25zdCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCSChoLCBsLCBzKSA6IHJvdGxTSChoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIG51bWJlcihvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYTMgc3VwcG9ydHMgb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24nKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICBieXRlU3dhcDMyKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIGlmICghaXNMRSlcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   byteSwap: function() { return /* binding */ byteSwap; },\n/* harmony export */   byteSwap32: function() { return /* binding */ byteSwap32; },\n/* harmony export */   byteSwapIfBE: function() { return /* binding */ byteSwapIfBE; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotl: function() { return /* binding */ rotl; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDQztBQUMvQyxZQUFZLFVBQVU7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNUO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/NTgwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5pbXBvcnQgeyBieXRlcyBhcyBhYnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gZXhwb3J0IHsgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBXZSBjYW4ndCByZXVzZSBpc0J5dGVzIGZyb20gX2Fzc2VydCwgYmVjYXVzZSBzb21laG93IHRoaXMgY2F1c2VzIGh1Z2UgcGVyZiBpc3N1ZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5leHBvcnQgY29uc3QgYnl0ZVN3YXBJZkJFID0gaXNMRSA/IChuKSA9PiBuIDogKG4pID0+IGJ5dGVTd2FwKG4pO1xuLy8gSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhieXRlc0xlbmd0aCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: function() { return /* binding */ assertNumber; },\n/* harmony export */   base16: function() { return /* binding */ base16; },\n/* harmony export */   base32: function() { return /* binding */ base32; },\n/* harmony export */   base32crockford: function() { return /* binding */ base32crockford; },\n/* harmony export */   base32hex: function() { return /* binding */ base32hex; },\n/* harmony export */   base32hexnopad: function() { return /* binding */ base32hexnopad; },\n/* harmony export */   base32nopad: function() { return /* binding */ base32nopad; },\n/* harmony export */   base58: function() { return /* binding */ base58; },\n/* harmony export */   base58check: function() { return /* binding */ base58check; },\n/* harmony export */   base58flickr: function() { return /* binding */ base58flickr; },\n/* harmony export */   base58xmr: function() { return /* binding */ base58xmr; },\n/* harmony export */   base58xrp: function() { return /* binding */ base58xrp; },\n/* harmony export */   base64: function() { return /* binding */ base64; },\n/* harmony export */   base64nopad: function() { return /* binding */ base64nopad; },\n/* harmony export */   base64url: function() { return /* binding */ base64url; },\n/* harmony export */   base64urlnopad: function() { return /* binding */ base64urlnopad; },\n/* harmony export */   bech32: function() { return /* binding */ bech32; },\n/* harmony export */   bech32m: function() { return /* binding */ bech32m; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   bytesToString: function() { return /* binding */ bytesToString; },\n/* harmony export */   createBase58check: function() { return /* binding */ createBase58check; },\n/* harmony export */   hex: function() { return /* binding */ hex; },\n/* harmony export */   str: function() { return /* binding */ str; },\n/* harmony export */   stringToBytes: function() { return /* binding */ stringToBytes; },\n/* harmony export */   utf8: function() { return /* binding */ utf8; },\n/* harmony export */   utils: function() { return /* binding */ utils; }\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32nopad = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32hexnopad = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = /* @__PURE__ */ genBech32('bech32');\nconst bech32m = /* @__PURE__ */ genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBLHdEQUF3RCxPQUFPLGNBQWMsU0FBUztBQUN0RjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LDBFQUEwRSxjQUFjO0FBQ3hGO0FBQ0EsbUZBQW1GLGFBQWE7QUFDaEc7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0EsMENBQTBDLGNBQWMsZ0JBQWdCLE1BQU07QUFDOUU7QUFDQTtBQUNBLGtCQUFrQixRQUFRLEdBQUcsNEJBQTRCLEVBQUUsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBLHdEQUF3RCxZQUFZLEdBQUcsSUFBSSxrQkFBa0IsTUFBTTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksY0FBYyxJQUFJO0FBQ3pFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnRUFBZ0UsVUFBVSxjQUFjLFNBQVM7QUFDakc7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCO0FBQzNCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcz8zNzVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXNcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpZCA9IChhKSA9PiBhO1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gYXJncy5tYXAoKHgpID0+IHguZW5jb2RlKS5yZWR1Y2VSaWdodCh3cmFwLCBpZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGFkIHN0cmluZ3MgYXJyYXkgc28gaXQgaGFzIGludGVnZXIgbnVtYmVyIG9mIGJpdHNcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbi8qKlxuICogU2xvdzogTyhuXjIpIHRpbWUgY29tcGxleGl0eVxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdW5kZWQpXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gLyogQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gLypAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbi8qKlxuICogSW1wbGVtZW50ZWQgd2l0aCBudW1iZXJzLCBiZWNhdXNlIEJpZ0ludCBpcyA1eCBzbG93ZXJcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDsgLy8gYml0d2lzZSBwb3NpdGlvbiBpbiBjdXJyZW50IGVsZW1lbnRcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTsgLy8gY2xlYW4gY2FycnksIG90aGVyd2lzZSBpdCB3aWxsIGNhdXNlIG92ZXJmbG93XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBJZiBib3RoIGJhc2VzIGFyZSBwb3dlciBvZiBzYW1lIG51bWJlciAobGlrZSBgMioqOCA8LT4gMioqNjRgKSxcbiAqIHRoZXJlIGlzIGEgbGluZWFyIGFsZ29yaXRobS4gRm9yIG5vdyB3ZSBoYXZlIGltcGxlbWVudGF0aW9uIGZvciBwb3dlci1vZi10d28gYmFzZXMgb25seS5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgY29udmVydFJhZGl4LCBjb252ZXJ0UmFkaXgyLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nLFxufTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgY29uc3QgYmFzZTE2ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMybm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4bm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmNyb2NrZm9yZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjRub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsbm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuLy8geG1yIHZlciBpcyBkb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuLy8gQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgYmFzZTU4KTtcbi8vIGxlZ2FjeSBleHBvcnQsIGJhZCBuYW1lXG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHByZWZpeCBsZW5ndGggJHtwcmVmaXgubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IGxvd2VyZWQubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGxvd2VyZWQuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbG93ZXJlZC5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShkYXRhKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghZGF0YS5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/lib/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@scure/starknet/lib/esm/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: function() { return /* binding */ CURVE; },\n/* harmony export */   Fp251: function() { return /* binding */ Fp251; },\n/* harmony export */   MAX_VALUE: function() { return /* binding */ MAX_VALUE; },\n/* harmony export */   ProjectivePoint: function() { return /* binding */ ProjectivePoint; },\n/* harmony export */   Signature: function() { return /* binding */ Signature; },\n/* harmony export */   _poseidonMDS: function() { return /* binding */ _poseidonMDS; },\n/* harmony export */   _starkCurve: function() { return /* binding */ _starkCurve; },\n/* harmony export */   computeHashOnElements: function() { return /* binding */ computeHashOnElements; },\n/* harmony export */   ethSigToPrivate: function() { return /* binding */ ethSigToPrivate; },\n/* harmony export */   getAccountPath: function() { return /* binding */ getAccountPath; },\n/* harmony export */   getPublicKey: function() { return /* binding */ getPublicKey; },\n/* harmony export */   getSharedSecret: function() { return /* binding */ getSharedSecret; },\n/* harmony export */   getStarkKey: function() { return /* binding */ getStarkKey; },\n/* harmony export */   grindKey: function() { return /* binding */ grindKey; },\n/* harmony export */   keccak: function() { return /* binding */ keccak; },\n/* harmony export */   pedersen: function() { return /* binding */ pedersen; },\n/* harmony export */   poseidonBasic: function() { return /* binding */ poseidonBasic; },\n/* harmony export */   poseidonCreate: function() { return /* binding */ poseidonCreate; },\n/* harmony export */   poseidonHash: function() { return /* binding */ poseidonHash; },\n/* harmony export */   poseidonHashFunc: function() { return /* binding */ poseidonHashFunc; },\n/* harmony export */   poseidonHashMany: function() { return /* binding */ poseidonHashMany; },\n/* harmony export */   poseidonHashSingle: function() { return /* binding */ poseidonHashSingle; },\n/* harmony export */   poseidonSmall: function() { return /* binding */ poseidonSmall; },\n/* harmony export */   sign: function() { return /* binding */ sign; },\n/* harmony export */   utils: function() { return /* binding */ utils; },\n/* harmony export */   verify: function() { return /* binding */ verify; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/_shortw_utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js\");\n\n\n\n\n\n\n\n\nconst CURVE_ORDER = BigInt('3618502788666131213697322783095070105526743751716087489154079457884512865583');\nconst MAX_VALUE = BigInt('0x800000000000000000000000000000000000000000000000000000000000000');\nconst nBitLength = 252;\nfunction bits2int(bytes) {\n    while (bytes[0] === 0)\n        bytes = bytes.subarray(1);\n    const delta = bytes.length * 8 - nBitLength;\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction hex0xToBytes(hex) {\n    if (typeof hex === 'string') {\n        hex = strip0x(hex);\n        if (hex.length & 1)\n            hex = '0' + hex;\n    }\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(hex);\n}\nconst curve = (0,_noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.weierstrass)({\n    a: BigInt(1),\n    b: BigInt('3141592653589793238462643383279502884197169399375105820974944592307816406665'),\n    Fp: (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt('0x800000000000011000000000000000000000000000000000000000000000001')),\n    n: CURVE_ORDER,\n    nBitLength,\n    Gx: BigInt('874739451078007766457464989774322083649278607533249481151382481072868806602'),\n    Gy: BigInt('152666792071518830868575557812948353041420400780739481342941381225525861407'),\n    h: BigInt(1),\n    lowS: false,\n    ...(0,_noble_curves_shortw_utils__WEBPACK_IMPORTED_MODULE_3__.getHash)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256),\n    bits2int,\n    bits2int_modN: (bytes) => {\n        const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes).toString(16);\n        if (hex.length === 63)\n            bytes = hex0xToBytes(hex + '0');\n        return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(bits2int(bytes), CURVE_ORDER);\n    },\n});\nconst _starkCurve = curve;\nfunction ensureBytes(hex) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.ensureBytes('', typeof hex === 'string' ? hex0xToBytes(hex) : hex);\n}\nfunction normPrivKey(privKey) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(ensureBytes(privKey)).padStart(64, '0');\n}\nfunction getPublicKey(privKey, isCompressed = false) {\n    return curve.getPublicKey(normPrivKey(privKey), isCompressed);\n}\nfunction getSharedSecret(privKeyA, pubKeyB) {\n    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);\n}\nfunction checkSignature(signature) {\n    const { r, s } = signature;\n    if (r < 0n || r >= MAX_VALUE)\n        throw new Error(`Signature.r should be [1, ${MAX_VALUE})`);\n    const w = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.invert)(s, CURVE_ORDER);\n    if (w < 0n || w >= MAX_VALUE)\n        throw new Error(`inv(Signature.s) should be [1, ${MAX_VALUE})`);\n}\nfunction checkMessage(msgHash) {\n    const bytes = ensureBytes(msgHash);\n    const num = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes);\n    if (num >= MAX_VALUE)\n        throw new Error(`msgHash should be [0, ${MAX_VALUE})`);\n    return bytes;\n}\nfunction sign(msgHash, privKey, opts) {\n    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);\n    checkSignature(sig);\n    return sig;\n}\nfunction verify(signature, msgHash, pubKey) {\n    if (!(signature instanceof Signature)) {\n        const bytes = ensureBytes(signature);\n        try {\n            signature = Signature.fromDER(bytes);\n        }\n        catch (derError) {\n            if (!(derError instanceof _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_1__.DER.Err))\n                throw derError;\n            signature = Signature.fromCompact(bytes);\n        }\n    }\n    checkSignature(signature);\n    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));\n}\nconst { CURVE, ProjectivePoint, Signature, utils } = curve;\n\nfunction extractX(bytes) {\n    const hex = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(bytes.subarray(1));\n    const stripped = hex.replace(/^0+/gm, '');\n    return `0x${stripped}`;\n}\nfunction strip0x(hex) {\n    return hex.replace(/^0x/i, '');\n}\nfunction grindKey(seed) {\n    const _seed = ensureBytes(seed);\n    const sha256mask = 2n ** 256n;\n    const limit = sha256mask - (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(sha256mask, CURVE_ORDER);\n    for (let i = 0;; i++) {\n        const key = sha256Num(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes(_seed, _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(BigInt(i))));\n        if (key < limit)\n            return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)(key, CURVE_ORDER).toString(16);\n        if (i === 100000)\n            throw new Error('grindKey is broken: tried 100k vals');\n    }\n}\nfunction getStarkKey(privateKey) {\n    return extractX(getPublicKey(privateKey, true));\n}\nfunction ethSigToPrivate(signature) {\n    signature = strip0x(signature);\n    if (signature.length !== 130)\n        throw new Error('Wrong ethereum signature');\n    return grindKey(signature.substring(0, 64));\n}\nconst MASK_31 = 2n ** 31n - 1n;\nconst int31 = (n) => Number(n & MASK_31);\nfunction getAccountPath(layer, application, ethereumAddress, index) {\n    const layerNum = int31(sha256Num(layer));\n    const applicationNum = int31(sha256Num(application));\n    const eth = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.hexToNumber(strip0x(ethereumAddress));\n    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;\n}\nconst PEDERSEN_POINTS = [\n    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),\n    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),\n    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),\n    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),\n    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n),\n];\nfunction pedersenPrecompute(p1, p2) {\n    const out = [];\n    let p = p1;\n    for (let i = 0; i < 248; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    p = p2;\n    for (let i = 0; i < 4; i++) {\n        out.push(p);\n        p = p.double();\n    }\n    return out;\n}\nconst PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);\nconst PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);\nfunction pedersenArg(arg) {\n    let value;\n    if (typeof arg === 'bigint') {\n        value = arg;\n    }\n    else if (typeof arg === 'number') {\n        if (!Number.isSafeInteger(arg))\n            throw new Error(`Invalid pedersenArg: ${arg}`);\n        value = BigInt(arg);\n    }\n    else {\n        value = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(ensureBytes(arg));\n    }\n    if (!(0n <= value && value < curve.CURVE.Fp.ORDER))\n        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);\n    return value;\n}\nfunction pedersenSingle(point, value, constants) {\n    let x = pedersenArg(value);\n    for (let j = 0; j < 252; j++) {\n        const pt = constants[j];\n        if (pt.equals(point))\n            throw new Error('Same point');\n        if ((x & 1n) !== 0n)\n            point = point.add(pt);\n        x >>= 1n;\n    }\n    return point;\n}\nfunction pedersen(x, y) {\n    let point = PEDERSEN_POINTS[0];\n    point = pedersenSingle(point, x, PEDERSEN_POINTS1);\n    point = pedersenSingle(point, y, PEDERSEN_POINTS2);\n    return extractX(point.toRawBytes(true));\n}\nconst computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));\nconst MASK_250 = _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bitMask(250);\nconst keccak = (data) => _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_5__.keccak_256)(data)) & MASK_250;\nconst sha256Num = (data) => _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(data));\nconst Fp251 = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.Field)(BigInt('3618502788666131213697322783095070105623107215331596699973092056135872020481'));\nfunction poseidonRoundConstant(Fp, name, idx) {\n    const val = Fp.fromBytes((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.utf8ToBytes)(`${name}${idx}`)));\n    return Fp.create(val);\n}\nfunction _poseidonMDS(Fp, name, m, attempt = 0) {\n    const x_values = [];\n    const y_values = [];\n    for (let i = 0; i < m; i++) {\n        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));\n        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));\n    }\n    if (new Set([...x_values, ...y_values]).size !== 2 * m)\n        throw new Error('X and Y values are not distinct');\n    return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));\n}\nconst MDS_SMALL = [\n    [3, 1, 1],\n    [1, -1, 1],\n    [1, 1, -2],\n].map((i) => i.map(BigInt));\nfunction poseidonBasic(opts, mds) {\n    (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.validateField)(opts.Fp);\n    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))\n        throw new Error(`Wrong poseidon opts: ${opts}`);\n    const m = opts.rate + opts.capacity;\n    const rounds = opts.roundsFull + opts.roundsPartial;\n    const roundConstants = [];\n    for (let i = 0; i < rounds; i++) {\n        const row = [];\n        for (let j = 0; j < m; j++)\n            row.push(poseidonRoundConstant(opts.Fp, 'Hades', m * i + j));\n        roundConstants.push(row);\n    }\n    const res = (0,_noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_7__.poseidon)({\n        ...opts,\n        t: m,\n        sboxPower: 3,\n        reversePartialPowIdx: true,\n        mds,\n        roundConstants,\n    });\n    res.m = m;\n    res.rate = opts.rate;\n    res.capacity = opts.capacity;\n    return res;\n}\nfunction poseidonCreate(opts, mdsAttempt = 0) {\n    const m = opts.rate + opts.capacity;\n    if (!Number.isSafeInteger(mdsAttempt))\n        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);\n    return poseidonBasic(opts, _poseidonMDS(opts.Fp, 'HadesMDS', m, mdsAttempt));\n}\nconst poseidonSmall = poseidonBasic({ Fp: Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);\nfunction poseidonHash(x, y, fn = poseidonSmall) {\n    return fn([x, y, 2n])[0];\n}\nfunction poseidonHashFunc(x, y, fn = poseidonSmall) {\n    return _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.numberToVarBytesBE(poseidonHash(_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(x), _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(y), fn));\n}\nfunction poseidonHashSingle(x, fn = poseidonSmall) {\n    return fn([x, 0n, 1n])[0];\n}\nfunction poseidonHashMany(values, fn = poseidonSmall) {\n    const { m, rate } = fn;\n    if (!Array.isArray(values))\n        throw new Error('bigint array expected in values');\n    const padded = Array.from(values);\n    padded.push(1n);\n    while (padded.length % rate !== 0)\n        padded.push(0n);\n    let state = new Array(m).fill(0n);\n    for (let i = 0; i < padded.length; i += rate) {\n        for (let j = 0; j < rate; j++)\n            state[j] += padded[i + j];\n        state = fn(state);\n    }\n    return state[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ0Y7QUFDSTtBQUNpQztBQUN4QjtBQUNXO0FBQ3BCO0FBQ0k7QUFDdEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUVBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ0EsY0FBYywrRUFBVztBQUN6QjtBQUNBO0FBQ0EsUUFBUSxxRUFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sbUVBQU8sQ0FBQyx3REFBTTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CLHlFQUFpQjtBQUNyQztBQUNBO0FBQ0EsZUFBZSxtRUFBRztBQUNsQixLQUFLO0FBQ0wsQ0FBQztBQUNNO0FBQ1A7QUFDQSxXQUFXLHFFQUFhO0FBQ3hCO0FBQ0E7QUFDQSxXQUFXLG9FQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxxREFBcUQsVUFBVTtBQUMvRCxjQUFjLHNFQUFNO0FBQ3BCO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlFQUFpQjtBQUNqQztBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUVBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJDQUEyQztBQUNDO0FBQ3BEO0FBQ0EsZ0JBQWdCLG9FQUFZO0FBQzVCO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwrQkFBK0IsbUVBQUc7QUFDbEMscUJBQXFCO0FBQ3JCLDhCQUE4QixxRUFBYSxRQUFRLDRFQUFvQjtBQUN2RTtBQUNBLG1CQUFtQixtRUFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IscUVBQWE7QUFDN0Isc0JBQXNCLFNBQVMsSUFBSSxlQUFlLElBQUksV0FBVyxJQUFJLGtCQUFrQixJQUFJLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5RUFBaUI7QUFDakM7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQkFBaUIsaUVBQVM7QUFDbkIseUJBQXlCLHlFQUFpQixDQUFDLDhEQUFVO0FBQzVELDRCQUE0Qix5RUFBaUIsQ0FBQyw0REFBTTtBQUM3QyxjQUFjLHFFQUFLO0FBQzFCO0FBQ0EsNkJBQTZCLDREQUFNLENBQUMsZ0VBQVcsSUFBSSxLQUFLLEVBQUUsSUFBSTtBQUM5RDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsbURBQW1ELEtBQUs7QUFDeEQsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksNkVBQWE7QUFDakI7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5RUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDTyxzQ0FBc0MsbUVBQW1FO0FBQ3pHO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsV0FBVyw0RUFBb0IsY0FBYyx5RUFBaUIsS0FBSyx5RUFBaUI7QUFDcEY7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L2xpYi9lc20vaW5kZXguanM/OTExNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCB2YWxpZGF0ZUZpZWxkLCBpbnZlcnQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuaW1wb3J0IHsgcG9zZWlkb24gfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzLCBERVIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzJztcbmltcG9ydCAqIGFzIHUgZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgeyBnZXRIYXNoIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzJztcbmNvbnN0IENVUlZFX09SREVSID0gQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NTI2NzQzNzUxNzE2MDg3NDg5MTU0MDc5NDU3ODg0NTEyODY1NTgzJyk7XG5leHBvcnQgY29uc3QgTUFYX1ZBTFVFID0gQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuY29uc3QgbkJpdExlbmd0aCA9IDI1MjtcbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgd2hpbGUgKGJ5dGVzWzBdID09PSAwKVxuICAgICAgICBieXRlcyA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIG5CaXRMZW5ndGg7XG4gICAgY29uc3QgbnVtID0gdS5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbn1cbmZ1bmN0aW9uIGhleDB4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gc3RyaXAweChoZXgpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgfVxuICAgIHJldHVybiB1LmhleFRvQnl0ZXMoaGV4KTtcbn1cbmNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3Moe1xuICAgIGE6IEJpZ0ludCgxKSxcbiAgICBiOiBCaWdJbnQoJzMxNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDY2NjUnKSxcbiAgICBGcDogRmllbGQoQmlnSW50KCcweDgwMDAwMDAwMDAwMDAxMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScpKSxcbiAgICBuOiBDVVJWRV9PUkRFUixcbiAgICBuQml0TGVuZ3RoLFxuICAgIEd4OiBCaWdJbnQoJzg3NDczOTQ1MTA3ODAwNzc2NjQ1NzQ2NDk4OTc3NDMyMjA4MzY0OTI3ODYwNzUzMzI0OTQ4MTE1MTM4MjQ4MTA3Mjg2ODgwNjYwMicpLFxuICAgIEd5OiBCaWdJbnQoJzE1MjY2Njc5MjA3MTUxODgzMDg2ODU3NTU1NzgxMjk0ODM1MzA0MTQyMDQwMDc4MDczOTQ4MTM0Mjk0MTM4MTIyNTUyNTg2MTQwNycpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZSxcbiAgICAuLi5nZXRIYXNoKHNoYTI1NiksXG4gICAgYml0czJpbnQsXG4gICAgYml0czJpbnRfbW9kTjogKGJ5dGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGhleCA9IHUuYnl0ZXNUb051bWJlckJFKGJ5dGVzKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSA2MylcbiAgICAgICAgICAgIGJ5dGVzID0gaGV4MHhUb0J5dGVzKGhleCArICcwJyk7XG4gICAgICAgIHJldHVybiBtb2QoYml0czJpbnQoYnl0ZXMpLCBDVVJWRV9PUkRFUik7XG4gICAgfSxcbn0pO1xuZXhwb3J0IGNvbnN0IF9zdGFya0N1cnZlID0gY3VydmU7XG5mdW5jdGlvbiBlbnN1cmVCeXRlcyhoZXgpIHtcbiAgICByZXR1cm4gdS5lbnN1cmVCeXRlcygnJywgdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoZXgweFRvQnl0ZXMoaGV4KSA6IGhleCk7XG59XG5mdW5jdGlvbiBub3JtUHJpdktleShwcml2S2V5KSB7XG4gICAgcmV0dXJuIHUuYnl0ZXNUb0hleChlbnN1cmVCeXRlcyhwcml2S2V5KSkucGFkU3RhcnQoNjQsICcwJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShub3JtUHJpdktleShwcml2S2V5KSwgaXNDb21wcmVzc2VkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdktleUEsIHB1YktleUIpIHtcbiAgICByZXR1cm4gY3VydmUuZ2V0U2hhcmVkU2VjcmV0KG5vcm1Qcml2S2V5KHByaXZLZXlBKSwgcHViS2V5Qik7XG59XG5mdW5jdGlvbiBjaGVja1NpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZ25hdHVyZTtcbiAgICBpZiAociA8IDBuIHx8IHIgPj0gTUFYX1ZBTFVFKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25hdHVyZS5yIHNob3VsZCBiZSBbMSwgJHtNQVhfVkFMVUV9KWApO1xuICAgIGNvbnN0IHcgPSBpbnZlcnQocywgQ1VSVkVfT1JERVIpO1xuICAgIGlmICh3IDwgMG4gfHwgdyA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52KFNpZ25hdHVyZS5zKSBzaG91bGQgYmUgWzEsICR7TUFYX1ZBTFVFfSlgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWVzc2FnZShtc2dIYXNoKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhtc2dIYXNoKTtcbiAgICBjb25zdCBudW0gPSB1LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgaWYgKG51bSA+PSBNQVhfVkFMVUUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbXNnSGFzaCBzaG91bGQgYmUgWzAsICR7TUFYX1ZBTFVFfSlgKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzKSB7XG4gICAgY29uc3Qgc2lnID0gY3VydmUuc2lnbihjaGVja01lc3NhZ2UobXNnSGFzaCksIG5vcm1Qcml2S2V5KHByaXZLZXkpLCBvcHRzKTtcbiAgICBjaGVja1NpZ25hdHVyZShzaWcpO1xuICAgIHJldHVybiBzaWc7XG59XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHViS2V5KSB7XG4gICAgaWYgKCEoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKHNpZ25hdHVyZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbURFUihieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1NpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIHJldHVybiBjdXJ2ZS52ZXJpZnkoc2lnbmF0dXJlLCBjaGVja01lc3NhZ2UobXNnSGFzaCksIGVuc3VyZUJ5dGVzKHB1YktleSkpO1xufVxuY29uc3QgeyBDVVJWRSwgUHJvamVjdGl2ZVBvaW50LCBTaWduYXR1cmUsIHV0aWxzIH0gPSBjdXJ2ZTtcbmV4cG9ydCB7IENVUlZFLCBQcm9qZWN0aXZlUG9pbnQsIFNpZ25hdHVyZSwgdXRpbHMgfTtcbmZ1bmN0aW9uIGV4dHJhY3RYKGJ5dGVzKSB7XG4gICAgY29uc3QgaGV4ID0gdS5ieXRlc1RvSGV4KGJ5dGVzLnN1YmFycmF5KDEpKTtcbiAgICBjb25zdCBzdHJpcHBlZCA9IGhleC5yZXBsYWNlKC9eMCsvZ20sICcnKTtcbiAgICByZXR1cm4gYDB4JHtzdHJpcHBlZH1gO1xufVxuZnVuY3Rpb24gc3RyaXAweChoZXgpIHtcbiAgICByZXR1cm4gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ3JpbmRLZXkoc2VlZCkge1xuICAgIGNvbnN0IF9zZWVkID0gZW5zdXJlQnl0ZXMoc2VlZCk7XG4gICAgY29uc3Qgc2hhMjU2bWFzayA9IDJuICoqIDI1Nm47XG4gICAgY29uc3QgbGltaXQgPSBzaGEyNTZtYXNrIC0gbW9kKHNoYTI1Nm1hc2ssIENVUlZFX09SREVSKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBzaGEyNTZOdW0odS5jb25jYXRCeXRlcyhfc2VlZCwgdS5udW1iZXJUb1ZhckJ5dGVzQkUoQmlnSW50KGkpKSkpO1xuICAgICAgICBpZiAoa2V5IDwgbGltaXQpXG4gICAgICAgICAgICByZXR1cm4gbW9kKGtleSwgQ1VSVkVfT1JERVIpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGkgPT09IDEwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ3JpbmRLZXkgaXMgYnJva2VuOiB0cmllZCAxMDBrIHZhbHMnKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcmtLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHRyYWN0WChnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgdHJ1ZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV0aFNpZ1RvUHJpdmF0ZShzaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzdHJpcDB4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBldGhlcmV1bSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gZ3JpbmRLZXkoc2lnbmF0dXJlLnN1YnN0cmluZygwLCA2NCkpO1xufVxuY29uc3QgTUFTS18zMSA9IDJuICoqIDMxbiAtIDFuO1xuY29uc3QgaW50MzEgPSAobikgPT4gTnVtYmVyKG4gJiBNQVNLXzMxKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50UGF0aChsYXllciwgYXBwbGljYXRpb24sIGV0aGVyZXVtQWRkcmVzcywgaW5kZXgpIHtcbiAgICBjb25zdCBsYXllck51bSA9IGludDMxKHNoYTI1Nk51bShsYXllcikpO1xuICAgIGNvbnN0IGFwcGxpY2F0aW9uTnVtID0gaW50MzEoc2hhMjU2TnVtKGFwcGxpY2F0aW9uKSk7XG4gICAgY29uc3QgZXRoID0gdS5oZXhUb051bWJlcihzdHJpcDB4KGV0aGVyZXVtQWRkcmVzcykpO1xuICAgIHJldHVybiBgbS8yNjQ1Jy8ke2xheWVyTnVtfScvJHthcHBsaWNhdGlvbk51bX0nLyR7aW50MzEoZXRoKX0nLyR7aW50MzEoZXRoID4+IDMxbil9Jy8ke2luZGV4fWA7XG59XG5jb25zdCBQRURFUlNFTl9QT0lOVFMgPSBbXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0biwgMTcxMzkzMTMyOTU0MDY2MDM3NzAyMzQwNjEwOTE5OTQxMDQxNDgxMDcwNTg2NzI2MDgwMjA3ODE4NzA4MjM0NTUyOTIwNzY5NDk4Nm4sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDk5Njc4MTIwNTgzMzAwODc3NDUxNDUwMDA4MjM3Njc4MzI0OTEwMjM5NjAyMzY2MzQ1NDgxMzQ0NzQyMzE0Nzk3NzM5NzIzMjc2M24sIDE2Njg1MDM2NzY3ODYzNzc3MjU4MDU0ODkzNDQ3NzEwMjM5MjEwNzkxMjY1NTIwMTkxNjAxNTY5MjA2MzQ2MTkyNTU5NzA0ODU3ODFuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMjUxNTYzMjc0NDg5NzUwNTM1MTE3ODg2NDI2NTMzMjIyNDM1Mjk0MDQ2NDI4MzQ3MzI5MjAzNjI3MDIxMjQ5MTY5NjE2MTg0MTg0biwgMTc5ODcxNjAwNzU2MjcyODkwNTI5NTQ4MDY3OTc4OTUyNjMyMjE3NTg2ODMyODA2MjQyMDIzNzQxOTE0MzU5MzAyMTY3NDk5Mjk3M24sIDFuKSxcbiAgICBuZXcgUHJvamVjdGl2ZVBvaW50KDIxMzg0MTQ2OTUxOTQxNTExNjA5NDMzMDU3MjcwMzY1NzU5NTkxOTUzMDkyMTg2MTE3MzgxOTMyNjExNzkzMTA1MTE4NTQ4MDc0NDduLCAxMTM0MTAyNzY3MzAwNjQ0ODYyNTUxMDIwOTM4NDY1NDAxMzM3ODQ4NjUyODY5MjkwNTI0MjY5MzE0NzQxMDYzOTYxMzUwNzIxNTZuLCAxbiksXG4gICAgbmV3IFByb2plY3RpdmVQb2ludCgyMzc5OTYyNzQ5NTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2biwgNzc2NDk2NDUzNjMzMjk4MTc1NDgzOTg1Mzk4NjQ4NzU4NTg2NTI1OTMzODEyNTM2NjUzMDg5NDAxOTA1MjkyMDYzNzA4ODE2NDIybiwgMW4pLFxuXTtcbmZ1bmN0aW9uIHBlZGVyc2VuUHJlY29tcHV0ZShwMSwgcDIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IHAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ4OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICBwID0gcDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2gocCk7XG4gICAgICAgIHAgPSBwLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuY29uc3QgUEVERVJTRU5fUE9JTlRTMSA9IHBlZGVyc2VuUHJlY29tcHV0ZShQRURFUlNFTl9QT0lOVFNbMV0sIFBFREVSU0VOX1BPSU5UU1syXSk7XG5jb25zdCBQRURFUlNFTl9QT0lOVFMyID0gcGVkZXJzZW5QcmVjb21wdXRlKFBFREVSU0VOX1BPSU5UU1szXSwgUEVERVJTRU5fUE9JTlRTWzRdKTtcbmZ1bmN0aW9uIHBlZGVyc2VuQXJnKGFyZykge1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYXJnKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZWRlcnNlbkFyZzogJHthcmd9YCk7XG4gICAgICAgIHZhbHVlID0gQmlnSW50KGFyZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHUuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKGFyZykpO1xuICAgIH1cbiAgICBpZiAoISgwbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8IGN1cnZlLkNVUlZFLkZwLk9SREVSKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQZWRlcnNlbkFyZyBzaG91bGQgYmUgMCA8PSB2YWx1ZSA8IENVUlZFLlA6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcGVkZXJzZW5TaW5nbGUocG9pbnQsIHZhbHVlLCBjb25zdGFudHMpIHtcbiAgICBsZXQgeCA9IHBlZGVyc2VuQXJnKHZhbHVlKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1MjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHB0ID0gY29uc3RhbnRzW2pdO1xuICAgICAgICBpZiAocHQuZXF1YWxzKHBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2FtZSBwb2ludCcpO1xuICAgICAgICBpZiAoKHggJiAxbikgIT09IDBuKVxuICAgICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQocHQpO1xuICAgICAgICB4ID4+PSAxbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBlZGVyc2VuKHgsIHkpIHtcbiAgICBsZXQgcG9pbnQgPSBQRURFUlNFTl9QT0lOVFNbMF07XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeCwgUEVERVJTRU5fUE9JTlRTMSk7XG4gICAgcG9pbnQgPSBwZWRlcnNlblNpbmdsZShwb2ludCwgeSwgUEVERVJTRU5fUE9JTlRTMik7XG4gICAgcmV0dXJuIGV4dHJhY3RYKHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkpO1xufVxuZXhwb3J0IGNvbnN0IGNvbXB1dGVIYXNoT25FbGVtZW50cyA9IChkYXRhLCBmbiA9IHBlZGVyc2VuKSA9PiBbMCwgLi4uZGF0YSwgZGF0YS5sZW5ndGhdLnJlZHVjZSgoeCwgeSkgPT4gZm4oeCwgeSkpO1xuY29uc3QgTUFTS18yNTAgPSB1LmJpdE1hc2soMjUwKTtcbmV4cG9ydCBjb25zdCBrZWNjYWsgPSAoZGF0YSkgPT4gdS5ieXRlc1RvTnVtYmVyQkUoa2VjY2FrXzI1NihkYXRhKSkgJiBNQVNLXzI1MDtcbmNvbnN0IHNoYTI1Nk51bSA9IChkYXRhKSA9PiB1LmJ5dGVzVG9OdW1iZXJCRShzaGEyNTYoZGF0YSkpO1xuZXhwb3J0IGNvbnN0IEZwMjUxID0gRmllbGQoQmlnSW50KCczNjE4NTAyNzg4NjY2MTMxMjEzNjk3MzIyNzgzMDk1MDcwMTA1NjIzMTA3MjE1MzMxNTk2Njk5OTczMDkyMDU2MTM1ODcyMDIwNDgxJykpO1xuZnVuY3Rpb24gcG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBuYW1lLCBpZHgpIHtcbiAgICBjb25zdCB2YWwgPSBGcC5mcm9tQnl0ZXMoc2hhMjU2KHV0ZjhUb0J5dGVzKGAke25hbWV9JHtpZHh9YCkpKTtcbiAgICByZXR1cm4gRnAuY3JlYXRlKHZhbCk7XG59XG5leHBvcnQgZnVuY3Rpb24gX3Bvc2VpZG9uTURTKEZwLCBuYW1lLCBtLCBhdHRlbXB0ID0gMCkge1xuICAgIGNvbnN0IHhfdmFsdWVzID0gW107XG4gICAgY29uc3QgeV92YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICB4X3ZhbHVlcy5wdXNoKHBvc2VpZG9uUm91bmRDb25zdGFudChGcCwgYCR7bmFtZX14YCwgYXR0ZW1wdCAqIG0gKyBpKSk7XG4gICAgICAgIHlfdmFsdWVzLnB1c2gocG9zZWlkb25Sb3VuZENvbnN0YW50KEZwLCBgJHtuYW1lfXlgLCBhdHRlbXB0ICogbSArIGkpKTtcbiAgICB9XG4gICAgaWYgKG5ldyBTZXQoWy4uLnhfdmFsdWVzLCAuLi55X3ZhbHVlc10pLnNpemUgIT09IDIgKiBtKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ggYW5kIFkgdmFsdWVzIGFyZSBub3QgZGlzdGluY3QnKTtcbiAgICByZXR1cm4geF92YWx1ZXMubWFwKCh4KSA9PiB5X3ZhbHVlcy5tYXAoKHkpID0+IEZwLmludihGcC5zdWIoeCwgeSkpKSk7XG59XG5jb25zdCBNRFNfU01BTEwgPSBbXG4gICAgWzMsIDEsIDFdLFxuICAgIFsxLCAtMSwgMV0sXG4gICAgWzEsIDEsIC0yXSxcbl0ubWFwKChpKSA9PiBpLm1hcChCaWdJbnQpKTtcbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkJhc2ljKG9wdHMsIG1kcykge1xuICAgIHZhbGlkYXRlRmllbGQob3B0cy5GcCk7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzLnJhdGUpIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzLmNhcGFjaXR5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NlaWRvbiBvcHRzOiAke29wdHN9YCk7XG4gICAgY29uc3QgbSA9IG9wdHMucmF0ZSArIG9wdHMuY2FwYWNpdHk7XG4gICAgY29uc3Qgcm91bmRzID0gb3B0cy5yb3VuZHNGdWxsICsgb3B0cy5yb3VuZHNQYXJ0aWFsO1xuICAgIGNvbnN0IHJvdW5kQ29uc3RhbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspXG4gICAgICAgICAgICByb3cucHVzaChwb3NlaWRvblJvdW5kQ29uc3RhbnQob3B0cy5GcCwgJ0hhZGVzJywgbSAqIGkgKyBqKSk7XG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLnB1c2gocm93KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gcG9zZWlkb24oe1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICB0OiBtLFxuICAgICAgICBzYm94UG93ZXI6IDMsXG4gICAgICAgIHJldmVyc2VQYXJ0aWFsUG93SWR4OiB0cnVlLFxuICAgICAgICBtZHMsXG4gICAgICAgIHJvdW5kQ29uc3RhbnRzLFxuICAgIH0pO1xuICAgIHJlcy5tID0gbTtcbiAgICByZXMucmF0ZSA9IG9wdHMucmF0ZTtcbiAgICByZXMuY2FwYWNpdHkgPSBvcHRzLmNhcGFjaXR5O1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25DcmVhdGUob3B0cywgbWRzQXR0ZW1wdCA9IDApIHtcbiAgICBjb25zdCBtID0gb3B0cy5yYXRlICsgb3B0cy5jYXBhY2l0eTtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG1kc0F0dGVtcHQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIG1kc0F0dGVtcHQ9JHttZHNBdHRlbXB0fWApO1xuICAgIHJldHVybiBwb3NlaWRvbkJhc2ljKG9wdHMsIF9wb3NlaWRvbk1EUyhvcHRzLkZwLCAnSGFkZXNNRFMnLCBtLCBtZHNBdHRlbXB0KSk7XG59XG5leHBvcnQgY29uc3QgcG9zZWlkb25TbWFsbCA9IHBvc2VpZG9uQmFzaWMoeyBGcDogRnAyNTEsIHJhdGU6IDIsIGNhcGFjaXR5OiAxLCByb3VuZHNGdWxsOiA4LCByb3VuZHNQYXJ0aWFsOiA4MyB9LCBNRFNfU01BTEwpO1xuZXhwb3J0IGZ1bmN0aW9uIHBvc2VpZG9uSGFzaCh4LCB5LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gZm4oW3gsIHksIDJuXSlbMF07XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb25IYXNoRnVuYyh4LCB5LCBmbiA9IHBvc2VpZG9uU21hbGwpIHtcbiAgICByZXR1cm4gdS5udW1iZXJUb1ZhckJ5dGVzQkUocG9zZWlkb25IYXNoKHUuYnl0ZXNUb051bWJlckJFKHgpLCB1LmJ5dGVzVG9OdW1iZXJCRSh5KSwgZm4pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hTaW5nbGUoeCwgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgcmV0dXJuIGZuKFt4LCAwbiwgMW5dKVswXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3NlaWRvbkhhc2hNYW55KHZhbHVlcywgZm4gPSBwb3NlaWRvblNtYWxsKSB7XG4gICAgY29uc3QgeyBtLCByYXRlIH0gPSBmbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgYXJyYXkgZXhwZWN0ZWQgaW4gdmFsdWVzJyk7XG4gICAgY29uc3QgcGFkZGVkID0gQXJyYXkuZnJvbSh2YWx1ZXMpO1xuICAgIHBhZGRlZC5wdXNoKDFuKTtcbiAgICB3aGlsZSAocGFkZGVkLmxlbmd0aCAlIHJhdGUgIT09IDApXG4gICAgICAgIHBhZGRlZC5wdXNoKDBuKTtcbiAgICBsZXQgc3RhdGUgPSBuZXcgQXJyYXkobSkuZmlsbCgwbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWQubGVuZ3RoOyBpICs9IHJhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYXRlOyBqKyspXG4gICAgICAgICAgICBzdGF0ZVtqXSArPSBwYWRkZWRbaSArIGpdO1xuICAgICAgICBzdGF0ZSA9IGZuKHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlWzBdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUMwQztBQUNxQjtBQUNQO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFJLFlBQVksZ0VBQVc7QUFDM0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixxRUFBVyxHQUFHLCtCQUErQjtBQUMxRSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcz9hOWJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3NEO0FBQ1Y7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYTtBQUNqQixJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz8wMTA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUVBQXFFLFFBQVEsTUFBTSxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNB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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU8sNEJBQTRCLElBQUk7QUFDM0UsdUJBQXVCLDBEQUFlLFFBQVEsMERBQWU7QUFDN0Q7QUFDQTtBQUNBLGtCQUFrQiwwREFBZSxzQkFBc0IsMERBQWU7QUFDdEU7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzPzUzZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poseidon: function() { return /* binding */ poseidon; },\n/* harmony export */   splitConstants: function() { return /* binding */ splitConstants; },\n/* harmony export */   validateOpts: function() { return /* binding */ validateOpts; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Poseidon Hash: https://eprint.iacr.org/2019/458.pdf, https://www.poseidon-hash.info\n\nfunction validateOpts(opts) {\n    const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;\n    const { roundsFull, roundsPartial, sboxPower, t } = opts;\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(Fp);\n    for (const i of ['t', 'roundsFull', 'roundsPartial']) {\n        if (typeof opts[i] !== 'number' || !Number.isSafeInteger(opts[i]))\n            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);\n    }\n    // MDS is TxT matrix\n    if (!Array.isArray(mds) || mds.length !== t)\n        throw new Error('Poseidon: wrong MDS matrix');\n    const _mds = mds.map((mdsRow) => {\n        if (!Array.isArray(mdsRow) || mdsRow.length !== t)\n            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);\n        return mdsRow.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon MDS matrix value=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (rev !== undefined && typeof rev !== 'boolean')\n        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);\n    if (roundsFull % 2 !== 0)\n        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);\n    const rounds = roundsFull + roundsPartial;\n    if (!Array.isArray(rc) || rc.length !== rounds)\n        throw new Error('Poseidon: wrong round constants');\n    const roundConstants = rc.map((rc) => {\n        if (!Array.isArray(rc) || rc.length !== t)\n            throw new Error(`Poseidon wrong round constants: ${rc}`);\n        return rc.map((i) => {\n            if (typeof i !== 'bigint' || !Fp.isValid(i))\n                throw new Error(`Poseidon wrong round constant=${i}`);\n            return Fp.create(i);\n        });\n    });\n    if (!sboxPower || ![3, 5, 7].includes(sboxPower))\n        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);\n    const _sboxPower = BigInt(sboxPower);\n    let sboxFn = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow)(Fp, n, _sboxPower);\n    // Unwrapped sbox power for common cases (195->142μs)\n    if (sboxPower === 3)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);\n    else if (sboxPower === 5)\n        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);\n    return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });\n}\nfunction splitConstants(rc, t) {\n    if (typeof t !== 'number')\n        throw new Error('poseidonSplitConstants: wrong t');\n    if (!Array.isArray(rc) || rc.length % t)\n        throw new Error('poseidonSplitConstants: wrong rc');\n    const res = [];\n    let tmp = [];\n    for (let i = 0; i < rc.length; i++) {\n        tmp.push(rc[i]);\n        if (tmp.length === t) {\n            res.push(tmp);\n            tmp = [];\n        }\n    }\n    return res;\n}\nfunction poseidon(opts) {\n    const _opts = validateOpts(opts);\n    const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;\n    const halfRoundsFull = _opts.roundsFull / 2;\n    const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;\n    const poseidonRound = (values, isFull, idx) => {\n        values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));\n        if (isFull)\n            values = values.map((i) => sboxFn(i));\n        else\n            values[partialIdx] = sboxFn(values[partialIdx]);\n        // Matrix multiplication\n        values = mds.map((i) => i.reduce((acc, i, j) => Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));\n        return values;\n    };\n    const poseidonHash = function poseidonHash(values) {\n        if (!Array.isArray(values) || values.length !== t)\n            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);\n        values = values.map((i) => {\n            if (typeof i !== 'bigint')\n                throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);\n            return Fp.create(i);\n        });\n        let round = 0;\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        // Apply r_p partial rounds.\n        for (let i = 0; i < roundsPartial; i++)\n            values = poseidonRound(values, false, round++);\n        // Apply r_f/2 full rounds.\n        for (let i = 0; i < halfRoundsFull; i++)\n            values = poseidonRound(values, true, round++);\n        if (round !== rounds)\n            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);\n        return values;\n    };\n    // For verification in tests\n    poseidonHash.roundConstants = roundConstants;\n    return poseidonHash;\n}\n//# sourceMappingURL=poseidon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3Bvc2VpZG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29EO0FBQzdDO0FBQ1AsWUFBWSx5REFBeUQ7QUFDckUsWUFBWSwwQ0FBMEM7QUFDdEQsSUFBSSwwREFBYTtBQUNqQjtBQUNBO0FBQ0EsdURBQXVELEVBQUUsR0FBRyxTQUFTLEdBQUcsZUFBZTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0EsNkRBQTZELEVBQUU7QUFDL0Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esd0VBQXdFLElBQUk7QUFDNUU7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEdBQUc7QUFDbEU7QUFDQTtBQUNBLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0Esd0JBQXdCLGtEQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQW9EO0FBQy9FO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksNERBQTREO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsRUFBRTtBQUMvRjtBQUNBO0FBQ0EseURBQXlELEdBQUcsR0FBRyxTQUFTO0FBQ3hFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQSw0RUFBNEUsTUFBTSxVQUFVLE9BQU87QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvcG9zZWlkb24uanM/YzNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBQb3NlaWRvbiBIYXNoOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5LzQ1OC5wZGYsIGh0dHBzOi8vd3d3LnBvc2VpZG9uLWhhc2guaW5mb1xuaW1wb3J0IHsgRnBQb3csIHZhbGlkYXRlRmllbGQgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhvcHRzKSB7XG4gICAgY29uc3QgeyBGcCwgbWRzLCByZXZlcnNlUGFydGlhbFBvd0lkeDogcmV2LCByb3VuZENvbnN0YW50czogcmMgfSA9IG9wdHM7XG4gICAgY29uc3QgeyByb3VuZHNGdWxsLCByb3VuZHNQYXJ0aWFsLCBzYm94UG93ZXIsIHQgfSA9IG9wdHM7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgZm9yIChjb25zdCBpIG9mIFsndCcsICdyb3VuZHNGdWxsJywgJ3JvdW5kc1BhcnRpYWwnXSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdHNbaV0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihvcHRzW2ldKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb246IGludmFsaWQgcGFyYW0gJHtpfT0ke29wdHNbaV19ICgke3R5cGVvZiBvcHRzW2ldfSlgKTtcbiAgICB9XG4gICAgLy8gTURTIGlzIFR4VCBtYXRyaXhcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWRzKSB8fCBtZHMubGVuZ3RoICE9PSB0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2VpZG9uOiB3cm9uZyBNRFMgbWF0cml4Jyk7XG4gICAgY29uc3QgX21kcyA9IG1kcy5tYXAoKG1kc1JvdykgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWRzUm93KSB8fCBtZHNSb3cubGVuZ3RoICE9PSB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiBNRFMgbWF0cml4IHJvdzogJHttZHNSb3d9YCk7XG4gICAgICAgIHJldHVybiBtZHNSb3cubWFwKChpKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gTURTIG1hdHJpeCB2YWx1ZT0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gRnAuY3JlYXRlKGkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmV2ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJldiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2VpZG9uOiBpbnZhbGlkIHBhcmFtIHJldmVyc2VQYXJ0aWFsUG93SWR4PSR7cmV2fWApO1xuICAgIGlmIChyb3VuZHNGdWxsICUgMiAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiByb3VuZHNGdWxsIGlzIG5vdCBldmVuOiAke3JvdW5kc0Z1bGx9YCk7XG4gICAgY29uc3Qgcm91bmRzID0gcm91bmRzRnVsbCArIHJvdW5kc1BhcnRpYWw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJjKSB8fCByYy5sZW5ndGggIT09IHJvdW5kcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NlaWRvbjogd3Jvbmcgcm91bmQgY29uc3RhbnRzJyk7XG4gICAgY29uc3Qgcm91bmRDb25zdGFudHMgPSByYy5tYXAoKHJjKSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYykgfHwgcmMubGVuZ3RoICE9PSB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiB3cm9uZyByb3VuZCBjb25zdGFudHM6ICR7cmN9YCk7XG4gICAgICAgIHJldHVybiByYy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcgfHwgIUZwLmlzVmFsaWQoaSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbiB3cm9uZyByb3VuZCBjb25zdGFudD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gRnAuY3JlYXRlKGkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIXNib3hQb3dlciB8fCAhWzMsIDUsIDddLmluY2x1ZGVzKHNib3hQb3dlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9zZWlkb24gd3Jvbmcgc2JveFBvd2VyPSR7c2JveFBvd2VyfWApO1xuICAgIGNvbnN0IF9zYm94UG93ZXIgPSBCaWdJbnQoc2JveFBvd2VyKTtcbiAgICBsZXQgc2JveEZuID0gKG4pID0+IEZwUG93KEZwLCBuLCBfc2JveFBvd2VyKTtcbiAgICAvLyBVbndyYXBwZWQgc2JveCBwb3dlciBmb3IgY29tbW9uIGNhc2VzICgxOTUtPjE0Ms68cylcbiAgICBpZiAoc2JveFBvd2VyID09PSAzKVxuICAgICAgICBzYm94Rm4gPSAobikgPT4gRnAubXVsKEZwLnNxck4obiksIG4pO1xuICAgIGVsc2UgaWYgKHNib3hQb3dlciA9PT0gNSlcbiAgICAgICAgc2JveEZuID0gKG4pID0+IEZwLm11bChGcC5zcXJOKEZwLnNxck4obikpLCBuKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMsIHJvdW5kcywgc2JveEZuLCByb3VuZENvbnN0YW50cywgbWRzOiBfbWRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0Q29uc3RhbnRzKHJjLCB0KSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NlaWRvblNwbGl0Q29uc3RhbnRzOiB3cm9uZyB0Jyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJjKSB8fCByYy5sZW5ndGggJSB0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2VpZG9uU3BsaXRDb25zdGFudHM6IHdyb25nIHJjJyk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IHRtcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG1wLnB1c2gocmNbaV0pO1xuICAgICAgICBpZiAodG1wLmxlbmd0aCA9PT0gdCkge1xuICAgICAgICAgICAgcmVzLnB1c2godG1wKTtcbiAgICAgICAgICAgIHRtcCA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zZWlkb24ob3B0cykge1xuICAgIGNvbnN0IF9vcHRzID0gdmFsaWRhdGVPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAsIG1kcywgcm91bmRDb25zdGFudHMsIHJvdW5kcywgcm91bmRzUGFydGlhbCwgc2JveEZuLCB0IH0gPSBfb3B0cztcbiAgICBjb25zdCBoYWxmUm91bmRzRnVsbCA9IF9vcHRzLnJvdW5kc0Z1bGwgLyAyO1xuICAgIGNvbnN0IHBhcnRpYWxJZHggPSBfb3B0cy5yZXZlcnNlUGFydGlhbFBvd0lkeCA/IHQgLSAxIDogMDtcbiAgICBjb25zdCBwb3NlaWRvblJvdW5kID0gKHZhbHVlcywgaXNGdWxsLCBpZHgpID0+IHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcCgoaSwgaikgPT4gRnAuYWRkKGksIHJvdW5kQ29uc3RhbnRzW2lkeF1bal0pKTtcbiAgICAgICAgaWYgKGlzRnVsbClcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKGkpID0+IHNib3hGbihpKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbHVlc1twYXJ0aWFsSWR4XSA9IHNib3hGbih2YWx1ZXNbcGFydGlhbElkeF0pO1xuICAgICAgICAvLyBNYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICAgICAgdmFsdWVzID0gbWRzLm1hcCgoaSkgPT4gaS5yZWR1Y2UoKGFjYywgaSwgaikgPT4gRnAuYWRkKGFjYywgRnAubXVsTihpLCB2YWx1ZXNbal0pKSwgRnAuWkVSTykpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgY29uc3QgcG9zZWlkb25IYXNoID0gZnVuY3Rpb24gcG9zZWlkb25IYXNoKHZhbHVlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoICE9PSB0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgdmFsdWVzIChleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzIHdpdGggbGVuZ3RoICR7dH0pYCk7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgdmFsdWU9JHtpfSAoJHt0eXBlb2YgaX0pYCk7XG4gICAgICAgICAgICByZXR1cm4gRnAuY3JlYXRlKGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJvdW5kID0gMDtcbiAgICAgICAgLy8gQXBwbHkgcl9mLzIgZnVsbCByb3VuZHMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFsZlJvdW5kc0Z1bGw7IGkrKylcbiAgICAgICAgICAgIHZhbHVlcyA9IHBvc2VpZG9uUm91bmQodmFsdWVzLCB0cnVlLCByb3VuZCsrKTtcbiAgICAgICAgLy8gQXBwbHkgcl9wIHBhcnRpYWwgcm91bmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kc1BhcnRpYWw7IGkrKylcbiAgICAgICAgICAgIHZhbHVlcyA9IHBvc2VpZG9uUm91bmQodmFsdWVzLCBmYWxzZSwgcm91bmQrKyk7XG4gICAgICAgIC8vIEFwcGx5IHJfZi8yIGZ1bGwgcm91bmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbGZSb3VuZHNGdWxsOyBpKyspXG4gICAgICAgICAgICB2YWx1ZXMgPSBwb3NlaWRvblJvdW5kKHZhbHVlcywgdHJ1ZSwgcm91bmQrKyk7XG4gICAgICAgIGlmIChyb3VuZCAhPT0gcm91bmRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NlaWRvbjogd3JvbmcgbnVtYmVyIG9mIHJvdW5kczogbGFzdCByb3VuZD0ke3JvdW5kfSwgdG90YWw9JHtyb3VuZHN9YCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICAvLyBGb3IgdmVyaWZpY2F0aW9uIGluIHRlc3RzXG4gICAgcG9zZWlkb25IYXNoLnJvdW5kQ29uc3RhbnRzID0gcm91bmRDb25zdGFudHM7XG4gICAgcmV0dXJuIHBvc2VpZG9uSGFzaDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvc2VpZG9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/poseidon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: function() { return /* binding */ bitGet; },\n/* harmony export */   bitLen: function() { return /* binding */ bitLen; },\n/* harmony export */   bitMask: function() { return /* binding */ bitMask; },\n/* harmony export */   bitSet: function() { return /* binding */ bitSet; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   bytesToNumberBE: function() { return /* binding */ bytesToNumberBE; },\n/* harmony export */   bytesToNumberLE: function() { return /* binding */ bytesToNumberLE; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createHmacDrbg: function() { return /* binding */ createHmacDrbg; },\n/* harmony export */   ensureBytes: function() { return /* binding */ ensureBytes; },\n/* harmony export */   equalBytes: function() { return /* binding */ equalBytes; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   hexToNumber: function() { return /* binding */ hexToNumber; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   numberToBytesBE: function() { return /* binding */ numberToBytesBE; },\n/* harmony export */   numberToBytesLE: function() { return /* binding */ numberToBytesLE; },\n/* harmony export */   numberToHexUnpadded: function() { return /* binding */ numberToHexUnpadded; },\n/* harmony export */   numberToVarBytesBE: function() { return /* binding */ numberToVarBytesBE; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   validateObject: function() { return /* binding */ validateObject; }\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    let res = new Uint8Array(sum);\n    let pad = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25ELDhEQUE4RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsV0FBVyxjQUFjLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzP2I2MDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0J5dGVzKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGlmICghaXNCeXRlcyhhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGxldCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGxldCBwYWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(data))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNvQztBQUNIO0FBQ1E7QUFDUTtBQUNqRDtBQUNBLGlCQUFpQix3REFBYTtBQUM5QixJQUFJLHFEQUFpQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QyxFQUFFLHNDQUFFO0FBQzdDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxhQUFhLDhDQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxHQUFHLEVBQUUsRUFBRTtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/ZGFkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuaW1wb3J0ICogYXMgbW9kIGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIXV0LmlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYXNzZXJ0R0UgaGVyZVxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbW9kLmdldE1pbkhhc2hMZW5ndGgoQ1VSVkUubik7XG4gICAgICAgICAgICByZXR1cm4gbW9kLm1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBwcmVjb21wdXRlIHRhYmxlIGZvciBhbiBhcmJpdHJhcnkgRUMgcG9pbnQuIE1ha2VzIHBvaW50IFwiY2FjaGVkXCIuXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxuICAgICAgICAgKiBAcmV0dXJucyBjYWNoZWQgcG9pbnRcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcbiAgICAgICAgICogZmFzdC5tdWx0aXBseShwcml2S2V5KTsgLy8gbXVjaCBmYXN0ZXIgRUNESCBub3dcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpOyAvLyAzIGlzIGFyYml0cmFyeSwganVzdCBuZWVkIGFueSBudW1iZXIgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIFB1YmxpYyBrZXksIGZ1bGwgd2hlbiBpc0NvbXByZXNzZWQ9ZmFsc2U7IHNob3J0IHdoZW4gaXNDb21wcmVzc2VkPXRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICBjb25zdCBhcnIgPSB1dC5pc0J5dGVzKGl0ZW0pO1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCB1dC5pc0J5dGVzKHNnKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLCtEQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzP2Y0OTYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG4vLyBjb3BpZWQgZnJvbSB1dGlsc1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: function() { return /* binding */ SHA2; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcz80Y2NiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   add3H: function() { return /* binding */ add3H; },\n/* harmony export */   add3L: function() { return /* binding */ add3L; },\n/* harmony export */   add4H: function() { return /* binding */ add4H; },\n/* harmony export */   add4L: function() { return /* binding */ add4L; },\n/* harmony export */   add5H: function() { return /* binding */ add5H; },\n/* harmony export */   add5L: function() { return /* binding */ add5L; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   rotlBH: function() { return /* binding */ rotlBH; },\n/* harmony export */   rotlBL: function() { return /* binding */ rotlBL; },\n/* harmony export */   rotlSH: function() { return /* binding */ rotlSH; },\n/* harmony export */   rotlSL: function() { return /* binding */ rotlSL; },\n/* harmony export */   rotr32H: function() { return /* binding */ rotr32H; },\n/* harmony export */   rotr32L: function() { return /* binding */ rotr32L; },\n/* harmony export */   rotrBH: function() { return /* binding */ rotrBH; },\n/* harmony export */   rotrBL: function() { return /* binding */ rotrBL; },\n/* harmony export */   rotrSH: function() { return /* binding */ rotrSH; },\n/* harmony export */   rotrSL: function() { return /* binding */ rotrSL; },\n/* harmony export */   shrSH: function() { return /* binding */ shrSH; },\n/* harmony export */   shrSL: function() { return /* binding */ shrSL; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lMO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLEdBQUcsRUFBQztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzPzEzZjkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanM/OGMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNyRDtBQUMzQztBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsb0JBQW9CLGtEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCLFFBQVEsaURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9zdGFya25ldC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcz8yNjFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2lCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz82MTMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: function() { return /* binding */ Keccak; },\n/* harmony export */   keccakP: function() { return /* binding */ keccakP; },\n/* harmony export */   keccak_224: function() { return /* binding */ keccak_224; },\n/* harmony export */   keccak_256: function() { return /* binding */ keccak_256; },\n/* harmony export */   keccak_384: function() { return /* binding */ keccak_384; },\n/* harmony export */   keccak_512: function() { return /* binding */ keccak_512; },\n/* harmony export */   sha3_224: function() { return /* binding */ sha3_224; },\n/* harmony export */   sha3_256: function() { return /* binding */ sha3_256; },\n/* harmony export */   sha3_384: function() { return /* binding */ sha3_384; },\n/* harmony export */   sha3_512: function() { return /* binding */ sha3_512; },\n/* harmony export */   shake128: function() { return /* binding */ shake128; },\n/* harmony export */   shake256: function() { return /* binding */ shake256; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ0s7QUFDNEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4Q0FBSztBQUN4RDtBQUNBLHFDQUFxQywrQ0FBTSxZQUFZLCtDQUFNO0FBQzdELHFDQUFxQywrQ0FBTSxZQUFZLCtDQUFNO0FBQzdEO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLGtCQUFrQjtBQUNsQyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGlEQUFLO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFlO0FBQ3JEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1Asa0RBQWtELHFFQUEwQixXQUFXO0FBQ2hGO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzP2NlODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIG51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvc3RhcmtuZXQvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjdXJlL3N0YXJrbmV0L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz9iNTNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG4vLyBPdGhlciBsaWJyYXJpZXMgd291bGQgc2lsZW50bHkgY29ycnVwdCB0aGUgZGF0YSBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yLFxuLy8gd2hlbiB0aGV5IGRvbid0IHN1cHBvcnQgaXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBpZiAoIWlzQnl0ZXMoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/starknet/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Permission: function() { return /* binding */ Permission; }\n/* harmony export */ });\nconst Permission = {\n    ACCOUNTS: 'accounts',\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtaW8vdHlwZXMtanMvZGlzdC9lc20vd2FsbGV0LWFwaS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtaW8vdHlwZXMtanMvZGlzdC9lc20vd2FsbGV0LWFwaS9jb25zdGFudHMuanM/NTI4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgUGVybWlzc2lvbiA9IHtcbiAgICBBQ0NPVU5UUzogJ2FjY291bnRzJyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@starknet-react/chains/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@starknet-react/chains/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devnet: function() { return /* binding */ devnet; },\n/* harmony export */   mainnet: function() { return /* binding */ mainnet; },\n/* harmony export */   sepolia: function() { return /* binding */ sepolia; }\n/* harmony export */ });\n// src/devnet.ts\nvar devnet = {\n  id: BigInt(\"0x534e5f5345504f4c4941\"),\n  network: \"devnet\",\n  name: \"Starknet Devnet\",\n  nativeCurrency: {\n    address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  testnet: true,\n  rpcUrls: {\n    default: {\n      http: []\n    },\n    public: {\n      http: [\"http://localhost:5050/rpc\"]\n    }\n  }\n};\n\n// src/starknet.ts\nvar mainnet = {\n  id: BigInt(\"0x534e5f4d41494e\"),\n  network: \"mainnet\",\n  name: \"Starknet\",\n  nativeCurrency: {\n    address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  rpcUrls: {\n    alchemy: {\n      http: [\"https://starknet-mainnet.g.alchemy.com/v2\"]\n    },\n    blast: {\n      http: [\"https://starknet-mainnet.blastapi.io\"]\n    },\n    infura: {\n      http: [\"https://starknet-mainnet.infura.io/v3\"]\n    },\n    lava: {\n      http: [\"https://g.w.lavanet.xyz:443/gateway/strk/rpc-http\"]\n    },\n    nethermind: {\n      http: [\"https://rpc.nethermind.io/mainnet-juno\"]\n    },\n    reddio: {\n      http: [\"https://starknet-mainnet.reddio.com\"]\n    },\n    default: {\n      http: []\n    },\n    public: {\n      http: [\n        \"https://starknet-mainnet.public.blastapi.io/rpc/v0.5\",\n        \"https://rpc.starknet.lava.build\",\n        \"https://free-rpc.nethermind.io/mainnet-juno/v0_5\"\n      ]\n    }\n  },\n  explorers: {\n    starkCompass: [\"https://www.starkcompass.com\"],\n    starkscan: [\"https://starkscan.co\"],\n    viewblock: [\"https://viewblock.io/starknet\"],\n    voyager: [\"https://voyager.online\"]\n  }\n};\nvar sepolia = {\n  id: BigInt(\"0x534e5f5345504f4c4941\"),\n  network: \"sepolia\",\n  name: \"Starknet Sepolia Testnet\",\n  nativeCurrency: {\n    address: \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18\n  },\n  testnet: true,\n  rpcUrls: {\n    // alchemy: {\n    //   http: [],\n    // },\n    blast: {\n      http: [\"https://starknet-sepolia.blastapi.io\"]\n    },\n    infura: {\n      http: [\"https://starknet-sepolia.infura.io/v3\"]\n    },\n    // lava: {\n    //   http: [],\n    // },\n    nethermind: {\n      http: [\"https://rpc.nethermind.io/sepolia-juno\"]\n    },\n    reddio: {\n      http: [\"https://starknet-sepolia.reddio.com\"]\n    },\n    default: {\n      http: []\n    },\n    public: {\n      http: [\n        \"https://starknet-sepolia.public.blastapi.io\",\n        \"https://free-rpc.nethermind.io/sepolia-juno\"\n      ]\n    }\n  },\n  explorers: {\n    starkscan: [\"https://sepolia.starkscan.co\"],\n    voyager: [\"https://sepolia.voyager.online\"]\n  }\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtcmVhY3QvY2hhaW5zL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtcmVhY3QvY2hhaW5zL2Rpc3QvaW5kZXguanM/YzY2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZGV2bmV0LnRzXG52YXIgZGV2bmV0ID0ge1xuICBpZDogQmlnSW50KFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiKSxcbiAgbmV0d29yazogXCJkZXZuZXRcIixcbiAgbmFtZTogXCJTdGFya25ldCBEZXZuZXRcIixcbiAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICBhZGRyZXNzOiBcIjB4MDQ5ZDM2NTcwZDRlNDZmNDhlOTk2NzRiZDNmY2M4NDY0NGRkZDZiOTZmN2M3NDFiMTU2MmI4MmY5ZTAwNGRjN1wiLFxuICAgIG5hbWU6IFwiRXRoZXJcIixcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgZGVjaW1hbHM6IDE4XG4gIH0sXG4gIHRlc3RuZXQ6IHRydWUsXG4gIHJwY1VybHM6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBodHRwOiBbXVxuICAgIH0sXG4gICAgcHVibGljOiB7XG4gICAgICBodHRwOiBbXCJodHRwOi8vbG9jYWxob3N0OjUwNTAvcnBjXCJdXG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvc3RhcmtuZXQudHNcbnZhciBtYWlubmV0ID0ge1xuICBpZDogQmlnSW50KFwiMHg1MzRlNWY0ZDQxNDk0ZVwiKSxcbiAgbmV0d29yazogXCJtYWlubmV0XCIsXG4gIG5hbWU6IFwiU3RhcmtuZXRcIixcbiAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICBhZGRyZXNzOiBcIjB4MDQ5ZDM2NTcwZDRlNDZmNDhlOTk2NzRiZDNmY2M4NDY0NGRkZDZiOTZmN2M3NDFiMTU2MmI4MmY5ZTAwNGRjN1wiLFxuICAgIG5hbWU6IFwiRXRoZXJcIixcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgZGVjaW1hbHM6IDE4XG4gIH0sXG4gIHJwY1VybHM6IHtcbiAgICBhbGNoZW15OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3N0YXJrbmV0LW1haW5uZXQuZy5hbGNoZW15LmNvbS92MlwiXVxuICAgIH0sXG4gICAgYmxhc3Q6IHtcbiAgICAgIGh0dHA6IFtcImh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5ibGFzdGFwaS5pb1wiXVxuICAgIH0sXG4gICAgaW5mdXJhOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3N0YXJrbmV0LW1haW5uZXQuaW5mdXJhLmlvL3YzXCJdXG4gICAgfSxcbiAgICBsYXZhOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL2cudy5sYXZhbmV0Lnh5ejo0NDMvZ2F0ZXdheS9zdHJrL3JwYy1odHRwXCJdXG4gICAgfSxcbiAgICBuZXRoZXJtaW5kOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3JwYy5uZXRoZXJtaW5kLmlvL21haW5uZXQtanVub1wiXVxuICAgIH0sXG4gICAgcmVkZGlvOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3N0YXJrbmV0LW1haW5uZXQucmVkZGlvLmNvbVwiXVxuICAgIH0sXG4gICAgZGVmYXVsdDoge1xuICAgICAgaHR0cDogW11cbiAgICB9LFxuICAgIHB1YmxpYzoge1xuICAgICAgaHR0cDogW1xuICAgICAgICBcImh0dHBzOi8vc3RhcmtuZXQtbWFpbm5ldC5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjL3YwLjVcIixcbiAgICAgICAgXCJodHRwczovL3JwYy5zdGFya25ldC5sYXZhLmJ1aWxkXCIsXG4gICAgICAgIFwiaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL21haW5uZXQtanVuby92MF81XCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIGV4cGxvcmVyczoge1xuICAgIHN0YXJrQ29tcGFzczogW1wiaHR0cHM6Ly93d3cuc3Rhcmtjb21wYXNzLmNvbVwiXSxcbiAgICBzdGFya3NjYW46IFtcImh0dHBzOi8vc3RhcmtzY2FuLmNvXCJdLFxuICAgIHZpZXdibG9jazogW1wiaHR0cHM6Ly92aWV3YmxvY2suaW8vc3RhcmtuZXRcIl0sXG4gICAgdm95YWdlcjogW1wiaHR0cHM6Ly92b3lhZ2VyLm9ubGluZVwiXVxuICB9XG59O1xudmFyIHNlcG9saWEgPSB7XG4gIGlkOiBCaWdJbnQoXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIpLFxuICBuZXR3b3JrOiBcInNlcG9saWFcIixcbiAgbmFtZTogXCJTdGFya25ldCBTZXBvbGlhIFRlc3RuZXRcIixcbiAgbmF0aXZlQ3VycmVuY3k6IHtcbiAgICBhZGRyZXNzOiBcIjB4MDQ5ZDM2NTcwZDRlNDZmNDhlOTk2NzRiZDNmY2M4NDY0NGRkZDZiOTZmN2M3NDFiMTU2MmI4MmY5ZTAwNGRjN1wiLFxuICAgIG5hbWU6IFwiRXRoZXJcIixcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgZGVjaW1hbHM6IDE4XG4gIH0sXG4gIHRlc3RuZXQ6IHRydWUsXG4gIHJwY1VybHM6IHtcbiAgICAvLyBhbGNoZW15OiB7XG4gICAgLy8gICBodHRwOiBbXSxcbiAgICAvLyB9LFxuICAgIGJsYXN0OiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3N0YXJrbmV0LXNlcG9saWEuYmxhc3RhcGkuaW9cIl1cbiAgICB9LFxuICAgIGluZnVyYToge1xuICAgICAgaHR0cDogW1wiaHR0cHM6Ly9zdGFya25ldC1zZXBvbGlhLmluZnVyYS5pby92M1wiXVxuICAgIH0sXG4gICAgLy8gbGF2YToge1xuICAgIC8vICAgaHR0cDogW10sXG4gICAgLy8gfSxcbiAgICBuZXRoZXJtaW5kOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3JwYy5uZXRoZXJtaW5kLmlvL3NlcG9saWEtanVub1wiXVxuICAgIH0sXG4gICAgcmVkZGlvOiB7XG4gICAgICBodHRwOiBbXCJodHRwczovL3N0YXJrbmV0LXNlcG9saWEucmVkZGlvLmNvbVwiXVxuICAgIH0sXG4gICAgZGVmYXVsdDoge1xuICAgICAgaHR0cDogW11cbiAgICB9LFxuICAgIHB1YmxpYzoge1xuICAgICAgaHR0cDogW1xuICAgICAgICBcImh0dHBzOi8vc3RhcmtuZXQtc2Vwb2xpYS5wdWJsaWMuYmxhc3RhcGkuaW9cIixcbiAgICAgICAgXCJodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vc2Vwb2xpYS1qdW5vXCJcbiAgICAgIF1cbiAgICB9XG4gIH0sXG4gIGV4cGxvcmVyczoge1xuICAgIHN0YXJrc2NhbjogW1wiaHR0cHM6Ly9zZXBvbGlhLnN0YXJrc2Nhbi5jb1wiXSxcbiAgICB2b3lhZ2VyOiBbXCJodHRwczovL3NlcG9saWEudm95YWdlci5vbmxpbmVcIl1cbiAgfVxufTtcbmV4cG9ydCB7XG4gIGRldm5ldCxcbiAgbWFpbm5ldCxcbiAgc2Vwb2xpYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@starknet-react/chains/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@starknet-react/core/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@starknet-react/core/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Connector: function() { return /* binding */ Connector; },\n/* harmony export */   ConnectorAlreadyConnectedError: function() { return /* binding */ ConnectorAlreadyConnectedError; },\n/* harmony export */   ConnectorNotConnectedError: function() { return /* binding */ ConnectorNotConnectedError; },\n/* harmony export */   ConnectorNotFoundError: function() { return /* binding */ ConnectorNotFoundError; },\n/* harmony export */   InjectedConnector: function() { return /* binding */ InjectedConnector; },\n/* harmony export */   MockConnector: function() { return /* binding */ MockConnector; },\n/* harmony export */   OverrideAccount: function() { return /* binding */ AccountProvider; },\n/* harmony export */   StarkCompassExplorer: function() { return /* binding */ StarkCompassExplorer; },\n/* harmony export */   StarknetConfig: function() { return /* binding */ StarknetConfig; },\n/* harmony export */   StarkscanExplorer: function() { return /* binding */ StarkscanExplorer; },\n/* harmony export */   UnsupportedAccountInterfaceError: function() { return /* binding */ UnsupportedAccountInterfaceError; },\n/* harmony export */   UserNotConnectedError: function() { return /* binding */ UserNotConnectedError; },\n/* harmony export */   UserRejectedRequestError: function() { return /* binding */ UserRejectedRequestError; },\n/* harmony export */   ViewblockExplorer: function() { return /* binding */ ViewblockExplorer; },\n/* harmony export */   VoyagerExplorer: function() { return /* binding */ VoyagerExplorer; },\n/* harmony export */   alchemyProvider: function() { return /* binding */ alchemyProvider; },\n/* harmony export */   argent: function() { return /* binding */ argent; },\n/* harmony export */   blastProvider: function() { return /* binding */ blastProvider; },\n/* harmony export */   braavos: function() { return /* binding */ braavos; },\n/* harmony export */   infuraProvider: function() { return /* binding */ infuraProvider; },\n/* harmony export */   injected: function() { return /* binding */ injected; },\n/* harmony export */   jsonRpcProvider: function() { return /* binding */ jsonRpcProvider; },\n/* harmony export */   lavaProvider: function() { return /* binding */ lavaProvider; },\n/* harmony export */   nethermindProvider: function() { return /* binding */ nethermindProvider; },\n/* harmony export */   publicProvider: function() { return /* binding */ publicProvider; },\n/* harmony export */   reddioProvider: function() { return /* binding */ reddioProvider; },\n/* harmony export */   starkcompass: function() { return /* binding */ starkcompass; },\n/* harmony export */   starknetChainId: function() { return /* binding */ starknetChainId; },\n/* harmony export */   starkscan: function() { return /* binding */ starkscan; },\n/* harmony export */   useAccount: function() { return /* binding */ useAccount; },\n/* harmony export */   useAddChain: function() { return /* binding */ useAddChain; },\n/* harmony export */   useBalance: function() { return /* binding */ useBalance; },\n/* harmony export */   useBlock: function() { return /* binding */ useBlock; },\n/* harmony export */   useBlockNumber: function() { return /* binding */ useBlockNumber; },\n/* harmony export */   useCall: function() { return /* binding */ useCall; },\n/* harmony export */   useConnect: function() { return /* binding */ useConnect; },\n/* harmony export */   useContract: function() { return /* binding */ useContract; },\n/* harmony export */   useContractFactory: function() { return /* binding */ useContractFactory; },\n/* harmony export */   useDeclareContract: function() { return /* binding */ useDeclareContract; },\n/* harmony export */   useDeployAccount: function() { return /* binding */ useDeployAccount; },\n/* harmony export */   useDisconnect: function() { return /* binding */ useDisconnect; },\n/* harmony export */   useEstimateFees: function() { return /* binding */ useEstimateFees; },\n/* harmony export */   useExplorer: function() { return /* binding */ useExplorer; },\n/* harmony export */   useInjectedConnectors: function() { return /* binding */ useInjectedConnectors; },\n/* harmony export */   useInvalidateOnBlock: function() { return /* binding */ useInvalidateOnBlock; },\n/* harmony export */   useNetwork: function() { return /* binding */ useNetwork; },\n/* harmony export */   useNonceForAddress: function() { return /* binding */ useNonceForAddress; },\n/* harmony export */   useProvider: function() { return /* binding */ useProvider; },\n/* harmony export */   useReadContract: function() { return /* binding */ useReadContract; },\n/* harmony export */   useSendTransaction: function() { return /* binding */ useSendTransaction; },\n/* harmony export */   useSignTypedData: function() { return /* binding */ useSignTypedData; },\n/* harmony export */   useStarkAddress: function() { return /* binding */ useStarkAddress; },\n/* harmony export */   useStarkName: function() { return /* binding */ useStarkName; },\n/* harmony export */   useStarkProfile: function() { return /* binding */ useStarkProfile; },\n/* harmony export */   useSwitchChain: function() { return /* binding */ useSwitchChain; },\n/* harmony export */   useTransactionReceipt: function() { return /* binding */ useTransactionReceipt; },\n/* harmony export */   useWalletRequest: function() { return /* binding */ useWalletRequest; },\n/* harmony export */   viewblock: function() { return /* binding */ viewblock; },\n/* harmony export */   voyager: function() { return /* binding */ voyager; }\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @starknet-io/types-js */ \"(app-pages-browser)/./node_modules/@starknet-io/types-js/dist/esm/wallet-api/constants.js\");\n/* harmony import */ var starknet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! starknet */ \"(app-pages-browser)/./node_modules/starknet/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _starknet_react_chains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @starknet-react/chains */ \"(app-pages-browser)/./node_modules/@starknet-react/chains/dist/index.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useMutation.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem */ \"(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js\");\n// src/connectors/base.ts\n\nvar Connector = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n};\n\n// src/connectors/injected.ts\n\n\n\n// src/errors.ts\nvar ConnectorAlreadyConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConnectorAlreadyConnectedError\";\n    this.message = \"Connector already connected\";\n  }\n};\nvar ConnectorNotConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConnectorNotConnectedError\";\n    this.message = \"Connector not connected\";\n  }\n};\nvar ConnectorNotFoundError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConnectorNotFoundError\";\n    this.message = \"Connector not found\";\n  }\n};\nvar UserRejectedRequestError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"UserRejectedRequestError\";\n    this.message = \"User rejected request\";\n  }\n};\nvar UserNotConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"UserNotConnectedError\";\n    this.message = \"User not connected\";\n  }\n};\nvar UnsupportedAccountInterfaceError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"UnsupportedAccountInterfaceError\";\n    this.message = \"Unsupported account interface. starknet-react v1 only supports the starknet.js v5 account interface\";\n  }\n};\n\n// src/connectors/injected.ts\nvar WALLET_NOT_FOUND_ICON_LIGHT = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+\";\nvar WALLET_NOT_FOUND_ICON_DARK = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==\";\nvar walletIcons = {\n  argentX: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI0LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA2NS4xOTUwOCA1Ny43MzU2MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNjUuMTk1MDggNTcuNzM1NjI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRkY4NzVCO30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTQwLjk4NTkyLDBIMjQuMjA4ODhjLTAuNTYsMC0xLjAxMDAxLDAuNDUxMDItMS4wMjE5NywxLjAxMjAyCgljLTAuMzM4OTksMTUuNzU1LTguNTgyMDMsMzAuNzA4OTgtMjIuNzcwMDIsNDEuMzAwOTljLTAuNDUwMDEsMC4zMzcwMS0wLjU1Mjk4LDAuOTY3OTktMC4yMjQsMS40MjNsOS44MTU5OCwxMy41NzMKCWMwLjMzNDA1LDAuNDYyMDEsMC45ODUwNSwwLjU2NTk4LDEuNDQyOTksMC4yMjY5OWM4Ljg3MTAzLTYuNTc5MDEsMTYuMDA3MDItMTQuNTE3LDIxLjE0NjA2LTIzLjMxNQoJYzUuMTM4LDguNzk4LDEyLjI3Mzk5LDE2LjczNTk5LDIxLjE0NiwyMy4zMTVjMC40NTY5NywwLjMzODk5LDEuMTA3OTcsMC4yMzUwMiwxLjQ0MTk2LTAuMjI2OTlsOS44MTYwNC0xMy41NzMKCWMwLjMyODk4LTAuNDU1MDIsMC4yMjY5OS0xLjA4Ni0wLjIyNC0xLjQyM0M1MC41ODk4NiwzMS43MjEwMSw0Mi4zNDY4OCwxNi43NjcwMyw0Mi4wMDc4OSwxLjAxMjAyCglDNDEuOTk1ODcsMC40NTEwMiw0MS41NDY4OSwwLDQwLjk4NTkyLDAiLz4KPC9zdmc+Cg==\",\n  braavos: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgdmlld0JveD0iMCAwIDUwMCA1MDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxwYXRoIGQ9Ik0zMjMuNDQgNDEuMzg4NkMzMjQuMTk4IDQyLjY3MjggMzIzLjE5NSA0NC4yNjAzIDMyMS43MDQgNDQuMjYwM0MyOTEuNTEgNDQuMjYwMyAyNjYuOTY1IDY4LjE2NTYgMjY2LjM4OSA5Ny44NzFDMjU2LjA1IDk1Ljk0MDcgMjQ1LjMzNyA5NS43OTU2IDIzNC43NTQgOTcuNTc4N0MyMzQuMDIzIDY4LjAwOSAyMDkuNTQgNDQuMjYwMyAxNzkuNDQ1IDQ0LjI2MDNDMTc3Ljk1MyA0NC4yNjAzIDE3Ni45NDkgNDIuNjcxNiAxNzcuNzA3IDQxLjM4NjVDMTkyLjMyMyAxNi42MzMgMjE5LjQ4MyAwIDI1MC41NzMgMEMyODEuNjY0IDAgMzA4LjgyNCAxNi42MzM5IDMyMy40NCA0MS4zODg2WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik00MTguNzU2IDIyNi44OTRDNDI2LjM3IDIyOS4yIDQzMy41ODEgMjIyLjUxNyA0MzEuMDM2IDIxNC45NzlDNDA0LjUwNyAxMzYuNDAxIDMxNi41MzUgMTA0LjM1OCAyNTAuMTU5IDEwNC4zNThDMTgzLjY3NCAxMDQuMzU4IDkzLjczOTEgMTM3LjQxOCA2OS4zMDUxIDIxNS4zMzFDNjYuOTU3NCAyMjIuODE4IDc0LjE0NjUgMjI5LjI3NSA4MS42NDc5IDIyNi45NzdMMjQ0LjI1IDE3Ny4xNTFDMjQ3LjU2OSAxNzYuMTM0IDI1MS4xMTYgMTc2LjEyOCAyNTQuNDM5IDE3Ny4xMzVMNDE4Ljc1NiAyMjYuODk0WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzIzMjRfNjE4NjkpIi8+CjxwYXRoIGQ9Ik02OS43MTY1IDIzOS40MjZMMjQ0LjM3IDE4Ni40NTZDMjQ3LjY2OSAxODUuNDU2IDI1MS4xOTEgMTg1LjQ1MyAyNTQuNDkyIDE4Ni40NDhMNDMwLjIzMiAyMzkuNDUyQzQ0NC43NiAyNDMuODMzIDQ1NC43MDEgMjU3LjIxNiA0NTQuNzAxIDI3Mi4zOVY0MzAuNDgxQzQ1NC4wMjggNDY5LjA3IDQxOS4zNjIgNTAwIDM4MC43ODYgNTAwSDMxNi43MTJDMzEwLjM3OSA1MDAgMzA1LjI1IDQ5NC44NzcgMzA1LjI1IDQ4OC41NDNWNDMzLjExNUMzMDUuMjUgNDExLjI4OSAzMTguMTY3IDM5MS41MzUgMzM4LjE1NSAzODIuNzkyQzM2NC45NDkgMzcxLjA3MSAzOTYuNjQ2IDM1NS4yMTggNDAyLjYwOCAzMjMuNDA2QzQwNC41MzIgMzEzLjEzOCAzOTcuODM3IDMwMy4yMzQgMzg3LjU5NSAzMDEuMTk4QzM2MS42OTkgMjk2LjA1MSAzMzIuOTg5IDI5OC4wMzkgMzA4LjcxMSAzMDguODk4QzI4MS4xNSAzMjEuMjI1IDI3My45NCAzNDEuNzMxIDI3MS4yNzEgMzY5LjI3TDI2OC4wMzYgMzk4LjkzOEMyNjcuMDQ3IDQwOC4wMDUgMjU4LjU0NiA0MTQuOTUyIDI0OS40MjkgNDE0Ljk1MkMyMzkuOTk4IDQxNC45NTIgMjMyLjkyNiA0MDcuNzY5IDIzMS45MDMgMzk4LjM4OEwyMjguNzI4IDM2OS4yN0MyMjYuNDQyIDM0NS42ODEgMjIyLjI5OCAzMjIuNzY3IDE5Ny45MTIgMzExLjg2QzE3MC4wOTUgMjk5LjQxOSAxNDIuMTQxIDI5NS4yODcgMTEyLjQwNCAzMDEuMTk4QzEwMi4xNjIgMzAzLjIzNCA5NS40NjcgMzEzLjEzOCA5Ny4zOTEzIDMyMy40MDZDMTAzLjQwNSAzNTUuNDk1IDEzNC44NTQgMzcwLjk4NSAxNjEuODQ0IDM4Mi43OTJDMTgxLjgzMyAzOTEuNTM1IDE5NC43NSA0MTEuMjg5IDE5NC43NSA0MzMuMTE1VjQ4OC41MzNDMTk0Ljc1IDQ5NC44NjcgMTg5LjYyMiA1MDAgMTgzLjI4OSA1MDBIMTE5LjIxNEM4MC42Mzc0IDUwMCA0NS45NzE2IDQ2OS4wNyA0NS4yOTc5IDQzMC40ODFWMjcyLjM0OUM0NS4yOTc5IDI1Ny4xOTQgNTUuMjE0MiAyNDMuODI0IDY5LjcxNjUgMjM5LjQyNloiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl8yMzI0XzYxODY5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzIzMjRfNjE4NjkiIHgxPSIyNDUuOTg2IiB5MT0iLTI3IiB4Mj0iNDI1LjQ5NiIgeTI9IjUwMi4zNzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0Y1RDQ1RSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk2MDAiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=\"\n};\nvar InjectedConnector = class extends Connector {\n  constructor({ options }) {\n    super();\n    this._options = options;\n  }\n  get id() {\n    return this._options.id;\n  }\n  get name() {\n    this.ensureWallet();\n    return this._options.name ?? this._wallet?.name ?? this._options.id;\n  }\n  get icon() {\n    this.ensureWallet();\n    const deafultIcon = {\n      dark: walletIcons[this.id] || WALLET_NOT_FOUND_ICON_DARK,\n      light: walletIcons[this.id] || WALLET_NOT_FOUND_ICON_LIGHT\n    };\n    return this._options.icon || this._wallet?.icon || deafultIcon;\n  }\n  available() {\n    this.ensureWallet();\n    return this._wallet !== void 0;\n  }\n  async chainId() {\n    this.ensureWallet();\n    const locked = await this.isLocked();\n    if (!this._wallet || locked) {\n      throw new ConnectorNotConnectedError();\n    }\n    try {\n      const chainIdHex = await this.request({ type: \"wallet_requestChainId\" });\n      const chainId = BigInt(chainIdHex);\n      return chainId;\n    } catch {\n      throw new ConnectorNotFoundError();\n    }\n  }\n  async ready() {\n    this.ensureWallet();\n    if (!this._wallet)\n      return false;\n    const permissions = await this.request({\n      type: \"wallet_getPermissions\"\n    });\n    return permissions?.includes(_starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__.Permission.ACCOUNTS);\n  }\n  async account(provider) {\n    this.ensureWallet();\n    const locked = await this.isLocked();\n    if (locked || !this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n    return new starknet__WEBPACK_IMPORTED_MODULE_1__.WalletAccount(provider, this._wallet);\n  }\n  async connect() {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n    let accounts;\n    try {\n      accounts = await this.request({\n        type: \"wallet_requestAccounts\"\n      });\n    } catch {\n      throw new UserRejectedRequestError();\n    }\n    if (!accounts) {\n      throw new UserRejectedRequestError();\n    }\n    this._wallet.on(\"accountsChanged\", async (accounts2) => {\n      await this.onAccountsChanged(accounts2);\n    });\n    this._wallet.on(\"networkChanged\", (chainId2, accounts2) => {\n      this.onNetworkChanged(chainId2, accounts2);\n    });\n    await this.onAccountsChanged(accounts);\n    const [account] = accounts;\n    const chainId = await this.chainId();\n    this.emit(\"connect\", { account, chainId });\n    return {\n      account,\n      chainId\n    };\n  }\n  async disconnect() {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n    this.emit(\"disconnect\");\n  }\n  async request(call) {\n    this.ensureWallet();\n    if (!this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n    try {\n      return await this._wallet.request(call);\n    } catch {\n      throw new UserRejectedRequestError();\n    }\n  }\n  async isLocked() {\n    const accounts = await this.request({\n      type: \"wallet_requestAccounts\",\n      params: { silent_mode: true }\n    });\n    return accounts.length === 0;\n  }\n  ensureWallet() {\n    const global_object = globalThis;\n    const wallet = global_object?.[`starknet_${this._options.id}`];\n    if (wallet) {\n      this._wallet = wallet;\n    }\n  }\n  async onAccountsChanged(accounts) {\n    if (!accounts) {\n      this.emit(\"disconnect\");\n    } else {\n      const [account] = accounts;\n      if (account) {\n        const chainId = await this.chainId();\n        this.emit(\"change\", { account, chainId });\n      } else {\n        this.emit(\"disconnect\");\n      }\n    }\n  }\n  onNetworkChanged(chainIdHex, accounts) {\n    if (chainIdHex) {\n      const chainId = BigInt(chainIdHex);\n      const [account] = accounts || [];\n      this.emit(\"change\", { chainId, account });\n    } else {\n      this.emit(\"change\", {});\n    }\n  }\n};\n\n// src/connectors/discovery.ts\n\n\n// src/connectors/helpers.ts\nfunction argent() {\n  return new InjectedConnector({\n    options: {\n      id: \"argentX\",\n      name: \"Argent X\"\n    }\n  });\n}\nfunction braavos() {\n  return new InjectedConnector({\n    options: {\n      id: \"braavos\",\n      name: \"Braavos\"\n    }\n  });\n}\nfunction injected({ id }) {\n  return new InjectedConnector({\n    options: {\n      id\n    }\n  });\n}\n\n// src/connectors/discovery.ts\nfunction useInjectedConnectors({\n  recommended,\n  includeRecommended = \"always\",\n  order = \"alphabetical\"\n}) {\n  const [injectedConnectors, setInjectedConnectors] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n  const refreshConnectors = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    const wallets = scanObjectForWallets(window);\n    const connectors2 = wallets.map((wallet) => injected({ id: wallet.id }));\n    setInjectedConnectors(connectors2);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    refreshConnectors();\n  }, [refreshConnectors]);\n  const connectors = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    return mergeConnectors(injectedConnectors, recommended ?? [], {\n      includeRecommended,\n      order\n    });\n  }, [injectedConnectors, recommended, includeRecommended, order]);\n  return { connectors };\n}\nfunction mergeConnectors(injected2, recommended, {\n  includeRecommended,\n  order\n}) {\n  const injectedIds = new Set(injected2.map((connector) => connector.id));\n  const allConnectors = [...injected2];\n  const shouldAddRecommended = includeRecommended === \"always\" || includeRecommended === \"onlyIfNoConnectors\" && injected2.length === 0;\n  if (shouldAddRecommended) {\n    allConnectors.push(\n      ...recommended.filter((connector) => !injectedIds.has(connector.id))\n    );\n  }\n  if (order === \"random\") {\n    return shuffle(allConnectors);\n  }\n  return allConnectors.sort((a, b) => a.id.localeCompare(b.id));\n}\nfunction shuffle(arr) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\nfunction scanObjectForWallets(obj) {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet;\n        }\n      }\n      return wallets;\n    }, {})\n  );\n}\nfunction isWalletObject(wallet) {\n  try {\n    return wallet && [\n      // wallet's must have methods/members, see IStarknetWindowObject\n      \"request\",\n      \"isConnected\",\n      \"provider\",\n      \"enable\",\n      \"isPreauthorized\",\n      \"on\",\n      \"off\",\n      \"version\",\n      \"id\",\n      \"name\",\n      \"icon\"\n    ].every((key) => key in wallet);\n  } catch (err) {\n  }\n  return false;\n}\n\n// src/connectors/mock.ts\n\n\nvar MockConnector = class extends Connector {\n  constructor({\n    accounts,\n    options\n  }) {\n    super();\n    this._accountIndex = 0;\n    this._connected = false;\n    this._chainId = _starknet_react_chains__WEBPACK_IMPORTED_MODULE_4__.devnet.id;\n    if (accounts.mainnet.length === 0 || accounts.sepolia.length === 0) {\n      throw new Error(\"MockConnector: accounts must not be empty\");\n    }\n    this._accounts = accounts;\n    this.options = options;\n  }\n  switchChain(chainId) {\n    this._chainId = chainId;\n    this._accountIndex = 0;\n    let account;\n    if (this.options.unifiedSwitchAccountAndChain) {\n      account = this._account.address;\n    }\n    this.emit(\"change\", { chainId, account });\n    if (this.options.emitChangeAccountOnChainSwitch ?? true) {\n      this.switchAccount(this._accountIndex);\n    }\n  }\n  switchAccount(accountIndex) {\n    this._accountIndex = accountIndex;\n    this.emit(\"change\", { account: this._account.address });\n  }\n  get id() {\n    return this.options.id;\n  }\n  get name() {\n    return this.options.name;\n  }\n  get icon() {\n    return this.options.icon ?? \"\";\n  }\n  available() {\n    return this.options.available ?? true;\n  }\n  async chainId() {\n    const chainIdHex = await this.request({ type: \"wallet_requestChainId\" });\n    const chainId = BigInt(chainIdHex);\n    return chainId;\n  }\n  async ready() {\n    const permissions = await this.request({\n      type: \"wallet_getPermissions\"\n    });\n    if (!permissions?.includes(_starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__.Permission.ACCOUNTS)) {\n      return false;\n    }\n    return true;\n  }\n  async connect() {\n    if (this.options.failConnect) {\n      throw new UserRejectedRequestError();\n    }\n    this._connected = true;\n    const accounts = await this.request({\n      type: \"wallet_requestAccounts\",\n      params: { silent_mode: true }\n    });\n    const chainId = await this.chainId();\n    const [account] = accounts;\n    return { account, chainId };\n  }\n  async disconnect() {\n    this._connected = false;\n    this.emit(\"disconnect\");\n  }\n  async request(call) {\n    const { type, params } = call;\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n    if (this.options.rejectRequest) {\n      throw new UserRejectedRequestError();\n    }\n    switch (type) {\n      case \"wallet_requestChainId\":\n        return this._chainId.toString();\n      case \"wallet_getPermissions\":\n        if (this._connected)\n          return [_starknet_io_types_js__WEBPACK_IMPORTED_MODULE_2__.Permission.ACCOUNTS];\n        return [];\n      case \"wallet_requestAccounts\":\n        return [this._account.address];\n      case \"wallet_addStarknetChain\":\n        return true;\n      case \"wallet_switchStarknetChain\": {\n        if (!params)\n          throw new Error(\"Params are missing\");\n        const { chainId } = params;\n        this.switchChain(BigInt(chainId));\n        return true;\n      }\n      case \"wallet_addDeclareTransaction\": {\n        if (!params)\n          throw new Error(\"Params are missing\");\n        const { compiled_class_hash, contract_class, class_hash } = params;\n        return await this._account.declare({\n          compiledClassHash: compiled_class_hash,\n          contract: {\n            ...contract_class,\n            abi: JSON.parse(contract_class.abi)\n          },\n          classHash: class_hash\n        });\n      }\n      case \"wallet_addInvokeTransaction\": {\n        if (!params)\n          throw new Error(\"Params are missing\");\n        const { calls } = params;\n        return await this._account.execute(transformCalls(calls));\n      }\n      case \"wallet_signTypedData\": {\n        if (!params)\n          throw new Error(\"Params are missing\");\n        const { domain, message, primaryType, types } = params;\n        return await this._account.signMessage({\n          domain,\n          message,\n          primaryType,\n          types\n        });\n      }\n      default:\n        throw new Error(\"Unknown request type\");\n    }\n  }\n  async account(provider) {\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n    if (!this._connected) {\n      throw new ConnectorNotConnectedError();\n    }\n    return this._account;\n  }\n  get _account() {\n    let account;\n    if (this._chainId === _starknet_react_chains__WEBPACK_IMPORTED_MODULE_4__.mainnet.id) {\n      account = this._accounts.mainnet[this._accountIndex];\n    } else {\n      account = this._accounts.sepolia[this._accountIndex];\n    }\n    if (!account) {\n      throw new ConnectorNotConnectedError();\n    }\n    return account;\n  }\n};\nfunction transformCalls(calls) {\n  return calls.map(\n    (call) => ({\n      contractAddress: call.contract_address,\n      entrypoint: call.entry_point,\n      calldata: call.calldata\n    })\n  );\n}\n\n// src/context/starknet.tsx\n\n\n\n\n\n// src/context/account.tsx\n\n\nvar AccountContext = react__WEBPACK_IMPORTED_MODULE_3__.createContext(\n  void 0\n);\nfunction useStarknetAccount() {\n  const account = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(AccountContext);\n  return { account };\n}\nfunction AccountProvider({\n  account,\n  children\n}) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(AccountContext.Provider, { value: account, children });\n}\n\n// src/context/starknet.tsx\n\nvar defaultQueryClient = new _tanstack_react_query__WEBPACK_IMPORTED_MODULE_6__.QueryClient();\nvar StarknetContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(void 0);\nfunction useStarknet() {\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(StarknetContext);\n  if (!state) {\n    throw new Error(\n      \"useStarknet must be used within a StarknetProvider or StarknetConfig\"\n    );\n  }\n  return state;\n}\nfunction useStarknetManager({\n  chains,\n  provider,\n  explorer,\n  connectors = [],\n  autoConnect = false\n}) {\n  const initialChain = chains[0];\n  if (initialChain === void 0) {\n    throw new Error(\"Must provide at least one chain.\");\n  }\n  const { chain: defaultChain, provider: defaultProvider } = providerForChain(\n    initialChain,\n    provider\n  );\n  const connectorRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n    currentChain: defaultChain,\n    currentProvider: defaultProvider,\n    connectors\n  });\n  const updateChainAndProvider = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    ({ chainId }) => {\n      if (!chainId)\n        return;\n      for (const chain of chains) {\n        if (chain.id === chainId) {\n          const { chain: newChain, provider: newProvider } = providerForChain(\n            chain,\n            provider\n          );\n          setState((state2) => ({\n            ...state2,\n            currentChain: newChain,\n            currentProvider: newProvider\n          }));\n          return;\n        }\n      }\n    },\n    [chains, provider]\n  );\n  const handleConnectorChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    async ({ chainId, account }) => {\n      if (chainId) {\n        updateChainAndProvider({ chainId });\n      }\n      if (account && connectorRef.current) {\n        const account2 = await connectorRef.current.account(\n          state.currentProvider\n        );\n        setState((state2) => ({\n          ...state2,\n          currentAccount: account2\n        }));\n      }\n    },\n    [updateChainAndProvider, state.currentProvider]\n  );\n  const connect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    async ({ connector }) => {\n      if (!connector) {\n        throw new Error(\"Must provide a connector.\");\n      }\n      const needsListenerSetup = connectorRef.current?.id !== connector.id;\n      if (needsListenerSetup) {\n        connectorRef.current?.off(\"change\", handleConnectorChange);\n      }\n      try {\n        const { chainId } = await connector.connect();\n        const account = await connector.account(state.currentProvider);\n        if (account.address !== state.currentAccount?.address) {\n          connectorRef.current = connector;\n          setState((state2) => ({\n            ...state2,\n            currentAccount: account\n          }));\n        }\n        if (autoConnect) {\n          localStorage.setItem(\"lastUsedConnector\", connector.id);\n        }\n        if (needsListenerSetup) {\n          connector.on(\"change\", handleConnectorChange);\n        }\n        updateChainAndProvider({ chainId });\n      } catch (err) {\n        setState((state2) => ({\n          ...state2,\n          error: new ConnectorNotFoundError()\n        }));\n        throw err;\n      }\n    },\n    [\n      autoConnect,\n      state.currentAccount,\n      state.currentProvider,\n      handleConnectorChange,\n      updateChainAndProvider\n    ]\n  );\n  const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n    setState((state2) => ({\n      ...state2,\n      currentAccount: void 0,\n      currentProvider: defaultProvider,\n      currentChain: defaultChain\n    }));\n    if (autoConnect) {\n      localStorage.removeItem(\"lastUsedConnector\");\n    }\n    if (!connectorRef.current)\n      return;\n    connectorRef.current.off(\"change\", handleConnectorChange);\n    try {\n      await connectorRef.current.disconnect();\n    } catch {\n    }\n    connectorRef.current = void 0;\n  }, [autoConnect, handleConnectorChange, defaultProvider, defaultChain]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    async function tryAutoConnect(connectors2) {\n      const lastConnectedConnectorId = localStorage.getItem(\"lastUsedConnector\");\n      if (lastConnectedConnectorId === null) {\n        return;\n      }\n      const lastConnectedConnector = connectors2.find(\n        (connector) => connector.id === lastConnectedConnectorId\n      );\n      if (lastConnectedConnector === void 0) {\n        return;\n      }\n      try {\n        if (!await lastConnectedConnector.ready()) {\n          return;\n        }\n        connect({ connector: lastConnectedConnector });\n      } catch {\n      }\n    }\n    if (autoConnect && !connectorRef.current) {\n      tryAutoConnect(connectors);\n    }\n  }, []);\n  return {\n    account: state.currentAccount,\n    provider: state.currentProvider,\n    chain: state.currentChain,\n    connector: connectorRef.current,\n    explorer,\n    connect,\n    disconnect,\n    connectors,\n    chains\n  };\n}\nfunction StarknetProvider({\n  chains,\n  provider,\n  connectors,\n  explorer,\n  autoConnect,\n  queryClient,\n  children\n}) {\n  const { account, ...state } = useStarknetManager({\n    chains,\n    provider,\n    explorer,\n    connectors,\n    autoConnect\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__.QueryClientProvider, { client: queryClient ?? defaultQueryClient, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(StarknetContext.Provider, { value: state, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(AccountProvider, { account, children }) }) });\n}\nfunction providerForChain(chain, factory) {\n  const provider = factory(chain);\n  if (provider) {\n    return { chain, provider };\n  }\n  throw new Error(`No provider found for chain ${chain.name}`);\n}\nfunction starknetChainId(chainId) {\n  switch (chainId) {\n    case _starknet_react_chains__WEBPACK_IMPORTED_MODULE_4__.mainnet.id:\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.StarknetChainId.SN_MAIN;\n    case _starknet_react_chains__WEBPACK_IMPORTED_MODULE_4__.sepolia.id:\n      return starknet__WEBPACK_IMPORTED_MODULE_1__.constants.StarknetChainId.SN_SEPOLIA;\n    default:\n      return void 0;\n  }\n}\n\n// src/context/index.tsx\n\nfunction StarknetConfig({ children, ...config }) {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(StarknetProvider, { ...config, children });\n}\n\n// src/explorers/starkCompass.ts\nvar StarkCompassExplorer = class {\n  constructor(chain) {\n    this.name = \"Stark Compass\";\n    this.link = chain.explorers?.[\"starkCompass\"]?.toString() ?? \"\";\n  }\n  block(hashOrNumber) {\n    return `${this.link}/blocks/${hashOrNumber.hash ?? hashOrNumber.number}`;\n  }\n  transaction(hash) {\n    return `${this.link}/transactions/${hash}`;\n  }\n  contract(address) {\n    return `${this.link}/contracts/${address}`;\n  }\n  class(hash) {\n    return `${this.link}/classes/${hash}`;\n  }\n};\nvar starkcompass = (chain) => {\n  return new StarkCompassExplorer(chain);\n};\n\n// src/explorers/starkscan.ts\nvar StarkscanExplorer = class {\n  constructor(chain) {\n    this.name = \"Starkscan\";\n    this.link = chain.explorers?.[\"starkscan\"]?.toString() ?? \"\";\n  }\n  block(hashOrNumber) {\n    return `${this.link}/block/${hashOrNumber.hash ?? hashOrNumber.number}`;\n  }\n  transaction(hash) {\n    return `${this.link}/tx/${hash}`;\n  }\n  contract(address) {\n    return `${this.link}/contract/${address}`;\n  }\n  class(hash) {\n    return `${this.link}/class/${hash}`;\n  }\n};\nvar starkscan = (chain) => {\n  return new StarkscanExplorer(chain);\n};\n\n// src/explorers/viewblock.ts\nvar ViewblockExplorer = class {\n  constructor(chain) {\n    this.name = \"Viewblock\";\n    this.link = chain.explorers?.[\"viewblock\"]?.toString() ?? \"\";\n  }\n  block(hashOrNumber) {\n    if (hashOrNumber.hash && hashOrNumber.number === void 0) {\n      throw new Error(\n        \"The viewblock explorer doesnt support hashes for blocks. Please provide a hash.\"\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.number}`;\n  }\n  transaction(hash) {\n    return `${this.link}/tx/${hash}`;\n  }\n  contract(address) {\n    return `${this.link}/contract/${address}`;\n  }\n  class(hash) {\n    return `${this.link}/class/${hash}`;\n  }\n};\nvar viewblock = (chain) => {\n  return new ViewblockExplorer(chain);\n};\n\n// src/explorers/voyager.ts\nvar VoyagerExplorer = class {\n  constructor(chain) {\n    this.name = \"Voyager\";\n    this.link = chain.explorers?.[\"voyager\"]?.toString() ?? \"\";\n  }\n  block(hashOrNumber) {\n    if (hashOrNumber.number !== void 0 && hashOrNumber.hash === void 0) {\n      throw new Error(\n        \"The voyager explorer doesn't support numbers for blocks. Please provide a hash.\"\n      );\n    }\n    return `${this.link}/block/${hashOrNumber.hash}`;\n  }\n  transaction(hash) {\n    return `${this.link}/tx/${hash}`;\n  }\n  contract(address) {\n    return `${this.link}/contract/${address}`;\n  }\n  class(hash) {\n    return `${this.link}/class/${hash}`;\n  }\n};\nvar voyager = (chain) => {\n  return new VoyagerExplorer(chain);\n};\n\n// src/hooks/use-account.ts\n\n\n// src/hooks/use-connect.ts\n\n\n// src/query.ts\n\nfunction useQuery(args) {\n  const base = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_8__.useQuery)(args);\n  return {\n    data: base.data,\n    error: base.error,\n    status: base.status,\n    isSuccess: base.isSuccess,\n    isError: base.isError,\n    isPending: base.isPending,\n    fetchStatus: base.fetchStatus,\n    isFetching: base.isFetching,\n    isLoading: base.isLoading,\n    refetch: base.refetch\n  };\n}\nfunction useMutation(args) {\n  const base = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_9__.useMutation)(args);\n  return {\n    data: base.data,\n    error: base.error,\n    reset: base.reset,\n    isError: base.isError,\n    isIdle: base.isIdle,\n    isPending: base.isPending,\n    isSuccess: base.isSuccess,\n    isPaused: base.isPaused,\n    mutate: base.mutate,\n    mutateAsync: base.mutateAsync,\n    status: base.status,\n    variables: base.variables\n  };\n}\n\n// src/hooks/use-connect.ts\nfunction useConnect(props = {}) {\n  const { connector, connectors, connect: connect_, chain } = useStarknet();\n  const { mutate, mutateAsync, variables, ...result } = useMutation({\n    mutationKey: [{ entity: \"connect\", chainId: chain.name }],\n    mutationFn: connect_,\n    ...props\n  });\n  const connect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (args) => mutate(args ?? { connector }),\n    [mutate, connector]\n  );\n  const connectAsync = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (args) => mutateAsync(args ?? { connector }),\n    [mutateAsync, connector]\n  );\n  return {\n    connector,\n    connectors,\n    pendingConnector: variables?.connector,\n    connect,\n    connectAsync,\n    variables,\n    ...result\n  };\n}\n\n// src/hooks/use-account.ts\nfunction useAccount() {\n  const { account: connectedAccount } = useStarknetAccount();\n  const { connectors } = useConnect();\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n    status: \"disconnected\"\n  });\n  const refreshState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n    if (!connectedAccount) {\n      return setState({\n        status: \"disconnected\",\n        isDisconnected: true,\n        isConnected: false,\n        isConnecting: false,\n        isReconnecting: false\n      });\n    }\n    for (const connector of connectors) {\n      if (!connector.available())\n        continue;\n      let connAccount;\n      try {\n        connAccount = await connector.request({\n          type: \"wallet_requestAccounts\",\n          params: { silent_mode: true }\n        });\n      } catch {\n      }\n      if (connAccount?.[0] === connectedAccount.address) {\n        return setState({\n          connector,\n          chainId: await connector.chainId(),\n          account: connectedAccount,\n          address: connectedAccount.address,\n          status: \"connected\",\n          isConnected: true,\n          isConnecting: false,\n          isDisconnected: false,\n          isReconnecting: false\n        });\n      }\n    }\n    setState({\n      connector: void 0,\n      chainId: void 0,\n      account: connectedAccount,\n      address: connectedAccount.address,\n      status: \"connected\",\n      isConnected: true,\n      isConnecting: false,\n      isDisconnected: false,\n      isReconnecting: false\n    });\n  }, [connectedAccount, connectors]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    refreshState();\n  }, [refreshState]);\n  return state;\n}\n\n// src/hooks/use-wallet-request.ts\n\nfunction useWalletRequest(props) {\n  const { connector } = useStarknet();\n  const { type, params, ...rest } = props;\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ type, params }),\n    mutationFn: mutationFn({ connector }),\n    ...rest\n  });\n  const request = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (args) => mutate(args ?? { type, params }),\n    [mutate, type, params]\n  );\n  const requestAsync = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (args) => mutateAsync(args ?? { type, params }),\n    [mutateAsync, type, params]\n  );\n  return {\n    request,\n    requestAsync,\n    ...result\n  };\n}\nfunction mutationKey({\n  type,\n  params\n}) {\n  return [{ entity: \"walletRequest\", type, params }];\n}\nfunction mutationFn({\n  connector\n}) {\n  return async ({ type, params }) => {\n    if (!connector)\n      throw new Error(\"No connector connected\");\n    if (!type)\n      throw new Error(\"Type is required\");\n    return await connector.request({ type, params });\n  };\n}\n\n// src/hooks/use-add-chain.ts\nfunction useAddChain(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addStarknetChain\",\n    params,\n    ...rest\n  });\n  const addChain = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_addStarknetChain\"\n      } : void 0\n    );\n  };\n  const addChainAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_addStarknetChain\"\n      } : void 0\n    );\n  };\n  return {\n    addChain,\n    addChainAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-balance.ts\n\n\n\n\n// src/hooks/use-contract.ts\n\n\nfunction useContract({\n  abi,\n  address,\n  provider: providedProvider\n}) {\n  const { provider: currentProvider } = useStarknet();\n  const contract = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    const provider = providedProvider ? providedProvider : currentProvider;\n    if (abi && address && provider) {\n      return new starknet__WEBPACK_IMPORTED_MODULE_1__.Contract(abi, address, provider).typedv2(\n        abi\n      );\n    }\n    return void 0;\n  }, [abi, address, providedProvider, currentProvider]);\n  return { contract };\n}\n\n// src/hooks/use-invalidate-on-block.ts\n\n\n\n// src/hooks/use-block-number.ts\n\nfunction useBlockNumber({\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n} = {}) {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey({ blockIdentifier }) {\n  return [{ entity: \"blockNumber\", blockIdentifier }];\n}\nfunction queryFn({\n  provider,\n  blockIdentifier\n}) {\n  return async () => {\n    const block = await provider.getBlock(blockIdentifier);\n    if (block.status !== \"PENDING\") {\n      return block.block_number;\n    }\n    return void 0;\n  };\n}\n\n// src/hooks/use-invalidate-on-block.ts\nfunction useInvalidateOnBlock({\n  enabled = true,\n  queryKey: queryKey11\n}) {\n  const queryClient = (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_7__.useQueryClient)();\n  const [prevBlockNumber, setPrevBlockNumber] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n  const { data: blockNumber } = useBlockNumber({\n    enabled\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!prevBlockNumber) {\n      return setPrevBlockNumber(blockNumber);\n    }\n    if (blockNumber !== prevBlockNumber) {\n      queryClient.invalidateQueries({ queryKey: queryKey11 }, { cancelRefetch: false });\n      return setPrevBlockNumber(blockNumber);\n    }\n  }, [blockNumber, prevBlockNumber, queryKey11, queryClient]);\n}\n\n// src/hooks/use-network.ts\nfunction useNetwork() {\n  const { chain, chains } = useStarknet();\n  return { chain, chains };\n}\n\n// src/hooks/use-balance.ts\nvar DEFAULT_FETCH_INTERVAL = 5e3;\nfunction useBalance({\n  token: token_,\n  address,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n}) {\n  const { chain } = useNetwork();\n  const token = token_ ?? chain.nativeCurrency.address;\n  const { contract } = useContract({\n    abi: balanceABIFragment,\n    address: token\n  });\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => queryKey2({ chain, token, address, blockIdentifier }),\n    [chain, token, address, blockIdentifier]\n  );\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => Boolean(enabled_ && contract && address),\n    [enabled_, contract, address]\n  );\n  const refetchInterval = refetchInterval_ ?? (blockIdentifier === starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.PENDING && watch ? DEFAULT_FETCH_INTERVAL : void 0);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    enabled,\n    refetchInterval,\n    queryKey: queryKey_,\n    queryFn: queryFn2({ chain, contract, token, address, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey2({\n  chain,\n  token,\n  address,\n  blockIdentifier\n}) {\n  return [\n    {\n      entity: \"balance\",\n      chainId: chain?.name,\n      token,\n      address,\n      blockIdentifier\n    }\n  ];\n}\nfunction queryFn2({\n  chain,\n  token,\n  address,\n  contract,\n  blockIdentifier\n}) {\n  return async () => {\n    if (!address)\n      throw new Error(\"address is required\");\n    if (!contract)\n      throw new Error(\"contract is required\");\n    const options = {\n      blockIdentifier\n    };\n    const isNativeCurrency = token === chain.nativeCurrency.address;\n    let symbol = chain.nativeCurrency.symbol;\n    if (!isNativeCurrency) {\n      const symbol_ = await contract.symbol(options);\n      symbol = starknet__WEBPACK_IMPORTED_MODULE_1__.shortString.decodeShortString(starknet__WEBPACK_IMPORTED_MODULE_1__.num.toHex(symbol_));\n    }\n    let decimals = chain.nativeCurrency.decimals;\n    if (!isNativeCurrency) {\n      const decimals_ = await contract.decimals(options);\n      decimals = Number(decimals_);\n    }\n    const balanceOf = await contract.balanceOf(address, options);\n    const formatted = (0,viem__WEBPACK_IMPORTED_MODULE_10__.formatUnits)(balanceOf, decimals);\n    return {\n      value: balanceOf,\n      decimals,\n      symbol,\n      formatted\n    };\n  };\n}\nvar balanceABIFragment = [\n  {\n    name: \"core::integer::u256\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"low\",\n        type: \"core::integer::u128\"\n      },\n      {\n        name: \"high\",\n        type: \"core::integer::u128\"\n      }\n    ]\n  },\n  {\n    name: \"balanceOf\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"account\",\n        type: \"core::starknet::contract_address::ContractAddress\"\n      }\n    ],\n    outputs: [\n      {\n        type: \"core::integer::u256\"\n      }\n    ],\n    state_mutability: \"view\"\n  },\n  {\n    name: \"symbol\",\n    type: \"function\",\n    inputs: [],\n    outputs: [\n      {\n        type: \"core::felt252\"\n      }\n    ],\n    state_mutability: \"view\"\n  },\n  {\n    name: \"decimals\",\n    type: \"function\",\n    inputs: [],\n    outputs: [\n      {\n        type: \"core::integer::u8\"\n      }\n    ],\n    state_mutability: \"view\"\n  }\n];\n\n// src/hooks/use-block.ts\n\nfunction useBlock({\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n} = {}) {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey3({ blockIdentifier }),\n    queryFn: queryFn3({ provider, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey3({ blockIdentifier }) {\n  return [{ entity: \"block\", blockIdentifier }];\n}\nfunction queryFn3({\n  provider,\n  blockIdentifier\n}) {\n  return async () => await provider.getBlock(blockIdentifier);\n}\n\n// src/hooks/use-call.ts\n\n\nvar DEFAULT_FETCH_INTERVAL2 = 5e3;\nfunction useCall({\n  abi,\n  address,\n  functionName,\n  args,\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  refetchInterval: refetchInterval_,\n  watch = false,\n  enabled: enabled_ = true,\n  parseArgs,\n  parseResult,\n  ...props\n}) {\n  const { chain } = useNetwork();\n  const { contract } = useContract({ abi, address });\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => queryKey4({\n      chain,\n      contract,\n      functionName,\n      args,\n      blockIdentifier\n    }),\n    [chain, contract, functionName, args, blockIdentifier]\n  );\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => Boolean(enabled_ && contract && functionName && args),\n    [enabled_, contract, functionName, args]\n  );\n  const refetchInterval = refetchInterval_ ?? (blockIdentifier === starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.PENDING && watch ? DEFAULT_FETCH_INTERVAL2 : void 0);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn4({\n      contract,\n      functionName,\n      args,\n      blockIdentifier,\n      parseArgs,\n      parseResult\n    }),\n    refetchInterval,\n    enabled,\n    ...props\n  });\n}\nfunction queryKey4({\n  chain,\n  contract,\n  functionName,\n  args,\n  blockIdentifier\n}) {\n  return [\n    {\n      entity: \"readContract\",\n      chainId: chain?.name,\n      contract: contract?.address,\n      functionName,\n      args,\n      blockIdentifier\n    }\n  ];\n}\nfunction queryFn4({\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n  parseArgs = true,\n  parseResult = true\n}) {\n  return async () => {\n    if (!contract)\n      throw new Error(\"contract is required\");\n    if (contract.functions[functionName] === void 0) {\n      throw new Error(`function ${functionName} not found in contract`);\n    }\n    return contract.call(functionName, args, {\n      parseRequest: parseArgs,\n      parseResponse: parseResult,\n      blockIdentifier\n    });\n  };\n}\n\n// src/hooks/use-contract-factory.ts\n\n\nfunction useContractFactory({\n  compiledContract,\n  classHash,\n  abi\n}) {\n  const { account } = useAccount();\n  const contractFactory = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    if (compiledContract && account && classHash) {\n      return new starknet__WEBPACK_IMPORTED_MODULE_1__.ContractFactory({\n        compiledContract,\n        classHash,\n        account,\n        abi\n      });\n    }\n    return void 0;\n  }, [compiledContract, classHash, account, abi]);\n  return { contractFactory };\n}\n\n// src/hooks/use-declare-contract.ts\nfunction useDeclareContract(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addDeclareTransaction\",\n    params,\n    ...rest\n  });\n  const declare = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_addDeclareTransaction\"\n      } : void 0\n    );\n  };\n  const declareAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_addDeclareTransaction\"\n      } : void 0\n    );\n  };\n  return {\n    declare,\n    declareAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-deploy-account.ts\nfunction useDeployAccount({\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n  ...props\n}) {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey2({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options\n    }),\n    mutationFn: mutationFn2({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options\n    }),\n    ...props\n  });\n  return {\n    deployAccount: mutate,\n    deployAccountAsync: mutateAsync,\n    ...result\n  };\n}\nfunction mutationKey2(props) {\n  return [{ entity: \"deployAccount\", ...props }];\n}\nfunction mutationFn2({\n  account,\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options\n}) {\n  return async () => {\n    if (!account)\n      throw new Error(\"account is required\");\n    if (!classHash)\n      throw new Error(\"classHash is required\");\n    return await account.deployAccount(\n      { classHash, constructorCalldata, addressSalt, contractAddress },\n      options\n    );\n  };\n}\n\n// src/hooks/use-disconnect.ts\nfunction useDisconnect(props = {}) {\n  const { disconnect, chain } = useStarknet();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: [{ entity: \"disconnect\", chainId: chain.name }],\n    mutationFn: disconnect,\n    ...props\n  });\n  return {\n    disconnect: mutate,\n    disconnectAsync: mutateAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-estimate-fees.ts\n\nfunction useEstimateFees({\n  calls,\n  options,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { account } = useAccount();\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => queryKey5({ calls, options }),\n    [calls, options]\n  );\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => Boolean(enabled_ && calls), [enabled_, calls]);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn5({\n      account,\n      calls,\n      options\n    }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey5({ calls, options }) {\n  return [\n    {\n      entity: \"estimateInvokeFee\",\n      calls,\n      options\n    }\n  ];\n}\nfunction queryFn5({\n  account,\n  calls,\n  options\n}) {\n  return async () => {\n    if (!account)\n      throw new Error(\"account is required\");\n    if (!calls || calls.length === 0)\n      throw new Error(\"calls are required\");\n    return account?.estimateInvokeFee(calls, options);\n  };\n}\n\n// src/hooks/use-explorer.ts\nfunction useExplorer() {\n  const { explorer, chain } = useStarknet();\n  if (!explorer)\n    throw Error(\"Explorer is undefined. Try adding it to StarknetConfig.\");\n  const explorerInstance = explorer(chain);\n  if (!explorerInstance)\n    throw Error(\"Explorer Instance is undefined\");\n  return explorerInstance;\n}\n\n// src/hooks/use-nonce-for-address.ts\n\nfunction useNonceForAddress({\n  address,\n  blockIdentifier = starknet__WEBPACK_IMPORTED_MODULE_1__.BlockTag.LATEST,\n  ...props\n}) {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey6({ address, blockIdentifier }),\n    queryFn: queryFn6({ address, provider, blockIdentifier }),\n    ...props\n  });\n}\nfunction queryKey6({\n  address,\n  blockIdentifier\n}) {\n  return [{ entity: \"nonce\", blockIdentifier, address }];\n}\nfunction queryFn6({\n  provider,\n  blockIdentifier,\n  address\n}) {\n  return async () => {\n    const nonce = await provider.getNonceForAddress(address, blockIdentifier);\n    return nonce;\n  };\n}\n\n// src/hooks/use-provider.ts\nfunction useProvider() {\n  const { provider } = useStarknet();\n  return { provider };\n}\n\n// src/hooks/use-read-contract.ts\nfunction useReadContract(props) {\n  return useCall(props);\n}\n\n// src/hooks/use-send-transaction.ts\nfunction useSendTransaction(props) {\n  const { calls, ...rest } = props;\n  const params = calls ? { calls: transformCalls2(calls) } : void 0;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_addInvokeTransaction\",\n    params,\n    ...rest\n  });\n  const send = (args) => {\n    return request(\n      args ? {\n        params: { calls: transformCalls2(args) },\n        type: \"wallet_addInvokeTransaction\"\n      } : void 0\n    );\n  };\n  const sendAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: { calls: transformCalls2(args) },\n        type: \"wallet_addInvokeTransaction\"\n      } : void 0\n    );\n  };\n  return {\n    send,\n    sendAsync,\n    ...result\n  };\n}\nfunction transformCalls2(calls) {\n  return calls.map(\n    (call) => ({\n      contract_address: call.contractAddress,\n      entry_point: call.entrypoint,\n      calldata: call.calldata\n    })\n  );\n}\n\n// src/hooks/use-sign.ts\nfunction useSignTypedData(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_signTypedData\",\n    params,\n    ...rest\n  });\n  const signTypedData = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_signTypedData\"\n      } : void 0\n    );\n  };\n  const signTypedDataAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_signTypedData\"\n      } : void 0\n    );\n  };\n  return {\n    signTypedData,\n    signTypedDataAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-stark-address.ts\n\n\nfunction useStarkAddress({\n  name,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => Boolean(enabled_ && name), [enabled_, name]);\n  return useQuery({\n    queryKey: queryKey7({ name, contract, network: chain.network }),\n    queryFn: queryFn7({ name, contract, provider, network: chain.network }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey7({\n  name,\n  contract,\n  network\n}) {\n  return [{ entity: \"addressFromStarkName\", name, contract, network }];\n}\nfunction queryFn7({\n  name,\n  contract,\n  provider,\n  network\n}) {\n  return async () => {\n    if (!name)\n      throw new Error(\"name is required\");\n    const namingContract = contract ?? StarknetIdNamingContract[network];\n    const p = new starknet__WEBPACK_IMPORTED_MODULE_1__.Provider(provider);\n    const encodedDomain = encodeDomain(name);\n    const result = await p.callContract({\n      contractAddress: namingContract,\n      entrypoint: \"domain_to_address\",\n      calldata: starknet__WEBPACK_IMPORTED_MODULE_1__.CallData.compile({ domain: encodedDomain, hint: [] })\n    });\n    if (BigInt(result[0]) === BigInt(0))\n      throw new Error(\"Address not found\");\n    return result[0];\n  };\n}\nvar StarknetIdNamingContract = {\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\"\n};\nvar encodeDomain = (domain) => {\n  if (!domain)\n    return [\"0\"];\n  const encoded = [];\n  for (const subdomain of domain.replace(\".stark\", \"\").split(\".\"))\n    encoded.push(starknet__WEBPACK_IMPORTED_MODULE_1__.starknetId.useEncoded(subdomain).toString(10));\n  return encoded;\n};\n\n// src/hooks/use-stark-name.ts\n\n\nfunction useStarkName({\n  address,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => Boolean(enabled_ && address),\n    [enabled_, address]\n  );\n  return useQuery({\n    queryKey: queryKey8({ address, contract, network: chain.network }),\n    queryFn: queryFn8({ address, contract, provider, network: chain.network }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey8({\n  address,\n  contract,\n  network\n}) {\n  return [{ entity: \"starkName\", address, contract, network }];\n}\nfunction queryFn8({\n  address,\n  contract,\n  provider,\n  network\n}) {\n  return async () => {\n    if (!address)\n      throw new Error(\"address is required\");\n    const namingContract = contract ?? StarknetIdNamingContract2[network];\n    const p = new starknet__WEBPACK_IMPORTED_MODULE_1__.Provider(provider);\n    return await p.getStarkName(address, namingContract);\n  };\n}\nvar StarknetIdNamingContract2 = {\n  sepolia: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n  mainnet: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\"\n};\n\n// src/hooks/use-stark-profile.ts\n\nfunction useStarkProfile({\n  address,\n  useDefaultPfp = true,\n  namingContract,\n  identityContract,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  if (!StarknetIdcontracts[chain.network])\n    throw new Error(\"Network not supported\");\n  const { contract: multicallContract } = useContract({\n    abi: multicallABI,\n    address: StarknetIdcontracts[chain.network][\"multicall\"]\n  });\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => Boolean(enabled_ && address),\n    [enabled_, address]\n  );\n  const { refetchInterval, ...rest } = props;\n  return useQuery({\n    queryKey: queryKey9({\n      address,\n      namingContract,\n      identityContract,\n      network: chain.network,\n      useDefaultPfp\n    }),\n    queryFn: queryFn9({\n      address,\n      useDefaultPfp,\n      namingContract,\n      provider,\n      network: chain.network,\n      identityContract,\n      multicallContract\n    }),\n    enabled,\n    refetchInterval,\n    ...rest\n  });\n}\nfunction queryKey9({\n  address,\n  namingContract,\n  identityContract,\n  network,\n  useDefaultPfp\n}) {\n  return [\n    {\n      entity: \"starkprofile\",\n      address,\n      namingContract,\n      identityContract,\n      network,\n      useDefaultPfp\n    }\n  ];\n}\nfunction queryFn9({\n  address,\n  useDefaultPfp,\n  namingContract,\n  identityContract,\n  provider,\n  network,\n  multicallContract\n}) {\n  return async () => {\n    throw new Error(\"Not implemented\");\n  };\n}\nvar StarknetIdcontracts = {\n  sepolia: {\n    naming: \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\",\n    identity: \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\",\n    verifier: \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\",\n    verifier_pop: \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\",\n    verifier_pfp: \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\",\n    multicall: \"0x07a9013697371ce40d0306b4c810c6a4db9bfda119dd9ae1e8701c8e288d734b\"\n  },\n  mainnet: {\n    naming: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n    identity: \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\",\n    verifier: \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\",\n    verifier_pop: \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\",\n    verifier_pfp: \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\",\n    multicall: \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\"\n  }\n};\nvar multicallABI = [\n  {\n    name: \"ComposableMulticallImpl\",\n    type: \"impl\",\n    interface_name: \"composable_multicall::IComposableMulticall\"\n  },\n  {\n    name: \"composable_multicall::Execution\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Static\",\n        type: \"()\"\n      },\n      {\n        name: \"IfEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\"\n      },\n      {\n        name: \"IfNotEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::DynamicFelt\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Hardcoded\",\n        type: \"core::felt252\"\n      },\n      {\n        name: \"Reference\",\n        type: \"(core::integer::u32, core::integer::u32)\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::DynamicCalldata\",\n    type: \"enum\",\n    variants: [\n      {\n        name: \"Hardcoded\",\n        type: \"core::felt252\"\n      },\n      {\n        name: \"Reference\",\n        type: \"(core::integer::u32, core::integer::u32)\"\n      },\n      {\n        name: \"ArrayReference\",\n        type: \"(core::integer::u32, core::integer::u32)\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::DynamicCall\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"execution\",\n        type: \"composable_multicall::Execution\"\n      },\n      {\n        name: \"to\",\n        type: \"composable_multicall::DynamicFelt\"\n      },\n      {\n        name: \"selector\",\n        type: \"composable_multicall::DynamicFelt\"\n      },\n      {\n        name: \"calldata\",\n        type: \"core::array::Array::<composable_multicall::DynamicCalldata>\"\n      }\n    ]\n  },\n  {\n    name: \"core::array::Span::<core::felt252>\",\n    type: \"struct\",\n    members: [\n      {\n        name: \"snapshot\",\n        type: \"@core::array::Array::<core::felt252>\"\n      }\n    ]\n  },\n  {\n    name: \"composable_multicall::IComposableMulticall\",\n    type: \"interface\",\n    items: [\n      {\n        name: \"aggregate\",\n        type: \"function\",\n        inputs: [\n          {\n            name: \"calls\",\n            type: \"core::array::Array::<composable_multicall::DynamicCall>\"\n          }\n        ],\n        outputs: [\n          {\n            type: \"core::array::Array::<core::array::Span::<core::felt252>>\"\n          }\n        ],\n        state_mutability: \"view\"\n      }\n    ]\n  },\n  {\n    kind: \"enum\",\n    name: \"composable_multicall::contract::ComposableMulticall::Event\",\n    type: \"event\",\n    variants: []\n  }\n];\n\n// src/hooks/use-switch-chain.ts\nfunction useSwitchChain(props) {\n  const { params, ...rest } = props;\n  const { request, requestAsync, ...result } = useWalletRequest({\n    type: \"wallet_switchStarknetChain\",\n    params,\n    ...rest\n  });\n  const switchChain = (args) => {\n    return request(\n      args ? {\n        params: args,\n        type: \"wallet_switchStarknetChain\"\n      } : void 0\n    );\n  };\n  const switchChainAsync = (args) => {\n    return requestAsync(\n      args ? {\n        params: args,\n        type: \"wallet_switchStarknetChain\"\n      } : void 0\n    );\n  };\n  return {\n    switchChain,\n    switchChainAsync,\n    ...result\n  };\n}\n\n// src/hooks/use-transaction-receipt.ts\n\nfunction useTransactionReceipt({\n  hash,\n  watch,\n  enabled: enabled_ = true,\n  ...props\n}) {\n  const { provider, chain } = useStarknet();\n  const queryKey_ = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => queryKey10({ chain, hash }), [chain, hash]);\n  const enabled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => Boolean(enabled_ && hash), [enabled_, hash]);\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_\n  });\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn10({ provider, hash }),\n    enabled,\n    ...props\n  });\n}\nfunction queryKey10({ chain, hash }) {\n  return [\n    { entity: \"transactionReceipt\", chainId: chain?.name, hash }\n  ];\n}\nfunction queryFn10({\n  provider,\n  hash\n}) {\n  return async () => {\n    if (!hash)\n      throw new Error(\"hash is required\");\n    return await provider.getTransactionReceipt(hash);\n  };\n}\n\n// src/providers/jsonrpc.ts\n\nfunction jsonRpcProvider({\n  rpc\n}) {\n  return (chain) => {\n    const config = rpc(chain);\n    if (!config)\n      return null;\n    const chainId = starknetChainId(chain.id);\n    const provider = new starknet__WEBPACK_IMPORTED_MODULE_1__.RpcProvider({ ...config, chainId });\n    return provider;\n  };\n}\n\n// src/providers/public.ts\nfunction publicProvider() {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const rpcs = chain.rpcUrls.public.http;\n      const nodeUrl = rpcs[Math.floor(Math.random() * rpcs.length)];\n      if (!nodeUrl)\n        return null;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/alchemy.ts\nfunction alchemyProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"alchemy\"]?.http[0];\n      if (!baseHttpUrl)\n        return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/blast.ts\nfunction blastProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"blast\"]?.http[0];\n      if (!baseHttpUrl)\n        return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/infura.ts\nfunction infuraProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"infura\"]?.http[0];\n      if (!baseHttpUrl)\n        return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/lava.ts\nfunction lavaProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"lava\"]?.http[0];\n      if (!baseHttpUrl)\n        return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/nethermind.ts\nfunction nethermindProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"nethermind\"]?.http[0];\n      if (!baseHttpUrl)\n        return null;\n      const nodeUrl = `${baseHttpUrl}/?apikey=${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n// src/providers/reddio.ts\nfunction reddioProvider({ apiKey }) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"reddio\"]?.http[0];\n      if (!baseHttpUrl)\n        return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    }\n  });\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtcmVhY3QvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5QztBQUN6Qyw4QkFBOEIscURBQVk7QUFDMUM7O0FBRUE7QUFHK0I7QUFHYjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQscURBQXFEO0FBQ3JEO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQkFBK0I7QUFDN0U7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLDZEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDZjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLE9BQU87QUFDL0MsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLEdBQUcsT0FBTztBQUMvQyxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVksR0FBRyxPQUFPO0FBQy9DLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLE9BQU87QUFDL0MsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLFdBQVcsT0FBTztBQUN2RCxlQUFlO0FBQ2Y7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVksR0FBRyxPQUFPO0FBQy9DLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQTZERTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3RhcmtuZXQtcmVhY3QvY29yZS9kaXN0L2luZGV4LmpzP2FlMTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Nvbm5lY3RvcnMvYmFzZS50c1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xudmFyIENvbm5lY3RvciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbn07XG5cbi8vIHNyYy9jb25uZWN0b3JzL2luamVjdGVkLnRzXG5pbXBvcnQge1xuICBQZXJtaXNzaW9uXG59IGZyb20gXCJAc3RhcmtuZXQtaW8vdHlwZXMtanNcIjtcbmltcG9ydCB7XG4gIFdhbGxldEFjY291bnRcbn0gZnJvbSBcInN0YXJrbmV0XCI7XG5cbi8vIHNyYy9lcnJvcnMudHNcbnZhciBDb25uZWN0b3JBbHJlYWR5Q29ubmVjdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNvbm5lY3RvckFscmVhZHlDb25uZWN0ZWRFcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IFwiQ29ubmVjdG9yIGFscmVhZHkgY29ubmVjdGVkXCI7XG4gIH1cbn07XG52YXIgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNvbm5lY3Rvck5vdENvbm5lY3RlZEVycm9yXCI7XG4gICAgdGhpcy5tZXNzYWdlID0gXCJDb25uZWN0b3Igbm90IGNvbm5lY3RlZFwiO1xuICB9XG59O1xudmFyIENvbm5lY3Rvck5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNvbm5lY3Rvck5vdEZvdW5kRXJyb3JcIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIkNvbm5lY3RvciBub3QgZm91bmRcIjtcbiAgfVxufTtcbnZhciBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm5hbWUgPSBcIlVzZXJSZWplY3RlZFJlcXVlc3RFcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IFwiVXNlciByZWplY3RlZCByZXF1ZXN0XCI7XG4gIH1cbn07XG52YXIgVXNlck5vdENvbm5lY3RlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5uYW1lID0gXCJVc2VyTm90Q29ubmVjdGVkRXJyb3JcIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIlVzZXIgbm90IGNvbm5lY3RlZFwiO1xuICB9XG59O1xudmFyIFVuc3VwcG9ydGVkQWNjb3VudEludGVyZmFjZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5uYW1lID0gXCJVbnN1cHBvcnRlZEFjY291bnRJbnRlcmZhY2VFcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IFwiVW5zdXBwb3J0ZWQgYWNjb3VudCBpbnRlcmZhY2UuIHN0YXJrbmV0LXJlYWN0IHYxIG9ubHkgc3VwcG9ydHMgdGhlIHN0YXJrbmV0LmpzIHY1IGFjY291bnQgaW50ZXJmYWNlXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9jb25uZWN0b3JzL2luamVjdGVkLnRzXG52YXIgV0FMTEVUX05PVF9GT1VORF9JQ09OX0xJR0hUID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJR1pwYkd3OUltNXZibVVpSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJZ2MzUnliMnRsTFhkcFpIUm9QU0l4TGpVaUlITjBjbTlyWlQwaVlteGhZMnNpUGdvZ0lEeHdZWFJvSUhOMGNtOXJaUzFzYVc1bFkyRndQU0p5YjNWdVpDSWdjM1J5YjJ0bExXeHBibVZxYjJsdVBTSnliM1Z1WkNJZ1pEMGlUVGt1T0RjNUlEY3VOVEU1WXpFdU1UY3hMVEV1TURJMUlETXVNRGN4TFRFdU1ESTFJRFF1TWpReUlEQWdNUzR4TnpJZ01TNHdNalVnTVM0eE56SWdNaTQyT0RjZ01DQXpMamN4TWkwdU1qQXpMakUzT1MwdU5ETXVNekkyTFM0Mk55NDBOREl0TGpjME5TNHpOakV0TVM0ME5TNDVPVGt0TVM0ME5TQXhMamd5TjNZdU56Vk5NakVnTVRKaE9TQTVJREFnTVRFdE1UZ2dNQ0E1SURrZ01DQXdNVEU0SURCNmJTMDVJRFV1TWpWb0xqQXdPSFl1TURBNFNERXlkaTB1TURBNGVpSWdMejRLUEM5emRtYytcIjtcbnZhciBXQUxMRVRfTk9UX0ZPVU5EX0lDT05fREFSSyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUdacGJHdzlJbTV2Ym1VaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdjM1J5YjJ0bExYZHBaSFJvUFNJeExqVWlJSE4wY205clpUMGlkMmhwZEdVaVBnb2dJRHh3WVhSb0lITjBjbTlyWlMxc2FXNWxZMkZ3UFNKeWIzVnVaQ0lnYzNSeWIydGxMV3hwYm1WcWIybHVQU0p5YjNWdVpDSWdaRDBpVFRrdU9EYzVJRGN1TlRFNVl6RXVNVGN4TFRFdU1ESTFJRE11TURjeExURXVNREkxSURRdU1qUXlJREFnTVM0eE56SWdNUzR3TWpVZ01TNHhOeklnTWk0Mk9EY2dNQ0F6TGpjeE1pMHVNakF6TGpFM09TMHVORE11TXpJMkxTNDJOeTQwTkRJdExqYzBOUzR6TmpFdE1TNDBOUzQ1T1RrdE1TNDBOU0F4TGpneU4zWXVOelZOTWpFZ01USmhPU0E1SURBZ01URXRNVGdnTUNBNUlEa2dNQ0F3TVRFNElEQjZiUzA1SURVdU1qVm9MakF3T0hZdU1EQTRTREV5ZGkwdU1EQTRlaUlnTHo0S1BDOXpkbWMrQ2c9PVwiO1xudmFyIHdhbGxldEljb25zID0ge1xuICBhcmdlbnRYOiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0S1BDRXRMU0JIWlc1bGNtRjBiM0k2SUVGa2IySmxJRWxzYkhWemRISmhkRzl5SURJMExqQXVNU3dnVTFaSElFVjRjRzl5ZENCUWJIVm5MVWx1SUM0Z1UxWkhJRlpsY25OcGIyNDZJRFl1TURBZ1FuVnBiR1FnTUNrZ0lDMHRQZ284YzNabklIWmxjbk5wYjI0OUlqRXVNU0lnYVdROUlreGhlV1Z5WHpFaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpSUhnOUlqQndlQ0lnZVQwaU1IQjRJZ29KSUhacFpYZENiM2c5SWpBZ01DQTJOUzR4T1RVd09DQTFOeTQzTXpVMk1pSWdjM1I1YkdVOUltVnVZV0pzWlMxaVlXTnJaM0p2ZFc1a09tNWxkeUF3SURBZ05qVXVNVGsxTURnZ05UY3VOek0xTmpJN0lpQjRiV3c2YzNCaFkyVTlJbkJ5WlhObGNuWmxJajRLUEhOMGVXeGxJSFI1Y0dVOUluUmxlSFF2WTNOeklqNEtDUzV6ZERCN1ptbHNiRG9qUmtZNE56VkNPMzBLUEM5emRIbHNaVDRLUEhCaGRHZ2dZMnhoYzNNOUluTjBNQ0lnWkQwaVRUUXdMams0TlRreUxEQklNalF1TWpBNE9EaGpMVEF1TlRZc01DMHhMakF4TURBeExEQXVORFV4TURJdE1TNHdNakU1Tnl3eExqQXhNakF5Q2dsakxUQXVNek00T1Rrc01UVXVOelUxTFRndU5UZ3lNRE1zTXpBdU56QTRPVGd0TWpJdU56Y3dNRElzTkRFdU16QXdPVGxqTFRBdU5EVXdNREVzTUM0ek16Y3dNUzB3TGpVMU1qazRMREF1T1RZM09Ua3RNQzR5TWpRc01TNDBNak5zT1M0NE1UVTVPQ3d4TXk0MU56TUtDV013TGpNek5EQTFMREF1TkRZeU1ERXNNQzQ1T0RVd05Td3dMalUyTlRrNExERXVORFF5T1Rrc01DNHlNalk1T1dNNExqZzNNVEF6TFRZdU5UYzVNREVzTVRZdU1EQTNNREl0TVRRdU5URTNMREl4TGpFME5qQTJMVEl6TGpNeE5Rb0pZelV1TVRNNExEZ3VOems0TERFeUxqSTNNems1TERFMkxqY3pOVGs1TERJeExqRTBOaXd5TXk0ek1UVmpNQzQwTlRZNU55d3dMak16T0RrNUxERXVNVEEzT1Rjc01DNHlNelV3TWl3eExqUTBNVGsyTFRBdU1qSTJPVGxzT1M0NE1UWXdOQzB4TXk0MU56TUtDV013TGpNeU9EazRMVEF1TkRVMU1ESXNNQzR5TWpZNU9TMHhMakE0Tmkwd0xqSXlOQzB4TGpReU0wTTFNQzQxT0RrNE5pd3pNUzQzTWpFd01TdzBNaTR6TkRZNE9Dd3hOaTQzTmpjd015dzBNaTR3TURjNE9Td3hMakF4TWpBeUNnbEROREV1T1RrMU9EY3NNQzQwTlRFd01pdzBNUzQxTkRZNE9Td3dMRFF3TGprNE5Ua3lMREFpTHo0S1BDOXpkbWMrQ2c9PVwiLFxuICBicmFhdm9zOiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5UQXdJaUJvWldsbmFIUTlJalV3TUNJZ2RtbGxkMEp2ZUQwaU1DQXdJRFV3TUNBMU1EQWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrQ2p4d1lYUm9JR1E5SWswek1qTXVORFFnTkRFdU16ZzROa016TWpRdU1UazRJRFF5TGpZM01qZ2dNekl6TGpFNU5TQTBOQzR5TmpBeklETXlNUzQzTURRZ05EUXVNall3TTBNeU9URXVOVEVnTkRRdU1qWXdNeUF5TmpZdU9UWTFJRFk0TGpFMk5UWWdNalkyTGpNNE9TQTVOeTQ0TnpGRE1qVTJMakExSURrMUxqazBNRGNnTWpRMUxqTXpOeUE1TlM0M09UVTJJREl6TkM0M05UUWdPVGN1TlRjNE4wTXlNelF1TURJeklEWTRMakF3T1NBeU1Ea3VOVFFnTkRRdU1qWXdNeUF4TnprdU5EUTFJRFEwTGpJMk1ETkRNVGMzTGprMU15QTBOQzR5TmpBeklERTNOaTQ1TkRrZ05ESXVOamN4TmlBeE56Y3VOekEzSURReExqTTROalZETVRreUxqTXlNeUF4Tmk0Mk16TWdNakU1TGpRNE15QXdJREkxTUM0MU56TWdNRU15T0RFdU5qWTBJREFnTXpBNExqZ3lOQ0F4Tmk0Mk16TTVJRE15TXk0ME5DQTBNUzR6T0RnMldpSWdabWxzYkQwaWRYSnNLQ053WVdsdWREQmZiR2x1WldGeVh6SXpNalJmTmpFNE5qa3BJaTgrQ2p4d1lYUm9JR1E5SWswME1UZ3VOelUySURJeU5pNDRPVFJETkRJMkxqTTNJREl5T1M0eUlEUXpNeTQxT0RFZ01qSXlMalV4TnlBME16RXVNRE0ySURJeE5DNDVOemxETkRBMExqVXdOeUF4TXpZdU5EQXhJRE14Tmk0MU16VWdNVEEwTGpNMU9DQXlOVEF1TVRVNUlERXdOQzR6TlRoRE1UZ3pMalkzTkNBeE1EUXVNelU0SURrekxqY3pPVEVnTVRNM0xqUXhPQ0EyT1M0ek1EVXhJREl4TlM0ek16RkROall1T1RVM05DQXlNakl1T0RFNElEYzBMakUwTmpVZ01qSTVMakkzTlNBNE1TNDJORGM1SURJeU5pNDVOemRNTWpRMExqSTFJREUzTnk0eE5URkRNalEzTGpVMk9TQXhOell1TVRNMElESTFNUzR4TVRZZ01UYzJMakV5T0NBeU5UUXVORE01SURFM055NHhNelZNTkRFNExqYzFOaUF5TWpZdU9EazBXaUlnWm1sc2JEMGlkWEpzS0NOd1lXbHVkREZmYkdsdVpXRnlYekl6TWpSZk5qRTROamtwSWk4K0NqeHdZWFJvSUdROUlrMDJPUzQzTVRZMUlESXpPUzQwTWpaTU1qUTBMak0zSURFNE5pNDBOVFpETWpRM0xqWTJPU0F4T0RVdU5EVTJJREkxTVM0eE9URWdNVGcxTGpRMU15QXlOVFF1TkRreUlERTROaTQwTkRoTU5ETXdMakl6TWlBeU16a3VORFV5UXpRME5DNDNOaUF5TkRNdU9ETXpJRFExTkM0M01ERWdNalUzTGpJeE5pQTBOVFF1TnpBeElESTNNaTR6T1ZZME16QXVORGd4UXpRMU5DNHdNamdnTkRZNUxqQTNJRFF4T1M0ek5qSWdOVEF3SURNNE1DNDNPRFlnTlRBd1NETXhOaTQzTVRKRE16RXdMak0zT1NBMU1EQWdNekExTGpJMUlEUTVOQzQ0TnpjZ016QTFMakkxSURRNE9DNDFORE5XTkRNekxqRXhOVU16TURVdU1qVWdOREV4TGpJNE9TQXpNVGd1TVRZM0lETTVNUzQxTXpVZ016TTRMakUxTlNBek9ESXVOemt5UXpNMk5DNDVORGtnTXpjeExqQTNNU0F6T1RZdU5qUTJJRE0xTlM0eU1UZ2dOREF5TGpZd09DQXpNak11TkRBMlF6UXdOQzQxTXpJZ016RXpMakV6T0NBek9UY3VPRE0zSURNd015NHlNelFnTXpnM0xqVTVOU0F6TURFdU1UazRRek0yTVM0Mk9Ua2dNamsyTGpBMU1TQXpNekl1T1RnNUlESTVPQzR3TXprZ016QTRMamN4TVNBek1EZ3VPRGs0UXpJNE1TNHhOU0F6TWpFdU1qSTFJREkzTXk0NU5DQXpOREV1TnpNeElESTNNUzR5TnpFZ016WTVMakkzVERJMk9DNHdNellnTXprNExqa3pPRU15TmpjdU1EUTNJRFF3T0M0d01EVWdNalU0TGpVME5pQTBNVFF1T1RVeUlESTBPUzQwTWprZ05ERTBMamsxTWtNeU16a3VPVGs0SURReE5DNDVOVElnTWpNeUxqa3lOaUEwTURjdU56WTVJREl6TVM0NU1ETWdNems0TGpNNE9Fd3lNamd1TnpJNElETTJPUzR5TjBNeU1qWXVORFF5SURNME5TNDJPREVnTWpJeUxqSTVPQ0F6TWpJdU56WTNJREU1Tnk0NU1USWdNekV4TGpnMlF6RTNNQzR3T1RVZ01qazVMalF4T1NBeE5ESXVNVFF4SURJNU5TNHlPRGNnTVRFeUxqUXdOQ0F6TURFdU1UazRRekV3TWk0eE5qSWdNekF6TGpJek5DQTVOUzQwTmpjZ016RXpMakV6T0NBNU55NHpPVEV6SURNeU15NDBNRFpETVRBekxqUXdOU0F6TlRVdU5EazFJREV6TkM0NE5UUWdNemN3TGprNE5TQXhOakV1T0RRMElETTRNaTQzT1RKRE1UZ3hMamd6TXlBek9URXVOVE0xSURFNU5DNDNOU0EwTVRFdU1qZzVJREU1TkM0M05TQTBNek11TVRFMVZqUTRPQzQxTXpORE1UazBMamMxSURRNU5DNDROamNnTVRnNUxqWXlNaUExTURBZ01UZ3pMakk0T1NBMU1EQklNVEU1TGpJeE5FTTRNQzQyTXpjMElEVXdNQ0EwTlM0NU56RTJJRFEyT1M0d055QTBOUzR5T1RjNUlEUXpNQzQwT0RGV01qY3lMak0wT1VNME5TNHlPVGM1SURJMU55NHhPVFFnTlRVdU1qRTBNaUF5TkRNdU9ESTBJRFk1TGpjeE5qVWdNak01TGpReU5sb2lJR1pwYkd3OUluVnliQ2dqY0dGcGJuUXlYMnhwYm1WaGNsOHlNekkwWHpZeE9EWTVLU0l2UGdvOFpHVm1jejRLUEd4cGJtVmhja2R5WVdScFpXNTBJR2xrUFNKd1lXbHVkREJmYkdsdVpXRnlYekl6TWpSZk5qRTROamtpSUhneFBTSXlORFV1T1RnMklpQjVNVDBpTFRJM0lpQjRNajBpTkRJMUxqUTVOaUlnZVRJOUlqVXdNaTR6TnpZaUlHZHlZV1JwWlc1MFZXNXBkSE05SW5WelpYSlRjR0ZqWlU5dVZYTmxJajRLUEhOMGIzQWdjM1J2Y0MxamIyeHZjajBpSTBZMVJEUTFSU0l2UGdvOGMzUnZjQ0J2Wm1aelpYUTlJakVpSUhOMGIzQXRZMjlzYjNJOUlpTkdSamsyTURBaUx6NEtQQzlzYVc1bFlYSkhjbUZrYVdWdWRENEtQR3hwYm1WaGNrZHlZV1JwWlc1MElHbGtQU0p3WVdsdWRERmZiR2x1WldGeVh6SXpNalJmTmpFNE5qa2lJSGd4UFNJeU5EVXVPVGcySWlCNU1UMGlMVEkzSWlCNE1qMGlOREkxTGpRNU5pSWdlVEk5SWpVd01pNHpOellpSUdkeVlXUnBaVzUwVlc1cGRITTlJblZ6WlhKVGNHRmpaVTl1VlhObElqNEtQSE4wYjNBZ2MzUnZjQzFqYjJ4dmNqMGlJMFkxUkRRMVJTSXZQZ284YzNSdmNDQnZabVp6WlhROUlqRWlJSE4wYjNBdFkyOXNiM0k5SWlOR1JqazJNREFpTHo0S1BDOXNhVzVsWVhKSGNtRmthV1Z1ZEQ0S1BHeHBibVZoY2tkeVlXUnBaVzUwSUdsa1BTSndZV2x1ZERKZmJHbHVaV0Z5WHpJek1qUmZOakU0TmpraUlIZ3hQU0l5TkRVdU9UZzJJaUI1TVQwaUxUSTNJaUI0TWowaU5ESTFMalE1TmlJZ2VUSTlJalV3TWk0ek56WWlJR2R5WVdScFpXNTBWVzVwZEhNOUluVnpaWEpUY0dGalpVOXVWWE5sSWo0S1BITjBiM0FnYzNSdmNDMWpiMnh2Y2owaUkwWTFSRFExUlNJdlBnbzhjM1J2Y0NCdlptWnpaWFE5SWpFaUlITjBiM0F0WTI5c2IzSTlJaU5HUmprMk1EQWlMejRLUEM5c2FXNWxZWEpIY21Ga2FXVnVkRDRLUEM5a1pXWnpQZ284TDNOMlp6ND1cIlxufTtcbnZhciBJbmplY3RlZENvbm5lY3RvciA9IGNsYXNzIGV4dGVuZHMgQ29ubmVjdG9yIHtcbiAgY29uc3RydWN0b3IoeyBvcHRpb25zIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5pZDtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICB0aGlzLmVuc3VyZVdhbGxldCgpO1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLm5hbWUgPz8gdGhpcy5fd2FsbGV0Py5uYW1lID8/IHRoaXMuX29wdGlvbnMuaWQ7XG4gIH1cbiAgZ2V0IGljb24oKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBjb25zdCBkZWFmdWx0SWNvbiA9IHtcbiAgICAgIGRhcms6IHdhbGxldEljb25zW3RoaXMuaWRdIHx8IFdBTExFVF9OT1RfRk9VTkRfSUNPTl9EQVJLLFxuICAgICAgbGlnaHQ6IHdhbGxldEljb25zW3RoaXMuaWRdIHx8IFdBTExFVF9OT1RfRk9VTkRfSUNPTl9MSUdIVFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuaWNvbiB8fCB0aGlzLl93YWxsZXQ/Lmljb24gfHwgZGVhZnVsdEljb247XG4gIH1cbiAgYXZhaWxhYmxlKCkge1xuICAgIHRoaXMuZW5zdXJlV2FsbGV0KCk7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldCAhPT0gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGNoYWluSWQoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBjb25zdCBsb2NrZWQgPSBhd2FpdCB0aGlzLmlzTG9ja2VkKCk7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQgfHwgbG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNoYWluSWRIZXggPSBhd2FpdCB0aGlzLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9yZXF1ZXN0Q2hhaW5JZFwiIH0pO1xuICAgICAgY29uc3QgY2hhaW5JZCA9IEJpZ0ludChjaGFpbklkSGV4KTtcbiAgICAgIHJldHVybiBjaGFpbklkO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVhZHkoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICB0eXBlOiBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHBlcm1pc3Npb25zPy5pbmNsdWRlcyhQZXJtaXNzaW9uLkFDQ09VTlRTKTtcbiAgfVxuICBhc3luYyBhY2NvdW50KHByb3ZpZGVyKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBjb25zdCBsb2NrZWQgPSBhd2FpdCB0aGlzLmlzTG9ja2VkKCk7XG4gICAgaWYgKGxvY2tlZCB8fCAhdGhpcy5fd2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXYWxsZXRBY2NvdW50KHByb3ZpZGVyLCB0aGlzLl93YWxsZXQpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgdGhpcy5lbnN1cmVXYWxsZXQoKTtcbiAgICBpZiAoIXRoaXMuX3dhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgbGV0IGFjY291bnRzO1xuICAgIHRyeSB7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHR5cGU6IFwid2FsbGV0X3JlcXVlc3RBY2NvdW50c1wiXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKCFhY2NvdW50cykge1xuICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLl93YWxsZXQub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgYXN5bmMgKGFjY291bnRzMikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5vbkFjY291bnRzQ2hhbmdlZChhY2NvdW50czIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3dhbGxldC5vbihcIm5ldHdvcmtDaGFuZ2VkXCIsIChjaGFpbklkMiwgYWNjb3VudHMyKSA9PiB7XG4gICAgICB0aGlzLm9uTmV0d29ya0NoYW5nZWQoY2hhaW5JZDIsIGFjY291bnRzMik7XG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5vbkFjY291bnRzQ2hhbmdlZChhY2NvdW50cyk7XG4gICAgY29uc3QgW2FjY291bnRdID0gYWNjb3VudHM7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuY2hhaW5JZCgpO1xuICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwgeyBhY2NvdW50LCBjaGFpbklkIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50LFxuICAgICAgY2hhaW5JZFxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLmVuc3VyZVdhbGxldCgpO1xuICAgIGlmICghdGhpcy5fd2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Rm91bmRFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoY2FsbCkge1xuICAgIHRoaXMuZW5zdXJlV2FsbGV0KCk7XG4gICAgaWYgKCF0aGlzLl93YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0b3JOb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhbGxldC5yZXF1ZXN0KGNhbGwpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcigpO1xuICAgIH1cbiAgfVxuICBhc3luYyBpc0xvY2tlZCgpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICB0eXBlOiBcIndhbGxldF9yZXF1ZXN0QWNjb3VudHNcIixcbiAgICAgIHBhcmFtczogeyBzaWxlbnRfbW9kZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY291bnRzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBlbnN1cmVXYWxsZXQoKSB7XG4gICAgY29uc3QgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7XG4gICAgY29uc3Qgd2FsbGV0ID0gZ2xvYmFsX29iamVjdD8uW2BzdGFya25ldF8ke3RoaXMuX29wdGlvbnMuaWR9YF07XG4gICAgaWYgKHdhbGxldCkge1xuICAgICAgdGhpcy5fd2FsbGV0ID0gd2FsbGV0O1xuICAgIH1cbiAgfVxuICBhc3luYyBvbkFjY291bnRzQ2hhbmdlZChhY2NvdW50cykge1xuICAgIGlmICghYWNjb3VudHMpIHtcbiAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFthY2NvdW50XSA9IGFjY291bnRzO1xuICAgICAgaWYgKGFjY291bnQpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuY2hhaW5JZCgpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgeyBhY2NvdW50LCBjaGFpbklkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25OZXR3b3JrQ2hhbmdlZChjaGFpbklkSGV4LCBhY2NvdW50cykge1xuICAgIGlmIChjaGFpbklkSGV4KSB7XG4gICAgICBjb25zdCBjaGFpbklkID0gQmlnSW50KGNoYWluSWRIZXgpO1xuICAgICAgY29uc3QgW2FjY291bnRdID0gYWNjb3VudHMgfHwgW107XG4gICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgeyBjaGFpbklkLCBhY2NvdW50IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwge30pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Nvbm5lY3RvcnMvZGlzY292ZXJ5LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29ubmVjdG9ycy9oZWxwZXJzLnRzXG5mdW5jdGlvbiBhcmdlbnQoKSB7XG4gIHJldHVybiBuZXcgSW5qZWN0ZWRDb25uZWN0b3Ioe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGlkOiBcImFyZ2VudFhcIixcbiAgICAgIG5hbWU6IFwiQXJnZW50IFhcIlxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBicmFhdm9zKCkge1xuICByZXR1cm4gbmV3IEluamVjdGVkQ29ubmVjdG9yKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBpZDogXCJicmFhdm9zXCIsXG4gICAgICBuYW1lOiBcIkJyYWF2b3NcIlxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpbmplY3RlZCh7IGlkIH0pIHtcbiAgcmV0dXJuIG5ldyBJbmplY3RlZENvbm5lY3Rvcih7XG4gICAgb3B0aW9uczoge1xuICAgICAgaWRcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvY29ubmVjdG9ycy9kaXNjb3ZlcnkudHNcbmZ1bmN0aW9uIHVzZUluamVjdGVkQ29ubmVjdG9ycyh7XG4gIHJlY29tbWVuZGVkLFxuICBpbmNsdWRlUmVjb21tZW5kZWQgPSBcImFsd2F5c1wiLFxuICBvcmRlciA9IFwiYWxwaGFiZXRpY2FsXCJcbn0pIHtcbiAgY29uc3QgW2luamVjdGVkQ29ubmVjdG9ycywgc2V0SW5qZWN0ZWRDb25uZWN0b3JzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgcmVmcmVzaENvbm5lY3RvcnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgd2FsbGV0cyA9IHNjYW5PYmplY3RGb3JXYWxsZXRzKHdpbmRvdyk7XG4gICAgY29uc3QgY29ubmVjdG9yczIgPSB3YWxsZXRzLm1hcCgod2FsbGV0KSA9PiBpbmplY3RlZCh7IGlkOiB3YWxsZXQuaWQgfSkpO1xuICAgIHNldEluamVjdGVkQ29ubmVjdG9ycyhjb25uZWN0b3JzMik7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWZyZXNoQ29ubmVjdG9ycygpO1xuICB9LCBbcmVmcmVzaENvbm5lY3RvcnNdKTtcbiAgY29uc3QgY29ubmVjdG9ycyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZUNvbm5lY3RvcnMoaW5qZWN0ZWRDb25uZWN0b3JzLCByZWNvbW1lbmRlZCA/PyBbXSwge1xuICAgICAgaW5jbHVkZVJlY29tbWVuZGVkLFxuICAgICAgb3JkZXJcbiAgICB9KTtcbiAgfSwgW2luamVjdGVkQ29ubmVjdG9ycywgcmVjb21tZW5kZWQsIGluY2x1ZGVSZWNvbW1lbmRlZCwgb3JkZXJdKTtcbiAgcmV0dXJuIHsgY29ubmVjdG9ycyB9O1xufVxuZnVuY3Rpb24gbWVyZ2VDb25uZWN0b3JzKGluamVjdGVkMiwgcmVjb21tZW5kZWQsIHtcbiAgaW5jbHVkZVJlY29tbWVuZGVkLFxuICBvcmRlclxufSkge1xuICBjb25zdCBpbmplY3RlZElkcyA9IG5ldyBTZXQoaW5qZWN0ZWQyLm1hcCgoY29ubmVjdG9yKSA9PiBjb25uZWN0b3IuaWQpKTtcbiAgY29uc3QgYWxsQ29ubmVjdG9ycyA9IFsuLi5pbmplY3RlZDJdO1xuICBjb25zdCBzaG91bGRBZGRSZWNvbW1lbmRlZCA9IGluY2x1ZGVSZWNvbW1lbmRlZCA9PT0gXCJhbHdheXNcIiB8fCBpbmNsdWRlUmVjb21tZW5kZWQgPT09IFwib25seUlmTm9Db25uZWN0b3JzXCIgJiYgaW5qZWN0ZWQyLmxlbmd0aCA9PT0gMDtcbiAgaWYgKHNob3VsZEFkZFJlY29tbWVuZGVkKSB7XG4gICAgYWxsQ29ubmVjdG9ycy5wdXNoKFxuICAgICAgLi4ucmVjb21tZW5kZWQuZmlsdGVyKChjb25uZWN0b3IpID0+ICFpbmplY3RlZElkcy5oYXMoY29ubmVjdG9yLmlkKSlcbiAgICApO1xuICB9XG4gIGlmIChvcmRlciA9PT0gXCJyYW5kb21cIikge1xuICAgIHJldHVybiBzaHVmZmxlKGFsbENvbm5lY3RvcnMpO1xuICB9XG4gIHJldHVybiBhbGxDb25uZWN0b3JzLnNvcnQoKGEsIGIpID0+IGEuaWQubG9jYWxlQ29tcGFyZShiLmlkKSk7XG59XG5mdW5jdGlvbiBzaHVmZmxlKGFycikge1xuICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgW2FycltpXSwgYXJyW2pdXSA9IFthcnJbal0sIGFycltpXV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHNjYW5PYmplY3RGb3JXYWxsZXRzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLnJlZHVjZSgod2FsbGV0cywga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJzdGFya25ldFwiKSkge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKGlzV2FsbGV0T2JqZWN0KHdhbGxldCkgJiYgIXdhbGxldHNbd2FsbGV0LmlkXSkge1xuICAgICAgICAgIHdhbGxldHNbd2FsbGV0LmlkXSA9IHdhbGxldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgfSwge30pXG4gICk7XG59XG5mdW5jdGlvbiBpc1dhbGxldE9iamVjdCh3YWxsZXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2FsbGV0ICYmIFtcbiAgICAgIC8vIHdhbGxldCdzIG11c3QgaGF2ZSBtZXRob2RzL21lbWJlcnMsIHNlZSBJU3RhcmtuZXRXaW5kb3dPYmplY3RcbiAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgXCJpc0Nvbm5lY3RlZFwiLFxuICAgICAgXCJwcm92aWRlclwiLFxuICAgICAgXCJlbmFibGVcIixcbiAgICAgIFwiaXNQcmVhdXRob3JpemVkXCIsXG4gICAgICBcIm9uXCIsXG4gICAgICBcIm9mZlwiLFxuICAgICAgXCJ2ZXJzaW9uXCIsXG4gICAgICBcImlkXCIsXG4gICAgICBcIm5hbWVcIixcbiAgICAgIFwiaWNvblwiXG4gICAgXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gd2FsbGV0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcmMvY29ubmVjdG9ycy9tb2NrLnRzXG5pbXBvcnQge1xuICBQZXJtaXNzaW9uIGFzIFBlcm1pc3Npb24yXG59IGZyb20gXCJAc3RhcmtuZXQtaW8vdHlwZXMtanNcIjtcbmltcG9ydCB7IGRldm5ldCwgbWFpbm5ldCB9IGZyb20gXCJAc3RhcmtuZXQtcmVhY3QvY2hhaW5zXCI7XG52YXIgTW9ja0Nvbm5lY3RvciA9IGNsYXNzIGV4dGVuZHMgQ29ubmVjdG9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGFjY291bnRzLFxuICAgIG9wdGlvbnNcbiAgfSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYWNjb3VudEluZGV4ID0gMDtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jaGFpbklkID0gZGV2bmV0LmlkO1xuICAgIGlmIChhY2NvdW50cy5tYWlubmV0Lmxlbmd0aCA9PT0gMCB8fCBhY2NvdW50cy5zZXBvbGlhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9ja0Nvbm5lY3RvcjogYWNjb3VudHMgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIHRoaXMuX2FjY291bnRzID0gYWNjb3VudHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBzd2l0Y2hDaGFpbihjaGFpbklkKSB7XG4gICAgdGhpcy5fY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgdGhpcy5fYWNjb3VudEluZGV4ID0gMDtcbiAgICBsZXQgYWNjb3VudDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnVuaWZpZWRTd2l0Y2hBY2NvdW50QW5kQ2hhaW4pIHtcbiAgICAgIGFjY291bnQgPSB0aGlzLl9hY2NvdW50LmFkZHJlc3M7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7IGNoYWluSWQsIGFjY291bnQgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbWl0Q2hhbmdlQWNjb3VudE9uQ2hhaW5Td2l0Y2ggPz8gdHJ1ZSkge1xuICAgICAgdGhpcy5zd2l0Y2hBY2NvdW50KHRoaXMuX2FjY291bnRJbmRleCk7XG4gICAgfVxuICB9XG4gIHN3aXRjaEFjY291bnQoYWNjb3VudEluZGV4KSB7XG4gICAgdGhpcy5fYWNjb3VudEluZGV4ID0gYWNjb3VudEluZGV4O1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCB7IGFjY291bnQ6IHRoaXMuX2FjY291bnQuYWRkcmVzcyB9KTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZDtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5hbWU7XG4gIH1cbiAgZ2V0IGljb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pY29uID8/IFwiXCI7XG4gIH1cbiAgYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXZhaWxhYmxlID8/IHRydWU7XG4gIH1cbiAgYXN5bmMgY2hhaW5JZCgpIHtcbiAgICBjb25zdCBjaGFpbklkSGV4ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdENoYWluSWRcIiB9KTtcbiAgICBjb25zdCBjaGFpbklkID0gQmlnSW50KGNoYWluSWRIZXgpO1xuICAgIHJldHVybiBjaGFpbklkO1xuICB9XG4gIGFzeW5jIHJlYWR5KCkge1xuICAgIGNvbnN0IHBlcm1pc3Npb25zID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIHR5cGU6IFwid2FsbGV0X2dldFBlcm1pc3Npb25zXCJcbiAgICB9KTtcbiAgICBpZiAoIXBlcm1pc3Npb25zPy5pbmNsdWRlcyhQZXJtaXNzaW9uMi5BQ0NPVU5UUykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZhaWxDb25uZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICBwYXJhbXM6IHsgc2lsZW50X21vZGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmNoYWluSWQoKTtcbiAgICBjb25zdCBbYWNjb3VudF0gPSBhY2NvdW50cztcbiAgICByZXR1cm4geyBhY2NvdW50LCBjaGFpbklkIH07XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoY2FsbCkge1xuICAgIGNvbnN0IHsgdHlwZSwgcGFyYW1zIH0gPSBjYWxsO1xuICAgIGlmICghdGhpcy5hdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdEZvdW5kRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWplY3RSZXF1ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKCk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIndhbGxldF9yZXF1ZXN0Q2hhaW5JZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5fY2hhaW5JZC50b1N0cmluZygpO1xuICAgICAgY2FzZSBcIndhbGxldF9nZXRQZXJtaXNzaW9uc1wiOlxuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKVxuICAgICAgICAgIHJldHVybiBbUGVybWlzc2lvbjIuQUNDT1VOVFNdO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICBjYXNlIFwid2FsbGV0X3JlcXVlc3RBY2NvdW50c1wiOlxuICAgICAgICByZXR1cm4gW3RoaXMuX2FjY291bnQuYWRkcmVzc107XG4gICAgICBjYXNlIFwid2FsbGV0X2FkZFN0YXJrbmV0Q2hhaW5cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwid2FsbGV0X3N3aXRjaFN0YXJrbmV0Q2hhaW5cIjoge1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbXMgYXJlIG1pc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnN3aXRjaENoYWluKEJpZ0ludChjaGFpbklkKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIndhbGxldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIjoge1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbXMgYXJlIG1pc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IHsgY29tcGlsZWRfY2xhc3NfaGFzaCwgY29udHJhY3RfY2xhc3MsIGNsYXNzX2hhc2ggfSA9IHBhcmFtcztcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjY291bnQuZGVjbGFyZSh7XG4gICAgICAgICAgY29tcGlsZWRDbGFzc0hhc2g6IGNvbXBpbGVkX2NsYXNzX2hhc2gsXG4gICAgICAgICAgY29udHJhY3Q6IHtcbiAgICAgICAgICAgIC4uLmNvbnRyYWN0X2NsYXNzLFxuICAgICAgICAgICAgYWJpOiBKU09OLnBhcnNlKGNvbnRyYWN0X2NsYXNzLmFiaSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsYXNzSGFzaDogY2xhc3NfaGFzaFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIjoge1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbXMgYXJlIG1pc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IHsgY2FsbHMgfSA9IHBhcmFtcztcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjY291bnQuZXhlY3V0ZSh0cmFuc2Zvcm1DYWxscyhjYWxscykpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIndhbGxldF9zaWduVHlwZWREYXRhXCI6IHtcbiAgICAgICAgaWYgKCFwYXJhbXMpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1zIGFyZSBtaXNzaW5nXCIpO1xuICAgICAgICBjb25zdCB7IGRvbWFpbiwgbWVzc2FnZSwgcHJpbWFyeVR5cGUsIHR5cGVzIH0gPSBwYXJhbXM7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY2NvdW50LnNpZ25NZXNzYWdlKHtcbiAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBwcmltYXJ5VHlwZSxcbiAgICAgICAgICB0eXBlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcmVxdWVzdCB0eXBlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBhY2NvdW50KHByb3ZpZGVyKSB7XG4gICAgaWYgKCF0aGlzLmF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Rm91bmRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rvck5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hY2NvdW50O1xuICB9XG4gIGdldCBfYWNjb3VudCgpIHtcbiAgICBsZXQgYWNjb3VudDtcbiAgICBpZiAodGhpcy5fY2hhaW5JZCA9PT0gbWFpbm5ldC5pZCkge1xuICAgICAgYWNjb3VudCA9IHRoaXMuX2FjY291bnRzLm1haW5uZXRbdGhpcy5fYWNjb3VudEluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjb3VudCA9IHRoaXMuX2FjY291bnRzLnNlcG9saWFbdGhpcy5fYWNjb3VudEluZGV4XTtcbiAgICB9XG4gICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnQ7XG4gIH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWxscyhjYWxscykge1xuICByZXR1cm4gY2FsbHMubWFwKFxuICAgIChjYWxsKSA9PiAoe1xuICAgICAgY29udHJhY3RBZGRyZXNzOiBjYWxsLmNvbnRyYWN0X2FkZHJlc3MsXG4gICAgICBlbnRyeXBvaW50OiBjYWxsLmVudHJ5X3BvaW50LFxuICAgICAgY2FsbGRhdGE6IGNhbGwuY2FsbGRhdGFcbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvY29udGV4dC9zdGFya25ldC50c3hcbmltcG9ydCB7IG1haW5uZXQgYXMgbWFpbm5ldDIsIHNlcG9saWEgfSBmcm9tIFwiQHN0YXJrbmV0LXJlYWN0L2NoYWluc1wiO1xuaW1wb3J0IHsgUXVlcnlDbGllbnQsIFF1ZXJ5Q2xpZW50UHJvdmlkZXIgfSBmcm9tIFwiQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5XCI7XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIGNvbnN0YW50c1xufSBmcm9tIFwic3RhcmtuZXRcIjtcblxuLy8gc3JjL2NvbnRleHQvYWNjb3VudC50c3hcbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBY2NvdW50Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gIHZvaWQgMFxuKTtcbmZ1bmN0aW9uIHVzZVN0YXJrbmV0QWNjb3VudCgpIHtcbiAgY29uc3QgYWNjb3VudCA9IHVzZUNvbnRleHQoQWNjb3VudENvbnRleHQpO1xuICByZXR1cm4geyBhY2NvdW50IH07XG59XG5mdW5jdGlvbiBBY2NvdW50UHJvdmlkZXIoe1xuICBhY2NvdW50LFxuICBjaGlsZHJlblxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChBY2NvdW50Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogYWNjb3VudCwgY2hpbGRyZW4gfSk7XG59XG5cbi8vIHNyYy9jb250ZXh0L3N0YXJrbmV0LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBkZWZhdWx0UXVlcnlDbGllbnQgPSBuZXcgUXVlcnlDbGllbnQoKTtcbnZhciBTdGFya25ldENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiB1c2VTdGFya25ldCgpIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VDb250ZXh0MihTdGFya25ldENvbnRleHQpO1xuICBpZiAoIXN0YXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ1c2VTdGFya25ldCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgU3RhcmtuZXRQcm92aWRlciBvciBTdGFya25ldENvbmZpZ1wiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VTdGFya25ldE1hbmFnZXIoe1xuICBjaGFpbnMsXG4gIHByb3ZpZGVyLFxuICBleHBsb3JlcixcbiAgY29ubmVjdG9ycyA9IFtdLFxuICBhdXRvQ29ubmVjdCA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGluaXRpYWxDaGFpbiA9IGNoYWluc1swXTtcbiAgaWYgKGluaXRpYWxDaGFpbiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBjaGFpbi5cIik7XG4gIH1cbiAgY29uc3QgeyBjaGFpbjogZGVmYXVsdENoYWluLCBwcm92aWRlcjogZGVmYXVsdFByb3ZpZGVyIH0gPSBwcm92aWRlckZvckNoYWluKFxuICAgIGluaXRpYWxDaGFpbixcbiAgICBwcm92aWRlclxuICApO1xuICBjb25zdCBjb25uZWN0b3JSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTIoe1xuICAgIGN1cnJlbnRDaGFpbjogZGVmYXVsdENoYWluLFxuICAgIGN1cnJlbnRQcm92aWRlcjogZGVmYXVsdFByb3ZpZGVyLFxuICAgIGNvbm5lY3RvcnNcbiAgfSk7XG4gIGNvbnN0IHVwZGF0ZUNoYWluQW5kUHJvdmlkZXIgPSB1c2VDYWxsYmFjazIoXG4gICAgKHsgY2hhaW5JZCB9KSA9PiB7XG4gICAgICBpZiAoIWNoYWluSWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZvciAoY29uc3QgY2hhaW4gb2YgY2hhaW5zKSB7XG4gICAgICAgIGlmIChjaGFpbi5pZCA9PT0gY2hhaW5JZCkge1xuICAgICAgICAgIGNvbnN0IHsgY2hhaW46IG5ld0NoYWluLCBwcm92aWRlcjogbmV3UHJvdmlkZXIgfSA9IHByb3ZpZGVyRm9yQ2hhaW4oXG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIHByb3ZpZGVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRTdGF0ZSgoc3RhdGUyKSA9PiAoe1xuICAgICAgICAgICAgLi4uc3RhdGUyLFxuICAgICAgICAgICAgY3VycmVudENoYWluOiBuZXdDaGFpbixcbiAgICAgICAgICAgIGN1cnJlbnRQcm92aWRlcjogbmV3UHJvdmlkZXJcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbY2hhaW5zLCBwcm92aWRlcl1cbiAgKTtcbiAgY29uc3QgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jICh7IGNoYWluSWQsIGFjY291bnQgfSkgPT4ge1xuICAgICAgaWYgKGNoYWluSWQpIHtcbiAgICAgICAgdXBkYXRlQ2hhaW5BbmRQcm92aWRlcih7IGNoYWluSWQgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYWNjb3VudCAmJiBjb25uZWN0b3JSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBhY2NvdW50MiA9IGF3YWl0IGNvbm5lY3RvclJlZi5jdXJyZW50LmFjY291bnQoXG4gICAgICAgICAgc3RhdGUuY3VycmVudFByb3ZpZGVyXG4gICAgICAgICk7XG4gICAgICAgIHNldFN0YXRlKChzdGF0ZTIpID0+ICh7XG4gICAgICAgICAgLi4uc3RhdGUyLFxuICAgICAgICAgIGN1cnJlbnRBY2NvdW50OiBhY2NvdW50MlxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbdXBkYXRlQ2hhaW5BbmRQcm92aWRlciwgc3RhdGUuY3VycmVudFByb3ZpZGVyXVxuICApO1xuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jICh7IGNvbm5lY3RvciB9KSA9PiB7XG4gICAgICBpZiAoIWNvbm5lY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBjb25uZWN0b3IuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVlZHNMaXN0ZW5lclNldHVwID0gY29ubmVjdG9yUmVmLmN1cnJlbnQ/LmlkICE9PSBjb25uZWN0b3IuaWQ7XG4gICAgICBpZiAobmVlZHNMaXN0ZW5lclNldHVwKSB7XG4gICAgICAgIGNvbm5lY3RvclJlZi5jdXJyZW50Py5vZmYoXCJjaGFuZ2VcIiwgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gYXdhaXQgY29ubmVjdG9yLmNvbm5lY3QoKTtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IGNvbm5lY3Rvci5hY2NvdW50KHN0YXRlLmN1cnJlbnRQcm92aWRlcik7XG4gICAgICAgIGlmIChhY2NvdW50LmFkZHJlc3MgIT09IHN0YXRlLmN1cnJlbnRBY2NvdW50Py5hZGRyZXNzKSB7XG4gICAgICAgICAgY29ubmVjdG9yUmVmLmN1cnJlbnQgPSBjb25uZWN0b3I7XG4gICAgICAgICAgc2V0U3RhdGUoKHN0YXRlMikgPT4gKHtcbiAgICAgICAgICAgIC4uLnN0YXRlMixcbiAgICAgICAgICAgIGN1cnJlbnRBY2NvdW50OiBhY2NvdW50XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRvQ29ubmVjdCkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibGFzdFVzZWRDb25uZWN0b3JcIiwgY29ubmVjdG9yLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNMaXN0ZW5lclNldHVwKSB7XG4gICAgICAgICAgY29ubmVjdG9yLm9uKFwiY2hhbmdlXCIsIGhhbmRsZUNvbm5lY3RvckNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ2hhaW5BbmRQcm92aWRlcih7IGNoYWluSWQgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2V0U3RhdGUoKHN0YXRlMikgPT4gKHtcbiAgICAgICAgICAuLi5zdGF0ZTIsXG4gICAgICAgICAgZXJyb3I6IG5ldyBDb25uZWN0b3JOb3RGb3VuZEVycm9yKClcbiAgICAgICAgfSkpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBhdXRvQ29ubmVjdCxcbiAgICAgIHN0YXRlLmN1cnJlbnRBY2NvdW50LFxuICAgICAgc3RhdGUuY3VycmVudFByb3ZpZGVyLFxuICAgICAgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlLFxuICAgICAgdXBkYXRlQ2hhaW5BbmRQcm92aWRlclxuICAgIF1cbiAgKTtcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrMihhc3luYyAoKSA9PiB7XG4gICAgc2V0U3RhdGUoKHN0YXRlMikgPT4gKHtcbiAgICAgIC4uLnN0YXRlMixcbiAgICAgIGN1cnJlbnRBY2NvdW50OiB2b2lkIDAsXG4gICAgICBjdXJyZW50UHJvdmlkZXI6IGRlZmF1bHRQcm92aWRlcixcbiAgICAgIGN1cnJlbnRDaGFpbjogZGVmYXVsdENoYWluXG4gICAgfSkpO1xuICAgIGlmIChhdXRvQ29ubmVjdCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJsYXN0VXNlZENvbm5lY3RvclwiKTtcbiAgICB9XG4gICAgaWYgKCFjb25uZWN0b3JSZWYuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25uZWN0b3JSZWYuY3VycmVudC5vZmYoXCJjaGFuZ2VcIiwgaGFuZGxlQ29ubmVjdG9yQ2hhbmdlKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29ubmVjdG9yUmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBjb25uZWN0b3JSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgfSwgW2F1dG9Db25uZWN0LCBoYW5kbGVDb25uZWN0b3JDaGFuZ2UsIGRlZmF1bHRQcm92aWRlciwgZGVmYXVsdENoYWluXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIHRyeUF1dG9Db25uZWN0KGNvbm5lY3RvcnMyKSB7XG4gICAgICBjb25zdCBsYXN0Q29ubmVjdGVkQ29ubmVjdG9ySWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImxhc3RVc2VkQ29ubmVjdG9yXCIpO1xuICAgICAgaWYgKGxhc3RDb25uZWN0ZWRDb25uZWN0b3JJZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0Q29ubmVjdGVkQ29ubmVjdG9yID0gY29ubmVjdG9yczIuZmluZChcbiAgICAgICAgKGNvbm5lY3RvcikgPT4gY29ubmVjdG9yLmlkID09PSBsYXN0Q29ubmVjdGVkQ29ubmVjdG9ySWRcbiAgICAgICk7XG4gICAgICBpZiAobGFzdENvbm5lY3RlZENvbm5lY3RvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghYXdhaXQgbGFzdENvbm5lY3RlZENvbm5lY3Rvci5yZWFkeSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3QoeyBjb25uZWN0b3I6IGxhc3RDb25uZWN0ZWRDb25uZWN0b3IgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF1dG9Db25uZWN0ICYmICFjb25uZWN0b3JSZWYuY3VycmVudCkge1xuICAgICAgdHJ5QXV0b0Nvbm5lY3QoY29ubmVjdG9ycyk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgYWNjb3VudDogc3RhdGUuY3VycmVudEFjY291bnQsXG4gICAgcHJvdmlkZXI6IHN0YXRlLmN1cnJlbnRQcm92aWRlcixcbiAgICBjaGFpbjogc3RhdGUuY3VycmVudENoYWluLFxuICAgIGNvbm5lY3RvcjogY29ubmVjdG9yUmVmLmN1cnJlbnQsXG4gICAgZXhwbG9yZXIsXG4gICAgY29ubmVjdCxcbiAgICBkaXNjb25uZWN0LFxuICAgIGNvbm5lY3RvcnMsXG4gICAgY2hhaW5zXG4gIH07XG59XG5mdW5jdGlvbiBTdGFya25ldFByb3ZpZGVyKHtcbiAgY2hhaW5zLFxuICBwcm92aWRlcixcbiAgY29ubmVjdG9ycyxcbiAgZXhwbG9yZXIsXG4gIGF1dG9Db25uZWN0LFxuICBxdWVyeUNsaWVudCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgeyBhY2NvdW50LCAuLi5zdGF0ZSB9ID0gdXNlU3RhcmtuZXRNYW5hZ2VyKHtcbiAgICBjaGFpbnMsXG4gICAgcHJvdmlkZXIsXG4gICAgZXhwbG9yZXIsXG4gICAgY29ubmVjdG9ycyxcbiAgICBhdXRvQ29ubmVjdFxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFF1ZXJ5Q2xpZW50UHJvdmlkZXIsIHsgY2xpZW50OiBxdWVyeUNsaWVudCA/PyBkZWZhdWx0UXVlcnlDbGllbnQsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihTdGFya25ldENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHN0YXRlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoQWNjb3VudFByb3ZpZGVyLCB7IGFjY291bnQsIGNoaWxkcmVuIH0pIH0pIH0pO1xufVxuZnVuY3Rpb24gcHJvdmlkZXJGb3JDaGFpbihjaGFpbiwgZmFjdG9yeSkge1xuICBjb25zdCBwcm92aWRlciA9IGZhY3RvcnkoY2hhaW4pO1xuICBpZiAocHJvdmlkZXIpIHtcbiAgICByZXR1cm4geyBjaGFpbiwgcHJvdmlkZXIgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYE5vIHByb3ZpZGVyIGZvdW5kIGZvciBjaGFpbiAke2NoYWluLm5hbWV9YCk7XG59XG5mdW5jdGlvbiBzdGFya25ldENoYWluSWQoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIG1haW5uZXQyLmlkOlxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5TdGFya25ldENoYWluSWQuU05fTUFJTjtcbiAgICBjYXNlIHNlcG9saWEuaWQ6XG4gICAgICByZXR1cm4gY29uc3RhbnRzLlN0YXJrbmV0Q2hhaW5JZC5TTl9TRVBPTElBO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5cbi8vIHNyYy9jb250ZXh0L2luZGV4LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIFN0YXJrbmV0Q29uZmlnKHsgY2hpbGRyZW4sIC4uLmNvbmZpZyB9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MyhTdGFya25ldFByb3ZpZGVyLCB7IC4uLmNvbmZpZywgY2hpbGRyZW4gfSk7XG59XG5cbi8vIHNyYy9leHBsb3JlcnMvc3RhcmtDb21wYXNzLnRzXG52YXIgU3RhcmtDb21wYXNzRXhwbG9yZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYWluKSB7XG4gICAgdGhpcy5uYW1lID0gXCJTdGFyayBDb21wYXNzXCI7XG4gICAgdGhpcy5saW5rID0gY2hhaW4uZXhwbG9yZXJzPy5bXCJzdGFya0NvbXBhc3NcIl0/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgfVxuICBibG9jayhoYXNoT3JOdW1iZXIpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS9ibG9ja3MvJHtoYXNoT3JOdW1iZXIuaGFzaCA/PyBoYXNoT3JOdW1iZXIubnVtYmVyfWA7XG4gIH1cbiAgdHJhbnNhY3Rpb24oaGFzaCkge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L3RyYW5zYWN0aW9ucy8ke2hhc2h9YDtcbiAgfVxuICBjb250cmFjdChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vY29udHJhY3RzLyR7YWRkcmVzc31gO1xuICB9XG4gIGNsYXNzKGhhc2gpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS9jbGFzc2VzLyR7aGFzaH1gO1xuICB9XG59O1xudmFyIHN0YXJrY29tcGFzcyA9IChjaGFpbikgPT4ge1xuICByZXR1cm4gbmV3IFN0YXJrQ29tcGFzc0V4cGxvcmVyKGNoYWluKTtcbn07XG5cbi8vIHNyYy9leHBsb3JlcnMvc3RhcmtzY2FuLnRzXG52YXIgU3RhcmtzY2FuRXhwbG9yZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYWluKSB7XG4gICAgdGhpcy5uYW1lID0gXCJTdGFya3NjYW5cIjtcbiAgICB0aGlzLmxpbmsgPSBjaGFpbi5leHBsb3JlcnM/LltcInN0YXJrc2NhblwiXT8udG9TdHJpbmcoKSA/PyBcIlwiO1xuICB9XG4gIGJsb2NrKGhhc2hPck51bWJlcikge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2Jsb2NrLyR7aGFzaE9yTnVtYmVyLmhhc2ggPz8gaGFzaE9yTnVtYmVyLm51bWJlcn1gO1xuICB9XG4gIHRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS90eC8ke2hhc2h9YDtcbiAgfVxuICBjb250cmFjdChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vY29udHJhY3QvJHthZGRyZXNzfWA7XG4gIH1cbiAgY2xhc3MoaGFzaCkge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2NsYXNzLyR7aGFzaH1gO1xuICB9XG59O1xudmFyIHN0YXJrc2NhbiA9IChjaGFpbikgPT4ge1xuICByZXR1cm4gbmV3IFN0YXJrc2NhbkV4cGxvcmVyKGNoYWluKTtcbn07XG5cbi8vIHNyYy9leHBsb3JlcnMvdmlld2Jsb2NrLnRzXG52YXIgVmlld2Jsb2NrRXhwbG9yZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYWluKSB7XG4gICAgdGhpcy5uYW1lID0gXCJWaWV3YmxvY2tcIjtcbiAgICB0aGlzLmxpbmsgPSBjaGFpbi5leHBsb3JlcnM/LltcInZpZXdibG9ja1wiXT8udG9TdHJpbmcoKSA/PyBcIlwiO1xuICB9XG4gIGJsb2NrKGhhc2hPck51bWJlcikge1xuICAgIGlmIChoYXNoT3JOdW1iZXIuaGFzaCAmJiBoYXNoT3JOdW1iZXIubnVtYmVyID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgdmlld2Jsb2NrIGV4cGxvcmVyIGRvZXNudCBzdXBwb3J0IGhhc2hlcyBmb3IgYmxvY2tzLiBQbGVhc2UgcHJvdmlkZSBhIGhhc2guXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2Jsb2NrLyR7aGFzaE9yTnVtYmVyLm51bWJlcn1gO1xuICB9XG4gIHRyYW5zYWN0aW9uKGhhc2gpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS90eC8ke2hhc2h9YDtcbiAgfVxuICBjb250cmFjdChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vY29udHJhY3QvJHthZGRyZXNzfWA7XG4gIH1cbiAgY2xhc3MoaGFzaCkge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2NsYXNzLyR7aGFzaH1gO1xuICB9XG59O1xudmFyIHZpZXdibG9jayA9IChjaGFpbikgPT4ge1xuICByZXR1cm4gbmV3IFZpZXdibG9ja0V4cGxvcmVyKGNoYWluKTtcbn07XG5cbi8vIHNyYy9leHBsb3JlcnMvdm95YWdlci50c1xudmFyIFZveWFnZXJFeHBsb3JlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhaW4pIHtcbiAgICB0aGlzLm5hbWUgPSBcIlZveWFnZXJcIjtcbiAgICB0aGlzLmxpbmsgPSBjaGFpbi5leHBsb3JlcnM/LltcInZveWFnZXJcIl0/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgfVxuICBibG9jayhoYXNoT3JOdW1iZXIpIHtcbiAgICBpZiAoaGFzaE9yTnVtYmVyLm51bWJlciAhPT0gdm9pZCAwICYmIGhhc2hPck51bWJlci5oYXNoID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgdm95YWdlciBleHBsb3JlciBkb2Vzbid0IHN1cHBvcnQgbnVtYmVycyBmb3IgYmxvY2tzLiBQbGVhc2UgcHJvdmlkZSBhIGhhc2guXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2Jsb2NrLyR7aGFzaE9yTnVtYmVyLmhhc2h9YDtcbiAgfVxuICB0cmFuc2FjdGlvbihoYXNoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubGlua30vdHgvJHtoYXNofWA7XG4gIH1cbiAgY29udHJhY3QoYWRkcmVzcykge1xuICAgIHJldHVybiBgJHt0aGlzLmxpbmt9L2NvbnRyYWN0LyR7YWRkcmVzc31gO1xuICB9XG4gIGNsYXNzKGhhc2gpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saW5rfS9jbGFzcy8ke2hhc2h9YDtcbiAgfVxufTtcbnZhciB2b3lhZ2VyID0gKGNoYWluKSA9PiB7XG4gIHJldHVybiBuZXcgVm95YWdlckV4cGxvcmVyKGNoYWluKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2UtYWNjb3VudC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MywgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9ob29rcy91c2UtY29ubmVjdC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9xdWVyeS50c1xuaW1wb3J0IHtcbiAgdXNlTXV0YXRpb24gYXMgdXNlTXV0YXRpb25fLFxuICB1c2VRdWVyeSBhcyB1c2VRdWVyeV9cbn0gZnJvbSBcIkB0YW5zdGFjay9yZWFjdC1xdWVyeVwiO1xuZnVuY3Rpb24gdXNlUXVlcnkoYXJncykge1xuICBjb25zdCBiYXNlID0gdXNlUXVlcnlfKGFyZ3MpO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IGJhc2UuZGF0YSxcbiAgICBlcnJvcjogYmFzZS5lcnJvcixcbiAgICBzdGF0dXM6IGJhc2Uuc3RhdHVzLFxuICAgIGlzU3VjY2VzczogYmFzZS5pc1N1Y2Nlc3MsXG4gICAgaXNFcnJvcjogYmFzZS5pc0Vycm9yLFxuICAgIGlzUGVuZGluZzogYmFzZS5pc1BlbmRpbmcsXG4gICAgZmV0Y2hTdGF0dXM6IGJhc2UuZmV0Y2hTdGF0dXMsXG4gICAgaXNGZXRjaGluZzogYmFzZS5pc0ZldGNoaW5nLFxuICAgIGlzTG9hZGluZzogYmFzZS5pc0xvYWRpbmcsXG4gICAgcmVmZXRjaDogYmFzZS5yZWZldGNoXG4gIH07XG59XG5mdW5jdGlvbiB1c2VNdXRhdGlvbihhcmdzKSB7XG4gIGNvbnN0IGJhc2UgPSB1c2VNdXRhdGlvbl8oYXJncyk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogYmFzZS5kYXRhLFxuICAgIGVycm9yOiBiYXNlLmVycm9yLFxuICAgIHJlc2V0OiBiYXNlLnJlc2V0LFxuICAgIGlzRXJyb3I6IGJhc2UuaXNFcnJvcixcbiAgICBpc0lkbGU6IGJhc2UuaXNJZGxlLFxuICAgIGlzUGVuZGluZzogYmFzZS5pc1BlbmRpbmcsXG4gICAgaXNTdWNjZXNzOiBiYXNlLmlzU3VjY2VzcyxcbiAgICBpc1BhdXNlZDogYmFzZS5pc1BhdXNlZCxcbiAgICBtdXRhdGU6IGJhc2UubXV0YXRlLFxuICAgIG11dGF0ZUFzeW5jOiBiYXNlLm11dGF0ZUFzeW5jLFxuICAgIHN0YXR1czogYmFzZS5zdGF0dXMsXG4gICAgdmFyaWFibGVzOiBiYXNlLnZhcmlhYmxlc1xuICB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWNvbm5lY3QudHNcbmZ1bmN0aW9uIHVzZUNvbm5lY3QocHJvcHMgPSB7fSkge1xuICBjb25zdCB7IGNvbm5lY3RvciwgY29ubmVjdG9ycywgY29ubmVjdDogY29ubmVjdF8sIGNoYWluIH0gPSB1c2VTdGFya25ldCgpO1xuICBjb25zdCB7IG11dGF0ZSwgbXV0YXRlQXN5bmMsIHZhcmlhYmxlcywgLi4ucmVzdWx0IH0gPSB1c2VNdXRhdGlvbih7XG4gICAgbXV0YXRpb25LZXk6IFt7IGVudGl0eTogXCJjb25uZWN0XCIsIGNoYWluSWQ6IGNoYWluLm5hbWUgfV0sXG4gICAgbXV0YXRpb25GbjogY29ubmVjdF8sXG4gICAgLi4ucHJvcHNcbiAgfSk7XG4gIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjazMoXG4gICAgKGFyZ3MpID0+IG11dGF0ZShhcmdzID8/IHsgY29ubmVjdG9yIH0pLFxuICAgIFttdXRhdGUsIGNvbm5lY3Rvcl1cbiAgKTtcbiAgY29uc3QgY29ubmVjdEFzeW5jID0gdXNlQ2FsbGJhY2szKFxuICAgIChhcmdzKSA9PiBtdXRhdGVBc3luYyhhcmdzID8/IHsgY29ubmVjdG9yIH0pLFxuICAgIFttdXRhdGVBc3luYywgY29ubmVjdG9yXVxuICApO1xuICByZXR1cm4ge1xuICAgIGNvbm5lY3RvcixcbiAgICBjb25uZWN0b3JzLFxuICAgIHBlbmRpbmdDb25uZWN0b3I6IHZhcmlhYmxlcz8uY29ubmVjdG9yLFxuICAgIGNvbm5lY3QsXG4gICAgY29ubmVjdEFzeW5jLFxuICAgIHZhcmlhYmxlcyxcbiAgICAuLi5yZXN1bHRcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1hY2NvdW50LnRzXG5mdW5jdGlvbiB1c2VBY2NvdW50KCkge1xuICBjb25zdCB7IGFjY291bnQ6IGNvbm5lY3RlZEFjY291bnQgfSA9IHVzZVN0YXJrbmV0QWNjb3VudCgpO1xuICBjb25zdCB7IGNvbm5lY3RvcnMgfSA9IHVzZUNvbm5lY3QoKTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTMoe1xuICAgIHN0YXR1czogXCJkaXNjb25uZWN0ZWRcIlxuICB9KTtcbiAgY29uc3QgcmVmcmVzaFN0YXRlID0gdXNlQ2FsbGJhY2s0KGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWNvbm5lY3RlZEFjY291bnQpIHtcbiAgICAgIHJldHVybiBzZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogXCJkaXNjb25uZWN0ZWRcIixcbiAgICAgICAgaXNEaXNjb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIGlzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgICAgaXNDb25uZWN0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNSZWNvbm5lY3Rpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb25uZWN0b3Igb2YgY29ubmVjdG9ycykge1xuICAgICAgaWYgKCFjb25uZWN0b3IuYXZhaWxhYmxlKCkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGV0IGNvbm5BY2NvdW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29ubkFjY291bnQgPSBhd2FpdCBjb25uZWN0b3IucmVxdWVzdCh7XG4gICAgICAgICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICAgICAgcGFyYW1zOiB7IHNpbGVudF9tb2RlOiB0cnVlIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIGlmIChjb25uQWNjb3VudD8uWzBdID09PSBjb25uZWN0ZWRBY2NvdW50LmFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHNldFN0YXRlKHtcbiAgICAgICAgICBjb25uZWN0b3IsXG4gICAgICAgICAgY2hhaW5JZDogYXdhaXQgY29ubmVjdG9yLmNoYWluSWQoKSxcbiAgICAgICAgICBhY2NvdW50OiBjb25uZWN0ZWRBY2NvdW50LFxuICAgICAgICAgIGFkZHJlc3M6IGNvbm5lY3RlZEFjY291bnQuYWRkcmVzcyxcbiAgICAgICAgICBzdGF0dXM6IFwiY29ubmVjdGVkXCIsXG4gICAgICAgICAgaXNDb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgaXNDb25uZWN0aW5nOiBmYWxzZSxcbiAgICAgICAgICBpc0Rpc2Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICAgICAgaXNSZWNvbm5lY3Rpbmc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRTdGF0ZSh7XG4gICAgICBjb25uZWN0b3I6IHZvaWQgMCxcbiAgICAgIGNoYWluSWQ6IHZvaWQgMCxcbiAgICAgIGFjY291bnQ6IGNvbm5lY3RlZEFjY291bnQsXG4gICAgICBhZGRyZXNzOiBjb25uZWN0ZWRBY2NvdW50LmFkZHJlc3MsXG4gICAgICBzdGF0dXM6IFwiY29ubmVjdGVkXCIsXG4gICAgICBpc0Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgIGlzQ29ubmVjdGluZzogZmFsc2UsXG4gICAgICBpc0Rpc2Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICBpc1JlY29ubmVjdGluZzogZmFsc2VcbiAgICB9KTtcbiAgfSwgW2Nvbm5lY3RlZEFjY291bnQsIGNvbm5lY3RvcnNdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgcmVmcmVzaFN0YXRlKCk7XG4gIH0sIFtyZWZyZXNoU3RhdGVdKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXdhbGxldC1yZXF1ZXN0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazUgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVdhbGxldFJlcXVlc3QocHJvcHMpIHtcbiAgY29uc3QgeyBjb25uZWN0b3IgfSA9IHVzZVN0YXJrbmV0KCk7XG4gIGNvbnN0IHsgdHlwZSwgcGFyYW1zLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgY29uc3QgeyBtdXRhdGUsIG11dGF0ZUFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZU11dGF0aW9uKHtcbiAgICBtdXRhdGlvbktleTogbXV0YXRpb25LZXkoeyB0eXBlLCBwYXJhbXMgfSksXG4gICAgbXV0YXRpb25GbjogbXV0YXRpb25Gbih7IGNvbm5lY3RvciB9KSxcbiAgICAuLi5yZXN0XG4gIH0pO1xuICBjb25zdCByZXF1ZXN0ID0gdXNlQ2FsbGJhY2s1KFxuICAgIChhcmdzKSA9PiBtdXRhdGUoYXJncyA/PyB7IHR5cGUsIHBhcmFtcyB9KSxcbiAgICBbbXV0YXRlLCB0eXBlLCBwYXJhbXNdXG4gICk7XG4gIGNvbnN0IHJlcXVlc3RBc3luYyA9IHVzZUNhbGxiYWNrNShcbiAgICAoYXJncykgPT4gbXV0YXRlQXN5bmMoYXJncyA/PyB7IHR5cGUsIHBhcmFtcyB9KSxcbiAgICBbbXV0YXRlQXN5bmMsIHR5cGUsIHBhcmFtc11cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICByZXF1ZXN0LFxuICAgIHJlcXVlc3RBc3luYyxcbiAgICAuLi5yZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIG11dGF0aW9uS2V5KHtcbiAgdHlwZSxcbiAgcGFyYW1zXG59KSB7XG4gIHJldHVybiBbeyBlbnRpdHk6IFwid2FsbGV0UmVxdWVzdFwiLCB0eXBlLCBwYXJhbXMgfV07XG59XG5mdW5jdGlvbiBtdXRhdGlvbkZuKHtcbiAgY29ubmVjdG9yXG59KSB7XG4gIHJldHVybiBhc3luYyAoeyB0eXBlLCBwYXJhbXMgfSkgPT4ge1xuICAgIGlmICghY29ubmVjdG9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29ubmVjdG9yIGNvbm5lY3RlZFwiKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIGlzIHJlcXVpcmVkXCIpO1xuICAgIHJldHVybiBhd2FpdCBjb25uZWN0b3IucmVxdWVzdCh7IHR5cGUsIHBhcmFtcyB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1hZGQtY2hhaW4udHNcbmZ1bmN0aW9uIHVzZUFkZENoYWluKHByb3BzKSB7XG4gIGNvbnN0IHsgcGFyYW1zLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgY29uc3QgeyByZXF1ZXN0LCByZXF1ZXN0QXN5bmMsIC4uLnJlc3VsdCB9ID0gdXNlV2FsbGV0UmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfYWRkU3RhcmtuZXRDaGFpblwiLFxuICAgIHBhcmFtcyxcbiAgICAuLi5yZXN0XG4gIH0pO1xuICBjb25zdCBhZGRDaGFpbiA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3QoXG4gICAgICBhcmdzID8ge1xuICAgICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X2FkZFN0YXJrbmV0Q2hhaW5cIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIGNvbnN0IGFkZENoYWluQXN5bmMgPSAoYXJncykgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0QXN5bmMoXG4gICAgICBhcmdzID8ge1xuICAgICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X2FkZFN0YXJrbmV0Q2hhaW5cIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWRkQ2hhaW4sXG4gICAgYWRkQ2hhaW5Bc3luYyxcbiAgICAuLi5yZXN1bHRcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1iYWxhbmNlLnRzXG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW8zIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBCbG9ja1RhZyBhcyBCbG9ja1RhZzIsXG4gIG51bSxcbiAgc2hvcnRTdHJpbmdcbn0gZnJvbSBcInN0YXJrbmV0XCI7XG5pbXBvcnQgeyBmb3JtYXRVbml0cyB9IGZyb20gXCJ2aWVtXCI7XG5cbi8vIHNyYy9ob29rcy91c2UtY29udHJhY3QudHNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIENvbnRyYWN0XG59IGZyb20gXCJzdGFya25ldFwiO1xuZnVuY3Rpb24gdXNlQ29udHJhY3Qoe1xuICBhYmksXG4gIGFkZHJlc3MsXG4gIHByb3ZpZGVyOiBwcm92aWRlZFByb3ZpZGVyXG59KSB7XG4gIGNvbnN0IHsgcHJvdmlkZXI6IGN1cnJlbnRQcm92aWRlciB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgY29uc3QgY29udHJhY3QgPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlZFByb3ZpZGVyID8gcHJvdmlkZWRQcm92aWRlciA6IGN1cnJlbnRQcm92aWRlcjtcbiAgICBpZiAoYWJpICYmIGFkZHJlc3MgJiYgcHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWJpLCBhZGRyZXNzLCBwcm92aWRlcikudHlwZWR2MihcbiAgICAgICAgYWJpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9LCBbYWJpLCBhZGRyZXNzLCBwcm92aWRlZFByb3ZpZGVyLCBjdXJyZW50UHJvdmlkZXJdKTtcbiAgcmV0dXJuIHsgY29udHJhY3QgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1pbnZhbGlkYXRlLW9uLWJsb2NrLnRzXG5pbXBvcnQgeyB1c2VRdWVyeUNsaWVudCB9IGZyb20gXCJAdGFuc3RhY2svcmVhY3QtcXVlcnlcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2hvb2tzL3VzZS1ibG9jay1udW1iZXIudHNcbmltcG9ydCB7IEJsb2NrVGFnIH0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VCbG9ja051bWJlcih7XG4gIGJsb2NrSWRlbnRpZmllciA9IEJsb2NrVGFnLkxBVEVTVCxcbiAgLi4ucHJvcHNcbn0gPSB7fSkge1xuICBjb25zdCB7IHByb3ZpZGVyIH0gPSB1c2VTdGFya25ldCgpO1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBxdWVyeUtleSh7IGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICBxdWVyeUZuOiBxdWVyeUZuKHsgcHJvdmlkZXIsIGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5KHsgYmxvY2tJZGVudGlmaWVyIH0pIHtcbiAgcmV0dXJuIFt7IGVudGl0eTogXCJibG9ja051bWJlclwiLCBibG9ja0lkZW50aWZpZXIgfV07XG59XG5mdW5jdGlvbiBxdWVyeUZuKHtcbiAgcHJvdmlkZXIsXG4gIGJsb2NrSWRlbnRpZmllclxufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgcHJvdmlkZXIuZ2V0QmxvY2soYmxvY2tJZGVudGlmaWVyKTtcbiAgICBpZiAoYmxvY2suc3RhdHVzICE9PSBcIlBFTkRJTkdcIikge1xuICAgICAgcmV0dXJuIGJsb2NrLmJsb2NrX251bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1pbnZhbGlkYXRlLW9uLWJsb2NrLnRzXG5mdW5jdGlvbiB1c2VJbnZhbGlkYXRlT25CbG9jayh7XG4gIGVuYWJsZWQgPSB0cnVlLFxuICBxdWVyeUtleTogcXVlcnlLZXkxMVxufSkge1xuICBjb25zdCBxdWVyeUNsaWVudCA9IHVzZVF1ZXJ5Q2xpZW50KCk7XG4gIGNvbnN0IFtwcmV2QmxvY2tOdW1iZXIsIHNldFByZXZCbG9ja051bWJlcl0gPSB1c2VTdGF0ZTQoKTtcbiAgY29uc3QgeyBkYXRhOiBibG9ja051bWJlciB9ID0gdXNlQmxvY2tOdW1iZXIoe1xuICAgIGVuYWJsZWRcbiAgfSk7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGlmICghcHJldkJsb2NrTnVtYmVyKSB7XG4gICAgICByZXR1cm4gc2V0UHJldkJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrTnVtYmVyICE9PSBwcmV2QmxvY2tOdW1iZXIpIHtcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHsgcXVlcnlLZXk6IHF1ZXJ5S2V5MTEgfSwgeyBjYW5jZWxSZWZldGNoOiBmYWxzZSB9KTtcbiAgICAgIHJldHVybiBzZXRQcmV2QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgIH1cbiAgfSwgW2Jsb2NrTnVtYmVyLCBwcmV2QmxvY2tOdW1iZXIsIHF1ZXJ5S2V5MTEsIHF1ZXJ5Q2xpZW50XSk7XG59XG5cbi8vIHNyYy9ob29rcy91c2UtbmV0d29yay50c1xuZnVuY3Rpb24gdXNlTmV0d29yaygpIHtcbiAgY29uc3QgeyBjaGFpbiwgY2hhaW5zIH0gPSB1c2VTdGFya25ldCgpO1xuICByZXR1cm4geyBjaGFpbiwgY2hhaW5zIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtYmFsYW5jZS50c1xudmFyIERFRkFVTFRfRkVUQ0hfSU5URVJWQUwgPSA1ZTM7XG5mdW5jdGlvbiB1c2VCYWxhbmNlKHtcbiAgdG9rZW46IHRva2VuXyxcbiAgYWRkcmVzcyxcbiAgcmVmZXRjaEludGVydmFsOiByZWZldGNoSW50ZXJ2YWxfLFxuICB3YXRjaCA9IGZhbHNlLFxuICBlbmFibGVkOiBlbmFibGVkXyA9IHRydWUsXG4gIGJsb2NrSWRlbnRpZmllciA9IEJsb2NrVGFnMi5MQVRFU1QsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgY2hhaW4gfSA9IHVzZU5ldHdvcmsoKTtcbiAgY29uc3QgdG9rZW4gPSB0b2tlbl8gPz8gY2hhaW4ubmF0aXZlQ3VycmVuY3kuYWRkcmVzcztcbiAgY29uc3QgeyBjb250cmFjdCB9ID0gdXNlQ29udHJhY3Qoe1xuICAgIGFiaTogYmFsYW5jZUFCSUZyYWdtZW50LFxuICAgIGFkZHJlc3M6IHRva2VuXG4gIH0pO1xuICBjb25zdCBxdWVyeUtleV8gPSB1c2VNZW1vMyhcbiAgICAoKSA9PiBxdWVyeUtleTIoeyBjaGFpbiwgdG9rZW4sIGFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICBbY2hhaW4sIHRva2VuLCBhZGRyZXNzLCBibG9ja0lkZW50aWZpZXJdXG4gICk7XG4gIGNvbnN0IGVuYWJsZWQgPSB1c2VNZW1vMyhcbiAgICAoKSA9PiBCb29sZWFuKGVuYWJsZWRfICYmIGNvbnRyYWN0ICYmIGFkZHJlc3MpLFxuICAgIFtlbmFibGVkXywgY29udHJhY3QsIGFkZHJlc3NdXG4gICk7XG4gIGNvbnN0IHJlZmV0Y2hJbnRlcnZhbCA9IHJlZmV0Y2hJbnRlcnZhbF8gPz8gKGJsb2NrSWRlbnRpZmllciA9PT0gQmxvY2tUYWcyLlBFTkRJTkcgJiYgd2F0Y2ggPyBERUZBVUxUX0ZFVENIX0lOVEVSVkFMIDogdm9pZCAwKTtcbiAgdXNlSW52YWxpZGF0ZU9uQmxvY2soe1xuICAgIGVuYWJsZWQ6IEJvb2xlYW4oZW5hYmxlZCAmJiB3YXRjaCksXG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5X1xuICB9KTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBlbmFibGVkLFxuICAgIHJlZmV0Y2hJbnRlcnZhbCxcbiAgICBxdWVyeUtleTogcXVlcnlLZXlfLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm4yKHsgY2hhaW4sIGNvbnRyYWN0LCB0b2tlbiwgYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyIH0pLFxuICAgIC4uLnByb3BzXG4gIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlLZXkyKHtcbiAgY2hhaW4sXG4gIHRva2VuLFxuICBhZGRyZXNzLFxuICBibG9ja0lkZW50aWZpZXJcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBlbnRpdHk6IFwiYmFsYW5jZVwiLFxuICAgICAgY2hhaW5JZDogY2hhaW4/Lm5hbWUsXG4gICAgICB0b2tlbixcbiAgICAgIGFkZHJlc3MsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBxdWVyeUZuMih7XG4gIGNoYWluLFxuICB0b2tlbixcbiAgYWRkcmVzcyxcbiAgY29udHJhY3QsXG4gIGJsb2NrSWRlbnRpZmllclxufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghYWRkcmVzcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZHJlc3MgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKCFjb250cmFjdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRyYWN0IGlzIHJlcXVpcmVkXCIpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9O1xuICAgIGNvbnN0IGlzTmF0aXZlQ3VycmVuY3kgPSB0b2tlbiA9PT0gY2hhaW4ubmF0aXZlQ3VycmVuY3kuYWRkcmVzcztcbiAgICBsZXQgc3ltYm9sID0gY2hhaW4ubmF0aXZlQ3VycmVuY3kuc3ltYm9sO1xuICAgIGlmICghaXNOYXRpdmVDdXJyZW5jeSkge1xuICAgICAgY29uc3Qgc3ltYm9sXyA9IGF3YWl0IGNvbnRyYWN0LnN5bWJvbChvcHRpb25zKTtcbiAgICAgIHN5bWJvbCA9IHNob3J0U3RyaW5nLmRlY29kZVNob3J0U3RyaW5nKG51bS50b0hleChzeW1ib2xfKSk7XG4gICAgfVxuICAgIGxldCBkZWNpbWFscyA9IGNoYWluLm5hdGl2ZUN1cnJlbmN5LmRlY2ltYWxzO1xuICAgIGlmICghaXNOYXRpdmVDdXJyZW5jeSkge1xuICAgICAgY29uc3QgZGVjaW1hbHNfID0gYXdhaXQgY29udHJhY3QuZGVjaW1hbHMob3B0aW9ucyk7XG4gICAgICBkZWNpbWFscyA9IE51bWJlcihkZWNpbWFsc18pO1xuICAgIH1cbiAgICBjb25zdCBiYWxhbmNlT2YgPSBhd2FpdCBjb250cmFjdC5iYWxhbmNlT2YoYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0VW5pdHMoYmFsYW5jZU9mLCBkZWNpbWFscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBiYWxhbmNlT2YsXG4gICAgICBkZWNpbWFscyxcbiAgICAgIHN5bWJvbCxcbiAgICAgIGZvcm1hdHRlZFxuICAgIH07XG4gIH07XG59XG52YXIgYmFsYW5jZUFCSUZyYWdtZW50ID0gW1xuICB7XG4gICAgbmFtZTogXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIsXG4gICAgdHlwZTogXCJzdHJ1Y3RcIixcbiAgICBtZW1iZXJzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwibG93XCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6aW50ZWdlcjo6dTEyOFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcImhpZ2hcIixcbiAgICAgICAgdHlwZTogXCJjb3JlOjppbnRlZ2VyOjp1MTI4XCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJhY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZV9tdXRhYmlsaXR5OiBcInZpZXdcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJzeW1ib2xcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgaW5wdXRzOiBbXSxcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiY29yZTo6ZmVsdDI1MlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZV9tdXRhYmlsaXR5OiBcInZpZXdcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJkZWNpbWFsc1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICBpbnB1dHM6IFtdLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJjb3JlOjppbnRlZ2VyOjp1OFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZV9tdXRhYmlsaXR5OiBcInZpZXdcIlxuICB9XG5dO1xuXG4vLyBzcmMvaG9va3MvdXNlLWJsb2NrLnRzXG5pbXBvcnQge1xuICBCbG9ja1RhZyBhcyBCbG9ja1RhZzNcbn0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VCbG9jayh7XG4gIGJsb2NrSWRlbnRpZmllciA9IEJsb2NrVGFnMy5MQVRFU1QsXG4gIC4uLnByb3BzXG59ID0ge30pIHtcbiAgY29uc3QgeyBwcm92aWRlciB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXkzKHsgYmxvY2tJZGVudGlmaWVyIH0pLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm4zKHsgcHJvdmlkZXIsIGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5Myh7IGJsb2NrSWRlbnRpZmllciB9KSB7XG4gIHJldHVybiBbeyBlbnRpdHk6IFwiYmxvY2tcIiwgYmxvY2tJZGVudGlmaWVyIH1dO1xufVxuZnVuY3Rpb24gcXVlcnlGbjMoe1xuICBwcm92aWRlcixcbiAgYmxvY2tJZGVudGlmaWVyXG59KSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiBhd2FpdCBwcm92aWRlci5nZXRCbG9jayhibG9ja0lkZW50aWZpZXIpO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWNhbGwudHNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIEJsb2NrVGFnIGFzIEJsb2NrVGFnNFxufSBmcm9tIFwic3RhcmtuZXRcIjtcbnZhciBERUZBVUxUX0ZFVENIX0lOVEVSVkFMMiA9IDVlMztcbmZ1bmN0aW9uIHVzZUNhbGwoe1xuICBhYmksXG4gIGFkZHJlc3MsXG4gIGZ1bmN0aW9uTmFtZSxcbiAgYXJncyxcbiAgYmxvY2tJZGVudGlmaWVyID0gQmxvY2tUYWc0LkxBVEVTVCxcbiAgcmVmZXRjaEludGVydmFsOiByZWZldGNoSW50ZXJ2YWxfLFxuICB3YXRjaCA9IGZhbHNlLFxuICBlbmFibGVkOiBlbmFibGVkXyA9IHRydWUsXG4gIHBhcnNlQXJncyxcbiAgcGFyc2VSZXN1bHQsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgY2hhaW4gfSA9IHVzZU5ldHdvcmsoKTtcbiAgY29uc3QgeyBjb250cmFjdCB9ID0gdXNlQ29udHJhY3QoeyBhYmksIGFkZHJlc3MgfSk7XG4gIGNvbnN0IHF1ZXJ5S2V5XyA9IHVzZU1lbW80KFxuICAgICgpID0+IHF1ZXJ5S2V5NCh7XG4gICAgICBjaGFpbixcbiAgICAgIGNvbnRyYWN0LFxuICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgYXJncyxcbiAgICAgIGJsb2NrSWRlbnRpZmllclxuICAgIH0pLFxuICAgIFtjaGFpbiwgY29udHJhY3QsIGZ1bmN0aW9uTmFtZSwgYXJncywgYmxvY2tJZGVudGlmaWVyXVxuICApO1xuICBjb25zdCBlbmFibGVkID0gdXNlTWVtbzQoXG4gICAgKCkgPT4gQm9vbGVhbihlbmFibGVkXyAmJiBjb250cmFjdCAmJiBmdW5jdGlvbk5hbWUgJiYgYXJncyksXG4gICAgW2VuYWJsZWRfLCBjb250cmFjdCwgZnVuY3Rpb25OYW1lLCBhcmdzXVxuICApO1xuICBjb25zdCByZWZldGNoSW50ZXJ2YWwgPSByZWZldGNoSW50ZXJ2YWxfID8/IChibG9ja0lkZW50aWZpZXIgPT09IEJsb2NrVGFnNC5QRU5ESU5HICYmIHdhdGNoID8gREVGQVVMVF9GRVRDSF9JTlRFUlZBTDIgOiB2b2lkIDApO1xuICB1c2VJbnZhbGlkYXRlT25CbG9jayh7XG4gICAgZW5hYmxlZDogQm9vbGVhbihlbmFibGVkICYmIHdhdGNoKSxcbiAgICBxdWVyeUtleTogcXVlcnlLZXlfXG4gIH0pO1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBxdWVyeUtleV8sXG4gICAgcXVlcnlGbjogcXVlcnlGbjQoe1xuICAgICAgY29udHJhY3QsXG4gICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICBhcmdzLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgcGFyc2VBcmdzLFxuICAgICAgcGFyc2VSZXN1bHRcbiAgICB9KSxcbiAgICByZWZldGNoSW50ZXJ2YWwsXG4gICAgZW5hYmxlZCxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5NCh7XG4gIGNoYWluLFxuICBjb250cmFjdCxcbiAgZnVuY3Rpb25OYW1lLFxuICBhcmdzLFxuICBibG9ja0lkZW50aWZpZXJcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBlbnRpdHk6IFwicmVhZENvbnRyYWN0XCIsXG4gICAgICBjaGFpbklkOiBjaGFpbj8ubmFtZSxcbiAgICAgIGNvbnRyYWN0OiBjb250cmFjdD8uYWRkcmVzcyxcbiAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgIGFyZ3MsXG4gICAgICBibG9ja0lkZW50aWZpZXJcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBxdWVyeUZuNCh7XG4gIGNvbnRyYWN0LFxuICBmdW5jdGlvbk5hbWUsXG4gIGFyZ3MsXG4gIGJsb2NrSWRlbnRpZmllcixcbiAgcGFyc2VBcmdzID0gdHJ1ZSxcbiAgcGFyc2VSZXN1bHQgPSB0cnVlXG59KSB7XG4gIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFjb250cmFjdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRyYWN0IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmIChjb250cmFjdC5mdW5jdGlvbnNbZnVuY3Rpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSBub3QgZm91bmQgaW4gY29udHJhY3RgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNhbGwoZnVuY3Rpb25OYW1lLCBhcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHBhcnNlQXJncyxcbiAgICAgIHBhcnNlUmVzcG9uc2U6IHBhcnNlUmVzdWx0LFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgfSk7XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtY29udHJhY3QtZmFjdG9yeS50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vNSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQ29udHJhY3RGYWN0b3J5IH0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VDb250cmFjdEZhY3Rvcnkoe1xuICBjb21waWxlZENvbnRyYWN0LFxuICBjbGFzc0hhc2gsXG4gIGFiaVxufSkge1xuICBjb25zdCB7IGFjY291bnQgfSA9IHVzZUFjY291bnQoKTtcbiAgY29uc3QgY29udHJhY3RGYWN0b3J5ID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIGlmIChjb21waWxlZENvbnRyYWN0ICYmIGFjY291bnQgJiYgY2xhc3NIYXNoKSB7XG4gICAgICByZXR1cm4gbmV3IENvbnRyYWN0RmFjdG9yeSh7XG4gICAgICAgIGNvbXBpbGVkQ29udHJhY3QsXG4gICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgYWJpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfSwgW2NvbXBpbGVkQ29udHJhY3QsIGNsYXNzSGFzaCwgYWNjb3VudCwgYWJpXSk7XG4gIHJldHVybiB7IGNvbnRyYWN0RmFjdG9yeSB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLWRlY2xhcmUtY29udHJhY3QudHNcbmZ1bmN0aW9uIHVzZURlY2xhcmVDb250cmFjdChwcm9wcykge1xuICBjb25zdCB7IHBhcmFtcywgLi4ucmVzdCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgcmVxdWVzdCwgcmVxdWVzdEFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZVdhbGxldFJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiLFxuICAgIHBhcmFtcyxcbiAgICAuLi5yZXN0XG4gIH0pO1xuICBjb25zdCBkZWNsYXJlID0gKGFyZ3MpID0+IHtcbiAgICByZXR1cm4gcmVxdWVzdChcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCJcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICB9O1xuICBjb25zdCBkZWNsYXJlQXN5bmMgPSAoYXJncykgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0QXN5bmMoXG4gICAgICBhcmdzID8ge1xuICAgICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X2FkZERlY2xhcmVUcmFuc2FjdGlvblwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBkZWNsYXJlLFxuICAgIGRlY2xhcmVBc3luYyxcbiAgICAuLi5yZXN1bHRcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1kZXBsb3ktYWNjb3VudC50c1xuZnVuY3Rpb24gdXNlRGVwbG95QWNjb3VudCh7XG4gIGNsYXNzSGFzaCxcbiAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgYWRkcmVzc1NhbHQsXG4gIGNvbnRyYWN0QWRkcmVzcyxcbiAgb3B0aW9ucyxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgeyBhY2NvdW50IH0gPSB1c2VBY2NvdW50KCk7XG4gIGNvbnN0IHsgbXV0YXRlLCBtdXRhdGVBc3luYywgLi4ucmVzdWx0IH0gPSB1c2VNdXRhdGlvbih7XG4gICAgbXV0YXRpb25LZXk6IG11dGF0aW9uS2V5Mih7XG4gICAgICBhY2NvdW50LFxuICAgICAgY2xhc3NIYXNoLFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgb3B0aW9uc1xuICAgIH0pLFxuICAgIG11dGF0aW9uRm46IG11dGF0aW9uRm4yKHtcbiAgICAgIGFjY291bnQsXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBvcHRpb25zXG4gICAgfSksXG4gICAgLi4ucHJvcHNcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZGVwbG95QWNjb3VudDogbXV0YXRlLFxuICAgIGRlcGxveUFjY291bnRBc3luYzogbXV0YXRlQXN5bmMsXG4gICAgLi4ucmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBtdXRhdGlvbktleTIocHJvcHMpIHtcbiAgcmV0dXJuIFt7IGVudGl0eTogXCJkZXBsb3lBY2NvdW50XCIsIC4uLnByb3BzIH1dO1xufVxuZnVuY3Rpb24gbXV0YXRpb25GbjIoe1xuICBhY2NvdW50LFxuICBjbGFzc0hhc2gsXG4gIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gIGFkZHJlc3NTYWx0LFxuICBjb250cmFjdEFkZHJlc3MsXG4gIG9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWFjY291bnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhY2NvdW50IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmICghY2xhc3NIYXNoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2xhc3NIYXNoIGlzIHJlcXVpcmVkXCIpO1xuICAgIHJldHVybiBhd2FpdCBhY2NvdW50LmRlcGxveUFjY291bnQoXG4gICAgICB7IGNsYXNzSGFzaCwgY29uc3RydWN0b3JDYWxsZGF0YSwgYWRkcmVzc1NhbHQsIGNvbnRyYWN0QWRkcmVzcyB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2UtZGlzY29ubmVjdC50c1xuZnVuY3Rpb24gdXNlRGlzY29ubmVjdChwcm9wcyA9IHt9KSB7XG4gIGNvbnN0IHsgZGlzY29ubmVjdCwgY2hhaW4gfSA9IHVzZVN0YXJrbmV0KCk7XG4gIGNvbnN0IHsgbXV0YXRlLCBtdXRhdGVBc3luYywgLi4ucmVzdWx0IH0gPSB1c2VNdXRhdGlvbih7XG4gICAgbXV0YXRpb25LZXk6IFt7IGVudGl0eTogXCJkaXNjb25uZWN0XCIsIGNoYWluSWQ6IGNoYWluLm5hbWUgfV0sXG4gICAgbXV0YXRpb25GbjogZGlzY29ubmVjdCxcbiAgICAuLi5wcm9wc1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBkaXNjb25uZWN0OiBtdXRhdGUsXG4gICAgZGlzY29ubmVjdEFzeW5jOiBtdXRhdGVBc3luYyxcbiAgICAuLi5yZXN1bHRcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1lc3RpbWF0ZS1mZWVzLnRzXG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW82IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VFc3RpbWF0ZUZlZXMoe1xuICBjYWxscyxcbiAgb3B0aW9ucyxcbiAgd2F0Y2ggPSBmYWxzZSxcbiAgZW5hYmxlZDogZW5hYmxlZF8gPSB0cnVlLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IGFjY291bnQgfSA9IHVzZUFjY291bnQoKTtcbiAgY29uc3QgcXVlcnlLZXlfID0gdXNlTWVtbzYoXG4gICAgKCkgPT4gcXVlcnlLZXk1KHsgY2FsbHMsIG9wdGlvbnMgfSksXG4gICAgW2NhbGxzLCBvcHRpb25zXVxuICApO1xuICBjb25zdCBlbmFibGVkID0gdXNlTWVtbzYoKCkgPT4gQm9vbGVhbihlbmFibGVkXyAmJiBjYWxscyksIFtlbmFibGVkXywgY2FsbHNdKTtcbiAgdXNlSW52YWxpZGF0ZU9uQmxvY2soe1xuICAgIGVuYWJsZWQ6IEJvb2xlYW4oZW5hYmxlZCAmJiB3YXRjaCksXG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5X1xuICB9KTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXlfLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm41KHtcbiAgICAgIGFjY291bnQsXG4gICAgICBjYWxscyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KSxcbiAgICBlbmFibGVkLFxuICAgIC4uLnByb3BzXG4gIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlLZXk1KHsgY2FsbHMsIG9wdGlvbnMgfSkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGVudGl0eTogXCJlc3RpbWF0ZUludm9rZUZlZVwiLFxuICAgICAgY2FsbHMsXG4gICAgICBvcHRpb25zXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gcXVlcnlGbjUoe1xuICBhY2NvdW50LFxuICBjYWxscyxcbiAgb3B0aW9uc1xufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghYWNjb3VudClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFjY291bnQgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKCFjYWxscyB8fCBjYWxscy5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxscyBhcmUgcmVxdWlyZWRcIik7XG4gICAgcmV0dXJuIGFjY291bnQ/LmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBvcHRpb25zKTtcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1leHBsb3Jlci50c1xuZnVuY3Rpb24gdXNlRXhwbG9yZXIoKSB7XG4gIGNvbnN0IHsgZXhwbG9yZXIsIGNoYWluIH0gPSB1c2VTdGFya25ldCgpO1xuICBpZiAoIWV4cGxvcmVyKVxuICAgIHRocm93IEVycm9yKFwiRXhwbG9yZXIgaXMgdW5kZWZpbmVkLiBUcnkgYWRkaW5nIGl0IHRvIFN0YXJrbmV0Q29uZmlnLlwiKTtcbiAgY29uc3QgZXhwbG9yZXJJbnN0YW5jZSA9IGV4cGxvcmVyKGNoYWluKTtcbiAgaWYgKCFleHBsb3Jlckluc3RhbmNlKVxuICAgIHRocm93IEVycm9yKFwiRXhwbG9yZXIgSW5zdGFuY2UgaXMgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gZXhwbG9yZXJJbnN0YW5jZTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1ub25jZS1mb3ItYWRkcmVzcy50c1xuaW1wb3J0IHtcbiAgQmxvY2tUYWcgYXMgQmxvY2tUYWc1XG59IGZyb20gXCJzdGFya25ldFwiO1xuZnVuY3Rpb24gdXNlTm9uY2VGb3JBZGRyZXNzKHtcbiAgYWRkcmVzcyxcbiAgYmxvY2tJZGVudGlmaWVyID0gQmxvY2tUYWc1LkxBVEVTVCxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgeyBwcm92aWRlciB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXk2KHsgYWRkcmVzcywgYmxvY2tJZGVudGlmaWVyIH0pLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm42KHsgYWRkcmVzcywgcHJvdmlkZXIsIGJsb2NrSWRlbnRpZmllciB9KSxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5Nih7XG4gIGFkZHJlc3MsXG4gIGJsb2NrSWRlbnRpZmllclxufSkge1xuICByZXR1cm4gW3sgZW50aXR5OiBcIm5vbmNlXCIsIGJsb2NrSWRlbnRpZmllciwgYWRkcmVzcyB9XTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5Rm42KHtcbiAgcHJvdmlkZXIsXG4gIGJsb2NrSWRlbnRpZmllcixcbiAgYWRkcmVzc1xufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG5vbmNlID0gYXdhaXQgcHJvdmlkZXIuZ2V0Tm9uY2VGb3JBZGRyZXNzKGFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgcmV0dXJuIG5vbmNlO1xuICB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXByb3ZpZGVyLnRzXG5mdW5jdGlvbiB1c2VQcm92aWRlcigpIHtcbiAgY29uc3QgeyBwcm92aWRlciB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgcmV0dXJuIHsgcHJvdmlkZXIgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1yZWFkLWNvbnRyYWN0LnRzXG5mdW5jdGlvbiB1c2VSZWFkQ29udHJhY3QocHJvcHMpIHtcbiAgcmV0dXJuIHVzZUNhbGwocHJvcHMpO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXNlbmQtdHJhbnNhY3Rpb24udHNcbmZ1bmN0aW9uIHVzZVNlbmRUcmFuc2FjdGlvbihwcm9wcykge1xuICBjb25zdCB7IGNhbGxzLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgY29uc3QgcGFyYW1zID0gY2FsbHMgPyB7IGNhbGxzOiB0cmFuc2Zvcm1DYWxsczIoY2FsbHMpIH0gOiB2b2lkIDA7XG4gIGNvbnN0IHsgcmVxdWVzdCwgcmVxdWVzdEFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZVdhbGxldFJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCIsXG4gICAgcGFyYW1zLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IHNlbmQgPSAoYXJncykgPT4ge1xuICAgIHJldHVybiByZXF1ZXN0KFxuICAgICAgYXJncyA/IHtcbiAgICAgICAgcGFyYW1zOiB7IGNhbGxzOiB0cmFuc2Zvcm1DYWxsczIoYXJncykgfSxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHNlbmRBc3luYyA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyhcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogeyBjYWxsczogdHJhbnNmb3JtQ2FsbHMyKGFyZ3MpIH0sXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCJcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHNlbmQsXG4gICAgc2VuZEFzeW5jLFxuICAgIC4uLnJlc3VsdFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ2FsbHMyKGNhbGxzKSB7XG4gIHJldHVybiBjYWxscy5tYXAoXG4gICAgKGNhbGwpID0+ICh7XG4gICAgICBjb250cmFjdF9hZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGVudHJ5X3BvaW50OiBjYWxsLmVudHJ5cG9pbnQsXG4gICAgICBjYWxsZGF0YTogY2FsbC5jYWxsZGF0YVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy9ob29rcy91c2Utc2lnbi50c1xuZnVuY3Rpb24gdXNlU2lnblR5cGVkRGF0YShwcm9wcykge1xuICBjb25zdCB7IHBhcmFtcywgLi4ucmVzdCB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgcmVxdWVzdCwgcmVxdWVzdEFzeW5jLCAuLi5yZXN1bHQgfSA9IHVzZVdhbGxldFJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3NpZ25UeXBlZERhdGFcIixcbiAgICBwYXJhbXMsXG4gICAgLi4ucmVzdFxuICB9KTtcbiAgY29uc3Qgc2lnblR5cGVkRGF0YSA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3QoXG4gICAgICBhcmdzID8ge1xuICAgICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgICAgIHR5cGU6IFwid2FsbGV0X3NpZ25UeXBlZERhdGFcIlxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH07XG4gIGNvbnN0IHNpZ25UeXBlZERhdGFBc3luYyA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyhcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfc2lnblR5cGVkRGF0YVwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzaWduVHlwZWREYXRhLFxuICAgIHNpZ25UeXBlZERhdGFBc3luYyxcbiAgICAuLi5yZXN1bHRcbiAgfTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZS1zdGFyay1hZGRyZXNzLnRzXG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW83IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBDYWxsRGF0YSxcbiAgUHJvdmlkZXIsXG4gIHN0YXJrbmV0SWRcbn0gZnJvbSBcInN0YXJrbmV0XCI7XG5mdW5jdGlvbiB1c2VTdGFya0FkZHJlc3Moe1xuICBuYW1lLFxuICBjb250cmFjdCxcbiAgZW5hYmxlZDogZW5hYmxlZF8gPSB0cnVlLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IHByb3ZpZGVyIH0gPSB1c2VQcm92aWRlcigpO1xuICBjb25zdCB7IGNoYWluIH0gPSB1c2VOZXR3b3JrKCk7XG4gIGNvbnN0IGVuYWJsZWQgPSB1c2VNZW1vNygoKSA9PiBCb29sZWFuKGVuYWJsZWRfICYmIG5hbWUpLCBbZW5hYmxlZF8sIG5hbWVdKTtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXk3KHsgbmFtZSwgY29udHJhY3QsIG5ldHdvcms6IGNoYWluLm5ldHdvcmsgfSksXG4gICAgcXVlcnlGbjogcXVlcnlGbjcoeyBuYW1lLCBjb250cmFjdCwgcHJvdmlkZXIsIG5ldHdvcms6IGNoYWluLm5ldHdvcmsgfSksXG4gICAgZW5hYmxlZCxcbiAgICAuLi5wcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5Nyh7XG4gIG5hbWUsXG4gIGNvbnRyYWN0LFxuICBuZXR3b3JrXG59KSB7XG4gIHJldHVybiBbeyBlbnRpdHk6IFwiYWRkcmVzc0Zyb21TdGFya05hbWVcIiwgbmFtZSwgY29udHJhY3QsIG5ldHdvcmsgfV07XG59XG5mdW5jdGlvbiBxdWVyeUZuNyh7XG4gIG5hbWUsXG4gIGNvbnRyYWN0LFxuICBwcm92aWRlcixcbiAgbmV0d29ya1xufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgaXMgcmVxdWlyZWRcIik7XG4gICAgY29uc3QgbmFtaW5nQ29udHJhY3QgPSBjb250cmFjdCA/PyBTdGFya25ldElkTmFtaW5nQ29udHJhY3RbbmV0d29ya107XG4gICAgY29uc3QgcCA9IG5ldyBQcm92aWRlcihwcm92aWRlcik7XG4gICAgY29uc3QgZW5jb2RlZERvbWFpbiA9IGVuY29kZURvbWFpbihuYW1lKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwLmNhbGxDb250cmFjdCh7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IG5hbWluZ0NvbnRyYWN0LFxuICAgICAgZW50cnlwb2ludDogXCJkb21haW5fdG9fYWRkcmVzc1wiLFxuICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoeyBkb21haW46IGVuY29kZWREb21haW4sIGhpbnQ6IFtdIH0pXG4gICAgfSk7XG4gICAgaWYgKEJpZ0ludChyZXN1bHRbMF0pID09PSBCaWdJbnQoMCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzIG5vdCBmb3VuZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdO1xuICB9O1xufVxudmFyIFN0YXJrbmV0SWROYW1pbmdDb250cmFjdCA9IHtcbiAgc2Vwb2xpYTogXCIweDE1NGJjMmUxYWY5MjYwYjllNjZhZjBlOWM0NmZjNzU3ZmY4OTNiM2ZmNmE4NTcxOGE4MTBiYWYxNDc0XCIsXG4gIG1haW5uZXQ6IFwiMHg2YWM1OTdmODExNmY4ODZmYTFjOTdhMjNmYTRlMDgyOTk5NzVlY2FmNmI1OTg4NzNjYTY3OTJiOWJiZmI2NzhcIlxufTtcbnZhciBlbmNvZGVEb21haW4gPSAoZG9tYWluKSA9PiB7XG4gIGlmICghZG9tYWluKVxuICAgIHJldHVybiBbXCIwXCJdO1xuICBjb25zdCBlbmNvZGVkID0gW107XG4gIGZvciAoY29uc3Qgc3ViZG9tYWluIG9mIGRvbWFpbi5yZXBsYWNlKFwiLnN0YXJrXCIsIFwiXCIpLnNwbGl0KFwiLlwiKSlcbiAgICBlbmNvZGVkLnB1c2goc3RhcmtuZXRJZC51c2VFbmNvZGVkKHN1YmRvbWFpbikudG9TdHJpbmcoMTApKTtcbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlLXN0YXJrLW5hbWUudHNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzggfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIFByb3ZpZGVyIGFzIFByb3ZpZGVyMlxufSBmcm9tIFwic3RhcmtuZXRcIjtcbmZ1bmN0aW9uIHVzZVN0YXJrTmFtZSh7XG4gIGFkZHJlc3MsXG4gIGNvbnRyYWN0LFxuICBlbmFibGVkOiBlbmFibGVkXyA9IHRydWUsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHVzZVByb3ZpZGVyKCk7XG4gIGNvbnN0IHsgY2hhaW4gfSA9IHVzZU5ldHdvcmsoKTtcbiAgY29uc3QgZW5hYmxlZCA9IHVzZU1lbW84KFxuICAgICgpID0+IEJvb2xlYW4oZW5hYmxlZF8gJiYgYWRkcmVzcyksXG4gICAgW2VuYWJsZWRfLCBhZGRyZXNzXVxuICApO1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBxdWVyeUtleTgoeyBhZGRyZXNzLCBjb250cmFjdCwgbmV0d29yazogY2hhaW4ubmV0d29yayB9KSxcbiAgICBxdWVyeUZuOiBxdWVyeUZuOCh7IGFkZHJlc3MsIGNvbnRyYWN0LCBwcm92aWRlciwgbmV0d29yazogY2hhaW4ubmV0d29yayB9KSxcbiAgICBlbmFibGVkLFxuICAgIC4uLnByb3BzXG4gIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlLZXk4KHtcbiAgYWRkcmVzcyxcbiAgY29udHJhY3QsXG4gIG5ldHdvcmtcbn0pIHtcbiAgcmV0dXJuIFt7IGVudGl0eTogXCJzdGFya05hbWVcIiwgYWRkcmVzcywgY29udHJhY3QsIG5ldHdvcmsgfV07XG59XG5mdW5jdGlvbiBxdWVyeUZuOCh7XG4gIGFkZHJlc3MsXG4gIGNvbnRyYWN0LFxuICBwcm92aWRlcixcbiAgbmV0d29ya1xufSkge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghYWRkcmVzcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZHJlc3MgaXMgcmVxdWlyZWRcIik7XG4gICAgY29uc3QgbmFtaW5nQ29udHJhY3QgPSBjb250cmFjdCA/PyBTdGFya25ldElkTmFtaW5nQ29udHJhY3QyW25ldHdvcmtdO1xuICAgIGNvbnN0IHAgPSBuZXcgUHJvdmlkZXIyKHByb3ZpZGVyKTtcbiAgICByZXR1cm4gYXdhaXQgcC5nZXRTdGFya05hbWUoYWRkcmVzcywgbmFtaW5nQ29udHJhY3QpO1xuICB9O1xufVxudmFyIFN0YXJrbmV0SWROYW1pbmdDb250cmFjdDIgPSB7XG4gIHNlcG9saWE6IFwiMHgxNTRiYzJlMWFmOTI2MGI5ZTY2YWYwZTljNDZmYzc1N2ZmODkzYjNmZjZhODU3MThhODEwYmFmMTQ3NFwiLFxuICBtYWlubmV0OiBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCJcbn07XG5cbi8vIHNyYy9ob29rcy91c2Utc3RhcmstcHJvZmlsZS50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vOSB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlU3RhcmtQcm9maWxlKHtcbiAgYWRkcmVzcyxcbiAgdXNlRGVmYXVsdFBmcCA9IHRydWUsXG4gIG5hbWluZ0NvbnRyYWN0LFxuICBpZGVudGl0eUNvbnRyYWN0LFxuICBlbmFibGVkOiBlbmFibGVkXyA9IHRydWUsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHVzZVByb3ZpZGVyKCk7XG4gIGNvbnN0IHsgY2hhaW4gfSA9IHVzZU5ldHdvcmsoKTtcbiAgaWYgKCFTdGFya25ldElkY29udHJhY3RzW2NoYWluLm5ldHdvcmtdKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgbm90IHN1cHBvcnRlZFwiKTtcbiAgY29uc3QgeyBjb250cmFjdDogbXVsdGljYWxsQ29udHJhY3QgfSA9IHVzZUNvbnRyYWN0KHtcbiAgICBhYmk6IG11bHRpY2FsbEFCSSxcbiAgICBhZGRyZXNzOiBTdGFya25ldElkY29udHJhY3RzW2NoYWluLm5ldHdvcmtdW1wibXVsdGljYWxsXCJdXG4gIH0pO1xuICBjb25zdCBlbmFibGVkID0gdXNlTWVtbzkoXG4gICAgKCkgPT4gQm9vbGVhbihlbmFibGVkXyAmJiBhZGRyZXNzKSxcbiAgICBbZW5hYmxlZF8sIGFkZHJlc3NdXG4gICk7XG4gIGNvbnN0IHsgcmVmZXRjaEludGVydmFsLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogcXVlcnlLZXk5KHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBuYW1pbmdDb250cmFjdCxcbiAgICAgIGlkZW50aXR5Q29udHJhY3QsXG4gICAgICBuZXR3b3JrOiBjaGFpbi5uZXR3b3JrLFxuICAgICAgdXNlRGVmYXVsdFBmcFxuICAgIH0pLFxuICAgIHF1ZXJ5Rm46IHF1ZXJ5Rm45KHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICB1c2VEZWZhdWx0UGZwLFxuICAgICAgbmFtaW5nQ29udHJhY3QsXG4gICAgICBwcm92aWRlcixcbiAgICAgIG5ldHdvcms6IGNoYWluLm5ldHdvcmssXG4gICAgICBpZGVudGl0eUNvbnRyYWN0LFxuICAgICAgbXVsdGljYWxsQ29udHJhY3RcbiAgICB9KSxcbiAgICBlbmFibGVkLFxuICAgIHJlZmV0Y2hJbnRlcnZhbCxcbiAgICAuLi5yZXN0XG4gIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlLZXk5KHtcbiAgYWRkcmVzcyxcbiAgbmFtaW5nQ29udHJhY3QsXG4gIGlkZW50aXR5Q29udHJhY3QsXG4gIG5ldHdvcmssXG4gIHVzZURlZmF1bHRQZnBcbn0pIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBlbnRpdHk6IFwic3Rhcmtwcm9maWxlXCIsXG4gICAgICBhZGRyZXNzLFxuICAgICAgbmFtaW5nQ29udHJhY3QsXG4gICAgICBpZGVudGl0eUNvbnRyYWN0LFxuICAgICAgbmV0d29yayxcbiAgICAgIHVzZURlZmF1bHRQZnBcbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBxdWVyeUZuOSh7XG4gIGFkZHJlc3MsXG4gIHVzZURlZmF1bHRQZnAsXG4gIG5hbWluZ0NvbnRyYWN0LFxuICBpZGVudGl0eUNvbnRyYWN0LFxuICBwcm92aWRlcixcbiAgbmV0d29yayxcbiAgbXVsdGljYWxsQ29udHJhY3Rcbn0pIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH07XG59XG52YXIgU3RhcmtuZXRJZGNvbnRyYWN0cyA9IHtcbiAgc2Vwb2xpYToge1xuICAgIG5hbWluZzogXCIweDE1NGJjMmUxYWY5MjYwYjllNjZhZjBlOWM0NmZjNzU3ZmY4OTNiM2ZmNmE4NTcxOGE4MTBiYWYxNDc0XCIsXG4gICAgaWRlbnRpdHk6IFwiMHgzNjk3NjYwYTA5ODFkNzM0NzgwNzMxOTQ5ZWNiMmI0YTM4ZDZhNThmYzQxNjI5ZWQ2MTFlOGRlZmRhXCIsXG4gICAgdmVyaWZpZXI6IFwiMHg2MEI5NGZFRGU1MjVmODE1QUU1RTgzNzdBNDYzZTEyMUM3ODdjQ0NmM2EzNjM1OEFhOUIxOGMxMmM0RDU2NlwiLFxuICAgIHZlcmlmaWVyX3BvcDogXCIweDE1YWU4OGFlMDU0Y2FhNzQwOTBiODkwMjVjMTU5NTY4M2YxMmVkZjdhNGVkMmFkMDI3NGRlM2UxZDRhXCIsXG4gICAgdmVyaWZpZXJfcGZwOiBcIjB4OWU3YmRiOGRhYmQwMmVhOGNmYzIzYjFkMWM1Mjc4ZTQ2NDkwZjE5M2Y4NzUxNmVkNWZmMmRmZWMwMlwiLFxuICAgIG11bHRpY2FsbDogXCIweDA3YTkwMTM2OTczNzFjZTQwZDAzMDZiNGM4MTBjNmE0ZGI5YmZkYTExOWRkOWFlMWU4NzAxYzhlMjg4ZDczNGJcIlxuICB9LFxuICBtYWlubmV0OiB7XG4gICAgbmFtaW5nOiBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCIsXG4gICAgaWRlbnRpdHk6IFwiMHgwNWRiZGVkYzIwM2U5Mjc0OWUyZTc0NmUyZDQwYTc2OGQ5NjZiZDI0M2RmMDRhNmI3MTJlMjIyYmMwNDBhOWFmXCIsXG4gICAgdmVyaWZpZXI6IFwiMHgwN2QxNGRmZDhlZTk1YjQxZmNlMTc5MTcwZDg4YmExZjBkNWE1MTJlMTNhZWIyMzJmMTljZmVlYzBhODhmOGJmXCIsXG4gICAgdmVyaWZpZXJfcG9wOiBcIjB4MDI5M2ViMmJhOTg2MmY3NjJiZDMwMzY1ODZkNTc1NWE3ODJiZDIyZTZmNTAyODMyMGYxZDA0MDVmZDQ3YmZmNFwiLFxuICAgIHZlcmlmaWVyX3BmcDogXCIweDA3MGFhYTIwZWM0YTQ2ZGE1N2M5MzJkOWZkODljYTVlNmJiOWNhMzE4OGQzZGYzNjFhMzIzMDZhZmY3ZDU5YzdcIixcbiAgICBtdWx0aWNhbGw6IFwiMHgwMzRmZmI4ZjQ0NTJkZjdhNjEzYTAyMTA4MjRkNjQxNGRiYWRjZGRjZTZjNmUxOWJmNGRkYzllMjJjZTVmOTcwXCJcbiAgfVxufTtcbnZhciBtdWx0aWNhbGxBQkkgPSBbXG4gIHtcbiAgICBuYW1lOiBcIkNvbXBvc2FibGVNdWx0aWNhbGxJbXBsXCIsXG4gICAgdHlwZTogXCJpbXBsXCIsXG4gICAgaW50ZXJmYWNlX25hbWU6IFwiY29tcG9zYWJsZV9tdWx0aWNhbGw6OklDb21wb3NhYmxlTXVsdGljYWxsXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiY29tcG9zYWJsZV9tdWx0aWNhbGw6OkV4ZWN1dGlvblwiLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiU3RhdGljXCIsXG4gICAgICAgIHR5cGU6IFwiKClcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJJZkVxdWFsXCIsXG4gICAgICAgIHR5cGU6IFwiKGNvcmU6OmludGVnZXI6OnUzMiwgY29yZTo6aW50ZWdlcjo6dTMyLCBjb3JlOjpmZWx0MjUyKVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIklmTm90RXF1YWxcIixcbiAgICAgICAgdHlwZTogXCIoY29yZTo6aW50ZWdlcjo6dTMyLCBjb3JlOjppbnRlZ2VyOjp1MzIsIGNvcmU6OmZlbHQyNTIpXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcImNvbXBvc2FibGVfbXVsdGljYWxsOjpEeW5hbWljRmVsdFwiLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiSGFyZGNvZGVkXCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6ZmVsdDI1MlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlJlZmVyZW5jZVwiLFxuICAgICAgICB0eXBlOiBcIihjb3JlOjppbnRlZ2VyOjp1MzIsIGNvcmU6OmludGVnZXI6OnUzMilcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiY29tcG9zYWJsZV9tdWx0aWNhbGw6OkR5bmFtaWNDYWxsZGF0YVwiLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiSGFyZGNvZGVkXCIsXG4gICAgICAgIHR5cGU6IFwiY29yZTo6ZmVsdDI1MlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIlJlZmVyZW5jZVwiLFxuICAgICAgICB0eXBlOiBcIihjb3JlOjppbnRlZ2VyOjp1MzIsIGNvcmU6OmludGVnZXI6OnUzMilcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJBcnJheVJlZmVyZW5jZVwiLFxuICAgICAgICB0eXBlOiBcIihjb3JlOjppbnRlZ2VyOjp1MzIsIGNvcmU6OmludGVnZXI6OnUzMilcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiY29tcG9zYWJsZV9tdWx0aWNhbGw6OkR5bmFtaWNDYWxsXCIsXG4gICAgdHlwZTogXCJzdHJ1Y3RcIixcbiAgICBtZW1iZXJzOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiZXhlY3V0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwiY29tcG9zYWJsZV9tdWx0aWNhbGw6OkV4ZWN1dGlvblwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcInRvXCIsXG4gICAgICAgIHR5cGU6IFwiY29tcG9zYWJsZV9tdWx0aWNhbGw6OkR5bmFtaWNGZWx0XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwic2VsZWN0b3JcIixcbiAgICAgICAgdHlwZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6RHluYW1pY0ZlbHRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJjYWxsZGF0YVwiLFxuICAgICAgICB0eXBlOiBcImNvcmU6OmFycmF5OjpBcnJheTo6PGNvbXBvc2FibGVfbXVsdGljYWxsOjpEeW5hbWljQ2FsbGRhdGE+XCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcImNvcmU6OmFycmF5OjpTcGFuOjo8Y29yZTo6ZmVsdDI1Mj5cIixcbiAgICB0eXBlOiBcInN0cnVjdFwiLFxuICAgIG1lbWJlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJzbmFwc2hvdFwiLFxuICAgICAgICB0eXBlOiBcIkBjb3JlOjphcnJheTo6QXJyYXk6Ojxjb3JlOjpmZWx0MjUyPlwiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgbmFtZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6SUNvbXBvc2FibGVNdWx0aWNhbGxcIixcbiAgICB0eXBlOiBcImludGVyZmFjZVwiLFxuICAgIGl0ZW1zOiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiYWdncmVnYXRlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJjYWxsc1wiLFxuICAgICAgICAgICAgdHlwZTogXCJjb3JlOjphcnJheTo6QXJyYXk6Ojxjb21wb3NhYmxlX211bHRpY2FsbDo6RHluYW1pY0NhbGw+XCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImNvcmU6OmFycmF5OjpBcnJheTo6PGNvcmU6OmFycmF5OjpTcGFuOjo8Y29yZTo6ZmVsdDI1Mj4+XCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlX211dGFiaWxpdHk6IFwidmlld1wiXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAga2luZDogXCJlbnVtXCIsXG4gICAgbmFtZTogXCJjb21wb3NhYmxlX211bHRpY2FsbDo6Y29udHJhY3Q6OkNvbXBvc2FibGVNdWx0aWNhbGw6OkV2ZW50XCIsXG4gICAgdHlwZTogXCJldmVudFwiLFxuICAgIHZhcmlhbnRzOiBbXVxuICB9XG5dO1xuXG4vLyBzcmMvaG9va3MvdXNlLXN3aXRjaC1jaGFpbi50c1xuZnVuY3Rpb24gdXNlU3dpdGNoQ2hhaW4ocHJvcHMpIHtcbiAgY29uc3QgeyBwYXJhbXMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICBjb25zdCB7IHJlcXVlc3QsIHJlcXVlc3RBc3luYywgLi4ucmVzdWx0IH0gPSB1c2VXYWxsZXRSZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9zd2l0Y2hTdGFya25ldENoYWluXCIsXG4gICAgcGFyYW1zLFxuICAgIC4uLnJlc3RcbiAgfSk7XG4gIGNvbnN0IHN3aXRjaENoYWluID0gKGFyZ3MpID0+IHtcbiAgICByZXR1cm4gcmVxdWVzdChcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfc3dpdGNoU3RhcmtuZXRDaGFpblwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgY29uc3Qgc3dpdGNoQ2hhaW5Bc3luYyA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyhcbiAgICAgIGFyZ3MgPyB7XG4gICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgdHlwZTogXCJ3YWxsZXRfc3dpdGNoU3RhcmtuZXRDaGFpblwiXG4gICAgICB9IDogdm9pZCAwXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzd2l0Y2hDaGFpbixcbiAgICBzd2l0Y2hDaGFpbkFzeW5jLFxuICAgIC4uLnJlc3VsdFxuICB9O1xufVxuXG4vLyBzcmMvaG9va3MvdXNlLXRyYW5zYWN0aW9uLXJlY2VpcHQudHNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzEwIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VUcmFuc2FjdGlvblJlY2VpcHQoe1xuICBoYXNoLFxuICB3YXRjaCxcbiAgZW5hYmxlZDogZW5hYmxlZF8gPSB0cnVlLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCB7IHByb3ZpZGVyLCBjaGFpbiB9ID0gdXNlU3RhcmtuZXQoKTtcbiAgY29uc3QgcXVlcnlLZXlfID0gdXNlTWVtbzEwKCgpID0+IHF1ZXJ5S2V5MTAoeyBjaGFpbiwgaGFzaCB9KSwgW2NoYWluLCBoYXNoXSk7XG4gIGNvbnN0IGVuYWJsZWQgPSB1c2VNZW1vMTAoKCkgPT4gQm9vbGVhbihlbmFibGVkXyAmJiBoYXNoKSwgW2VuYWJsZWRfLCBoYXNoXSk7XG4gIHVzZUludmFsaWRhdGVPbkJsb2NrKHtcbiAgICBlbmFibGVkOiBCb29sZWFuKGVuYWJsZWQgJiYgd2F0Y2gpLFxuICAgIHF1ZXJ5S2V5OiBxdWVyeUtleV9cbiAgfSk7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IHF1ZXJ5S2V5XyxcbiAgICBxdWVyeUZuOiBxdWVyeUZuMTAoeyBwcm92aWRlciwgaGFzaCB9KSxcbiAgICBlbmFibGVkLFxuICAgIC4uLnByb3BzXG4gIH0pO1xufVxuZnVuY3Rpb24gcXVlcnlLZXkxMCh7IGNoYWluLCBoYXNoIH0pIHtcbiAgcmV0dXJuIFtcbiAgICB7IGVudGl0eTogXCJ0cmFuc2FjdGlvblJlY2VpcHRcIiwgY2hhaW5JZDogY2hhaW4/Lm5hbWUsIGhhc2ggfVxuICBdO1xufVxuZnVuY3Rpb24gcXVlcnlGbjEwKHtcbiAgcHJvdmlkZXIsXG4gIGhhc2hcbn0pIHtcbiAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWhhc2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYXNoIGlzIHJlcXVpcmVkXCIpO1xuICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gIH07XG59XG5cbi8vIHNyYy9wcm92aWRlcnMvanNvbnJwYy50c1xuaW1wb3J0IHsgUnBjUHJvdmlkZXIgfSBmcm9tIFwic3RhcmtuZXRcIjtcbmZ1bmN0aW9uIGpzb25ScGNQcm92aWRlcih7XG4gIHJwY1xufSkge1xuICByZXR1cm4gKGNoYWluKSA9PiB7XG4gICAgY29uc3QgY29uZmlnID0gcnBjKGNoYWluKTtcbiAgICBpZiAoIWNvbmZpZylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNoYWluSWQgPSBzdGFya25ldENoYWluSWQoY2hhaW4uaWQpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFJwY1Byb3ZpZGVyKHsgLi4uY29uZmlnLCBjaGFpbklkIH0pO1xuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9wdWJsaWMudHNcbmZ1bmN0aW9uIHB1YmxpY1Byb3ZpZGVyKCkge1xuICByZXR1cm4ganNvblJwY1Byb3ZpZGVyKHtcbiAgICBycGM6IChjaGFpbikgPT4ge1xuICAgICAgY29uc3QgcnBjcyA9IGNoYWluLnJwY1VybHMucHVibGljLmh0dHA7XG4gICAgICBjb25zdCBub2RlVXJsID0gcnBjc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBycGNzLmxlbmd0aCldO1xuICAgICAgaWYgKCFub2RlVXJsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB7IG5vZGVVcmwgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXJzL2FsY2hlbXkudHNcbmZ1bmN0aW9uIGFsY2hlbXlQcm92aWRlcih7IGFwaUtleSB9KSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKGNoYWluKSA9PiB7XG4gICAgICBjb25zdCBiYXNlSHR0cFVybCA9IGNoYWluLnJwY1VybHNbXCJhbGNoZW15XCJdPy5odHRwWzBdO1xuICAgICAgaWYgKCFiYXNlSHR0cFVybClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBub2RlVXJsID0gYCR7YmFzZUh0dHBVcmx9LyR7YXBpS2V5fWA7XG4gICAgICByZXR1cm4geyBub2RlVXJsIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9ibGFzdC50c1xuZnVuY3Rpb24gYmxhc3RQcm92aWRlcih7IGFwaUtleSB9KSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKGNoYWluKSA9PiB7XG4gICAgICBjb25zdCBiYXNlSHR0cFVybCA9IGNoYWluLnJwY1VybHNbXCJibGFzdFwiXT8uaHR0cFswXTtcbiAgICAgIGlmICghYmFzZUh0dHBVcmwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3Qgbm9kZVVybCA9IGAke2Jhc2VIdHRwVXJsfS8ke2FwaUtleX1gO1xuICAgICAgcmV0dXJuIHsgbm9kZVVybCB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9wcm92aWRlcnMvaW5mdXJhLnRzXG5mdW5jdGlvbiBpbmZ1cmFQcm92aWRlcih7IGFwaUtleSB9KSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKGNoYWluKSA9PiB7XG4gICAgICBjb25zdCBiYXNlSHR0cFVybCA9IGNoYWluLnJwY1VybHNbXCJpbmZ1cmFcIl0/Lmh0dHBbMF07XG4gICAgICBpZiAoIWJhc2VIdHRwVXJsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IG5vZGVVcmwgPSBgJHtiYXNlSHR0cFVybH0vJHthcGlLZXl9YDtcbiAgICAgIHJldHVybiB7IG5vZGVVcmwgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdmlkZXJzL2xhdmEudHNcbmZ1bmN0aW9uIGxhdmFQcm92aWRlcih7IGFwaUtleSB9KSB7XG4gIHJldHVybiBqc29uUnBjUHJvdmlkZXIoe1xuICAgIHJwYzogKGNoYWluKSA9PiB7XG4gICAgICBjb25zdCBiYXNlSHR0cFVybCA9IGNoYWluLnJwY1VybHNbXCJsYXZhXCJdPy5odHRwWzBdO1xuICAgICAgaWYgKCFiYXNlSHR0cFVybClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBub2RlVXJsID0gYCR7YmFzZUh0dHBVcmx9LyR7YXBpS2V5fWA7XG4gICAgICByZXR1cm4geyBub2RlVXJsIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9uZXRoZXJtaW5kLnRzXG5mdW5jdGlvbiBuZXRoZXJtaW5kUHJvdmlkZXIoeyBhcGlLZXkgfSkge1xuICByZXR1cm4ganNvblJwY1Byb3ZpZGVyKHtcbiAgICBycGM6IChjaGFpbikgPT4ge1xuICAgICAgY29uc3QgYmFzZUh0dHBVcmwgPSBjaGFpbi5ycGNVcmxzW1wibmV0aGVybWluZFwiXT8uaHR0cFswXTtcbiAgICAgIGlmICghYmFzZUh0dHBVcmwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3Qgbm9kZVVybCA9IGAke2Jhc2VIdHRwVXJsfS8/YXBpa2V5PSR7YXBpS2V5fWA7XG4gICAgICByZXR1cm4geyBub2RlVXJsIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVycy9yZWRkaW8udHNcbmZ1bmN0aW9uIHJlZGRpb1Byb3ZpZGVyKHsgYXBpS2V5IH0pIHtcbiAgcmV0dXJuIGpzb25ScGNQcm92aWRlcih7XG4gICAgcnBjOiAoY2hhaW4pID0+IHtcbiAgICAgIGNvbnN0IGJhc2VIdHRwVXJsID0gY2hhaW4ucnBjVXJsc1tcInJlZGRpb1wiXT8uaHR0cFswXTtcbiAgICAgIGlmICghYmFzZUh0dHBVcmwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY29uc3Qgbm9kZVVybCA9IGAke2Jhc2VIdHRwVXJsfS8ke2FwaUtleX1gO1xuICAgICAgcmV0dXJuIHsgbm9kZVVybCB9O1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnQge1xuICBDb25uZWN0b3IsXG4gIENvbm5lY3RvckFscmVhZHlDb25uZWN0ZWRFcnJvcixcbiAgQ29ubmVjdG9yTm90Q29ubmVjdGVkRXJyb3IsXG4gIENvbm5lY3Rvck5vdEZvdW5kRXJyb3IsXG4gIEluamVjdGVkQ29ubmVjdG9yLFxuICBNb2NrQ29ubmVjdG9yLFxuICBBY2NvdW50UHJvdmlkZXIgYXMgT3ZlcnJpZGVBY2NvdW50LFxuICBTdGFya0NvbXBhc3NFeHBsb3JlcixcbiAgU3RhcmtuZXRDb25maWcsXG4gIFN0YXJrc2NhbkV4cGxvcmVyLFxuICBVbnN1cHBvcnRlZEFjY291bnRJbnRlcmZhY2VFcnJvcixcbiAgVXNlck5vdENvbm5lY3RlZEVycm9yLFxuICBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsXG4gIFZpZXdibG9ja0V4cGxvcmVyLFxuICBWb3lhZ2VyRXhwbG9yZXIsXG4gIGFsY2hlbXlQcm92aWRlcixcbiAgYXJnZW50LFxuICBibGFzdFByb3ZpZGVyLFxuICBicmFhdm9zLFxuICBpbmZ1cmFQcm92aWRlcixcbiAgaW5qZWN0ZWQsXG4gIGpzb25ScGNQcm92aWRlcixcbiAgbGF2YVByb3ZpZGVyLFxuICBuZXRoZXJtaW5kUHJvdmlkZXIsXG4gIHB1YmxpY1Byb3ZpZGVyLFxuICByZWRkaW9Qcm92aWRlcixcbiAgc3Rhcmtjb21wYXNzLFxuICBzdGFya25ldENoYWluSWQsXG4gIHN0YXJrc2NhbixcbiAgdXNlQWNjb3VudCxcbiAgdXNlQWRkQ2hhaW4sXG4gIHVzZUJhbGFuY2UsXG4gIHVzZUJsb2NrLFxuICB1c2VCbG9ja051bWJlcixcbiAgdXNlQ2FsbCxcbiAgdXNlQ29ubmVjdCxcbiAgdXNlQ29udHJhY3QsXG4gIHVzZUNvbnRyYWN0RmFjdG9yeSxcbiAgdXNlRGVjbGFyZUNvbnRyYWN0LFxuICB1c2VEZXBsb3lBY2NvdW50LFxuICB1c2VEaXNjb25uZWN0LFxuICB1c2VFc3RpbWF0ZUZlZXMsXG4gIHVzZUV4cGxvcmVyLFxuICB1c2VJbmplY3RlZENvbm5lY3RvcnMsXG4gIHVzZUludmFsaWRhdGVPbkJsb2NrLFxuICB1c2VOZXR3b3JrLFxuICB1c2VOb25jZUZvckFkZHJlc3MsXG4gIHVzZVByb3ZpZGVyLFxuICB1c2VSZWFkQ29udHJhY3QsXG4gIHVzZVNlbmRUcmFuc2FjdGlvbixcbiAgdXNlU2lnblR5cGVkRGF0YSxcbiAgdXNlU3RhcmtBZGRyZXNzLFxuICB1c2VTdGFya05hbWUsXG4gIHVzZVN0YXJrUHJvZmlsZSxcbiAgdXNlU3dpdGNoQ2hhaW4sXG4gIHVzZVRyYW5zYWN0aW9uUmVjZWlwdCxcbiAgdXNlV2FsbGV0UmVxdWVzdCxcbiAgdmlld2Jsb2NrLFxuICB2b3lhZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@starknet-react/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/focusManager.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusManager: function() { return /* binding */ FocusManager; },\n/* harmony export */   focusManager: function() { return /* binding */ focusManager; }\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/focusManager.ts\n\n\nvar FocusManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #focused;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onFocus) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const listener = () => onFocus();\n        window.addEventListener(\"visibilitychange\", listener, false);\n        return () => {\n          window.removeEventListener(\"visibilitychange\", listener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === \"boolean\") {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n  setFocused(focused) {\n    const changed = this.#focused !== focused;\n    if (changed) {\n      this.#focused = focused;\n      this.onFocus();\n    }\n  }\n  onFocus() {\n    const isFocused = this.isFocused();\n    this.listeners.forEach((listener) => {\n      listener(isFocused);\n    });\n  }\n  isFocused() {\n    if (typeof this.#focused === \"boolean\") {\n      return this.#focused;\n    }\n    return globalThis.document?.visibilityState !== \"hidden\";\n  }\n};\nvar focusManager = new FocusManager();\n\n//# sourceMappingURL=focusManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vZm9jdXNNYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNpRDtBQUNYO0FBQ3RDLGlDQUFpQywwREFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL2ZvY3VzTWFuYWdlci5qcz9mODlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9mb2N1c01hbmFnZXIudHNcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gXCIuL3N1YnNjcmliYWJsZS5qc1wiO1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xudmFyIEZvY3VzTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgI2ZvY3VzZWQ7XG4gICNjbGVhbnVwO1xuICAjc2V0dXA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jc2V0dXAgPSAob25Gb2N1cykgPT4ge1xuICAgICAgaWYgKCFpc1NlcnZlciAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IG9uRm9jdXMoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIG9uU3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy4jY2xlYW51cCkge1xuICAgICAgdGhpcy5zZXRFdmVudExpc3RlbmVyKHRoaXMuI3NldHVwKTtcbiAgICB9XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgICAgdGhpcy4jY2xlYW51cCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2V0RXZlbnRMaXN0ZW5lcihzZXR1cCkge1xuICAgIHRoaXMuI3NldHVwID0gc2V0dXA7XG4gICAgdGhpcy4jY2xlYW51cD8uKCk7XG4gICAgdGhpcy4jY2xlYW51cCA9IHNldHVwKChmb2N1c2VkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZvY3VzZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXNlZChmb2N1c2VkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25Gb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldEZvY3VzZWQoZm9jdXNlZCkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLiNmb2N1c2VkICE9PSBmb2N1c2VkO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNmb2N1c2VkID0gZm9jdXNlZDtcbiAgICAgIHRoaXMub25Gb2N1cygpO1xuICAgIH1cbiAgfVxuICBvbkZvY3VzKCkge1xuICAgIGNvbnN0IGlzRm9jdXNlZCA9IHRoaXMuaXNGb2N1c2VkKCk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgIGxpc3RlbmVyKGlzRm9jdXNlZCk7XG4gICAgfSk7XG4gIH1cbiAgaXNGb2N1c2VkKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy4jZm9jdXNlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLiNmb2N1c2VkO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5kb2N1bWVudD8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiO1xuICB9XG59O1xudmFyIGZvY3VzTWFuYWdlciA9IG5ldyBGb2N1c01hbmFnZXIoKTtcbmV4cG9ydCB7XG4gIEZvY3VzTWFuYWdlcixcbiAgZm9jdXNNYW5hZ2VyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNNYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasNextPage: function() { return /* binding */ hasNextPage; },\n/* harmony export */   hasPreviousPage: function() { return /* binding */ hasPreviousPage; },\n/* harmony export */   infiniteQueryBehavior: function() { return /* binding */ infiniteQueryBehavior; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/infiniteQueryBehavior.ts\n\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options;\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n        const oldPages = context.state.data?.pages || [];\n        const oldPageParams = context.state.data?.pageParams || [];\n        const empty = { pages: [], pageParams: [] };\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureQueryFn)(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(\n            queryFnContext\n          );\n          const { maxPages } = context.options;\n          const addTo = previous ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToStart : _utils_js__WEBPACK_IMPORTED_MODULE_0__.addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        let result;\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam\n          );\n          const remainingPages = pages ?? oldPages.length;\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result);\n            if (param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n          }\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data)\n    return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam)\n    return false;\n  return getPreviousPageParam(options, data) != null;\n}\n\n//# sourceMappingURL=infiniteQueryBehavior.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vaW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLHdEQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixtQ0FBbUMsaURBQVUsR0FBRywrQ0FBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtQkFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL2luZmluaXRlUXVlcnlCZWhhdmlvci5qcz8xMzc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IudHNcbmltcG9ydCB7IGFkZFRvRW5kLCBhZGRUb1N0YXJ0LCBlbnN1cmVRdWVyeUZuIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIGluZmluaXRlUXVlcnlCZWhhdmlvcihwYWdlcykge1xuICByZXR1cm4ge1xuICAgIG9uRmV0Y2g6IChjb250ZXh0LCBxdWVyeSkgPT4ge1xuICAgICAgY29uc3QgZmV0Y2hGbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gY29udGV4dC5mZXRjaE9wdGlvbnM/Lm1ldGE/LmZldGNoTW9yZT8uZGlyZWN0aW9uO1xuICAgICAgICBjb25zdCBvbGRQYWdlcyA9IGNvbnRleHQuc3RhdGUuZGF0YT8ucGFnZXMgfHwgW107XG4gICAgICAgIGNvbnN0IG9sZFBhZ2VQYXJhbXMgPSBjb250ZXh0LnN0YXRlLmRhdGE/LnBhZ2VQYXJhbXMgfHwgW107XG4gICAgICAgIGNvbnN0IGVtcHR5ID0geyBwYWdlczogW10sIHBhZ2VQYXJhbXM6IFtdIH07XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYWRkU2lnbmFsUHJvcGVydHkgPSAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgXCJzaWduYWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY29udGV4dC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuc2lnbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBxdWVyeUZuID0gZW5zdXJlUXVlcnlGbihjb250ZXh0Lm9wdGlvbnMsIGNvbnRleHQuZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgY29uc3QgZmV0Y2hQYWdlID0gYXN5bmMgKGRhdGEsIHBhcmFtLCBwcmV2aW91cykgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYW0gPT0gbnVsbCAmJiBkYXRhLnBhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcXVlcnlGbkNvbnRleHQgPSB7XG4gICAgICAgICAgICBxdWVyeUtleTogY29udGV4dC5xdWVyeUtleSxcbiAgICAgICAgICAgIHBhZ2VQYXJhbTogcGFyYW0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IHByZXZpb3VzID8gXCJiYWNrd2FyZFwiIDogXCJmb3J3YXJkXCIsXG4gICAgICAgICAgICBtZXRhOiBjb250ZXh0Lm9wdGlvbnMubWV0YVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWRkU2lnbmFsUHJvcGVydHkocXVlcnlGbkNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBxdWVyeUZuKFxuICAgICAgICAgICAgcXVlcnlGbkNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHsgbWF4UGFnZXMgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCBhZGRUbyA9IHByZXZpb3VzID8gYWRkVG9TdGFydCA6IGFkZFRvRW5kO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlczogYWRkVG8oZGF0YS5wYWdlcywgcGFnZSwgbWF4UGFnZXMpLFxuICAgICAgICAgICAgcGFnZVBhcmFtczogYWRkVG8oZGF0YS5wYWdlUGFyYW1zLCBwYXJhbSwgbWF4UGFnZXMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmJiBvbGRQYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiO1xuICAgICAgICAgIGNvbnN0IHBhZ2VQYXJhbUZuID0gcHJldmlvdXMgPyBnZXRQcmV2aW91c1BhZ2VQYXJhbSA6IGdldE5leHRQYWdlUGFyYW07XG4gICAgICAgICAgY29uc3Qgb2xkRGF0YSA9IHtcbiAgICAgICAgICAgIHBhZ2VzOiBvbGRQYWdlcyxcbiAgICAgICAgICAgIHBhZ2VQYXJhbXM6IG9sZFBhZ2VQYXJhbXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IHBhcmFtID0gcGFnZVBhcmFtRm4ob3B0aW9ucywgb2xkRGF0YSk7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKG9sZERhdGEsIHBhcmFtLCBwcmV2aW91cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKFxuICAgICAgICAgICAgZW1wdHksXG4gICAgICAgICAgICBvbGRQYWdlUGFyYW1zWzBdID8/IG9wdGlvbnMuaW5pdGlhbFBhZ2VQYXJhbVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nUGFnZXMgPSBwYWdlcyA/PyBvbGRQYWdlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZW1haW5pbmdQYWdlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IGdldE5leHRQYWdlUGFyYW0ob3B0aW9ucywgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChwYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hQYWdlKHJlc3VsdCwgcGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIGlmIChjb250ZXh0Lm9wdGlvbnMucGVyc2lzdGVyKSB7XG4gICAgICAgIGNvbnRleHQuZmV0Y2hGbiA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5vcHRpb25zLnBlcnNpc3Rlcj8uKFxuICAgICAgICAgICAgZmV0Y2hGbixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcXVlcnlLZXk6IGNvbnRleHQucXVlcnlLZXksXG4gICAgICAgICAgICAgIG1ldGE6IGNvbnRleHQub3B0aW9ucy5tZXRhLFxuICAgICAgICAgICAgICBzaWduYWw6IGNvbnRleHQuc2lnbmFsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5mZXRjaEZuID0gZmV0Y2hGbjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXROZXh0UGFnZVBhcmFtKG9wdGlvbnMsIHsgcGFnZXMsIHBhZ2VQYXJhbXMgfSkge1xuICBjb25zdCBsYXN0SW5kZXggPSBwYWdlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gcGFnZXMubGVuZ3RoID4gMCA/IG9wdGlvbnMuZ2V0TmV4dFBhZ2VQYXJhbShcbiAgICBwYWdlc1tsYXN0SW5kZXhdLFxuICAgIHBhZ2VzLFxuICAgIHBhZ2VQYXJhbXNbbGFzdEluZGV4XSxcbiAgICBwYWdlUGFyYW1zXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCB7IHBhZ2VzLCBwYWdlUGFyYW1zIH0pIHtcbiAgcmV0dXJuIHBhZ2VzLmxlbmd0aCA+IDAgPyBvcHRpb25zLmdldFByZXZpb3VzUGFnZVBhcmFtPy4ocGFnZXNbMF0sIHBhZ2VzLCBwYWdlUGFyYW1zWzBdLCBwYWdlUGFyYW1zKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGhhc05leHRQYWdlKG9wdGlvbnMsIGRhdGEpIHtcbiAgaWYgKCFkYXRhKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGdldE5leHRQYWdlUGFyYW0ob3B0aW9ucywgZGF0YSkgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhc1ByZXZpb3VzUGFnZShvcHRpb25zLCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhb3B0aW9ucy5nZXRQcmV2aW91c1BhZ2VQYXJhbSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBnZXRQcmV2aW91c1BhZ2VQYXJhbShvcHRpb25zLCBkYXRhKSAhPSBudWxsO1xufVxuZXhwb3J0IHtcbiAgaGFzTmV4dFBhZ2UsXG4gIGhhc1ByZXZpb3VzUGFnZSxcbiAgaW5maW5pdGVRdWVyeUJlaGF2aW9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5maW5pdGVRdWVyeUJlaGF2aW9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutation.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mutation: function() { return /* binding */ Mutation; },\n/* harmony export */   getDefaultState: function() { return /* binding */ getDefaultState; }\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\");\n// src/mutation.ts\n\n\n\nvar Mutation = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #observers;\n  #mutationCache;\n  #retryer;\n  constructor(config) {\n    super();\n    this.mutationId = config.mutationId;\n    this.#mutationCache = config.mutationCache;\n    this.#observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n  setOptions(options) {\n    this.options = options;\n    this.updateGcTime(this.options.gcTime);\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#mutationCache.notify({\n        type: \"observerAdded\",\n        mutation: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    this.#observers = this.#observers.filter((x) => x !== observer);\n    this.scheduleGc();\n    this.#mutationCache.notify({\n      type: \"observerRemoved\",\n      mutation: this,\n      observer\n    });\n  }\n  optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === \"pending\") {\n        this.scheduleGc();\n      } else {\n        this.#mutationCache.remove(this);\n      }\n    }\n  }\n  continue() {\n    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n    this.execute(this.state.variables);\n  }\n  async execute(variables) {\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_1__.createRetryer)({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error(\"No mutationFn found\"));\n        }\n        return this.options.mutationFn(variables);\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this)\n    });\n    const restored = this.state.status === \"pending\";\n    const isPaused = !this.#retryer.canStart();\n    try {\n      if (!restored) {\n        this.#dispatch({ type: \"pending\", variables, isPaused });\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this\n        );\n        const context = await this.options.onMutate?.(variables);\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: \"pending\",\n            context,\n            variables,\n            isPaused\n          });\n        }\n      }\n      const data = await this.#retryer.start();\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSuccess?.(data, variables, this.state.context);\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this\n      );\n      await this.options.onSettled?.(data, null, variables, this.state.context);\n      this.#dispatch({ type: \"success\", data });\n      return data;\n    } catch (error) {\n      try {\n        await this.#mutationCache.config.onError?.(\n          error,\n          variables,\n          this.state.context,\n          this\n        );\n        await this.options.onError?.(\n          error,\n          variables,\n          this.state.context\n        );\n        await this.#mutationCache.config.onSettled?.(\n          void 0,\n          error,\n          this.state.variables,\n          this.state.context,\n          this\n        );\n        await this.options.onSettled?.(\n          void 0,\n          error,\n          variables,\n          this.state.context\n        );\n        throw error;\n      } finally {\n        this.#dispatch({ type: \"error\", error });\n      }\n    } finally {\n      this.#mutationCache.runNext(this);\n    }\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            isPaused: true\n          };\n        case \"continue\":\n          return {\n            ...state,\n            isPaused: false\n          };\n        case \"pending\":\n          return {\n            ...state,\n            context: action.context,\n            data: void 0,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: \"pending\",\n            variables: action.variables,\n            submittedAt: Date.now()\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: \"success\",\n            isPaused: false\n          };\n        case \"error\":\n          return {\n            ...state,\n            data: void 0,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: \"error\"\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action);\n      });\n      this.#mutationCache.notify({\n        mutation: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState() {\n  return {\n    context: void 0,\n    data: void 0,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: \"idle\",\n    variables: void 0,\n    submittedAt: 0\n  };\n}\n\n//# sourceMappingURL=mutation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNtRDtBQUNSO0FBQ0U7QUFDN0MsNkJBQTZCLG9EQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEMsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0NBQXNDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9tdXRhdGlvbi5qcz8zODYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9tdXRhdGlvbi50c1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IFJlbW92YWJsZSB9IGZyb20gXCIuL3JlbW92YWJsZS5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlUmV0cnllciB9IGZyb20gXCIuL3JldHJ5ZXIuanNcIjtcbnZhciBNdXRhdGlvbiA9IGNsYXNzIGV4dGVuZHMgUmVtb3ZhYmxlIHtcbiAgI29ic2VydmVycztcbiAgI211dGF0aW9uQ2FjaGU7XG4gICNyZXRyeWVyO1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubXV0YXRpb25JZCA9IGNvbmZpZy5tdXRhdGlvbklkO1xuICAgIHRoaXMuI211dGF0aW9uQ2FjaGUgPSBjb25maWcubXV0YXRpb25DYWNoZTtcbiAgICB0aGlzLiNvYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0gY29uZmlnLnN0YXRlIHx8IGdldERlZmF1bHRTdGF0ZSgpO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnVwZGF0ZUdjVGltZSh0aGlzLm9wdGlvbnMuZ2NUaW1lKTtcbiAgfVxuICBnZXQgbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1ldGE7XG4gIH1cbiAgYWRkT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICBpZiAoIXRoaXMuI29ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMuI29ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgIHRoaXMuY2xlYXJHY1RpbWVvdXQoKTtcbiAgICAgIHRoaXMuI211dGF0aW9uQ2FjaGUubm90aWZ5KHtcbiAgICAgICAgdHlwZTogXCJvYnNlcnZlckFkZGVkXCIsXG4gICAgICAgIG11dGF0aW9uOiB0aGlzLFxuICAgICAgICBvYnNlcnZlclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgdGhpcy4jb2JzZXJ2ZXJzID0gdGhpcy4jb2JzZXJ2ZXJzLmZpbHRlcigoeCkgPT4geCAhPT0gb2JzZXJ2ZXIpO1xuICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICAgIHRoaXMuI211dGF0aW9uQ2FjaGUubm90aWZ5KHtcbiAgICAgIHR5cGU6IFwib2JzZXJ2ZXJSZW1vdmVkXCIsXG4gICAgICBtdXRhdGlvbjogdGhpcyxcbiAgICAgIG9ic2VydmVyXG4gICAgfSk7XG4gIH1cbiAgb3B0aW9uYWxSZW1vdmUoKSB7XG4gICAgaWYgKCF0aGlzLiNvYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVHYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jbXV0YXRpb25DYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnRpbnVlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZXRyeWVyPy5jb250aW51ZSgpID8/IC8vIGNvbnRpbnVpbmcgYSBtdXRhdGlvbiBhc3N1bWVzIHRoYXQgdmFyaWFibGVzIGFyZSBzZXQsIG11dGF0aW9uIG11c3QgaGF2ZSBiZWVuIGRlaHlkcmF0ZWQgYmVmb3JlXG4gICAgdGhpcy5leGVjdXRlKHRoaXMuc3RhdGUudmFyaWFibGVzKTtcbiAgfVxuICBhc3luYyBleGVjdXRlKHZhcmlhYmxlcykge1xuICAgIHRoaXMuI3JldHJ5ZXIgPSBjcmVhdGVSZXRyeWVyKHtcbiAgICAgIGZuOiAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11dGF0aW9uRm4pIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gbXV0YXRpb25GbiBmb3VuZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tdXRhdGlvbkZuKHZhcmlhYmxlcyk7XG4gICAgICB9LFxuICAgICAgb25GYWlsOiAoZmFpbHVyZUNvdW50LCBlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwiZmFpbGVkXCIsIGZhaWx1cmVDb3VudCwgZXJyb3IgfSk7XG4gICAgICB9LFxuICAgICAgb25QYXVzZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7IHR5cGU6IFwicGF1c2VcIiB9KTtcbiAgICAgIH0sXG4gICAgICBvbkNvbnRpbnVlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJjb250aW51ZVwiIH0pO1xuICAgICAgfSxcbiAgICAgIHJldHJ5OiB0aGlzLm9wdGlvbnMucmV0cnkgPz8gMCxcbiAgICAgIHJldHJ5RGVsYXk6IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5LFxuICAgICAgbmV0d29ya01vZGU6IHRoaXMub3B0aW9ucy5uZXR3b3JrTW9kZSxcbiAgICAgIGNhblJ1bjogKCkgPT4gdGhpcy4jbXV0YXRpb25DYWNoZS5jYW5SdW4odGhpcylcbiAgICB9KTtcbiAgICBjb25zdCByZXN0b3JlZCA9IHRoaXMuc3RhdGUuc3RhdHVzID09PSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCBpc1BhdXNlZCA9ICF0aGlzLiNyZXRyeWVyLmNhblN0YXJ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcmVzdG9yZWQpIHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInBlbmRpbmdcIiwgdmFyaWFibGVzLCBpc1BhdXNlZCB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25NdXRhdGU/LihcbiAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5vcHRpb25zLm9uTXV0YXRlPy4odmFyaWFibGVzKTtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHRoaXMuc3RhdGUuY29udGV4dCkge1xuICAgICAgICAgIHRoaXMuI2Rpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgIGlzUGF1c2VkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLiNyZXRyeWVyLnN0YXJ0KCk7XG4gICAgICBhd2FpdCB0aGlzLiNtdXRhdGlvbkNhY2hlLmNvbmZpZy5vblN1Y2Nlc3M/LihcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMub25TdWNjZXNzPy4oZGF0YSwgdmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQpO1xuICAgICAgYXdhaXQgdGhpcy4jbXV0YXRpb25DYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMuc3RhdGUudmFyaWFibGVzLFxuICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMub25TZXR0bGVkPy4oZGF0YSwgbnVsbCwgdmFyaWFibGVzLCB0aGlzLnN0YXRlLmNvbnRleHQpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInN1Y2Nlc3NcIiwgZGF0YSB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLiNtdXRhdGlvbkNhY2hlLmNvbmZpZy5vbkVycm9yPy4oXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMub3B0aW9ucy5vbkVycm9yPy4oXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLiNtdXRhdGlvbkNhY2hlLmNvbmZpZy5vblNldHRsZWQ/LihcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhpcy5zdGF0ZS52YXJpYWJsZXMsXG4gICAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0LFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLm9uU2V0dGxlZD8uKFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0XG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLnJ1bk5leHQodGhpcyk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBjb25zdCByZWR1Y2VyID0gKHN0YXRlKSA9PiB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IGFjdGlvbi5mYWlsdXJlQ291bnQsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicGF1c2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBpc1BhdXNlZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgY29udGV4dDogYWN0aW9uLmNvbnRleHQsXG4gICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgICAgICAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICBpc1BhdXNlZDogYWN0aW9uLmlzUGF1c2VkLFxuICAgICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIHZhcmlhYmxlczogYWN0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHN1Ym1pdHRlZEF0OiBEYXRlLm5vdygpXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICAgICAgICAgIGZhaWx1cmVSZWFzb246IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICBlcnJvcjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgZmFpbHVyZUNvdW50OiBzdGF0ZS5mYWlsdXJlQ291bnQgKyAxLFxuICAgICAgICAgICAgZmFpbHVyZVJlYXNvbjogYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCJcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHJlZHVjZXIodGhpcy5zdGF0ZSk7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLiNvYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIub25NdXRhdGlvblVwZGF0ZShhY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiNtdXRhdGlvbkNhY2hlLm5vdGlmeSh7XG4gICAgICAgIG11dGF0aW9uOiB0aGlzLFxuICAgICAgICB0eXBlOiBcInVwZGF0ZWRcIixcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiB2b2lkIDAsXG4gICAgZGF0YTogdm9pZCAwLFxuICAgIGVycm9yOiBudWxsLFxuICAgIGZhaWx1cmVDb3VudDogMCxcbiAgICBmYWlsdXJlUmVhc29uOiBudWxsLFxuICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICBzdGF0dXM6IFwiaWRsZVwiLFxuICAgIHZhcmlhYmxlczogdm9pZCAwLFxuICAgIHN1Ym1pdHRlZEF0OiAwXG4gIH07XG59XG5leHBvcnQge1xuICBNdXRhdGlvbixcbiAgZ2V0RGVmYXVsdFN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV0YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutationCache.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MutationCache: function() { return /* binding */ MutationCache; }\n/* harmony export */ });\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _mutation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutation.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/mutationCache.ts\n\n\n\n\nvar MutationCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Map();\n    this.#mutationId = Date.now();\n  }\n  #mutations;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new _mutation_js__WEBPACK_IMPORTED_MODULE_1__.Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    const scope = scopeFor(mutation);\n    const mutations = this.#mutations.get(scope) ?? [];\n    mutations.push(mutation);\n    this.#mutations.set(scope, mutations);\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    const scope = scopeFor(mutation);\n    if (this.#mutations.has(scope)) {\n      const mutations = this.#mutations.get(scope)?.filter((x) => x !== mutation);\n      if (mutations) {\n        if (mutations.length === 0) {\n          this.#mutations.delete(scope);\n        } else {\n          this.#mutations.set(scope, mutations);\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const firstPendingMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m.state.status === \"pending\");\n    return !firstPendingMutation || firstPendingMutation === mutation;\n  }\n  runNext(mutation) {\n    const foundMutation = this.#mutations.get(scopeFor(mutation))?.find((m) => m !== mutation && m.state.isPaused);\n    return foundMutation?.continue() ?? Promise.resolve();\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.getAll().forEach((mutation) => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return [...this.#mutations.values()].flat();\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.matchMutation)(filters, mutation));\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_2__.notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(_utils_js__WEBPACK_IMPORTED_MODULE_3__.noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id ?? String(mutation.mutationId);\n}\n\n//# sourceMappingURL=mutationCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb25DYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ21EO0FBQ1Y7QUFDUTtBQUNBO0FBQ2pELGtDQUFrQywwREFBWTtBQUM5Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLG9CQUFvQix3REFBYTtBQUNqQztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDhDQUE4Qyx3REFBYTtBQUMzRDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCO0FBQ0Esb0VBQW9FLDJDQUFJO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL211dGF0aW9uQ2FjaGUuanM/ZjUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbXV0YXRpb25DYWNoZS50c1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IE11dGF0aW9uIH0gZnJvbSBcIi4vbXV0YXRpb24uanNcIjtcbmltcG9ydCB7IG1hdGNoTXV0YXRpb24sIG5vb3AgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG52YXIgTXV0YXRpb25DYWNoZSA9IGNsYXNzIGV4dGVuZHMgU3Vic2NyaWJhYmxlIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuI211dGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jbXV0YXRpb25JZCA9IERhdGUubm93KCk7XG4gIH1cbiAgI211dGF0aW9ucztcbiAgI211dGF0aW9uSWQ7XG4gIGJ1aWxkKGNsaWVudCwgb3B0aW9ucywgc3RhdGUpIHtcbiAgICBjb25zdCBtdXRhdGlvbiA9IG5ldyBNdXRhdGlvbih7XG4gICAgICBtdXRhdGlvbkNhY2hlOiB0aGlzLFxuICAgICAgbXV0YXRpb25JZDogKyt0aGlzLiNtdXRhdGlvbklkLFxuICAgICAgb3B0aW9uczogY2xpZW50LmRlZmF1bHRNdXRhdGlvbk9wdGlvbnMob3B0aW9ucyksXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIHRoaXMuYWRkKG11dGF0aW9uKTtcbiAgICByZXR1cm4gbXV0YXRpb247XG4gIH1cbiAgYWRkKG11dGF0aW9uKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBzY29wZUZvcihtdXRhdGlvbik7XG4gICAgY29uc3QgbXV0YXRpb25zID0gdGhpcy4jbXV0YXRpb25zLmdldChzY29wZSkgPz8gW107XG4gICAgbXV0YXRpb25zLnB1c2gobXV0YXRpb24pO1xuICAgIHRoaXMuI211dGF0aW9ucy5zZXQoc2NvcGUsIG11dGF0aW9ucyk7XG4gICAgdGhpcy5ub3RpZnkoeyB0eXBlOiBcImFkZGVkXCIsIG11dGF0aW9uIH0pO1xuICB9XG4gIHJlbW92ZShtdXRhdGlvbikge1xuICAgIGNvbnN0IHNjb3BlID0gc2NvcGVGb3IobXV0YXRpb24pO1xuICAgIGlmICh0aGlzLiNtdXRhdGlvbnMuaGFzKHNjb3BlKSkge1xuICAgICAgY29uc3QgbXV0YXRpb25zID0gdGhpcy4jbXV0YXRpb25zLmdldChzY29wZSk/LmZpbHRlcigoeCkgPT4geCAhPT0gbXV0YXRpb24pO1xuICAgICAgaWYgKG11dGF0aW9ucykge1xuICAgICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuI211dGF0aW9ucy5kZWxldGUoc2NvcGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI211dGF0aW9ucy5zZXQoc2NvcGUsIG11dGF0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ub3RpZnkoeyB0eXBlOiBcInJlbW92ZWRcIiwgbXV0YXRpb24gfSk7XG4gIH1cbiAgY2FuUnVuKG11dGF0aW9uKSB7XG4gICAgY29uc3QgZmlyc3RQZW5kaW5nTXV0YXRpb24gPSB0aGlzLiNtdXRhdGlvbnMuZ2V0KHNjb3BlRm9yKG11dGF0aW9uKSk/LmZpbmQoKG0pID0+IG0uc3RhdGUuc3RhdHVzID09PSBcInBlbmRpbmdcIik7XG4gICAgcmV0dXJuICFmaXJzdFBlbmRpbmdNdXRhdGlvbiB8fCBmaXJzdFBlbmRpbmdNdXRhdGlvbiA9PT0gbXV0YXRpb247XG4gIH1cbiAgcnVuTmV4dChtdXRhdGlvbikge1xuICAgIGNvbnN0IGZvdW5kTXV0YXRpb24gPSB0aGlzLiNtdXRhdGlvbnMuZ2V0KHNjb3BlRm9yKG11dGF0aW9uKSk/LmZpbmQoKG0pID0+IG0gIT09IG11dGF0aW9uICYmIG0uc3RhdGUuaXNQYXVzZWQpO1xuICAgIHJldHVybiBmb3VuZE11dGF0aW9uPy5jb250aW51ZSgpID8/IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5nZXRBbGwoKS5mb3JFYWNoKChtdXRhdGlvbikgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZShtdXRhdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLiNtdXRhdGlvbnMudmFsdWVzKCldLmZsYXQoKTtcbiAgfVxuICBmaW5kKGZpbHRlcnMpIHtcbiAgICBjb25zdCBkZWZhdWx0ZWRGaWx0ZXJzID0geyBleGFjdDogdHJ1ZSwgLi4uZmlsdGVycyB9O1xuICAgIHJldHVybiB0aGlzLmdldEFsbCgpLmZpbmQoXG4gICAgICAobXV0YXRpb24pID0+IG1hdGNoTXV0YXRpb24oZGVmYXVsdGVkRmlsdGVycywgbXV0YXRpb24pXG4gICAgKTtcbiAgfVxuICBmaW5kQWxsKGZpbHRlcnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEFsbCgpLmZpbHRlcigobXV0YXRpb24pID0+IG1hdGNoTXV0YXRpb24oZmlsdGVycywgbXV0YXRpb24pKTtcbiAgfVxuICBub3RpZnkoZXZlbnQpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlc3VtZVBhdXNlZE11dGF0aW9ucygpIHtcbiAgICBjb25zdCBwYXVzZWRNdXRhdGlvbnMgPSB0aGlzLmdldEFsbCgpLmZpbHRlcigoeCkgPT4geC5zdGF0ZS5pc1BhdXNlZCk7XG4gICAgcmV0dXJuIG5vdGlmeU1hbmFnZXIuYmF0Y2goXG4gICAgICAoKSA9PiBQcm9taXNlLmFsbChcbiAgICAgICAgcGF1c2VkTXV0YXRpb25zLm1hcCgobXV0YXRpb24pID0+IG11dGF0aW9uLmNvbnRpbnVlKCkuY2F0Y2gobm9vcCkpXG4gICAgICApXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNjb3BlRm9yKG11dGF0aW9uKSB7XG4gIHJldHVybiBtdXRhdGlvbi5vcHRpb25zLnNjb3BlPy5pZCA/PyBTdHJpbmcobXV0YXRpb24ubXV0YXRpb25JZCk7XG59XG5leHBvcnQge1xuICBNdXRhdGlvbkNhY2hlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV0YXRpb25DYWNoZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationObserver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/mutationObserver.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MutationObserver: function() { return /* binding */ MutationObserver; }\n/* harmony export */ });\n/* harmony import */ var _mutation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mutation.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutation.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/mutationObserver.ts\n\n\n\n\nvar MutationObserver = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #client;\n  #currentResult = void 0;\n  #currentMutation;\n  #mutateOptions;\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.#updateResult();\n  }\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.#client.defaultMutationOptions(options);\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: \"observerOptionsUpdated\",\n        mutation: this.#currentMutation,\n        observer: this\n      });\n    }\n    if (prevOptions?.mutationKey && this.options.mutationKey && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashKey)(prevOptions.mutationKey) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashKey)(this.options.mutationKey)) {\n      this.reset();\n    } else if (this.#currentMutation?.state.status === \"pending\") {\n      this.#currentMutation.setOptions(this.options);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this);\n    }\n  }\n  onMutationUpdate(action) {\n    this.#updateResult();\n    this.#notify(action);\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  reset() {\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = void 0;\n    this.#updateResult();\n    this.#notify();\n  }\n  mutate(variables, options) {\n    this.#mutateOptions = options;\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);\n    this.#currentMutation.addObserver(this);\n    return this.#currentMutation.execute(variables);\n  }\n  #updateResult() {\n    const state = this.#currentMutation?.state ?? (0,_mutation_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultState)();\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === \"pending\",\n      isSuccess: state.status === \"success\",\n      isError: state.status === \"error\",\n      isIdle: state.status === \"idle\",\n      mutate: this.mutate,\n      reset: this.reset\n    };\n  }\n  #notify(action) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables;\n        const context = this.#currentResult.context;\n        if (action?.type === \"success\") {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context);\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context);\n        } else if (action?.type === \"error\") {\n          this.#mutateOptions.onError?.(action.error, variables, context);\n          this.#mutateOptions.onSettled?.(\n            void 0,\n            action.error,\n            variables,\n            context\n          );\n        }\n      }\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult);\n      });\n    });\n  }\n};\n\n//# sourceMappingURL=mutationObserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbXV0YXRpb25PYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ2dEO0FBQ0c7QUFDRjtBQUNTO0FBQzFELHFDQUFxQywwREFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdFQUFnRSxrREFBTyw4QkFBOEIsa0RBQU87QUFDNUc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2REFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9tdXRhdGlvbk9ic2VydmVyLmpzP2I4MjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL211dGF0aW9uT2JzZXJ2ZXIudHNcbmltcG9ydCB7IGdldERlZmF1bHRTdGF0ZSB9IGZyb20gXCIuL211dGF0aW9uLmpzXCI7XG5pbXBvcnQgeyBub3RpZnlNYW5hZ2VyIH0gZnJvbSBcIi4vbm90aWZ5TWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG5pbXBvcnQgeyBoYXNoS2V5LCBzaGFsbG93RXF1YWxPYmplY3RzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBNdXRhdGlvbk9ic2VydmVyID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICAjY2xpZW50O1xuICAjY3VycmVudFJlc3VsdCA9IHZvaWQgMDtcbiAgI2N1cnJlbnRNdXRhdGlvbjtcbiAgI211dGF0ZU9wdGlvbnM7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmJpbmRNZXRob2RzKCk7XG4gICAgdGhpcy4jdXBkYXRlUmVzdWx0KCk7XG4gIH1cbiAgYmluZE1ldGhvZHMoKSB7XG4gICAgdGhpcy5tdXRhdGUgPSB0aGlzLm11dGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzZXQgPSB0aGlzLnJlc2V0LmJpbmQodGhpcyk7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgcHJldk9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy4jY2xpZW50LmRlZmF1bHRNdXRhdGlvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKCFzaGFsbG93RXF1YWxPYmplY3RzKHRoaXMub3B0aW9ucywgcHJldk9wdGlvbnMpKSB7XG4gICAgICB0aGlzLiNjbGllbnQuZ2V0TXV0YXRpb25DYWNoZSgpLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IFwib2JzZXJ2ZXJPcHRpb25zVXBkYXRlZFwiLFxuICAgICAgICBtdXRhdGlvbjogdGhpcy4jY3VycmVudE11dGF0aW9uLFxuICAgICAgICBvYnNlcnZlcjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcmV2T3B0aW9ucz8ubXV0YXRpb25LZXkgJiYgdGhpcy5vcHRpb25zLm11dGF0aW9uS2V5ICYmIGhhc2hLZXkocHJldk9wdGlvbnMubXV0YXRpb25LZXkpICE9PSBoYXNoS2V5KHRoaXMub3B0aW9ucy5tdXRhdGlvbktleSkpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2N1cnJlbnRNdXRhdGlvbj8uc3RhdGUuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgdGhpcy4jY3VycmVudE11dGF0aW9uLnNldE9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRNdXRhdGlvbj8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIG9uTXV0YXRpb25VcGRhdGUoYWN0aW9uKSB7XG4gICAgdGhpcy4jdXBkYXRlUmVzdWx0KCk7XG4gICAgdGhpcy4jbm90aWZ5KGFjdGlvbik7XG4gIH1cbiAgZ2V0Q3VycmVudFJlc3VsdCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFJlc3VsdDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLiNjdXJyZW50TXV0YXRpb24/LnJlbW92ZU9ic2VydmVyKHRoaXMpO1xuICAgIHRoaXMuI2N1cnJlbnRNdXRhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLiN1cGRhdGVSZXN1bHQoKTtcbiAgICB0aGlzLiNub3RpZnkoKTtcbiAgfVxuICBtdXRhdGUodmFyaWFibGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy4jbXV0YXRlT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy4jY3VycmVudE11dGF0aW9uPy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICB0aGlzLiNjdXJyZW50TXV0YXRpb24gPSB0aGlzLiNjbGllbnQuZ2V0TXV0YXRpb25DYWNoZSgpLmJ1aWxkKHRoaXMuI2NsaWVudCwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLiNjdXJyZW50TXV0YXRpb24uYWRkT2JzZXJ2ZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRNdXRhdGlvbi5leGVjdXRlKHZhcmlhYmxlcyk7XG4gIH1cbiAgI3VwZGF0ZVJlc3VsdCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI2N1cnJlbnRNdXRhdGlvbj8uc3RhdGUgPz8gZ2V0RGVmYXVsdFN0YXRlKCk7XG4gICAgdGhpcy4jY3VycmVudFJlc3VsdCA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgaXNQZW5kaW5nOiBzdGF0ZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiLFxuICAgICAgaXNTdWNjZXNzOiBzdGF0ZS5zdGF0dXMgPT09IFwic3VjY2Vzc1wiLFxuICAgICAgaXNFcnJvcjogc3RhdGUuc3RhdHVzID09PSBcImVycm9yXCIsXG4gICAgICBpc0lkbGU6IHN0YXRlLnN0YXR1cyA9PT0gXCJpZGxlXCIsXG4gICAgICBtdXRhdGU6IHRoaXMubXV0YXRlLFxuICAgICAgcmVzZXQ6IHRoaXMucmVzZXRcbiAgICB9O1xuICB9XG4gICNub3RpZnkoYWN0aW9uKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbXV0YXRlT3B0aW9ucyAmJiB0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuI2N1cnJlbnRSZXN1bHQudmFyaWFibGVzO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jY3VycmVudFJlc3VsdC5jb250ZXh0O1xuICAgICAgICBpZiAoYWN0aW9uPy50eXBlID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICAgIHRoaXMuI211dGF0ZU9wdGlvbnMub25TdWNjZXNzPy4oYWN0aW9uLmRhdGEsIHZhcmlhYmxlcywgY29udGV4dCk7XG4gICAgICAgICAgdGhpcy4jbXV0YXRlT3B0aW9ucy5vblNldHRsZWQ/LihhY3Rpb24uZGF0YSwgbnVsbCwgdmFyaWFibGVzLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24/LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRoaXMuI211dGF0ZU9wdGlvbnMub25FcnJvcj8uKGFjdGlvbi5lcnJvciwgdmFyaWFibGVzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLiNtdXRhdGVPcHRpb25zLm9uU2V0dGxlZD8uKFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgYWN0aW9uLmVycm9yLFxuICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKHRoaXMuI2N1cnJlbnRSZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBNdXRhdGlvbk9ic2VydmVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXV0YXRpb25PYnNlcnZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationObserver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/notifyManager.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotifyManager: function() { return /* binding */ createNotifyManager; },\n/* harmony export */   notifyManager: function() { return /* binding */ notifyManager; }\n/* harmony export */ });\n// src/notifyManager.ts\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n  let notifyFn = (callback) => {\n    callback();\n  };\n  let batchNotifyFn = (callback) => {\n    callback();\n  };\n  let scheduleFn = (cb) => setTimeout(cb, 0);\n  const schedule = (callback) => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  return {\n    batch: (callback) => {\n      let result;\n      transactions++;\n      try {\n        result = callback();\n      } finally {\n        transactions--;\n        if (!transactions) {\n          flush();\n        }\n      }\n      return result;\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: (callback) => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args);\n        });\n      };\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn) => {\n      notifyFn = fn;\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn) => {\n      batchNotifyFn = fn;\n    },\n    setScheduler: (fn) => {\n      scheduleFn = fn;\n    }\n  };\n}\nvar notifyManager = createNotifyManager();\n\n//# sourceMappingURL=notifyManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbm90aWZ5TWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vbm90aWZ5TWFuYWdlci5qcz9mOWM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ub3RpZnlNYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlNYW5hZ2VyKCkge1xuICBsZXQgcXVldWUgPSBbXTtcbiAgbGV0IHRyYW5zYWN0aW9ucyA9IDA7XG4gIGxldCBub3RpZnlGbiA9IChjYWxsYmFjaykgPT4ge1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG4gIGxldCBiYXRjaE5vdGlmeUZuID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcbiAgbGV0IHNjaGVkdWxlRm4gPSAoY2IpID0+IHNldFRpbWVvdXQoY2IsIDApO1xuICBjb25zdCBzY2hlZHVsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGlmICh0cmFuc2FjdGlvbnMpIHtcbiAgICAgIHF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZuKCgpID0+IHtcbiAgICAgICAgbm90aWZ5Rm4oY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBmbHVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICBpZiAob3JpZ2luYWxRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHNjaGVkdWxlRm4oKCkgPT4ge1xuICAgICAgICBiYXRjaE5vdGlmeUZuKCgpID0+IHtcbiAgICAgICAgICBvcmlnaW5hbFF1ZXVlLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBub3RpZnlGbihjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGJhdGNoOiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICB0cmFuc2FjdGlvbnMrKztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cmFuc2FjdGlvbnMtLTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWxsIGNhbGxzIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHdpbGwgYmUgYmF0Y2hlZC5cbiAgICAgKi9cbiAgICBiYXRjaENhbGxzOiAoY2FsbGJhY2spID0+IHtcbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBzY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHNjaGVkdWxlLFxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB0byBzZXQgYSBjdXN0b20gbm90aWZ5IGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZm9yIGV4YW1wbGUgd3JhcCBub3RpZmljYXRpb25zIHdpdGggYFJlYWN0LmFjdGAgd2hpbGUgcnVubmluZyB0ZXN0cy5cbiAgICAgKi9cbiAgICBzZXROb3RpZnlGdW5jdGlvbjogKGZuKSA9PiB7XG4gICAgICBub3RpZnlGbiA9IGZuO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHNldCBhIGN1c3RvbSBmdW5jdGlvbiB0byBiYXRjaCBub3RpZmljYXRpb25zIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgdGljay5cbiAgICAgKiBCeSBkZWZhdWx0IFJlYWN0IFF1ZXJ5IHdpbGwgdXNlIHRoZSBiYXRjaCBmdW5jdGlvbiBwcm92aWRlZCBieSBSZWFjdERPTSBvciBSZWFjdCBOYXRpdmUuXG4gICAgICovXG4gICAgc2V0QmF0Y2hOb3RpZnlGdW5jdGlvbjogKGZuKSA9PiB7XG4gICAgICBiYXRjaE5vdGlmeUZuID0gZm47XG4gICAgfSxcbiAgICBzZXRTY2hlZHVsZXI6IChmbikgPT4ge1xuICAgICAgc2NoZWR1bGVGbiA9IGZuO1xuICAgIH1cbiAgfTtcbn1cbnZhciBub3RpZnlNYW5hZ2VyID0gY3JlYXRlTm90aWZ5TWFuYWdlcigpO1xuZXhwb3J0IHtcbiAgY3JlYXRlTm90aWZ5TWFuYWdlcixcbiAgbm90aWZ5TWFuYWdlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlmeU1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/onlineManager.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnlineManager: function() { return /* binding */ OnlineManager; },\n/* harmony export */   onlineManager: function() { return /* binding */ onlineManager; }\n/* harmony export */ });\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/onlineManager.ts\n\n\nvar OnlineManager = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  #online = true;\n  #cleanup;\n  #setup;\n  constructor() {\n    super();\n    this.#setup = (onOnline) => {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true);\n        const offlineListener = () => onOnline(false);\n        window.addEventListener(\"online\", onlineListener, false);\n        window.addEventListener(\"offline\", offlineListener, false);\n        return () => {\n          window.removeEventListener(\"online\", onlineListener);\n          window.removeEventListener(\"offline\", offlineListener);\n        };\n      }\n      return;\n    };\n  }\n  onSubscribe() {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.();\n      this.#cleanup = void 0;\n    }\n  }\n  setEventListener(setup) {\n    this.#setup = setup;\n    this.#cleanup?.();\n    this.#cleanup = setup(this.setOnline.bind(this));\n  }\n  setOnline(online) {\n    const changed = this.#online !== online;\n    if (changed) {\n      this.#online = online;\n      this.listeners.forEach((listener) => {\n        listener(online);\n      });\n    }\n  }\n  isOnline() {\n    return this.#online;\n  }\n};\nvar onlineManager = new OnlineManager();\n\n//# sourceMappingURL=onlineManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vb25saW5lTWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDaUQ7QUFDWDtBQUN0QyxrQ0FBa0MsMERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9vbmxpbmVNYW5hZ2VyLmpzPzkxYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL29ubGluZU1hbmFnZXIudHNcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gXCIuL3N1YnNjcmliYWJsZS5qc1wiO1xuaW1wb3J0IHsgaXNTZXJ2ZXIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xudmFyIE9ubGluZU1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIFN1YnNjcmliYWJsZSB7XG4gICNvbmxpbmUgPSB0cnVlO1xuICAjY2xlYW51cDtcbiAgI3NldHVwO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3NldHVwID0gKG9uT25saW5lKSA9PiB7XG4gICAgICBpZiAoIWlzU2VydmVyICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IG9ubGluZUxpc3RlbmVyID0gKCkgPT4gb25PbmxpbmUodHJ1ZSk7XG4gICAgICAgIGNvbnN0IG9mZmxpbmVMaXN0ZW5lciA9ICgpID0+IG9uT25saW5lKGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgb25saW5lTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9mZmxpbmVMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9ubGluZUxpc3RlbmVyKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb2ZmbGluZUxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIG9uU3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy4jY2xlYW51cCkge1xuICAgICAgdGhpcy5zZXRFdmVudExpc3RlbmVyKHRoaXMuI3NldHVwKTtcbiAgICB9XG4gIH1cbiAgb25VbnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHRoaXMuI2NsZWFudXA/LigpO1xuICAgICAgdGhpcy4jY2xlYW51cCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2V0RXZlbnRMaXN0ZW5lcihzZXR1cCkge1xuICAgIHRoaXMuI3NldHVwID0gc2V0dXA7XG4gICAgdGhpcy4jY2xlYW51cD8uKCk7XG4gICAgdGhpcy4jY2xlYW51cCA9IHNldHVwKHRoaXMuc2V0T25saW5lLmJpbmQodGhpcykpO1xuICB9XG4gIHNldE9ubGluZShvbmxpbmUpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy4jb25saW5lICE9PSBvbmxpbmU7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuI29ubGluZSA9IG9ubGluZTtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKG9ubGluZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaXNPbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ubGluZTtcbiAgfVxufTtcbnZhciBvbmxpbmVNYW5hZ2VyID0gbmV3IE9ubGluZU1hbmFnZXIoKTtcbmV4cG9ydCB7XG4gIE9ubGluZU1hbmFnZXIsXG4gIG9ubGluZU1hbmFnZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbmxpbmVNYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/query.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Query: function() { return /* binding */ Query; },\n/* harmony export */   fetchState: function() { return /* binding */ fetchState; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _retryer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./retryer.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\");\n/* harmony import */ var _removable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\");\n// src/query.ts\n\n\n\n\nvar Query = class extends _removable_js__WEBPACK_IMPORTED_MODULE_0__.Removable {\n  #initialState;\n  #revertState;\n  #cache;\n  #retryer;\n  #defaultOptions;\n  #abortSignalConsumed;\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = getDefaultState(this.options);\n    this.state = config.state ?? this.#initialState;\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    return this.#retryer?.promise;\n  }\n  setOptions(options) {\n    this.options = { ...this.#defaultOptions, ...options };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({ type: \"setState\", state, setStateOptions });\n  }\n  cancel(options) {\n    const promise = this.#retryer?.promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({ silent: true });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.observers.some(\n      (observer) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(observer.options.enabled, this) !== false\n    );\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale\n      );\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || this.state.data === void 0 || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timeUntilStale)(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());\n    observer?.refetch({ cancelRefetch: false });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({ type: \"observerAdded\", query: this, observer });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer);\n      if (!this.observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({ type: \"observerRemoved\", query: this, observer });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: \"invalidate\" });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {\n        this.cancel({ silent: true });\n      } else if (this.#retryer) {\n        this.#retryer.continueRetry();\n        return this.#retryer.promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (true) {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`\n        );\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = (object) => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureQueryFn)(this.options, fetchOptions);\n      const queryFnContext = {\n        queryKey: this.queryKey,\n        meta: this.meta\n      };\n      addSignalProperty(queryFnContext);\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this\n        );\n      }\n      return queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(\n      context,\n      this\n    );\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({ type: \"fetch\", meta: context.fetchOptions?.meta });\n    }\n    const onError = (error) => {\n      if (!((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!(0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error)) {\n        this.#cache.config.onError?.(\n          error,\n          this\n        );\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error,\n          this\n        );\n      }\n      if (!this.isFetchingOptimistic) {\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    };\n    this.#retryer = (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.createRetryer)({\n      initialPromise: fetchOptions?.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === void 0) {\n          if (true) {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`\n            );\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error,\n          this\n        );\n        if (!this.isFetchingOptimistic) {\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: \"failed\", failureCount, error });\n      },\n      onPause: () => {\n        this.#dispatch({ type: \"pause\" });\n      },\n      onContinue: () => {\n        this.#dispatch({ type: \"continue\" });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    });\n    return this.#retryer.start();\n  }\n  #dispatch(action) {\n    const reducer = (state) => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            }\n          };\n        case \"error\":\n          const error = action.error;\n          if ((0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.isCancelledError)(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: \"idle\" };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({ query: this, type: \"updated\", action });\n    });\n  }\n};\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: (0,_retryer_js__WEBPACK_IMPORTED_MODULE_2__.canFetch)(options.networkMode) ? \"fetching\" : \"paused\",\n    ...data === void 0 && {\n      error: null,\n      status: \"pending\"\n    }\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\n\n//# sourceMappingURL=query.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFPb0I7QUFDK0I7QUFDc0I7QUFDOUI7QUFDM0MsMEJBQTBCLG9EQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzREFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkNBQUksUUFBUSwyQ0FBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5REFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHlEQUFjO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdEQUFnRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQSxZQUFZLDZEQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxXQUFXLDZEQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBcUM7QUFDbkQ7QUFDQSx1SkFBdUosZUFBZTtBQUN0SztBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RCxPQUFPO0FBQ1A7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QyxPQUFPO0FBQ1A7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBZ0I7QUFDOUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkIsc0NBQXNDO0FBQ2pFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnkuanM/NzQ5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkudHNcbmltcG9ydCB7XG4gIGVuc3VyZVF1ZXJ5Rm4sXG4gIG5vb3AsXG4gIHJlcGxhY2VEYXRhLFxuICByZXNvbHZlRW5hYmxlZCxcbiAgdGltZVVudGlsU3RhbGVcbn0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBjYW5GZXRjaCwgY3JlYXRlUmV0cnllciwgaXNDYW5jZWxsZWRFcnJvciB9IGZyb20gXCIuL3JldHJ5ZXIuanNcIjtcbmltcG9ydCB7IFJlbW92YWJsZSB9IGZyb20gXCIuL3JlbW92YWJsZS5qc1wiO1xudmFyIFF1ZXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZW1vdmFibGUge1xuICAjaW5pdGlhbFN0YXRlO1xuICAjcmV2ZXJ0U3RhdGU7XG4gICNjYWNoZTtcbiAgI3JldHJ5ZXI7XG4gICNkZWZhdWx0T3B0aW9ucztcbiAgI2Fib3J0U2lnbmFsQ29uc3VtZWQ7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCA9IGZhbHNlO1xuICAgIHRoaXMuI2RlZmF1bHRPcHRpb25zID0gY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgIHRoaXMuc2V0T3B0aW9ucyhjb25maWcub3B0aW9ucyk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLiNjYWNoZSA9IGNvbmZpZy5jYWNoZTtcbiAgICB0aGlzLnF1ZXJ5S2V5ID0gY29uZmlnLnF1ZXJ5S2V5O1xuICAgIHRoaXMucXVlcnlIYXNoID0gY29uZmlnLnF1ZXJ5SGFzaDtcbiAgICB0aGlzLiNpbml0aWFsU3RhdGUgPSBnZXREZWZhdWx0U3RhdGUodGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnN0YXRlID0gY29uZmlnLnN0YXRlID8/IHRoaXMuI2luaXRpYWxTdGF0ZTtcbiAgICB0aGlzLnNjaGVkdWxlR2MoKTtcbiAgfVxuICBnZXQgbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1ldGE7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JldHJ5ZXI/LnByb21pc2U7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLiNkZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMudXBkYXRlR2NUaW1lKHRoaXMub3B0aW9ucy5nY1RpbWUpO1xuICB9XG4gIG9wdGlvbmFsUmVtb3ZlKCkge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMubGVuZ3RoICYmIHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwiaWRsZVwiKSB7XG4gICAgICB0aGlzLiNjYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldERhdGEobmV3RGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRhdGEgPSByZXBsYWNlRGF0YSh0aGlzLnN0YXRlLmRhdGEsIG5ld0RhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4jZGlzcGF0Y2goe1xuICAgICAgZGF0YSxcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgZGF0YVVwZGF0ZWRBdDogb3B0aW9ucz8udXBkYXRlZEF0LFxuICAgICAgbWFudWFsOiBvcHRpb25zPy5tYW51YWxcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzZXRTdGF0ZShzdGF0ZSwgc2V0U3RhdGVPcHRpb25zKSB7XG4gICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcInNldFN0YXRlXCIsIHN0YXRlLCBzZXRTdGF0ZU9wdGlvbnMgfSk7XG4gIH1cbiAgY2FuY2VsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy4jcmV0cnllcj8ucHJvbWlzZTtcbiAgICB0aGlzLiNyZXRyeWVyPy5jYW5jZWwob3B0aW9ucyk7XG4gICAgcmV0dXJuIHByb21pc2UgPyBwcm9taXNlLnRoZW4obm9vcCkuY2F0Y2gobm9vcCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNhbmNlbCh7IHNpbGVudDogdHJ1ZSB9KTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuI2luaXRpYWxTdGF0ZSk7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNvbWUoXG4gICAgICAob2JzZXJ2ZXIpID0+IHJlc29sdmVFbmFibGVkKG9ic2VydmVyLm9wdGlvbnMuZW5hYmxlZCwgdGhpcykgIT09IGZhbHNlXG4gICAgKTtcbiAgfVxuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE9ic2VydmVyc0NvdW50KCkgPiAwICYmICF0aGlzLmlzQWN0aXZlKCk7XG4gIH1cbiAgaXNTdGFsZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0ludmFsaWRhdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0T2JzZXJ2ZXJzQ291bnQoKSA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5zb21lKFxuICAgICAgICAob2JzZXJ2ZXIpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKS5pc1N0YWxlXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kYXRhID09PSB2b2lkIDA7XG4gIH1cbiAgaXNTdGFsZUJ5VGltZShzdGFsZVRpbWUgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCB8fCB0aGlzLnN0YXRlLmRhdGEgPT09IHZvaWQgMCB8fCAhdGltZVVudGlsU3RhbGUodGhpcy5zdGF0ZS5kYXRhVXBkYXRlZEF0LCBzdGFsZVRpbWUpO1xuICB9XG4gIG9uRm9jdXMoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVycy5maW5kKCh4KSA9PiB4LnNob3VsZEZldGNoT25XaW5kb3dGb2N1cygpKTtcbiAgICBvYnNlcnZlcj8ucmVmZXRjaCh7IGNhbmNlbFJlZmV0Y2g6IGZhbHNlIH0pO1xuICAgIHRoaXMuI3JldHJ5ZXI/LmNvbnRpbnVlKCk7XG4gIH1cbiAgb25PbmxpbmUoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVycy5maW5kKCh4KSA9PiB4LnNob3VsZEZldGNoT25SZWNvbm5lY3QoKSk7XG4gICAgb2JzZXJ2ZXI/LnJlZmV0Y2goeyBjYW5jZWxSZWZldGNoOiBmYWxzZSB9KTtcbiAgICB0aGlzLiNyZXRyeWVyPy5jb250aW51ZSgpO1xuICB9XG4gIGFkZE9ic2VydmVyKG9ic2VydmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5pbmNsdWRlcyhvYnNlcnZlcikpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICAgICAgdGhpcy4jY2FjaGUubm90aWZ5KHsgdHlwZTogXCJvYnNlcnZlckFkZGVkXCIsIHF1ZXJ5OiB0aGlzLCBvYnNlcnZlciB9KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpIHtcbiAgICBpZiAodGhpcy5vYnNlcnZlcnMuaW5jbHVkZXMob2JzZXJ2ZXIpKSB7XG4gICAgICB0aGlzLm9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzLmZpbHRlcigoeCkgPT4geCAhPT0gb2JzZXJ2ZXIpO1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3JldHJ5ZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy4jYWJvcnRTaWduYWxDb25zdW1lZCkge1xuICAgICAgICAgICAgdGhpcy4jcmV0cnllci5jYW5jZWwoeyByZXZlcnQ6IHRydWUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI3JldHJ5ZXIuY2FuY2VsUmV0cnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNjYWNoZS5ub3RpZnkoeyB0eXBlOiBcIm9ic2VydmVyUmVtb3ZlZFwiLCBxdWVyeTogdGhpcywgb2JzZXJ2ZXIgfSk7XG4gICAgfVxuICB9XG4gIGdldE9ic2VydmVyc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLm9ic2VydmVycy5sZW5ndGg7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNJbnZhbGlkYXRlZCkge1xuICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImludmFsaWRhdGVcIiB9KTtcbiAgICB9XG4gIH1cbiAgZmV0Y2gob3B0aW9ucywgZmV0Y2hPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZmV0Y2hTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5kYXRhICE9PSB2b2lkIDAgJiYgZmV0Y2hPcHRpb25zPy5jYW5jZWxSZWZldGNoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNyZXRyeWVyKSB7XG4gICAgICAgIHRoaXMuI3JldHJ5ZXIuY29udGludWVSZXRyeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy4jcmV0cnllci5wcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5xdWVyeUZuKSB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXJzLmZpbmQoKHgpID0+IHgub3B0aW9ucy5xdWVyeUZuKTtcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob2JzZXJ2ZXIub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMucXVlcnlLZXkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYEFzIG9mIHY0LCBxdWVyeUtleSBuZWVkcyB0byBiZSBhbiBBcnJheS4gSWYgeW91IGFyZSB1c2luZyBhIHN0cmluZyBsaWtlICdyZXBvRGF0YScsIHBsZWFzZSBjaGFuZ2UgaXQgdG8gYW4gQXJyYXksIGUuZy4gWydyZXBvRGF0YSddYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgYWRkU2lnbmFsUHJvcGVydHkgPSAob2JqZWN0KSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcInNpZ25hbFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuI2Fib3J0U2lnbmFsQ29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeUZuID0gZW5zdXJlUXVlcnlGbih0aGlzLm9wdGlvbnMsIGZldGNoT3B0aW9ucyk7XG4gICAgICBjb25zdCBxdWVyeUZuQ29udGV4dCA9IHtcbiAgICAgICAgcXVlcnlLZXk6IHRoaXMucXVlcnlLZXksXG4gICAgICAgIG1ldGE6IHRoaXMubWV0YVxuICAgICAgfTtcbiAgICAgIGFkZFNpZ25hbFByb3BlcnR5KHF1ZXJ5Rm5Db250ZXh0KTtcbiAgICAgIHRoaXMuI2Fib3J0U2lnbmFsQ29uc3VtZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucGVyc2lzdGVyKFxuICAgICAgICAgIHF1ZXJ5Rm4sXG4gICAgICAgICAgcXVlcnlGbkNvbnRleHQsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHF1ZXJ5Rm4ocXVlcnlGbkNvbnRleHQpO1xuICAgIH07XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGZldGNoT3B0aW9ucyxcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgIHF1ZXJ5S2V5OiB0aGlzLnF1ZXJ5S2V5LFxuICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICBmZXRjaEZuXG4gICAgfTtcbiAgICBhZGRTaWduYWxQcm9wZXJ0eShjb250ZXh0KTtcbiAgICB0aGlzLm9wdGlvbnMuYmVoYXZpb3I/Lm9uRmV0Y2goXG4gICAgICBjb250ZXh0LFxuICAgICAgdGhpc1xuICAgICk7XG4gICAgdGhpcy4jcmV2ZXJ0U3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0aGlzLnN0YXRlLmZldGNoU3RhdHVzID09PSBcImlkbGVcIiB8fCB0aGlzLnN0YXRlLmZldGNoTWV0YSAhPT0gY29udGV4dC5mZXRjaE9wdGlvbnM/Lm1ldGEpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJmZXRjaFwiLCBtZXRhOiBjb250ZXh0LmZldGNoT3B0aW9ucz8ubWV0YSB9KTtcbiAgICB9XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgaWYgKCEoaXNDYW5jZWxsZWRFcnJvcihlcnJvcikgJiYgZXJyb3Iuc2lsZW50KSkge1xuICAgICAgICB0aGlzLiNkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0NhbmNlbGxlZEVycm9yKGVycm9yKSkge1xuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25FcnJvcj8uKFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy4jY2FjaGUuY29uZmlnLm9uU2V0dGxlZD8uKFxuICAgICAgICAgIHRoaXMuc3RhdGUuZGF0YSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNGZXRjaGluZ09wdGltaXN0aWMpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzRmV0Y2hpbmdPcHRpbWlzdGljID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNyZXRyeWVyID0gY3JlYXRlUmV0cnllcih7XG4gICAgICBpbml0aWFsUHJvbWlzZTogZmV0Y2hPcHRpb25zPy5pbml0aWFsUHJvbWlzZSxcbiAgICAgIGZuOiBjb250ZXh0LmZldGNoRm4sXG4gICAgICBhYm9ydDogYWJvcnRDb250cm9sbGVyLmFib3J0LmJpbmQoYWJvcnRDb250cm9sbGVyKSxcbiAgICAgIG9uU3VjY2VzczogKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIGBRdWVyeSBkYXRhIGNhbm5vdCBiZSB1bmRlZmluZWQuIFBsZWFzZSBtYWtlIHN1cmUgdG8gcmV0dXJuIGEgdmFsdWUgb3RoZXIgdGhhbiB1bmRlZmluZWQgZnJvbSB5b3VyIHF1ZXJ5IGZ1bmN0aW9uLiBBZmZlY3RlZCBxdWVyeSBrZXk6ICR7dGhpcy5xdWVyeUhhc2h9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoYCR7dGhpcy5xdWVyeUhhc2h9IGRhdGEgaXMgdW5kZWZpbmVkYCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jY2FjaGUuY29uZmlnLm9uU3VjY2Vzcz8uKGRhdGEsIHRoaXMpO1xuICAgICAgICB0aGlzLiNjYWNoZS5jb25maWcub25TZXR0bGVkPy4oXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRmV0Y2hpbmdPcHRpbWlzdGljKSB7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZUdjKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0ZldGNoaW5nT3B0aW1pc3RpYyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvbkZhaWw6IChmYWlsdXJlQ291bnQsIGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJmYWlsZWRcIiwgZmFpbHVyZUNvdW50LCBlcnJvciB9KTtcbiAgICAgIH0sXG4gICAgICBvblBhdXNlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoKHsgdHlwZTogXCJwYXVzZVwiIH0pO1xuICAgICAgfSxcbiAgICAgIG9uQ29udGludWU6ICgpID0+IHtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2goeyB0eXBlOiBcImNvbnRpbnVlXCIgfSk7XG4gICAgICB9LFxuICAgICAgcmV0cnk6IGNvbnRleHQub3B0aW9ucy5yZXRyeSxcbiAgICAgIHJldHJ5RGVsYXk6IGNvbnRleHQub3B0aW9ucy5yZXRyeURlbGF5LFxuICAgICAgbmV0d29ya01vZGU6IGNvbnRleHQub3B0aW9ucy5uZXR3b3JrTW9kZSxcbiAgICAgIGNhblJ1bjogKCkgPT4gdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLiNyZXRyeWVyLnN0YXJ0KCk7XG4gIH1cbiAgI2Rpc3BhdGNoKGFjdGlvbikge1xuICAgIGNvbnN0IHJlZHVjZXIgPSAoc3RhdGUpID0+IHtcbiAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZFwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiBhY3Rpb24uZmFpbHVyZUNvdW50LFxuICAgICAgICAgICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBhY3Rpb24uZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicGF1c2VcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogXCJwYXVzZWRcIlxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiBcImZldGNoaW5nXCJcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZmV0Y2hcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAuLi5mZXRjaFN0YXRlKHN0YXRlLmRhdGEsIHRoaXMub3B0aW9ucyksXG4gICAgICAgICAgICBmZXRjaE1ldGE6IGFjdGlvbi5tZXRhID8/IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGRhdGE6IGFjdGlvbi5kYXRhLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZUNvdW50OiBzdGF0ZS5kYXRhVXBkYXRlQ291bnQgKyAxLFxuICAgICAgICAgICAgZGF0YVVwZGF0ZWRBdDogYWN0aW9uLmRhdGFVcGRhdGVkQXQgPz8gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgaXNJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgLi4uIWFjdGlvbi5tYW51YWwgJiYge1xuICAgICAgICAgICAgICBmZXRjaFN0YXR1czogXCJpZGxlXCIsXG4gICAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgICAgICAgICAgICBmZXRjaEZhaWx1cmVSZWFzb246IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICBjb25zdCBlcnJvciA9IGFjdGlvbi5lcnJvcjtcbiAgICAgICAgICBpZiAoaXNDYW5jZWxsZWRFcnJvcihlcnJvcikgJiYgZXJyb3IucmV2ZXJ0ICYmIHRoaXMuI3JldmVydFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi50aGlzLiNyZXZlcnRTdGF0ZSwgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JVcGRhdGVDb3VudDogc3RhdGUuZXJyb3JVcGRhdGVDb3VudCArIDEsXG4gICAgICAgICAgICBlcnJvclVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGZldGNoRmFpbHVyZUNvdW50OiBzdGF0ZS5mZXRjaEZhaWx1cmVDb3VudCArIDEsXG4gICAgICAgICAgICBmZXRjaEZhaWx1cmVSZWFzb246IGVycm9yLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCJcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiaW52YWxpZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIGlzSW52YWxpZGF0ZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic2V0U3RhdGVcIjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAuLi5hY3Rpb24uc3RhdGVcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zdGF0ZSA9IHJlZHVjZXIodGhpcy5zdGF0ZSk7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLm9ic2VydmVycy5mb3JFYWNoKChvYnNlcnZlcikgPT4ge1xuICAgICAgICBvYnNlcnZlci5vblF1ZXJ5VXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NhY2hlLm5vdGlmeSh7IHF1ZXJ5OiB0aGlzLCB0eXBlOiBcInVwZGF0ZWRcIiwgYWN0aW9uIH0pO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gZmV0Y2hTdGF0ZShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgZmV0Y2hGYWlsdXJlQ291bnQ6IDAsXG4gICAgZmV0Y2hGYWlsdXJlUmVhc29uOiBudWxsLFxuICAgIGZldGNoU3RhdHVzOiBjYW5GZXRjaChvcHRpb25zLm5ldHdvcmtNb2RlKSA/IFwiZmV0Y2hpbmdcIiA6IFwicGF1c2VkXCIsXG4gICAgLi4uZGF0YSA9PT0gdm9pZCAwICYmIHtcbiAgICAgIGVycm9yOiBudWxsLFxuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZShvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGEgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsRGF0YSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsRGF0YSgpIDogb3B0aW9ucy5pbml0aWFsRGF0YTtcbiAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgY29uc3QgaW5pdGlhbERhdGFVcGRhdGVkQXQgPSBoYXNEYXRhID8gdHlwZW9mIG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQoKSA6IG9wdGlvbnMuaW5pdGlhbERhdGFVcGRhdGVkQXQgOiAwO1xuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgZGF0YVVwZGF0ZUNvdW50OiAwLFxuICAgIGRhdGFVcGRhdGVkQXQ6IGhhc0RhdGEgPyBpbml0aWFsRGF0YVVwZGF0ZWRBdCA/PyBEYXRlLm5vdygpIDogMCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBlcnJvclVwZGF0ZUNvdW50OiAwLFxuICAgIGVycm9yVXBkYXRlZEF0OiAwLFxuICAgIGZldGNoRmFpbHVyZUNvdW50OiAwLFxuICAgIGZldGNoRmFpbHVyZVJlYXNvbjogbnVsbCxcbiAgICBmZXRjaE1ldGE6IG51bGwsXG4gICAgaXNJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgc3RhdHVzOiBoYXNEYXRhID8gXCJzdWNjZXNzXCIgOiBcInBlbmRpbmdcIixcbiAgICBmZXRjaFN0YXR1czogXCJpZGxlXCJcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIFF1ZXJ5LFxuICBmZXRjaFN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryCache.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryCache: function() { return /* binding */ QueryCache; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./query.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n// src/queryCache.ts\n\n\n\n\nvar QueryCache = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashQueryKeyByOptions)(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new _query_js__WEBPACK_IMPORTED_MODULE_2__.Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchQuery)(filters, query)) : queries;\n  }\n  notify(event) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\n\n//# sourceMappingURL=queryCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDYWNoZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQytEO0FBQzVCO0FBQ2dCO0FBQ0Y7QUFDakQsK0JBQStCLDBEQUFZO0FBQzNDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnRUFBcUI7QUFDaEU7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFhO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHVFQUF1RSxxREFBVTtBQUNqRjtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSw0REFBYTtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3F1ZXJ5Q2FjaGUuanM/NTg2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnlDYWNoZS50c1xuaW1wb3J0IHsgaGFzaFF1ZXJ5S2V5QnlPcHRpb25zLCBtYXRjaFF1ZXJ5IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IFF1ZXJ5IH0gZnJvbSBcIi4vcXVlcnkuanNcIjtcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tIFwiLi9zdWJzY3JpYmFibGUuanNcIjtcbnZhciBRdWVyeUNhY2hlID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy4jcXVlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgI3F1ZXJpZXM7XG4gIGJ1aWxkKGNsaWVudCwgb3B0aW9ucywgc3RhdGUpIHtcbiAgICBjb25zdCBxdWVyeUtleSA9IG9wdGlvbnMucXVlcnlLZXk7XG4gICAgY29uc3QgcXVlcnlIYXNoID0gb3B0aW9ucy5xdWVyeUhhc2ggPz8gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBvcHRpb25zKTtcbiAgICBsZXQgcXVlcnkgPSB0aGlzLmdldChxdWVyeUhhc2gpO1xuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHtcbiAgICAgICAgY2FjaGU6IHRoaXMsXG4gICAgICAgIHF1ZXJ5S2V5LFxuICAgICAgICBxdWVyeUhhc2gsXG4gICAgICAgIG9wdGlvbnM6IGNsaWVudC5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnM6IGNsaWVudC5nZXRRdWVyeURlZmF1bHRzKHF1ZXJ5S2V5KVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZChxdWVyeSk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICBhZGQocXVlcnkpIHtcbiAgICBpZiAoIXRoaXMuI3F1ZXJpZXMuaGFzKHF1ZXJ5LnF1ZXJ5SGFzaCkpIHtcbiAgICAgIHRoaXMuI3F1ZXJpZXMuc2V0KHF1ZXJ5LnF1ZXJ5SGFzaCwgcXVlcnkpO1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiBcImFkZGVkXCIsXG4gICAgICAgIHF1ZXJ5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKHF1ZXJ5KSB7XG4gICAgY29uc3QgcXVlcnlJbk1hcCA9IHRoaXMuI3F1ZXJpZXMuZ2V0KHF1ZXJ5LnF1ZXJ5SGFzaCk7XG4gICAgaWYgKHF1ZXJ5SW5NYXApIHtcbiAgICAgIHF1ZXJ5LmRlc3Ryb3koKTtcbiAgICAgIGlmIChxdWVyeUluTWFwID09PSBxdWVyeSkge1xuICAgICAgICB0aGlzLiNxdWVyaWVzLmRlbGV0ZShxdWVyeS5xdWVyeUhhc2gpO1xuICAgICAgfVxuICAgICAgdGhpcy5ub3RpZnkoeyB0eXBlOiBcInJlbW92ZWRcIiwgcXVlcnkgfSk7XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5nZXRBbGwoKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZShxdWVyeSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQocXVlcnlIYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3F1ZXJpZXMuZ2V0KHF1ZXJ5SGFzaCk7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiBbLi4udGhpcy4jcXVlcmllcy52YWx1ZXMoKV07XG4gIH1cbiAgZmluZChmaWx0ZXJzKSB7XG4gICAgY29uc3QgZGVmYXVsdGVkRmlsdGVycyA9IHsgZXhhY3Q6IHRydWUsIC4uLmZpbHRlcnMgfTtcbiAgICByZXR1cm4gdGhpcy5nZXRBbGwoKS5maW5kKFxuICAgICAgKHF1ZXJ5KSA9PiBtYXRjaFF1ZXJ5KGRlZmF1bHRlZEZpbHRlcnMsIHF1ZXJ5KVxuICAgICk7XG4gIH1cbiAgZmluZEFsbChmaWx0ZXJzID0ge30pIHtcbiAgICBjb25zdCBxdWVyaWVzID0gdGhpcy5nZXRBbGwoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlsdGVycykubGVuZ3RoID4gMCA/IHF1ZXJpZXMuZmlsdGVyKChxdWVyeSkgPT4gbWF0Y2hRdWVyeShmaWx0ZXJzLCBxdWVyeSkpIDogcXVlcmllcztcbiAgfVxuICBub3RpZnkoZXZlbnQpIHtcbiAgICBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG9uRm9jdXMoKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICB0aGlzLmdldEFsbCgpLmZvckVhY2goKHF1ZXJ5KSA9PiB7XG4gICAgICAgIHF1ZXJ5Lm9uRm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG9uT25saW5lKCkge1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgdGhpcy5nZXRBbGwoKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeS5vbk9ubGluZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5leHBvcnQge1xuICBRdWVyeUNhY2hlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlDYWNoZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryClient.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClient: function() { return /* binding */ QueryClient; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _queryCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queryCache.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryCache.js\");\n/* harmony import */ var _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mutationCache.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationCache.js\");\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./infiniteQueryBehavior.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js\");\n// src/queryClient.ts\n\n\n\n\n\n\n\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new _queryCache_js__WEBPACK_IMPORTED_MODULE_0__.QueryCache();\n    this.#mutationCache = config.mutationCache || new _mutationCache_js__WEBPACK_IMPORTED_MODULE_1__.MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1)\n      return;\n    this.#unsubscribeFocus = _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = _onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0)\n      return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const cachedData = this.getQueryData(options.queryKey);\n    if (cachedData === void 0)\n      return this.fetchQuery(options);\n    else {\n      const defaultedOptions = this.defaultQueryOptions(options);\n      const query = this.#queryCache.build(this, defaultedOptions);\n      if (options.revalidateIfStale && query.isStaleByTime((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveStaleTime)(defaultedOptions.staleTime, query))) {\n        void this.prefetchQuery(defaultedOptions);\n      }\n      return Promise.resolve(cachedData);\n    }\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.functionalUpdate)(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    const refetchFilters = {\n      type: \"active\",\n      ...filters\n    };\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries(filters = {}, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  invalidateQueries(filters = {}, options = {}) {\n    return _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? \"active\"\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries(filters = {}, options) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true\n    };\n    const promises = _notifyManager_js__WEBPACK_IMPORTED_MODULE_5__.notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveStaleTime)(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = (0,_infiniteQueryBehavior_js__WEBPACK_IMPORTED_MODULE_6__.infiniteQueryBehavior)(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n  }\n  resumePausedMutations() {\n    if (_onlineManager_js__WEBPACK_IMPORTED_MODULE_3__.onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(queryKey, queryDefault.queryKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashKey)(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    let result = {};\n    defaults.forEach((queryDefault) => {\n      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.partialMatchKey)(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions };\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hashQueryKeyByOptions)(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === _utils_js__WEBPACK_IMPORTED_MODULE_4__.skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\n\n//# sourceMappingURL=queryClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQVNvQjtBQUN5QjtBQUNNO0FBQ0Y7QUFDRTtBQUNBO0FBQ2dCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixnREFBZ0Qsc0RBQVU7QUFDMUQsc0RBQXNELDREQUFhO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwREFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEIsNERBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEU7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwyREFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDBCQUEwQjtBQUNwRztBQUNBO0FBQ0EsV0FBVyw0REFBYTtBQUN4QixxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWE7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hELHFDQUFxQztBQUNyQyxxQkFBcUIsNERBQWE7QUFDbEM7QUFDQTtBQUNBLHNDQUFzQywyQ0FBSSxRQUFRLDJDQUFJO0FBQ3REO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUMsV0FBVyw0REFBYTtBQUN4QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJDQUFJO0FBQ3RDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQ0FBc0MsMkNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywyQ0FBSSxRQUFRLDJDQUFJO0FBQ3pEO0FBQ0E7QUFDQSx1QkFBdUIsZ0ZBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQ0FBSSxRQUFRLDJDQUFJO0FBQ2pFO0FBQ0E7QUFDQSxRQUFRLDREQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0RBQU87QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBZTtBQUN6QixtQkFBbUI7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtEQUFPO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMERBQWU7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdFQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnREFBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3F1ZXJ5LWNvcmUvYnVpbGQvbW9kZXJuL3F1ZXJ5Q2xpZW50LmpzPzFjY2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5Q2xpZW50LnRzXG5pbXBvcnQge1xuICBmdW5jdGlvbmFsVXBkYXRlLFxuICBoYXNoS2V5LFxuICBoYXNoUXVlcnlLZXlCeU9wdGlvbnMsXG4gIG5vb3AsXG4gIHBhcnRpYWxNYXRjaEtleSxcbiAgcmVzb2x2ZVN0YWxlVGltZSxcbiAgc2tpcFRva2VuXG59IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBRdWVyeUNhY2hlIH0gZnJvbSBcIi4vcXVlcnlDYWNoZS5qc1wiO1xuaW1wb3J0IHsgTXV0YXRpb25DYWNoZSB9IGZyb20gXCIuL211dGF0aW9uQ2FjaGUuanNcIjtcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gXCIuL2ZvY3VzTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgb25saW5lTWFuYWdlciB9IGZyb20gXCIuL29ubGluZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tIFwiLi9ub3RpZnlNYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3IgfSBmcm9tIFwiLi9pbmZpbml0ZVF1ZXJ5QmVoYXZpb3IuanNcIjtcbnZhciBRdWVyeUNsaWVudCA9IGNsYXNzIHtcbiAgI3F1ZXJ5Q2FjaGU7XG4gICNtdXRhdGlvbkNhY2hlO1xuICAjZGVmYXVsdE9wdGlvbnM7XG4gICNxdWVyeURlZmF1bHRzO1xuICAjbXV0YXRpb25EZWZhdWx0cztcbiAgI21vdW50Q291bnQ7XG4gICN1bnN1YnNjcmliZUZvY3VzO1xuICAjdW5zdWJzY3JpYmVPbmxpbmU7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy4jcXVlcnlDYWNoZSA9IGNvbmZpZy5xdWVyeUNhY2hlIHx8IG5ldyBRdWVyeUNhY2hlKCk7XG4gICAgdGhpcy4jbXV0YXRpb25DYWNoZSA9IGNvbmZpZy5tdXRhdGlvbkNhY2hlIHx8IG5ldyBNdXRhdGlvbkNhY2hlKCk7XG4gICAgdGhpcy4jZGVmYXVsdE9wdGlvbnMgPSBjb25maWcuZGVmYXVsdE9wdGlvbnMgfHwge307XG4gICAgdGhpcy4jcXVlcnlEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jbXV0YXRpb25EZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jbW91bnRDb3VudCA9IDA7XG4gIH1cbiAgbW91bnQoKSB7XG4gICAgdGhpcy4jbW91bnRDb3VudCsrO1xuICAgIGlmICh0aGlzLiNtb3VudENvdW50ICE9PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlRm9jdXMgPSBmb2N1c01hbmFnZXIuc3Vic2NyaWJlKGFzeW5jIChmb2N1c2VkKSA9PiB7XG4gICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3VtZVBhdXNlZE11dGF0aW9ucygpO1xuICAgICAgICB0aGlzLiNxdWVyeUNhY2hlLm9uRm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiN1bnN1YnNjcmliZU9ubGluZSA9IG9ubGluZU1hbmFnZXIuc3Vic2NyaWJlKGFzeW5jIChvbmxpbmUpID0+IHtcbiAgICAgIGlmIChvbmxpbmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN1bWVQYXVzZWRNdXRhdGlvbnMoKTtcbiAgICAgICAgdGhpcy4jcXVlcnlDYWNoZS5vbk9ubGluZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVubW91bnQoKSB7XG4gICAgdGhpcy4jbW91bnRDb3VudC0tO1xuICAgIGlmICh0aGlzLiNtb3VudENvdW50ICE9PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlRm9jdXM/LigpO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlRm9jdXMgPSB2b2lkIDA7XG4gICAgdGhpcy4jdW5zdWJzY3JpYmVPbmxpbmU/LigpO1xuICAgIHRoaXMuI3Vuc3Vic2NyaWJlT25saW5lID0gdm9pZCAwO1xuICB9XG4gIGlzRmV0Y2hpbmcoZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoeyAuLi5maWx0ZXJzLCBmZXRjaFN0YXR1czogXCJmZXRjaGluZ1wiIH0pLmxlbmd0aDtcbiAgfVxuICBpc011dGF0aW5nKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy4jbXV0YXRpb25DYWNoZS5maW5kQWxsKHsgLi4uZmlsdGVycywgc3RhdHVzOiBcInBlbmRpbmdcIiB9KS5sZW5ndGg7XG4gIH1cbiAgZ2V0UXVlcnlEYXRhKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyh7IHF1ZXJ5S2V5IH0pO1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmdldChvcHRpb25zLnF1ZXJ5SGFzaCk/LnN0YXRlLmRhdGE7XG4gIH1cbiAgZW5zdXJlUXVlcnlEYXRhKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5nZXRRdWVyeURhdGEob3B0aW9ucy5xdWVyeUtleSk7XG4gICAgaWYgKGNhY2hlZERhdGEgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkob3B0aW9ucyk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMucmV2YWxpZGF0ZUlmU3RhbGUgJiYgcXVlcnkuaXNTdGFsZUJ5VGltZShyZXNvbHZlU3RhbGVUaW1lKGRlZmF1bHRlZE9wdGlvbnMuc3RhbGVUaW1lLCBxdWVyeSkpKSB7XG4gICAgICAgIHZvaWQgdGhpcy5wcmVmZXRjaFF1ZXJ5KGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWREYXRhKTtcbiAgICB9XG4gIH1cbiAgZ2V0UXVlcmllc0RhdGEoZmlsdGVycykge1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykubWFwKCh7IHF1ZXJ5S2V5LCBzdGF0ZSB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc3RhdGUuZGF0YTtcbiAgICAgIHJldHVybiBbcXVlcnlLZXksIGRhdGFdO1xuICAgIH0pO1xuICB9XG4gIHNldFF1ZXJ5RGF0YShxdWVyeUtleSwgdXBkYXRlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSB0aGlzLmRlZmF1bHRRdWVyeU9wdGlvbnMoeyBxdWVyeUtleSB9KTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuI3F1ZXJ5Q2FjaGUuZ2V0KFxuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2hcbiAgICApO1xuICAgIGNvbnN0IHByZXZEYXRhID0gcXVlcnk/LnN0YXRlLmRhdGE7XG4gICAgY29uc3QgZGF0YSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgcHJldkRhdGEpO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpLnNldERhdGEoZGF0YSwgeyAuLi5vcHRpb25zLCBtYW51YWw6IHRydWUgfSk7XG4gIH1cbiAgc2V0UXVlcmllc0RhdGEoZmlsdGVycywgdXBkYXRlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLm1hcCgoeyBxdWVyeUtleSB9KSA9PiBbXG4gICAgICAgIHF1ZXJ5S2V5LFxuICAgICAgICB0aGlzLnNldFF1ZXJ5RGF0YShxdWVyeUtleSwgdXBkYXRlciwgb3B0aW9ucylcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBnZXRRdWVyeVN0YXRlKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZGVmYXVsdFF1ZXJ5T3B0aW9ucyh7IHF1ZXJ5S2V5IH0pO1xuICAgIHJldHVybiB0aGlzLiNxdWVyeUNhY2hlLmdldChvcHRpb25zLnF1ZXJ5SGFzaCk/LnN0YXRlO1xuICB9XG4gIHJlbW92ZVF1ZXJpZXMoZmlsdGVycykge1xuICAgIGNvbnN0IHF1ZXJ5Q2FjaGUgPSB0aGlzLiNxdWVyeUNhY2hlO1xuICAgIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZvckVhY2goKHF1ZXJ5KSA9PiB7XG4gICAgICAgIHF1ZXJ5Q2FjaGUucmVtb3ZlKHF1ZXJ5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0UXVlcmllcyhmaWx0ZXJzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlDYWNoZSA9IHRoaXMuI3F1ZXJ5Q2FjaGU7XG4gICAgY29uc3QgcmVmZXRjaEZpbHRlcnMgPSB7XG4gICAgICB0eXBlOiBcImFjdGl2ZVwiLFxuICAgICAgLi4uZmlsdGVyc1xuICAgIH07XG4gICAgcmV0dXJuIG5vdGlmeU1hbmFnZXIuYmF0Y2goKCkgPT4ge1xuICAgICAgcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLmZvckVhY2goKHF1ZXJ5KSA9PiB7XG4gICAgICAgIHF1ZXJ5LnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnJlZmV0Y2hRdWVyaWVzKHJlZmV0Y2hGaWx0ZXJzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBjYW5jZWxRdWVyaWVzKGZpbHRlcnMgPSB7fSwgY2FuY2VsT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgZGVmYXVsdGVkQ2FuY2VsT3B0aW9ucyA9IHsgcmV2ZXJ0OiB0cnVlLCAuLi5jYW5jZWxPcHRpb25zIH07XG4gICAgY29uc3QgcHJvbWlzZXMgPSBub3RpZnlNYW5hZ2VyLmJhdGNoKFxuICAgICAgKCkgPT4gdGhpcy4jcXVlcnlDYWNoZS5maW5kQWxsKGZpbHRlcnMpLm1hcCgocXVlcnkpID0+IHF1ZXJ5LmNhbmNlbChkZWZhdWx0ZWRDYW5jZWxPcHRpb25zKSlcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuICBpbnZhbGlkYXRlUXVlcmllcyhmaWx0ZXJzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBub3RpZnlNYW5hZ2VyLmJhdGNoKCgpID0+IHtcbiAgICAgIHRoaXMuI3F1ZXJ5Q2FjaGUuZmluZEFsbChmaWx0ZXJzKS5mb3JFYWNoKChxdWVyeSkgPT4ge1xuICAgICAgICBxdWVyeS5pbnZhbGlkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmaWx0ZXJzLnJlZmV0Y2hUeXBlID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWZldGNoRmlsdGVycyA9IHtcbiAgICAgICAgLi4uZmlsdGVycyxcbiAgICAgICAgdHlwZTogZmlsdGVycy5yZWZldGNoVHlwZSA/PyBmaWx0ZXJzLnR5cGUgPz8gXCJhY3RpdmVcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLnJlZmV0Y2hRdWVyaWVzKHJlZmV0Y2hGaWx0ZXJzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICByZWZldGNoUXVlcmllcyhmaWx0ZXJzID0ge30sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY2FuY2VsUmVmZXRjaDogb3B0aW9ucz8uY2FuY2VsUmVmZXRjaCA/PyB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBwcm9taXNlcyA9IG5vdGlmeU1hbmFnZXIuYmF0Y2goXG4gICAgICAoKSA9PiB0aGlzLiNxdWVyeUNhY2hlLmZpbmRBbGwoZmlsdGVycykuZmlsdGVyKChxdWVyeSkgPT4gIXF1ZXJ5LmlzRGlzYWJsZWQoKSkubWFwKChxdWVyeSkgPT4ge1xuICAgICAgICBsZXQgcHJvbWlzZSA9IHF1ZXJ5LmZldGNoKHZvaWQgMCwgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgaWYgKCFmZXRjaE9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuY2F0Y2gobm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnN0YXRlLmZldGNoU3RhdHVzID09PSBcInBhdXNlZFwiID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihub29wKTtcbiAgfVxuICBmZXRjaFF1ZXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmIChkZWZhdWx0ZWRPcHRpb25zLnJldHJ5ID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRlZE9wdGlvbnMucmV0cnkgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNxdWVyeUNhY2hlLmJ1aWxkKHRoaXMsIGRlZmF1bHRlZE9wdGlvbnMpO1xuICAgIHJldHVybiBxdWVyeS5pc1N0YWxlQnlUaW1lKFxuICAgICAgcmVzb2x2ZVN0YWxlVGltZShkZWZhdWx0ZWRPcHRpb25zLnN0YWxlVGltZSwgcXVlcnkpXG4gICAgKSA/IHF1ZXJ5LmZldGNoKGRlZmF1bHRlZE9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKHF1ZXJ5LnN0YXRlLmRhdGEpO1xuICB9XG4gIHByZWZldGNoUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkob3B0aW9ucykudGhlbihub29wKS5jYXRjaChub29wKTtcbiAgfVxuICBmZXRjaEluZmluaXRlUXVlcnkob3B0aW9ucykge1xuICAgIG9wdGlvbnMuYmVoYXZpb3IgPSBpbmZpbml0ZVF1ZXJ5QmVoYXZpb3Iob3B0aW9ucy5wYWdlcyk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hRdWVyeShvcHRpb25zKTtcbiAgfVxuICBwcmVmZXRjaEluZmluaXRlUXVlcnkob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZldGNoSW5maW5pdGVRdWVyeShvcHRpb25zKS50aGVuKG5vb3ApLmNhdGNoKG5vb3ApO1xuICB9XG4gIHJlc3VtZVBhdXNlZE11dGF0aW9ucygpIHtcbiAgICBpZiAob25saW5lTWFuYWdlci5pc09ubGluZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jbXV0YXRpb25DYWNoZS5yZXN1bWVQYXVzZWRNdXRhdGlvbnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGdldFF1ZXJ5Q2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3F1ZXJ5Q2FjaGU7XG4gIH1cbiAgZ2V0TXV0YXRpb25DYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbXV0YXRpb25DYWNoZTtcbiAgfVxuICBnZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVmYXVsdE9wdGlvbnM7XG4gIH1cbiAgc2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuI2RlZmF1bHRPcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBzZXRRdWVyeURlZmF1bHRzKHF1ZXJ5S2V5LCBvcHRpb25zKSB7XG4gICAgdGhpcy4jcXVlcnlEZWZhdWx0cy5zZXQoaGFzaEtleShxdWVyeUtleSksIHtcbiAgICAgIHF1ZXJ5S2V5LFxuICAgICAgZGVmYXVsdE9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBnZXRRdWVyeURlZmF1bHRzKHF1ZXJ5S2V5KSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBbLi4udGhpcy4jcXVlcnlEZWZhdWx0cy52YWx1ZXMoKV07XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGRlZmF1bHRzLmZvckVhY2goKHF1ZXJ5RGVmYXVsdCkgPT4ge1xuICAgICAgaWYgKHBhcnRpYWxNYXRjaEtleShxdWVyeUtleSwgcXVlcnlEZWZhdWx0LnF1ZXJ5S2V5KSkge1xuICAgICAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCwgLi4ucXVlcnlEZWZhdWx0LmRlZmF1bHRPcHRpb25zIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXRNdXRhdGlvbkRlZmF1bHRzKG11dGF0aW9uS2V5LCBvcHRpb25zKSB7XG4gICAgdGhpcy4jbXV0YXRpb25EZWZhdWx0cy5zZXQoaGFzaEtleShtdXRhdGlvbktleSksIHtcbiAgICAgIG11dGF0aW9uS2V5LFxuICAgICAgZGVmYXVsdE9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICBnZXRNdXRhdGlvbkRlZmF1bHRzKG11dGF0aW9uS2V5KSB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSBbLi4udGhpcy4jbXV0YXRpb25EZWZhdWx0cy52YWx1ZXMoKV07XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGRlZmF1bHRzLmZvckVhY2goKHF1ZXJ5RGVmYXVsdCkgPT4ge1xuICAgICAgaWYgKHBhcnRpYWxNYXRjaEtleShtdXRhdGlvbktleSwgcXVlcnlEZWZhdWx0Lm11dGF0aW9uS2V5KSkge1xuICAgICAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCwgLi4ucXVlcnlEZWZhdWx0LmRlZmF1bHRPcHRpb25zIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5fZGVmYXVsdGVkKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdGVkT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMuI2RlZmF1bHRPcHRpb25zLnF1ZXJpZXMsXG4gICAgICAuLi50aGlzLmdldFF1ZXJ5RGVmYXVsdHMob3B0aW9ucy5xdWVyeUtleSksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgX2RlZmF1bHRlZDogdHJ1ZVxuICAgIH07XG4gICAgaWYgKCFkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5SGFzaCkge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5xdWVyeUhhc2ggPSBoYXNoUXVlcnlLZXlCeU9wdGlvbnMoXG4gICAgICAgIGRlZmF1bHRlZE9wdGlvbnMucXVlcnlLZXksXG4gICAgICAgIGRlZmF1bHRlZE9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0ZWRPcHRpb25zLnJlZmV0Y2hPblJlY29ubmVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLnJlZmV0Y2hPblJlY29ubmVjdCA9IGRlZmF1bHRlZE9wdGlvbnMubmV0d29ya01vZGUgIT09IFwiYWx3YXlzXCI7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0ZWRPcHRpb25zLnRocm93T25FcnJvciA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLnRocm93T25FcnJvciA9ICEhZGVmYXVsdGVkT3B0aW9ucy5zdXNwZW5zZTtcbiAgICB9XG4gICAgaWYgKCFkZWZhdWx0ZWRPcHRpb25zLm5ldHdvcmtNb2RlICYmIGRlZmF1bHRlZE9wdGlvbnMucGVyc2lzdGVyKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLm5ldHdvcmtNb2RlID0gXCJvZmZsaW5lRmlyc3RcIjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRlZE9wdGlvbnMuZW5hYmxlZCAhPT0gdHJ1ZSAmJiBkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5Rm4gPT09IHNraXBUb2tlbikge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0ZWRPcHRpb25zO1xuICB9XG4gIGRlZmF1bHRNdXRhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zPy5fZGVmYXVsdGVkKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuI2RlZmF1bHRPcHRpb25zLm11dGF0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnM/Lm11dGF0aW9uS2V5ICYmIHRoaXMuZ2V0TXV0YXRpb25EZWZhdWx0cyhvcHRpb25zLm11dGF0aW9uS2V5KSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBfZGVmYXVsdGVkOiB0cnVlXG4gICAgfTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLiNxdWVyeUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy4jbXV0YXRpb25DYWNoZS5jbGVhcigpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgUXVlcnlDbGllbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryObserver.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/queryObserver.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryObserver: function() { return /* binding */ QueryObserver; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n/* harmony import */ var _notifyManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./notifyManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _subscribable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subscribable.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\");\n/* harmony import */ var _query_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./query.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/query.js\");\n// src/queryObserver.ts\n\n\n\n\n\nvar QueryObserver = class extends _subscribable_js__WEBPACK_IMPORTED_MODULE_0__.Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(prevOptions.enabled, this.#currentQuery) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(this.options.staleTime, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) !== (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(_utils_js__WEBPACK_IMPORTED_MODULE_1__.noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer || this.#currentResult.isStale || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isValidTimeout)(staleTime)) {\n      return;\n    }\n    const time = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.timeUntilStale)(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isServer || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(this.options.enabled, this.#currentQuery) === false || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isValidTimeout)(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || _focusManager_js__WEBPACK_IMPORTED_MODULE_2__.focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...(0,_query_js__WEBPACK_IMPORTED_MODULE_3__.fetchState)(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(newState.data);\n          data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.replaceData)(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    _notifyManager_js__WEBPACK_IMPORTED_MODULE_4__.notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnabled)(options.enabled, query) !== false && query.isStaleByTime((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.resolveStaleTime)(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shallowEqualObjects)(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\n\n//# sourceMappingURL=queryObserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcXVlcnlPYnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQVVvQjtBQUMrQjtBQUNGO0FBQ0E7QUFDVDtBQUN4QyxrQ0FBa0MsMERBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2SSx5REFBYztBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOERBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseURBQWMsK0NBQStDLHlEQUFjLDZDQUE2QywyREFBZ0IsaURBQWlELDJEQUFnQjtBQUNqUTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseURBQWMsK0NBQStDLHlEQUFjO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLGlDQUFpQyx5REFBYztBQUMvQztBQUNBO0FBQ0EsU0FBUyx5REFBYywwREFBMEQsMkRBQWdCO0FBQ2pHO0FBQ0E7QUFDQSxPQUFPLDhEQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9xdWVyeU9ic2VydmVyLmpzPzI5ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5T2JzZXJ2ZXIudHNcbmltcG9ydCB7XG4gIGlzU2VydmVyLFxuICBpc1ZhbGlkVGltZW91dCxcbiAgbm9vcCxcbiAgcmVwbGFjZURhdGEsXG4gIHJlc29sdmVFbmFibGVkLFxuICByZXNvbHZlU3RhbGVUaW1lLFxuICBzaGFsbG93RXF1YWxPYmplY3RzLFxuICB0aW1lVW50aWxTdGFsZVxufSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgbm90aWZ5TWFuYWdlciB9IGZyb20gXCIuL25vdGlmeU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gXCIuL2ZvY3VzTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgU3Vic2NyaWJhYmxlIH0gZnJvbSBcIi4vc3Vic2NyaWJhYmxlLmpzXCI7XG5pbXBvcnQgeyBmZXRjaFN0YXRlIH0gZnJvbSBcIi4vcXVlcnkuanNcIjtcbnZhciBRdWVyeU9ic2VydmVyID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuI3NlbGVjdEVycm9yID0gbnVsbDtcbiAgICB0aGlzLmJpbmRNZXRob2RzKCk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG4gICNjbGllbnQ7XG4gICNjdXJyZW50UXVlcnkgPSB2b2lkIDA7XG4gICNjdXJyZW50UXVlcnlJbml0aWFsU3RhdGUgPSB2b2lkIDA7XG4gICNjdXJyZW50UmVzdWx0ID0gdm9pZCAwO1xuICAjY3VycmVudFJlc3VsdFN0YXRlO1xuICAjY3VycmVudFJlc3VsdE9wdGlvbnM7XG4gICNzZWxlY3RFcnJvcjtcbiAgI3NlbGVjdEZuO1xuICAjc2VsZWN0UmVzdWx0O1xuICAvLyBUaGlzIHByb3BlcnR5IGtlZXBzIHRyYWNrIG9mIHRoZSBsYXN0IHF1ZXJ5IHdpdGggZGVmaW5lZCBkYXRhLlxuICAvLyBJdCB3aWxsIGJlIHVzZWQgdG8gcGFzcyB0aGUgcHJldmlvdXMgZGF0YSBhbmQgcXVlcnkgdG8gdGhlIHBsYWNlaG9sZGVyIGZ1bmN0aW9uIGJldHdlZW4gcmVuZGVycy5cbiAgI2xhc3RRdWVyeVdpdGhEZWZpbmVkRGF0YTtcbiAgI3N0YWxlVGltZW91dElkO1xuICAjcmVmZXRjaEludGVydmFsSWQ7XG4gICNjdXJyZW50UmVmZXRjaEludGVydmFsO1xuICAjdHJhY2tlZFByb3BzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgYmluZE1ldGhvZHMoKSB7XG4gICAgdGhpcy5yZWZldGNoID0gdGhpcy5yZWZldGNoLmJpbmQodGhpcyk7XG4gIH1cbiAgb25TdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzLnNpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRRdWVyeS5hZGRPYnNlcnZlcih0aGlzKTtcbiAgICAgIGlmIChzaG91bGRGZXRjaE9uTW91bnQodGhpcy4jY3VycmVudFF1ZXJ5LCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHRoaXMuI2V4ZWN1dGVGZXRjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVSZXN1bHQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VwZGF0ZVRpbWVycygpO1xuICAgIH1cbiAgfVxuICBvblVuc3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy5oYXNMaXN0ZW5lcnMoKSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG4gIHNob3VsZEZldGNoT25SZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHNob3VsZEZldGNoT24oXG4gICAgICB0aGlzLiNjdXJyZW50UXVlcnksXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICB0aGlzLm9wdGlvbnMucmVmZXRjaE9uUmVjb25uZWN0XG4gICAgKTtcbiAgfVxuICBzaG91bGRGZXRjaE9uV2luZG93Rm9jdXMoKSB7XG4gICAgcmV0dXJuIHNob3VsZEZldGNoT24oXG4gICAgICB0aGlzLiNjdXJyZW50UXVlcnksXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICB0aGlzLm9wdGlvbnMucmVmZXRjaE9uV2luZG93Rm9jdXNcbiAgICApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI2NsZWFyU3RhbGVUaW1lb3V0KCk7XG4gICAgdGhpcy4jY2xlYXJSZWZldGNoSW50ZXJ2YWwoKTtcbiAgICB0aGlzLiNjdXJyZW50UXVlcnkucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gIH1cbiAgc2V0T3B0aW9ucyhvcHRpb25zLCBub3RpZnlPcHRpb25zKSB7XG4gICAgY29uc3QgcHJldk9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgcHJldlF1ZXJ5ID0gdGhpcy4jY3VycmVudFF1ZXJ5O1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuI2NsaWVudC5kZWZhdWx0UXVlcnlPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCAhPT0gdm9pZCAwICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZW5hYmxlZCAhPT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lbmFibGVkICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlc29sdmVFbmFibGVkKHRoaXMub3B0aW9ucy5lbmFibGVkLCB0aGlzLiNjdXJyZW50UXVlcnkpICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGVuYWJsZWQgdG8gYmUgYSBib29sZWFuIG9yIGEgY2FsbGJhY2sgdGhhdCByZXR1cm5zIGEgYm9vbGVhblwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVRdWVyeSgpO1xuICAgIHRoaXMuI2N1cnJlbnRRdWVyeS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKHByZXZPcHRpb25zLl9kZWZhdWx0ZWQgJiYgIXNoYWxsb3dFcXVhbE9iamVjdHModGhpcy5vcHRpb25zLCBwcmV2T3B0aW9ucykpIHtcbiAgICAgIHRoaXMuI2NsaWVudC5nZXRRdWVyeUNhY2hlKCkubm90aWZ5KHtcbiAgICAgICAgdHlwZTogXCJvYnNlcnZlck9wdGlvbnNVcGRhdGVkXCIsXG4gICAgICAgIHF1ZXJ5OiB0aGlzLiNjdXJyZW50UXVlcnksXG4gICAgICAgIG9ic2VydmVyOiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbW91bnRlZCA9IHRoaXMuaGFzTGlzdGVuZXJzKCk7XG4gICAgaWYgKG1vdW50ZWQgJiYgc2hvdWxkRmV0Y2hPcHRpb25hbGx5KFxuICAgICAgdGhpcy4jY3VycmVudFF1ZXJ5LFxuICAgICAgcHJldlF1ZXJ5LFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgcHJldk9wdGlvbnNcbiAgICApKSB7XG4gICAgICB0aGlzLiNleGVjdXRlRmV0Y2goKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSZXN1bHQobm90aWZ5T3B0aW9ucyk7XG4gICAgaWYgKG1vdW50ZWQgJiYgKHRoaXMuI2N1cnJlbnRRdWVyeSAhPT0gcHJldlF1ZXJ5IHx8IHJlc29sdmVFbmFibGVkKHRoaXMub3B0aW9ucy5lbmFibGVkLCB0aGlzLiNjdXJyZW50UXVlcnkpICE9PSByZXNvbHZlRW5hYmxlZChwcmV2T3B0aW9ucy5lbmFibGVkLCB0aGlzLiNjdXJyZW50UXVlcnkpIHx8IHJlc29sdmVTdGFsZVRpbWUodGhpcy5vcHRpb25zLnN0YWxlVGltZSwgdGhpcy4jY3VycmVudFF1ZXJ5KSAhPT0gcmVzb2x2ZVN0YWxlVGltZShwcmV2T3B0aW9ucy5zdGFsZVRpbWUsIHRoaXMuI2N1cnJlbnRRdWVyeSkpKSB7XG4gICAgICB0aGlzLiN1cGRhdGVTdGFsZVRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFJlZmV0Y2hJbnRlcnZhbCA9IHRoaXMuI2NvbXB1dGVSZWZldGNoSW50ZXJ2YWwoKTtcbiAgICBpZiAobW91bnRlZCAmJiAodGhpcy4jY3VycmVudFF1ZXJ5ICE9PSBwcmV2UXVlcnkgfHwgcmVzb2x2ZUVuYWJsZWQodGhpcy5vcHRpb25zLmVuYWJsZWQsIHRoaXMuI2N1cnJlbnRRdWVyeSkgIT09IHJlc29sdmVFbmFibGVkKHByZXZPcHRpb25zLmVuYWJsZWQsIHRoaXMuI2N1cnJlbnRRdWVyeSkgfHwgbmV4dFJlZmV0Y2hJbnRlcnZhbCAhPT0gdGhpcy4jY3VycmVudFJlZmV0Y2hJbnRlcnZhbCkpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVJlZmV0Y2hJbnRlcnZhbChuZXh0UmVmZXRjaEludGVydmFsKTtcbiAgICB9XG4gIH1cbiAgZ2V0T3B0aW1pc3RpY1Jlc3VsdChvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNjbGllbnQuZ2V0UXVlcnlDYWNoZSgpLmJ1aWxkKHRoaXMuI2NsaWVudCwgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVSZXN1bHQocXVlcnksIG9wdGlvbnMpO1xuICAgIGlmIChzaG91bGRBc3NpZ25PYnNlcnZlckN1cnJlbnRQcm9wZXJ0aWVzKHRoaXMsIHJlc3VsdCkpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRSZXN1bHQgPSByZXN1bHQ7XG4gICAgICB0aGlzLiNjdXJyZW50UmVzdWx0T3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHRoaXMuI2N1cnJlbnRSZXN1bHRTdGF0ZSA9IHRoaXMuI2N1cnJlbnRRdWVyeS5zdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRDdXJyZW50UmVzdWx0KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UmVzdWx0O1xuICB9XG4gIHRyYWNrUmVzdWx0KHJlc3VsdCwgb25Qcm9wVHJhY2tlZCkge1xuICAgIGNvbnN0IHRyYWNrZWRSZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrZWRSZXN1bHQsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnRyYWNrUHJvcChrZXkpO1xuICAgICAgICAgIG9uUHJvcFRyYWNrZWQ/LihrZXkpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRyYWNrZWRSZXN1bHQ7XG4gIH1cbiAgdHJhY2tQcm9wKGtleSkge1xuICAgIHRoaXMuI3RyYWNrZWRQcm9wcy5hZGQoa2V5KTtcbiAgfVxuICBnZXRDdXJyZW50UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRRdWVyeTtcbiAgfVxuICByZWZldGNoKHsgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaCh7XG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgZmV0Y2hPcHRpbWlzdGljKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0ZWRPcHRpb25zID0gdGhpcy4jY2xpZW50LmRlZmF1bHRRdWVyeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNjbGllbnQuZ2V0UXVlcnlDYWNoZSgpLmJ1aWxkKHRoaXMuI2NsaWVudCwgZGVmYXVsdGVkT3B0aW9ucyk7XG4gICAgcXVlcnkuaXNGZXRjaGluZ09wdGltaXN0aWMgPSB0cnVlO1xuICAgIHJldHVybiBxdWVyeS5mZXRjaCgpLnRoZW4oKCkgPT4gdGhpcy5jcmVhdGVSZXN1bHQocXVlcnksIGRlZmF1bHRlZE9wdGlvbnMpKTtcbiAgfVxuICBmZXRjaChmZXRjaE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy4jZXhlY3V0ZUZldGNoKHtcbiAgICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgICAgIGNhbmNlbFJlZmV0Y2g6IGZldGNoT3B0aW9ucy5jYW5jZWxSZWZldGNoID8/IHRydWVcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XG4gICAgICByZXR1cm4gdGhpcy4jY3VycmVudFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICAjZXhlY3V0ZUZldGNoKGZldGNoT3B0aW9ucykge1xuICAgIHRoaXMuI3VwZGF0ZVF1ZXJ5KCk7XG4gICAgbGV0IHByb21pc2UgPSB0aGlzLiNjdXJyZW50UXVlcnkuZmV0Y2goXG4gICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICBmZXRjaE9wdGlvbnNcbiAgICApO1xuICAgIGlmICghZmV0Y2hPcHRpb25zPy50aHJvd09uRXJyb3IpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLmNhdGNoKG5vb3ApO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAjdXBkYXRlU3RhbGVUaW1lb3V0KCkge1xuICAgIHRoaXMuI2NsZWFyU3RhbGVUaW1lb3V0KCk7XG4gICAgY29uc3Qgc3RhbGVUaW1lID0gcmVzb2x2ZVN0YWxlVGltZShcbiAgICAgIHRoaXMub3B0aW9ucy5zdGFsZVRpbWUsXG4gICAgICB0aGlzLiNjdXJyZW50UXVlcnlcbiAgICApO1xuICAgIGlmIChpc1NlcnZlciB8fCB0aGlzLiNjdXJyZW50UmVzdWx0LmlzU3RhbGUgfHwgIWlzVmFsaWRUaW1lb3V0KHN0YWxlVGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IHRpbWVVbnRpbFN0YWxlKHRoaXMuI2N1cnJlbnRSZXN1bHQuZGF0YVVwZGF0ZWRBdCwgc3RhbGVUaW1lKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gdGltZSArIDE7XG4gICAgdGhpcy4jc3RhbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy4jY3VycmVudFJlc3VsdC5pc1N0YWxlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUmVzdWx0KCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCk7XG4gIH1cbiAgI2NvbXB1dGVSZWZldGNoSW50ZXJ2YWwoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbCh0aGlzLiNjdXJyZW50UXVlcnkpIDogdGhpcy5vcHRpb25zLnJlZmV0Y2hJbnRlcnZhbCkgPz8gZmFsc2U7XG4gIH1cbiAgI3VwZGF0ZVJlZmV0Y2hJbnRlcnZhbChuZXh0SW50ZXJ2YWwpIHtcbiAgICB0aGlzLiNjbGVhclJlZmV0Y2hJbnRlcnZhbCgpO1xuICAgIHRoaXMuI2N1cnJlbnRSZWZldGNoSW50ZXJ2YWwgPSBuZXh0SW50ZXJ2YWw7XG4gICAgaWYgKGlzU2VydmVyIHx8IHJlc29sdmVFbmFibGVkKHRoaXMub3B0aW9ucy5lbmFibGVkLCB0aGlzLiNjdXJyZW50UXVlcnkpID09PSBmYWxzZSB8fCAhaXNWYWxpZFRpbWVvdXQodGhpcy4jY3VycmVudFJlZmV0Y2hJbnRlcnZhbCkgfHwgdGhpcy4jY3VycmVudFJlZmV0Y2hJbnRlcnZhbCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXRjaEludGVydmFsSW5CYWNrZ3JvdW5kIHx8IGZvY3VzTWFuYWdlci5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLiNleGVjdXRlRmV0Y2goKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLiNjdXJyZW50UmVmZXRjaEludGVydmFsKTtcbiAgfVxuICAjdXBkYXRlVGltZXJzKCkge1xuICAgIHRoaXMuI3VwZGF0ZVN0YWxlVGltZW91dCgpO1xuICAgIHRoaXMuI3VwZGF0ZVJlZmV0Y2hJbnRlcnZhbCh0aGlzLiNjb21wdXRlUmVmZXRjaEludGVydmFsKCkpO1xuICB9XG4gICNjbGVhclN0YWxlVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy4jc3RhbGVUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNzdGFsZVRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNzdGFsZVRpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgI2NsZWFyUmVmZXRjaEludGVydmFsKCkge1xuICAgIGlmICh0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLiNyZWZldGNoSW50ZXJ2YWxJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgY3JlYXRlUmVzdWx0KHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJldlF1ZXJ5ID0gdGhpcy4jY3VycmVudFF1ZXJ5O1xuICAgIGNvbnN0IHByZXZPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHByZXZSZXN1bHQgPSB0aGlzLiNjdXJyZW50UmVzdWx0O1xuICAgIGNvbnN0IHByZXZSZXN1bHRTdGF0ZSA9IHRoaXMuI2N1cnJlbnRSZXN1bHRTdGF0ZTtcbiAgICBjb25zdCBwcmV2UmVzdWx0T3B0aW9ucyA9IHRoaXMuI2N1cnJlbnRSZXN1bHRPcHRpb25zO1xuICAgIGNvbnN0IHF1ZXJ5Q2hhbmdlID0gcXVlcnkgIT09IHByZXZRdWVyeTtcbiAgICBjb25zdCBxdWVyeUluaXRpYWxTdGF0ZSA9IHF1ZXJ5Q2hhbmdlID8gcXVlcnkuc3RhdGUgOiB0aGlzLiNjdXJyZW50UXVlcnlJbml0aWFsU3RhdGU7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gcXVlcnk7XG4gICAgbGV0IG5ld1N0YXRlID0geyAuLi5zdGF0ZSB9O1xuICAgIGxldCBpc1BsYWNlaG9sZGVyRGF0YSA9IGZhbHNlO1xuICAgIGxldCBkYXRhO1xuICAgIGlmIChvcHRpb25zLl9vcHRpbWlzdGljUmVzdWx0cykge1xuICAgICAgY29uc3QgbW91bnRlZCA9IHRoaXMuaGFzTGlzdGVuZXJzKCk7XG4gICAgICBjb25zdCBmZXRjaE9uTW91bnQgPSAhbW91bnRlZCAmJiBzaG91bGRGZXRjaE9uTW91bnQocXVlcnksIG9wdGlvbnMpO1xuICAgICAgY29uc3QgZmV0Y2hPcHRpb25hbGx5ID0gbW91bnRlZCAmJiBzaG91bGRGZXRjaE9wdGlvbmFsbHkocXVlcnksIHByZXZRdWVyeSwgb3B0aW9ucywgcHJldk9wdGlvbnMpO1xuICAgICAgaWYgKGZldGNoT25Nb3VudCB8fCBmZXRjaE9wdGlvbmFsbHkpIHtcbiAgICAgICAgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgICAgLi4uZmV0Y2hTdGF0ZShzdGF0ZS5kYXRhLCBxdWVyeS5vcHRpb25zKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuX29wdGltaXN0aWNSZXN1bHRzID09PSBcImlzUmVzdG9yaW5nXCIpIHtcbiAgICAgICAgbmV3U3RhdGUuZmV0Y2hTdGF0dXMgPSBcImlkbGVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHsgZXJyb3IsIGVycm9yVXBkYXRlZEF0LCBzdGF0dXMgfSA9IG5ld1N0YXRlO1xuICAgIGlmIChvcHRpb25zLnNlbGVjdCAmJiBuZXdTdGF0ZS5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChwcmV2UmVzdWx0ICYmIG5ld1N0YXRlLmRhdGEgPT09IHByZXZSZXN1bHRTdGF0ZT8uZGF0YSAmJiBvcHRpb25zLnNlbGVjdCA9PT0gdGhpcy4jc2VsZWN0Rm4pIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuI3NlbGVjdFJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy4jc2VsZWN0Rm4gPSBvcHRpb25zLnNlbGVjdDtcbiAgICAgICAgICBkYXRhID0gb3B0aW9ucy5zZWxlY3QobmV3U3RhdGUuZGF0YSk7XG4gICAgICAgICAgZGF0YSA9IHJlcGxhY2VEYXRhKHByZXZSZXN1bHQ/LmRhdGEsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuI3NlbGVjdFJlc3VsdCA9IGRhdGE7XG4gICAgICAgICAgdGhpcy4jc2VsZWN0RXJyb3IgPSBudWxsO1xuICAgICAgICB9IGNhdGNoIChzZWxlY3RFcnJvcikge1xuICAgICAgICAgIHRoaXMuI3NlbGVjdEVycm9yID0gc2VsZWN0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IG5ld1N0YXRlLmRhdGE7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyRGF0YSAhPT0gdm9pZCAwICYmIGRhdGEgPT09IHZvaWQgMCAmJiBzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICBsZXQgcGxhY2Vob2xkZXJEYXRhO1xuICAgICAgaWYgKHByZXZSZXN1bHQ/LmlzUGxhY2Vob2xkZXJEYXRhICYmIG9wdGlvbnMucGxhY2Vob2xkZXJEYXRhID09PSBwcmV2UmVzdWx0T3B0aW9ucz8ucGxhY2Vob2xkZXJEYXRhKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyRGF0YSA9IHByZXZSZXN1bHQuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsYWNlaG9sZGVyRGF0YSA9IHR5cGVvZiBvcHRpb25zLnBsYWNlaG9sZGVyRGF0YSA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5wbGFjZWhvbGRlckRhdGEoXG4gICAgICAgICAgdGhpcy4jbGFzdFF1ZXJ5V2l0aERlZmluZWREYXRhPy5zdGF0ZS5kYXRhLFxuICAgICAgICAgIHRoaXMuI2xhc3RRdWVyeVdpdGhEZWZpbmVkRGF0YVxuICAgICAgICApIDogb3B0aW9ucy5wbGFjZWhvbGRlckRhdGE7XG4gICAgICAgIGlmIChvcHRpb25zLnNlbGVjdCAmJiBwbGFjZWhvbGRlckRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlckRhdGEgPSBvcHRpb25zLnNlbGVjdChwbGFjZWhvbGRlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy4jc2VsZWN0RXJyb3IgPSBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKHNlbGVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNzZWxlY3RFcnJvciA9IHNlbGVjdEVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYWNlaG9sZGVyRGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICBkYXRhID0gcmVwbGFjZURhdGEoXG4gICAgICAgICAgcHJldlJlc3VsdD8uZGF0YSxcbiAgICAgICAgICBwbGFjZWhvbGRlckRhdGEsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBpc1BsYWNlaG9sZGVyRGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLiNzZWxlY3RFcnJvcikge1xuICAgICAgZXJyb3IgPSB0aGlzLiNzZWxlY3RFcnJvcjtcbiAgICAgIGRhdGEgPSB0aGlzLiNzZWxlY3RSZXN1bHQ7XG4gICAgICBlcnJvclVwZGF0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICBzdGF0dXMgPSBcImVycm9yXCI7XG4gICAgfVxuICAgIGNvbnN0IGlzRmV0Y2hpbmcgPSBuZXdTdGF0ZS5mZXRjaFN0YXR1cyA9PT0gXCJmZXRjaGluZ1wiO1xuICAgIGNvbnN0IGlzUGVuZGluZyA9IHN0YXR1cyA9PT0gXCJwZW5kaW5nXCI7XG4gICAgY29uc3QgaXNFcnJvciA9IHN0YXR1cyA9PT0gXCJlcnJvclwiO1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IGlzUGVuZGluZyAmJiBpc0ZldGNoaW5nO1xuICAgIGNvbnN0IGhhc0RhdGEgPSBkYXRhICE9PSB2b2lkIDA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgc3RhdHVzLFxuICAgICAgZmV0Y2hTdGF0dXM6IG5ld1N0YXRlLmZldGNoU3RhdHVzLFxuICAgICAgaXNQZW5kaW5nLFxuICAgICAgaXNTdWNjZXNzOiBzdGF0dXMgPT09IFwic3VjY2Vzc1wiLFxuICAgICAgaXNFcnJvcixcbiAgICAgIGlzSW5pdGlhbExvYWRpbmc6IGlzTG9hZGluZyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGRhdGEsXG4gICAgICBkYXRhVXBkYXRlZEF0OiBuZXdTdGF0ZS5kYXRhVXBkYXRlZEF0LFxuICAgICAgZXJyb3IsXG4gICAgICBlcnJvclVwZGF0ZWRBdCxcbiAgICAgIGZhaWx1cmVDb3VudDogbmV3U3RhdGUuZmV0Y2hGYWlsdXJlQ291bnQsXG4gICAgICBmYWlsdXJlUmVhc29uOiBuZXdTdGF0ZS5mZXRjaEZhaWx1cmVSZWFzb24sXG4gICAgICBlcnJvclVwZGF0ZUNvdW50OiBuZXdTdGF0ZS5lcnJvclVwZGF0ZUNvdW50LFxuICAgICAgaXNGZXRjaGVkOiBuZXdTdGF0ZS5kYXRhVXBkYXRlQ291bnQgPiAwIHx8IG5ld1N0YXRlLmVycm9yVXBkYXRlQ291bnQgPiAwLFxuICAgICAgaXNGZXRjaGVkQWZ0ZXJNb3VudDogbmV3U3RhdGUuZGF0YVVwZGF0ZUNvdW50ID4gcXVlcnlJbml0aWFsU3RhdGUuZGF0YVVwZGF0ZUNvdW50IHx8IG5ld1N0YXRlLmVycm9yVXBkYXRlQ291bnQgPiBxdWVyeUluaXRpYWxTdGF0ZS5lcnJvclVwZGF0ZUNvdW50LFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGlzUmVmZXRjaGluZzogaXNGZXRjaGluZyAmJiAhaXNQZW5kaW5nLFxuICAgICAgaXNMb2FkaW5nRXJyb3I6IGlzRXJyb3IgJiYgIWhhc0RhdGEsXG4gICAgICBpc1BhdXNlZDogbmV3U3RhdGUuZmV0Y2hTdGF0dXMgPT09IFwicGF1c2VkXCIsXG4gICAgICBpc1BsYWNlaG9sZGVyRGF0YSxcbiAgICAgIGlzUmVmZXRjaEVycm9yOiBpc0Vycm9yICYmIGhhc0RhdGEsXG4gICAgICBpc1N0YWxlOiBpc1N0YWxlKHF1ZXJ5LCBvcHRpb25zKSxcbiAgICAgIHJlZmV0Y2g6IHRoaXMucmVmZXRjaFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB1cGRhdGVSZXN1bHQobm90aWZ5T3B0aW9ucykge1xuICAgIGNvbnN0IHByZXZSZXN1bHQgPSB0aGlzLiNjdXJyZW50UmVzdWx0O1xuICAgIGNvbnN0IG5leHRSZXN1bHQgPSB0aGlzLmNyZWF0ZVJlc3VsdCh0aGlzLiNjdXJyZW50UXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4jY3VycmVudFJlc3VsdFN0YXRlID0gdGhpcy4jY3VycmVudFF1ZXJ5LnN0YXRlO1xuICAgIHRoaXMuI2N1cnJlbnRSZXN1bHRPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLiNjdXJyZW50UmVzdWx0U3RhdGUuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLiNsYXN0UXVlcnlXaXRoRGVmaW5lZERhdGEgPSB0aGlzLiNjdXJyZW50UXVlcnk7XG4gICAgfVxuICAgIGlmIChzaGFsbG93RXF1YWxPYmplY3RzKG5leHRSZXN1bHQsIHByZXZSZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRSZXN1bHQgPSBuZXh0UmVzdWx0O1xuICAgIGNvbnN0IGRlZmF1bHROb3RpZnlPcHRpb25zID0ge307XG4gICAgY29uc3Qgc2hvdWxkTm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgaWYgKCFwcmV2UmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBub3RpZnlPbkNoYW5nZVByb3BzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICBjb25zdCBub3RpZnlPbkNoYW5nZVByb3BzVmFsdWUgPSB0eXBlb2Ygbm90aWZ5T25DaGFuZ2VQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gbm90aWZ5T25DaGFuZ2VQcm9wcygpIDogbm90aWZ5T25DaGFuZ2VQcm9wcztcbiAgICAgIGlmIChub3RpZnlPbkNoYW5nZVByb3BzVmFsdWUgPT09IFwiYWxsXCIgfHwgIW5vdGlmeU9uQ2hhbmdlUHJvcHNWYWx1ZSAmJiAhdGhpcy4jdHJhY2tlZFByb3BzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNsdWRlZFByb3BzID0gbmV3IFNldChcbiAgICAgICAgbm90aWZ5T25DaGFuZ2VQcm9wc1ZhbHVlID8/IHRoaXMuI3RyYWNrZWRQcm9wc1xuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgICAgIGluY2x1ZGVkUHJvcHMuYWRkKFwiZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy4jY3VycmVudFJlc3VsdCkuc29tZSgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5O1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy4jY3VycmVudFJlc3VsdFt0eXBlZEtleV0gIT09IHByZXZSZXN1bHRbdHlwZWRLZXldO1xuICAgICAgICByZXR1cm4gY2hhbmdlZCAmJiBpbmNsdWRlZFByb3BzLmhhcyh0eXBlZEtleSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmIChub3RpZnlPcHRpb25zPy5saXN0ZW5lcnMgIT09IGZhbHNlICYmIHNob3VsZE5vdGlmeUxpc3RlbmVycygpKSB7XG4gICAgICBkZWZhdWx0Tm90aWZ5T3B0aW9ucy5saXN0ZW5lcnMgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLiNub3RpZnkoeyAuLi5kZWZhdWx0Tm90aWZ5T3B0aW9ucywgLi4ubm90aWZ5T3B0aW9ucyB9KTtcbiAgfVxuICAjdXBkYXRlUXVlcnkoKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLiNjbGllbnQuZ2V0UXVlcnlDYWNoZSgpLmJ1aWxkKHRoaXMuI2NsaWVudCwgdGhpcy5vcHRpb25zKTtcbiAgICBpZiAocXVlcnkgPT09IHRoaXMuI2N1cnJlbnRRdWVyeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2UXVlcnkgPSB0aGlzLiNjdXJyZW50UXVlcnk7XG4gICAgdGhpcy4jY3VycmVudFF1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy4jY3VycmVudFF1ZXJ5SW5pdGlhbFN0YXRlID0gcXVlcnkuc3RhdGU7XG4gICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCkpIHtcbiAgICAgIHByZXZRdWVyeT8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XG4gICAgICBxdWVyeS5hZGRPYnNlcnZlcih0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25RdWVyeVVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZVJlc3VsdCgpO1xuICAgIGlmICh0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICB0aGlzLiN1cGRhdGVUaW1lcnMoKTtcbiAgICB9XG4gIH1cbiAgI25vdGlmeShub3RpZnlPcHRpb25zKSB7XG4gICAgbm90aWZ5TWFuYWdlci5iYXRjaCgoKSA9PiB7XG4gICAgICBpZiAobm90aWZ5T3B0aW9ucy5saXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lcih0aGlzLiNjdXJyZW50UmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLiNjbGllbnQuZ2V0UXVlcnlDYWNoZSgpLm5vdGlmeSh7XG4gICAgICAgIHF1ZXJ5OiB0aGlzLiNjdXJyZW50UXVlcnksXG4gICAgICAgIHR5cGU6IFwib2JzZXJ2ZXJSZXN1bHRzVXBkYXRlZFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZExvYWRPbk1vdW50KHF1ZXJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiByZXNvbHZlRW5hYmxlZChvcHRpb25zLmVuYWJsZWQsIHF1ZXJ5KSAhPT0gZmFsc2UgJiYgcXVlcnkuc3RhdGUuZGF0YSA9PT0gdm9pZCAwICYmICEocXVlcnkuc3RhdGUuc3RhdHVzID09PSBcImVycm9yXCIgJiYgb3B0aW9ucy5yZXRyeU9uTW91bnQgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNob3VsZEZldGNoT25Nb3VudChxdWVyeSwgb3B0aW9ucykge1xuICByZXR1cm4gc2hvdWxkTG9hZE9uTW91bnQocXVlcnksIG9wdGlvbnMpIHx8IHF1ZXJ5LnN0YXRlLmRhdGEgIT09IHZvaWQgMCAmJiBzaG91bGRGZXRjaE9uKHF1ZXJ5LCBvcHRpb25zLCBvcHRpb25zLnJlZmV0Y2hPbk1vdW50KTtcbn1cbmZ1bmN0aW9uIHNob3VsZEZldGNoT24ocXVlcnksIG9wdGlvbnMsIGZpZWxkKSB7XG4gIGlmIChyZXNvbHZlRW5hYmxlZChvcHRpb25zLmVuYWJsZWQsIHF1ZXJ5KSAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBmaWVsZCA9PT0gXCJmdW5jdGlvblwiID8gZmllbGQocXVlcnkpIDogZmllbGQ7XG4gICAgcmV0dXJuIHZhbHVlID09PSBcImFsd2F5c1wiIHx8IHZhbHVlICE9PSBmYWxzZSAmJiBpc1N0YWxlKHF1ZXJ5LCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRGZXRjaE9wdGlvbmFsbHkocXVlcnksIHByZXZRdWVyeSwgb3B0aW9ucywgcHJldk9wdGlvbnMpIHtcbiAgcmV0dXJuIChxdWVyeSAhPT0gcHJldlF1ZXJ5IHx8IHJlc29sdmVFbmFibGVkKHByZXZPcHRpb25zLmVuYWJsZWQsIHF1ZXJ5KSA9PT0gZmFsc2UpICYmICghb3B0aW9ucy5zdXNwZW5zZSB8fCBxdWVyeS5zdGF0ZS5zdGF0dXMgIT09IFwiZXJyb3JcIikgJiYgaXNTdGFsZShxdWVyeSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpc1N0YWxlKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiByZXNvbHZlRW5hYmxlZChvcHRpb25zLmVuYWJsZWQsIHF1ZXJ5KSAhPT0gZmFsc2UgJiYgcXVlcnkuaXNTdGFsZUJ5VGltZShyZXNvbHZlU3RhbGVUaW1lKG9wdGlvbnMuc3RhbGVUaW1lLCBxdWVyeSkpO1xufVxuZnVuY3Rpb24gc2hvdWxkQXNzaWduT2JzZXJ2ZXJDdXJyZW50UHJvcGVydGllcyhvYnNlcnZlciwgb3B0aW1pc3RpY1Jlc3VsdCkge1xuICBpZiAoIXNoYWxsb3dFcXVhbE9iamVjdHMob2JzZXJ2ZXIuZ2V0Q3VycmVudFJlc3VsdCgpLCBvcHRpbWlzdGljUmVzdWx0KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCB7XG4gIFF1ZXJ5T2JzZXJ2ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeU9ic2VydmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryObserver.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/removable.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Removable: function() { return /* binding */ Removable; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/removable.ts\n\nvar Removable = class {\n  #gcTimeout;\n  destroy() {\n    this.clearGcTimeout();\n  }\n  scheduleGc() {\n    this.clearGcTimeout();\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isValidTimeout)(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.gcTime);\n    }\n  }\n  updateGcTime(newGcTime) {\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isServer ? Infinity : 5 * 60 * 1e3)\n    );\n  }\n  clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout);\n      this.#gcTimeout = void 0;\n    }\n  }\n};\n\n//# sourceMappingURL=removable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmVtb3ZhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmVtb3ZhYmxlLmpzPzg5NGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3JlbW92YWJsZS50c1xuaW1wb3J0IHsgaXNTZXJ2ZXIsIGlzVmFsaWRUaW1lb3V0IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbnZhciBSZW1vdmFibGUgPSBjbGFzcyB7XG4gICNnY1RpbWVvdXQ7XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICB9XG4gIHNjaGVkdWxlR2MoKSB7XG4gICAgdGhpcy5jbGVhckdjVGltZW91dCgpO1xuICAgIGlmIChpc1ZhbGlkVGltZW91dCh0aGlzLmdjVGltZSkpIHtcbiAgICAgIHRoaXMuI2djVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLm9wdGlvbmFsUmVtb3ZlKCk7XG4gICAgICB9LCB0aGlzLmdjVGltZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUdjVGltZShuZXdHY1RpbWUpIHtcbiAgICB0aGlzLmdjVGltZSA9IE1hdGgubWF4KFxuICAgICAgdGhpcy5nY1RpbWUgfHwgMCxcbiAgICAgIG5ld0djVGltZSA/PyAoaXNTZXJ2ZXIgPyBJbmZpbml0eSA6IDUgKiA2MCAqIDFlMylcbiAgICApO1xuICB9XG4gIGNsZWFyR2NUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLiNnY1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNnY1RpbWVvdXQpO1xuICAgICAgdGhpcy4jZ2NUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCB7XG4gIFJlbW92YWJsZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92YWJsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/removable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/retryer.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancelledError: function() { return /* binding */ CancelledError; },\n/* harmony export */   canFetch: function() { return /* binding */ canFetch; },\n/* harmony export */   createRetryer: function() { return /* binding */ createRetryer; },\n/* harmony export */   isCancelledError: function() { return /* binding */ isCancelledError; }\n/* harmony export */ });\n/* harmony import */ var _focusManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./focusManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/focusManager.js\");\n/* harmony import */ var _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./onlineManager.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/onlineManager.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\");\n// src/retryer.ts\n\n\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n  const cancel = (cancelOptions) => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => _focusManager_js__WEBPACK_IMPORTED_MODULE_1__.focusManager.isFocused() && (config.networkMode === \"always\" || _onlineManager_js__WEBPACK_IMPORTED_MODULE_0__.onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      promiseResolve(value);\n    }\n  };\n  const reject = (value) => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      promiseReject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {\n      if (isResolved) {\n        return;\n      }\n      const retry = config.retry ?? (_utils_js__WEBPACK_IMPORTED_MODULE_2__.isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.sleep)(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return promise;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return promise;\n    }\n  };\n}\n\n//# sourceMappingURL=retryer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vcmV0cnllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDaUQ7QUFDRTtBQUNOO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDREQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQVksb0RBQW9ELDREQUFhO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnREFBSztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9yZXRyeWVyLmpzP2VlZTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3JldHJ5ZXIudHNcbmltcG9ydCB7IGZvY3VzTWFuYWdlciB9IGZyb20gXCIuL2ZvY3VzTWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgb25saW5lTWFuYWdlciB9IGZyb20gXCIuL29ubGluZU1hbmFnZXIuanNcIjtcbmltcG9ydCB7IGlzU2VydmVyLCBzbGVlcCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiBkZWZhdWx0UmV0cnlEZWxheShmYWlsdXJlQ291bnQpIHtcbiAgcmV0dXJuIE1hdGgubWluKDFlMyAqIDIgKiogZmFpbHVyZUNvdW50LCAzZTQpO1xufVxuZnVuY3Rpb24gY2FuRmV0Y2gobmV0d29ya01vZGUpIHtcbiAgcmV0dXJuIChuZXR3b3JrTW9kZSA/PyBcIm9ubGluZVwiKSA9PT0gXCJvbmxpbmVcIiA/IG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSA6IHRydWU7XG59XG52YXIgQ2FuY2VsbGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwiQ2FuY2VsbGVkRXJyb3JcIik7XG4gICAgdGhpcy5yZXZlcnQgPSBvcHRpb25zPy5yZXZlcnQ7XG4gICAgdGhpcy5zaWxlbnQgPSBvcHRpb25zPy5zaWxlbnQ7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0NhbmNlbGxlZEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENhbmNlbGxlZEVycm9yO1xufVxuZnVuY3Rpb24gY3JlYXRlUmV0cnllcihjb25maWcpIHtcbiAgbGV0IGlzUmV0cnlDYW5jZWxsZWQgPSBmYWxzZTtcbiAgbGV0IGZhaWx1cmVDb3VudCA9IDA7XG4gIGxldCBpc1Jlc29sdmVkID0gZmFsc2U7XG4gIGxldCBjb250aW51ZUZuO1xuICBsZXQgcHJvbWlzZVJlc29sdmU7XG4gIGxldCBwcm9taXNlUmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKG91dGVyUmVzb2x2ZSwgb3V0ZXJSZWplY3QpID0+IHtcbiAgICBwcm9taXNlUmVzb2x2ZSA9IG91dGVyUmVzb2x2ZTtcbiAgICBwcm9taXNlUmVqZWN0ID0gb3V0ZXJSZWplY3Q7XG4gIH0pO1xuICBjb25zdCBjYW5jZWwgPSAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgcmVqZWN0KG5ldyBDYW5jZWxsZWRFcnJvcihjYW5jZWxPcHRpb25zKSk7XG4gICAgICBjb25maWcuYWJvcnQ/LigpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2FuY2VsUmV0cnkgPSAoKSA9PiB7XG4gICAgaXNSZXRyeUNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG4gIGNvbnN0IGNvbnRpbnVlUmV0cnkgPSAoKSA9PiB7XG4gICAgaXNSZXRyeUNhbmNlbGxlZCA9IGZhbHNlO1xuICB9O1xuICBjb25zdCBjYW5Db250aW51ZSA9ICgpID0+IGZvY3VzTWFuYWdlci5pc0ZvY3VzZWQoKSAmJiAoY29uZmlnLm5ldHdvcmtNb2RlID09PSBcImFsd2F5c1wiIHx8IG9ubGluZU1hbmFnZXIuaXNPbmxpbmUoKSkgJiYgY29uZmlnLmNhblJ1bigpO1xuICBjb25zdCBjYW5TdGFydCA9ICgpID0+IGNhbkZldGNoKGNvbmZpZy5uZXR3b3JrTW9kZSkgJiYgY29uZmlnLmNhblJ1bigpO1xuICBjb25zdCByZXNvbHZlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGNvbmZpZy5vblN1Y2Nlc3M/Lih2YWx1ZSk7XG4gICAgICBjb250aW51ZUZuPy4oKTtcbiAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICBjb25maWcub25FcnJvcj8uKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlRm4/LigpO1xuICAgICAgcHJvbWlzZVJlamVjdCh2YWx1ZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBwYXVzZSA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGNvbnRpbnVlUmVzb2x2ZSkgPT4ge1xuICAgICAgY29udGludWVGbiA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNSZXNvbHZlZCB8fCBjYW5Db250aW51ZSgpKSB7XG4gICAgICAgICAgY29udGludWVSZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbmZpZy5vblBhdXNlPy4oKTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnRpbnVlRm4gPSB2b2lkIDA7XG4gICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgY29uZmlnLm9uQ29udGludWU/LigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByb21pc2VPclZhbHVlO1xuICAgIGNvbnN0IGluaXRpYWxQcm9taXNlID0gZmFpbHVyZUNvdW50ID09PSAwID8gY29uZmlnLmluaXRpYWxQcm9taXNlIDogdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlT3JWYWx1ZSA9IGluaXRpYWxQcm9taXNlID8/IGNvbmZpZy5mbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwcm9taXNlT3JWYWx1ZSA9IFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgUHJvbWlzZS5yZXNvbHZlKHByb21pc2VPclZhbHVlKS50aGVuKHJlc29sdmUpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0cnkgPSBjb25maWcucmV0cnkgPz8gKGlzU2VydmVyID8gMCA6IDMpO1xuICAgICAgY29uc3QgcmV0cnlEZWxheSA9IGNvbmZpZy5yZXRyeURlbGF5ID8/IGRlZmF1bHRSZXRyeURlbGF5O1xuICAgICAgY29uc3QgZGVsYXkgPSB0eXBlb2YgcmV0cnlEZWxheSA9PT0gXCJmdW5jdGlvblwiID8gcmV0cnlEZWxheShmYWlsdXJlQ291bnQsIGVycm9yKSA6IHJldHJ5RGVsYXk7XG4gICAgICBjb25zdCBzaG91bGRSZXRyeSA9IHJldHJ5ID09PSB0cnVlIHx8IHR5cGVvZiByZXRyeSA9PT0gXCJudW1iZXJcIiAmJiBmYWlsdXJlQ291bnQgPCByZXRyeSB8fCB0eXBlb2YgcmV0cnkgPT09IFwiZnVuY3Rpb25cIiAmJiByZXRyeShmYWlsdXJlQ291bnQsIGVycm9yKTtcbiAgICAgIGlmIChpc1JldHJ5Q2FuY2VsbGVkIHx8ICFzaG91bGRSZXRyeSkge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmYWlsdXJlQ291bnQrKztcbiAgICAgIGNvbmZpZy5vbkZhaWw/LihmYWlsdXJlQ291bnQsIGVycm9yKTtcbiAgICAgIHNsZWVwKGRlbGF5KS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbkNvbnRpbnVlKCkgPyB2b2lkIDAgOiBwYXVzZSgpO1xuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChpc1JldHJ5Q2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICBjYW5jZWwsXG4gICAgY29udGludWU6ICgpID0+IHtcbiAgICAgIGNvbnRpbnVlRm4/LigpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICBjYW5jZWxSZXRyeSxcbiAgICBjb250aW51ZVJldHJ5LFxuICAgIGNhblN0YXJ0LFxuICAgIHN0YXJ0OiAoKSA9PiB7XG4gICAgICBpZiAoY2FuU3RhcnQoKSkge1xuICAgICAgICBydW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdXNlKCkudGhlbihydW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9O1xufVxuZXhwb3J0IHtcbiAgQ2FuY2VsbGVkRXJyb3IsXG4gIGNhbkZldGNoLFxuICBjcmVhdGVSZXRyeWVyLFxuICBpc0NhbmNlbGxlZEVycm9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnllci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/retryer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/subscribable.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subscribable: function() { return /* binding */ Subscribable; }\n/* harmony export */ });\n// src/subscribable.ts\nvar Subscribable = class {\n  constructor() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n  subscribe(listener) {\n    this.listeners.add(listener);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(listener);\n      this.onUnsubscribe();\n    };\n  }\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n  onSubscribe() {\n  }\n  onUnsubscribe() {\n  }\n};\n\n//# sourceMappingURL=subscribable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vc3Vic2NyaWJhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9xdWVyeS1jb3JlL2J1aWxkL21vZGVybi9zdWJzY3JpYmFibGUuanM/MmEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvc3Vic2NyaWJhYmxlLnRzXG52YXIgU3Vic2NyaWJhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB0aGlzLnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICB9XG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgdGhpcy5vblN1YnNjcmliZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgdGhpcy5vblVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfVxuICBoYXNMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLnNpemUgPiAwO1xuICB9XG4gIG9uU3Vic2NyaWJlKCkge1xuICB9XG4gIG9uVW5zdWJzY3JpYmUoKSB7XG4gIH1cbn07XG5leHBvcnQge1xuICBTdWJzY3JpYmFibGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmFibGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/subscribable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tanstack/query-core/build/modern/utils.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addToEnd: function() { return /* binding */ addToEnd; },\n/* harmony export */   addToStart: function() { return /* binding */ addToStart; },\n/* harmony export */   ensureQueryFn: function() { return /* binding */ ensureQueryFn; },\n/* harmony export */   functionalUpdate: function() { return /* binding */ functionalUpdate; },\n/* harmony export */   hashKey: function() { return /* binding */ hashKey; },\n/* harmony export */   hashQueryKeyByOptions: function() { return /* binding */ hashQueryKeyByOptions; },\n/* harmony export */   isPlainArray: function() { return /* binding */ isPlainArray; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isServer: function() { return /* binding */ isServer; },\n/* harmony export */   isValidTimeout: function() { return /* binding */ isValidTimeout; },\n/* harmony export */   keepPreviousData: function() { return /* binding */ keepPreviousData; },\n/* harmony export */   matchMutation: function() { return /* binding */ matchMutation; },\n/* harmony export */   matchQuery: function() { return /* binding */ matchQuery; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   partialMatchKey: function() { return /* binding */ partialMatchKey; },\n/* harmony export */   replaceData: function() { return /* binding */ replaceData; },\n/* harmony export */   replaceEqualDeep: function() { return /* binding */ replaceEqualDeep; },\n/* harmony export */   resolveEnabled: function() { return /* binding */ resolveEnabled; },\n/* harmony export */   resolveStaleTime: function() { return /* binding */ resolveStaleTime; },\n/* harmony export */   shallowEqualObjects: function() { return /* binding */ shallowEqualObjects; },\n/* harmony export */   skipToken: function() { return /* binding */ skipToken; },\n/* harmony export */   sleep: function() { return /* binding */ sleep; },\n/* harmony export */   timeUntilStale: function() { return /* binding */ timeUntilStale; }\n/* harmony export */ });\n// src/utils.ts\nvar isServer = typeof window === \"undefined\" || \"Deno\" in globalThis;\nfunction noop() {\n  return void 0;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === \"number\" && value >= 0 && value !== Infinity;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction resolveStaleTime(staleTime, query) {\n  return typeof staleTime === \"function\" ? staleTime(query) : staleTime;\n}\nfunction resolveEnabled(enabled, query) {\n  return typeof enabled === \"function\" ? enabled(query) : enabled;\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = \"all\",\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n  if (type !== \"all\") {\n    const isActive = query.isActive();\n    if (type === \"active\" && !isActive) {\n      return false;\n    }\n    if (type === \"inactive\" && isActive) {\n      return false;\n    }\n  }\n  if (typeof stale === \"boolean\" && query.isStale() !== stale) {\n    return false;\n  }\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const { exact, status, predicate, mutationKey } = filters;\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n  if (status && mutation.state.status !== status) {\n    return false;\n  }\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = options?.queryKeyHashFn || hashKey;\n  return hashFn(queryKey);\n}\nfunction hashKey(queryKey) {\n  return JSON.stringify(\n    queryKey,\n    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n      result[key] = val[key];\n      return result;\n    }, {}) : val\n  );\n}\nfunction partialMatchKey(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));\n  }\n  return false;\n}\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n  const array = isPlainArray(a) && isPlainArray(b);\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aItems = array ? a : Object.keys(a);\n    const aSize = aItems.length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {\n        copy[key] = void 0;\n        equalItems++;\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key]);\n        if (copy[key] === a[key] && a[key] !== void 0) {\n          equalItems++;\n        }\n      }\n    }\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n  return b;\n}\nfunction shallowEqualObjects(a, b) {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (ctor === void 0) {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction sleep(timeout) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout);\n  });\n}\nfunction replaceData(prevData, data, options) {\n  if (typeof options.structuralSharing === \"function\") {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    if (true) {\n      try {\n        return replaceEqualDeep(prevData, data);\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`\n        );\n      }\n    }\n    return replaceEqualDeep(prevData, data);\n  }\n  return data;\n}\nfunction keepPreviousData(previousData) {\n  return previousData;\n}\nfunction addToEnd(items, item, max = 0) {\n  const newItems = [...items, item];\n  return max && newItems.length > max ? newItems.slice(1) : newItems;\n}\nfunction addToStart(items, item, max = 0) {\n  const newItems = [item, ...items];\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;\n}\nvar skipToken = Symbol();\nfunction ensureQueryFn(options, fetchOptions) {\n  if (true) {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`\n      );\n    }\n  }\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise;\n  }\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));\n  }\n  return options.queryFn;\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0tBQW9LLGtCQUFrQixLQUFLLE1BQU07QUFDak07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBLGlIQUFpSCxrQkFBa0I7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQXlCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcXVlcnktY29yZS9idWlsZC9tb2Rlcm4vdXRpbHMuanM/MWE1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMudHNcbnZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgXCJEZW5vXCIgaW4gZ2xvYmFsVGhpcztcbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiID8gdXBkYXRlcihpbnB1dCkgOiB1cGRhdGVyO1xufVxuZnVuY3Rpb24gaXNWYWxpZFRpbWVvdXQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+PSAwICYmIHZhbHVlICE9PSBJbmZpbml0eTtcbn1cbmZ1bmN0aW9uIHRpbWVVbnRpbFN0YWxlKHVwZGF0ZWRBdCwgc3RhbGVUaW1lKSB7XG4gIHJldHVybiBNYXRoLm1heCh1cGRhdGVkQXQgKyAoc3RhbGVUaW1lIHx8IDApIC0gRGF0ZS5ub3coKSwgMCk7XG59XG5mdW5jdGlvbiByZXNvbHZlU3RhbGVUaW1lKHN0YWxlVGltZSwgcXVlcnkpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdGFsZVRpbWUgPT09IFwiZnVuY3Rpb25cIiA/IHN0YWxlVGltZShxdWVyeSkgOiBzdGFsZVRpbWU7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZChlbmFibGVkLCBxdWVyeSkge1xuICByZXR1cm4gdHlwZW9mIGVuYWJsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGVuYWJsZWQocXVlcnkpIDogZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIG1hdGNoUXVlcnkoZmlsdGVycywgcXVlcnkpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUgPSBcImFsbFwiLFxuICAgIGV4YWN0LFxuICAgIGZldGNoU3RhdHVzLFxuICAgIHByZWRpY2F0ZSxcbiAgICBxdWVyeUtleSxcbiAgICBzdGFsZVxuICB9ID0gZmlsdGVycztcbiAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgaWYgKGV4YWN0KSB7XG4gICAgICBpZiAocXVlcnkucXVlcnlIYXNoICE9PSBoYXNoUXVlcnlLZXlCeU9wdGlvbnMocXVlcnlLZXksIHF1ZXJ5Lm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFwYXJ0aWFsTWF0Y2hLZXkocXVlcnkucXVlcnlLZXksIHF1ZXJ5S2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZSAhPT0gXCJhbGxcIikge1xuICAgIGNvbnN0IGlzQWN0aXZlID0gcXVlcnkuaXNBY3RpdmUoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJhY3RpdmVcIiAmJiAhaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiaW5hY3RpdmVcIiAmJiBpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHN0YWxlID09PSBcImJvb2xlYW5cIiAmJiBxdWVyeS5pc1N0YWxlKCkgIT09IHN0YWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmZXRjaFN0YXR1cyAmJiBmZXRjaFN0YXR1cyAhPT0gcXVlcnkuc3RhdGUuZmV0Y2hTdGF0dXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKHF1ZXJ5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoTXV0YXRpb24oZmlsdGVycywgbXV0YXRpb24pIHtcbiAgY29uc3QgeyBleGFjdCwgc3RhdHVzLCBwcmVkaWNhdGUsIG11dGF0aW9uS2V5IH0gPSBmaWx0ZXJzO1xuICBpZiAobXV0YXRpb25LZXkpIHtcbiAgICBpZiAoIW11dGF0aW9uLm9wdGlvbnMubXV0YXRpb25LZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGV4YWN0KSB7XG4gICAgICBpZiAoaGFzaEtleShtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5KSAhPT0gaGFzaEtleShtdXRhdGlvbktleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXBhcnRpYWxNYXRjaEtleShtdXRhdGlvbi5vcHRpb25zLm11dGF0aW9uS2V5LCBtdXRhdGlvbktleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXR1cyAmJiBtdXRhdGlvbi5zdGF0ZS5zdGF0dXMgIT09IHN0YXR1cykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJlZGljYXRlICYmICFwcmVkaWNhdGUobXV0YXRpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFzaFF1ZXJ5S2V5QnlPcHRpb25zKHF1ZXJ5S2V5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGhhc2hGbiA9IG9wdGlvbnM/LnF1ZXJ5S2V5SGFzaEZuIHx8IGhhc2hLZXk7XG4gIHJldHVybiBoYXNoRm4ocXVlcnlLZXkpO1xufVxuZnVuY3Rpb24gaGFzaEtleShxdWVyeUtleSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgcXVlcnlLZXksXG4gICAgKF8sIHZhbCkgPT4gaXNQbGFpbk9iamVjdCh2YWwpID8gT2JqZWN0LmtleXModmFsKS5zb3J0KCkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWxba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pIDogdmFsXG4gICk7XG59XG5mdW5jdGlvbiBwYXJ0aWFsTWF0Y2hLZXkoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiAhT2JqZWN0LmtleXMoYikuc29tZSgoa2V5KSA9PiAhcGFydGlhbE1hdGNoS2V5KGFba2V5XSwgYltrZXldKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVwbGFjZUVxdWFsRGVlcChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgY29uc3QgYXJyYXkgPSBpc1BsYWluQXJyYXkoYSkgJiYgaXNQbGFpbkFycmF5KGIpO1xuICBpZiAoYXJyYXkgfHwgaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgY29uc3QgYUl0ZW1zID0gYXJyYXkgPyBhIDogT2JqZWN0LmtleXMoYSk7XG4gICAgY29uc3QgYVNpemUgPSBhSXRlbXMubGVuZ3RoO1xuICAgIGNvbnN0IGJJdGVtcyA9IGFycmF5ID8gYiA6IE9iamVjdC5rZXlzKGIpO1xuICAgIGNvbnN0IGJTaXplID0gYkl0ZW1zLmxlbmd0aDtcbiAgICBjb25zdCBjb3B5ID0gYXJyYXkgPyBbXSA6IHt9O1xuICAgIGxldCBlcXVhbEl0ZW1zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJTaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGFycmF5ID8gaSA6IGJJdGVtc1tpXTtcbiAgICAgIGlmICgoIWFycmF5ICYmIGFJdGVtcy5pbmNsdWRlcyhrZXkpIHx8IGFycmF5KSAmJiBhW2tleV0gPT09IHZvaWQgMCAmJiBiW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICBjb3B5W2tleV0gPSB2b2lkIDA7XG4gICAgICAgIGVxdWFsSXRlbXMrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlba2V5XSA9IHJlcGxhY2VFcXVhbERlZXAoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICBpZiAoY29weVtrZXldID09PSBhW2tleV0gJiYgYVtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBlcXVhbEl0ZW1zKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFTaXplID09PSBiU2l6ZSAmJiBlcXVhbEl0ZW1zID09PSBhU2l6ZSA/IGEgOiBjb3B5O1xuICB9XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsT2JqZWN0cyhhLCBiKSB7XG4gIGlmICghYiB8fCBPYmplY3Qua2V5cyhhKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgaWYgKGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNQbGFpbkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgaWYgKCFoYXNPYmplY3RQcm90b3R5cGUobykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmICghaGFzT2JqZWN0UHJvdG90eXBlKHByb3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghcHJvdC5oYXNPd25Qcm9wZXJ0eShcImlzUHJvdG90eXBlT2ZcIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvKSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc09iamVjdFByb3RvdHlwZShvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBzbGVlcCh0aW1lb3V0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZURhdGEocHJldkRhdGEsIGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnN0cnVjdHVyYWxTaGFyaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5zdHJ1Y3R1cmFsU2hhcmluZyhwcmV2RGF0YSwgZGF0YSk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5zdHJ1Y3R1cmFsU2hhcmluZyAhPT0gZmFsc2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZUVxdWFsRGVlcChwcmV2RGF0YSwgZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBTdHJ1Y3R1cmFsIHNoYXJpbmcgcmVxdWlyZXMgZGF0YSB0byBiZSBKU09OIHNlcmlhbGl6YWJsZS4gVG8gZml4IHRoaXMsIHR1cm4gb2ZmIHN0cnVjdHVyYWxTaGFyaW5nIG9yIHJldHVybiBKU09OLXNlcmlhbGl6YWJsZSBkYXRhIGZyb20geW91ciBxdWVyeUZuLiBbJHtvcHRpb25zLnF1ZXJ5SGFzaH1dOiAke2Vycm9yfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VFcXVhbERlZXAocHJldkRhdGEsIGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24ga2VlcFByZXZpb3VzRGF0YShwcmV2aW91c0RhdGEpIHtcbiAgcmV0dXJuIHByZXZpb3VzRGF0YTtcbn1cbmZ1bmN0aW9uIGFkZFRvRW5kKGl0ZW1zLCBpdGVtLCBtYXggPSAwKSB7XG4gIGNvbnN0IG5ld0l0ZW1zID0gWy4uLml0ZW1zLCBpdGVtXTtcbiAgcmV0dXJuIG1heCAmJiBuZXdJdGVtcy5sZW5ndGggPiBtYXggPyBuZXdJdGVtcy5zbGljZSgxKSA6IG5ld0l0ZW1zO1xufVxuZnVuY3Rpb24gYWRkVG9TdGFydChpdGVtcywgaXRlbSwgbWF4ID0gMCkge1xuICBjb25zdCBuZXdJdGVtcyA9IFtpdGVtLCAuLi5pdGVtc107XG4gIHJldHVybiBtYXggJiYgbmV3SXRlbXMubGVuZ3RoID4gbWF4ID8gbmV3SXRlbXMuc2xpY2UoMCwgLTEpIDogbmV3SXRlbXM7XG59XG52YXIgc2tpcFRva2VuID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBlbnN1cmVRdWVyeUZuKG9wdGlvbnMsIGZldGNoT3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKG9wdGlvbnMucXVlcnlGbiA9PT0gc2tpcFRva2VuKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIGludm9rZSBxdWVyeUZuIHdoZW4gc2V0IHRvIHNraXBUb2tlbi4gVGhpcyBpcyBsaWtlbHkgYSBjb25maWd1cmF0aW9uIGVycm9yLiBRdWVyeSBoYXNoOiAnJHtvcHRpb25zLnF1ZXJ5SGFzaH0nYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvcHRpb25zLnF1ZXJ5Rm4gJiYgZmV0Y2hPcHRpb25zPy5pbml0aWFsUHJvbWlzZSkge1xuICAgIHJldHVybiAoKSA9PiBmZXRjaE9wdGlvbnMuaW5pdGlhbFByb21pc2U7XG4gIH1cbiAgaWYgKCFvcHRpb25zLnF1ZXJ5Rm4gfHwgb3B0aW9ucy5xdWVyeUZuID09PSBza2lwVG9rZW4pIHtcbiAgICByZXR1cm4gKCkgPT4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBNaXNzaW5nIHF1ZXJ5Rm46ICcke29wdGlvbnMucXVlcnlIYXNofSdgKSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMucXVlcnlGbjtcbn1cbmV4cG9ydCB7XG4gIGFkZFRvRW5kLFxuICBhZGRUb1N0YXJ0LFxuICBlbnN1cmVRdWVyeUZuLFxuICBmdW5jdGlvbmFsVXBkYXRlLFxuICBoYXNoS2V5LFxuICBoYXNoUXVlcnlLZXlCeU9wdGlvbnMsXG4gIGlzUGxhaW5BcnJheSxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNTZXJ2ZXIsXG4gIGlzVmFsaWRUaW1lb3V0LFxuICBrZWVwUHJldmlvdXNEYXRhLFxuICBtYXRjaE11dGF0aW9uLFxuICBtYXRjaFF1ZXJ5LFxuICBub29wLFxuICBwYXJ0aWFsTWF0Y2hLZXksXG4gIHJlcGxhY2VEYXRhLFxuICByZXBsYWNlRXF1YWxEZWVwLFxuICByZXNvbHZlRW5hYmxlZCxcbiAgcmVzb2x2ZVN0YWxlVGltZSxcbiAgc2hhbGxvd0VxdWFsT2JqZWN0cyxcbiAgc2tpcFRva2VuLFxuICBzbGVlcCxcbiAgdGltZVVudGlsU3RhbGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryClientContext: function() { return /* binding */ QueryClientContext; },\n/* harmony export */   QueryClientProvider: function() { return /* binding */ QueryClientProvider; },\n/* harmony export */   useQueryClient: function() { return /* binding */ useQueryClient; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryClientContext,QueryClientProvider,useQueryClient auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryClientProvider.tsx\n\n\nvar QueryClientContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar useQueryClient = (queryClient)=>{\n    _s();\n    const client = react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryClientContext);\n    if (queryClient) {\n        return queryClient;\n    }\n    if (!client) {\n        throw new Error(\"No QueryClient set, use QueryClientProvider to set one\");\n    }\n    return client;\n};\n_s(useQueryClient, \"6C1IqtdJdCPZ/voWsX/6r3Oc32M=\");\nvar QueryClientProvider = (param)=>{\n    let { client, children } = param;\n    _s1();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        client.mount();\n        return ()=>{\n            client.unmount();\n        };\n    }, [\n        client\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryClientContext.Provider, {\n        value: client,\n        children\n    });\n};\n_s1(QueryClientProvider, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = QueryClientProvider;\n //# sourceMappingURL=QueryClientProvider.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryClientProvider\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL1F1ZXJ5Q2xpZW50UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUN1QjtBQXVDbkI7QUFuQ0csSUFBTUUsbUNBQTJCRixnREFBQSxDQUN0QztBQUdLLElBQU1JLGlCQUFpQixDQUFDQzs7SUFDN0IsTUFBTUMsU0FBZU4sNkNBQUEsQ0FBV0U7SUFFaEMsSUFBSUcsYUFBYTtRQUNmLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJLENBQUNDLFFBQVE7UUFDWCxNQUFNLElBQUlFLE1BQU07SUFDbEI7SUFFQSxPQUFPRjtBQUNUO0dBWmFGO0FBbUJOLElBQU1LLHNCQUFzQjtRQUFDLEVBQ2xDSCxNQUFBLEVBQ0FJLFFBQUEsRUFDRjs7SUFDUVYsNENBQUEsQ0FBVTtRQUNkTSxPQUFPTSxLQUFBO1FBQ1AsT0FBTztZQUNMTixPQUFPTyxPQUFBO1FBQ1Q7SUFDRixHQUFHO1FBQUNQO0tBQU87SUFFWCxPQUNFLGdCQUFBTCxzREFBQUEsQ0FBQ0MsbUJBQW1CWSxRQUFBLEVBQW5CO1FBQTRCQyxPQUFPVDtRQUNqQ0k7SUFBQTtBQUdQO0lBaEJhRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL1F1ZXJ5Q2xpZW50UHJvdmlkZXIudHN4Pzk5ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBRdWVyeUNsaWVudCB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuXG5leHBvcnQgY29uc3QgUXVlcnlDbGllbnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxRdWVyeUNsaWVudCB8IHVuZGVmaW5lZD4oXG4gIHVuZGVmaW5lZCxcbilcblxuZXhwb3J0IGNvbnN0IHVzZVF1ZXJ5Q2xpZW50ID0gKHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQpID0+IHtcbiAgY29uc3QgY2xpZW50ID0gUmVhY3QudXNlQ29udGV4dChRdWVyeUNsaWVudENvbnRleHQpXG5cbiAgaWYgKHF1ZXJ5Q2xpZW50KSB7XG4gICAgcmV0dXJuIHF1ZXJ5Q2xpZW50XG4gIH1cblxuICBpZiAoIWNsaWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gUXVlcnlDbGllbnQgc2V0LCB1c2UgUXVlcnlDbGllbnRQcm92aWRlciB0byBzZXQgb25lJylcbiAgfVxuXG4gIHJldHVybiBjbGllbnRcbn1cblxuZXhwb3J0IHR5cGUgUXVlcnlDbGllbnRQcm92aWRlclByb3BzID0ge1xuICBjbGllbnQ6IFF1ZXJ5Q2xpZW50XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlXG59XG5cbmV4cG9ydCBjb25zdCBRdWVyeUNsaWVudFByb3ZpZGVyID0gKHtcbiAgY2xpZW50LFxuICBjaGlsZHJlbixcbn06IFF1ZXJ5Q2xpZW50UHJvdmlkZXJQcm9wcyk6IFJlYWN0LkpTWC5FbGVtZW50ID0+IHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjbGllbnQubW91bnQoKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGllbnQudW5tb3VudCgpXG4gICAgfVxuICB9LCBbY2xpZW50XSlcblxuICByZXR1cm4gKFxuICAgIDxRdWVyeUNsaWVudENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NsaWVudH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9RdWVyeUNsaWVudENvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsImpzeCIsIlF1ZXJ5Q2xpZW50Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VRdWVyeUNsaWVudCIsInF1ZXJ5Q2xpZW50IiwiY2xpZW50IiwidXNlQ29udGV4dCIsIkVycm9yIiwiUXVlcnlDbGllbnRQcm92aWRlciIsImNoaWxkcmVuIiwidXNlRWZmZWN0IiwibW91bnQiLCJ1bm1vdW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryErrorResetBoundary: function() { return /* binding */ QueryErrorResetBoundary; },\n/* harmony export */   useQueryErrorResetBoundary: function() { return /* binding */ useQueryErrorResetBoundary; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ QueryErrorResetBoundary,useQueryErrorResetBoundary auto */ var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n// src/QueryErrorResetBoundary.tsx\n\n\nfunction createValue() {\n    let isReset = false;\n    return {\n        clearReset: ()=>{\n            isReset = false;\n        },\n        reset: ()=>{\n            isReset = true;\n        },\n        isReset: ()=>{\n            return isReset;\n        }\n    };\n}\nvar QueryErrorResetBoundaryContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(createValue());\nvar useQueryErrorResetBoundary = ()=>{\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(QueryErrorResetBoundaryContext);\n};\n_s(useQueryErrorResetBoundary, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar QueryErrorResetBoundary = (param)=>{\n    let { children } = param;\n    _s1();\n    const [value] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createValue());\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(QueryErrorResetBoundaryContext.Provider, {\n        value,\n        children: typeof children === \"function\" ? children(value) : children\n    });\n};\n_s1(QueryErrorResetBoundary, \"L9UPBb11nR62tM6xIubumSAcs3Y=\");\n_c = QueryErrorResetBoundary;\n //# sourceMappingURL=QueryErrorResetBoundary.js.map\nvar _c;\n$RefreshReg$(_c, \"QueryErrorResetBoundary\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL1F1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUN1QjtBQTZDbkI7QUFuQ0osU0FBU0U7SUFDUCxJQUFJQyxVQUFVO0lBQ2QsT0FBTztRQUNMQyxZQUFZO1lBQ1ZELFVBQVU7UUFDWjtRQUNBRSxPQUFPO1lBQ0xGLFVBQVU7UUFDWjtRQUNBQSxTQUFTO1lBQ1AsT0FBT0E7UUFDVDtJQUNGO0FBQ0Y7QUFFQSxJQUFNRywrQ0FBdUNOLGdEQUFBLENBQWNFO0FBSXBELElBQU1NLDZCQUE2Qjs7SUFDbENSLE9BQUFBLDZDQUFBLENBQVdNO0FBQThCO0dBRHBDRTtBQVdOLElBQU1FLDBCQUEwQjtRQUFDLEVBQ3RDQyxRQUFBLEVBQ0Y7O0lBQ0UsTUFBTSxDQUFDQyxNQUFLLEdBQVVaLDJDQUFBLENBQVMsSUFBTUU7SUFDckMsT0FDRSxnQkFBQUQsc0RBQUFBLENBQUNLLCtCQUErQlEsUUFBQSxFQUEvQjtRQUF3Q0Y7UUFDdENELFVBQUEsT0FBT0EsYUFBYSxhQUNoQkEsU0FBc0JDLFNBQ3ZCRDtJQUFBO0FBR1Y7SUFYYUQ7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9RdWVyeUVycm9yUmVzZXRCb3VuZGFyeS50c3g/ZWE1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuXG4vLyBDT05URVhUXG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlWYWx1ZSB7XG4gIGNsZWFyUmVzZXQ6ICgpID0+IHZvaWRcbiAgaXNSZXNldDogKCkgPT4gYm9vbGVhblxuICByZXNldDogKCkgPT4gdm9pZFxufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWx1ZSgpOiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlIHtcbiAgbGV0IGlzUmVzZXQgPSBmYWxzZVxuICByZXR1cm4ge1xuICAgIGNsZWFyUmVzZXQ6ICgpID0+IHtcbiAgICAgIGlzUmVzZXQgPSBmYWxzZVxuICAgIH0sXG4gICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgIGlzUmVzZXQgPSB0cnVlXG4gICAgfSxcbiAgICBpc1Jlc2V0OiAoKSA9PiB7XG4gICAgICByZXR1cm4gaXNSZXNldFxuICAgIH0sXG4gIH1cbn1cblxuY29uc3QgUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChjcmVhdGVWYWx1ZSgpKVxuXG4vLyBIT09LXG5cbmV4cG9ydCBjb25zdCB1c2VRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSA9ICgpID0+XG4gIFJlYWN0LnVzZUNvbnRleHQoUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0KVxuXG4vLyBDT01QT05FTlRcblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVByb3BzIHtcbiAgY2hpbGRyZW46XG4gICAgfCAoKHZhbHVlOiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlKSA9PiBSZWFjdC5SZWFjdE5vZGUpXG4gICAgfCBSZWFjdC5SZWFjdE5vZGVcbn1cblxuZXhwb3J0IGNvbnN0IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5ID0gKHtcbiAgY2hpbGRyZW4sXG59OiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVByb3BzKSA9PiB7XG4gIGNvbnN0IFt2YWx1ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVWYWx1ZSgpKVxuICByZXR1cm4gKFxuICAgIDxRdWVyeUVycm9yUmVzZXRCb3VuZGFyeUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHt0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAoY2hpbGRyZW4gYXMgRnVuY3Rpb24pKHZhbHVlKVxuICAgICAgICA6IGNoaWxkcmVufVxuICAgIDwvUXVlcnlFcnJvclJlc2V0Qm91bmRhcnlDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJqc3giLCJjcmVhdGVWYWx1ZSIsImlzUmVzZXQiLCJjbGVhclJlc2V0IiwicmVzZXQiLCJRdWVyeUVycm9yUmVzZXRCb3VuZGFyeUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkiLCJ1c2VDb250ZXh0IiwiUXVlcnlFcnJvclJlc2V0Qm91bmRhcnkiLCJjaGlsZHJlbiIsInZhbHVlIiwidXNlU3RhdGUiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensurePreventErrorBoundaryRetry: function() { return /* binding */ ensurePreventErrorBoundaryRetry; },\n/* harmony export */   getHasError: function() { return /* binding */ getHasError; },\n/* harmony export */   useClearResetErrorBoundary: function() { return /* binding */ useClearResetErrorBoundary; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js\");\n/* __next_internal_client_entry_do_not_use__ ensurePreventErrorBoundaryRetry,getHasError,useClearResetErrorBoundary auto */ var _s = $RefreshSig$();\n// src/errorBoundaryUtils.ts\n\n\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary)=>{\n    if (options.suspense || options.throwOnError) {\n        if (!errorResetBoundary.isReset()) {\n            options.retryOnMount = false;\n        }\n    }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary)=>{\n    _s();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        errorResetBoundary.clearReset();\n    }, [\n        errorResetBoundary\n    ]);\n};\n_s(useClearResetErrorBoundary, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\nvar getHasError = (param)=>{\n    let { result, errorResetBoundary, throwOnError, query } = param;\n    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.shouldThrowError)(throwOnError, [\n        result.error,\n        query\n    ]);\n};\n //# sourceMappingURL=errorBoundaryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL2Vycm9yQm91bmRhcnlVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ3VCO0FBQ1U7QUFVMUIsSUFBTUUsa0NBQWtDLENBTzdDQyxTQU9BQztJQUVBLElBQUlELFFBQVFFLFFBQUEsSUFBWUYsUUFBUUcsWUFBQSxFQUFjO1FBRTVDLElBQUksQ0FBQ0YsbUJBQW1CRyxPQUFBLElBQVc7WUFDakNKLFFBQVFLLFlBQUEsR0FBZTtRQUN6QjtJQUNGO0FBQ0Y7QUFFTyxJQUFNQyw2QkFBNkIsQ0FDeENMOztJQUVNSiw0Q0FBQSxDQUFVO1FBQ2RJLG1CQUFtQk8sVUFBQTtJQUNyQixHQUFHO1FBQUNQO0tBQW1CO0FBQ3pCO0dBTmFLO0FBUU4sSUFBTUcsY0FBYztRQU16QixFQUNBQyxNQUFBLEVBQ0FULGtCQUFBLEVBQ0FFLFlBQUEsRUFDQVEsS0FBQSxFQUNGO0lBTUUsT0FDRUQsT0FBT0UsT0FBQSxJQUNQLENBQUNYLG1CQUFtQkcsT0FBQSxNQUNwQixDQUFDTSxPQUFPRyxVQUFBLElBQ1JGLFNBQ0FiLDJEQUFnQkEsQ0FBQ0ssY0FBYztRQUFDTyxPQUFPSSxLQUFBO1FBQU9IO0tBQU07QUFFeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9lcnJvckJvdW5kYXJ5VXRpbHMudHM/OWMyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgc2hvdWxkVGhyb3dFcnJvciB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgdHlwZSB7XG4gIERlZmF1bHRlZFF1ZXJ5T2JzZXJ2ZXJPcHRpb25zLFxuICBRdWVyeSxcbiAgUXVlcnlLZXksXG4gIFF1ZXJ5T2JzZXJ2ZXJSZXN1bHQsXG4gIFRocm93T25FcnJvcixcbn0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5pbXBvcnQgdHlwZSB7IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5VmFsdWUgfSBmcm9tICcuL1F1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5J1xuXG5leHBvcnQgY29uc3QgZW5zdXJlUHJldmVudEVycm9yQm91bmRhcnlSZXRyeSA9IDxcbiAgVFF1ZXJ5Rm5EYXRhLFxuICBURXJyb3IsXG4gIFREYXRhLFxuICBUUXVlcnlEYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSxcbj4oXG4gIG9wdGlvbnM6IERlZmF1bHRlZFF1ZXJ5T2JzZXJ2ZXJPcHRpb25zPFxuICAgIFRRdWVyeUZuRGF0YSxcbiAgICBURXJyb3IsXG4gICAgVERhdGEsXG4gICAgVFF1ZXJ5RGF0YSxcbiAgICBUUXVlcnlLZXlcbiAgPixcbiAgZXJyb3JSZXNldEJvdW5kYXJ5OiBRdWVyeUVycm9yUmVzZXRCb3VuZGFyeVZhbHVlLFxuKSA9PiB7XG4gIGlmIChvcHRpb25zLnN1c3BlbnNlIHx8IG9wdGlvbnMudGhyb3dPbkVycm9yKSB7XG4gICAgLy8gUHJldmVudCByZXRyeWluZyBmYWlsZWQgcXVlcnkgaWYgdGhlIGVycm9yIGJvdW5kYXJ5IGhhcyBub3QgYmVlbiByZXNldCB5ZXRcbiAgICBpZiAoIWVycm9yUmVzZXRCb3VuZGFyeS5pc1Jlc2V0KCkpIHtcbiAgICAgIG9wdGlvbnMucmV0cnlPbk1vdW50ID0gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5ID0gKFxuICBlcnJvclJlc2V0Qm91bmRhcnk6IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5VmFsdWUsXG4pID0+IHtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBlcnJvclJlc2V0Qm91bmRhcnkuY2xlYXJSZXNldCgpXG4gIH0sIFtlcnJvclJlc2V0Qm91bmRhcnldKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0SGFzRXJyb3IgPSA8XG4gIFREYXRhLFxuICBURXJyb3IsXG4gIFRRdWVyeUZuRGF0YSxcbiAgVFF1ZXJ5RGF0YSxcbiAgVFF1ZXJ5S2V5IGV4dGVuZHMgUXVlcnlLZXksXG4+KHtcbiAgcmVzdWx0LFxuICBlcnJvclJlc2V0Qm91bmRhcnksXG4gIHRocm93T25FcnJvcixcbiAgcXVlcnksXG59OiB7XG4gIHJlc3VsdDogUXVlcnlPYnNlcnZlclJlc3VsdDxURGF0YSwgVEVycm9yPlxuICBlcnJvclJlc2V0Qm91bmRhcnk6IFF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5VmFsdWVcbiAgdGhyb3dPbkVycm9yOiBUaHJvd09uRXJyb3I8VFF1ZXJ5Rm5EYXRhLCBURXJyb3IsIFRRdWVyeURhdGEsIFRRdWVyeUtleT5cbiAgcXVlcnk6IFF1ZXJ5PFRRdWVyeUZuRGF0YSwgVEVycm9yLCBUUXVlcnlEYXRhLCBUUXVlcnlLZXk+IHwgdW5kZWZpbmVkXG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgcmVzdWx0LmlzRXJyb3IgJiZcbiAgICAhZXJyb3JSZXNldEJvdW5kYXJ5LmlzUmVzZXQoKSAmJlxuICAgICFyZXN1bHQuaXNGZXRjaGluZyAmJlxuICAgIHF1ZXJ5ICYmXG4gICAgc2hvdWxkVGhyb3dFcnJvcih0aHJvd09uRXJyb3IsIFtyZXN1bHQuZXJyb3IsIHF1ZXJ5XSlcbiAgKVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0Iiwic2hvdWxkVGhyb3dFcnJvciIsImVuc3VyZVByZXZlbnRFcnJvckJvdW5kYXJ5UmV0cnkiLCJvcHRpb25zIiwiZXJyb3JSZXNldEJvdW5kYXJ5Iiwic3VzcGVuc2UiLCJ0aHJvd09uRXJyb3IiLCJpc1Jlc2V0IiwicmV0cnlPbk1vdW50IiwidXNlQ2xlYXJSZXNldEVycm9yQm91bmRhcnkiLCJ1c2VFZmZlY3QiLCJjbGVhclJlc2V0IiwiZ2V0SGFzRXJyb3IiLCJyZXN1bHQiLCJxdWVyeSIsImlzRXJyb3IiLCJpc0ZldGNoaW5nIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/isRestoring.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/isRestoring.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IsRestoringProvider: function() { return /* binding */ IsRestoringProvider; },\n/* harmony export */   useIsRestoring: function() { return /* binding */ useIsRestoring; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ IsRestoringProvider,useIsRestoring auto */ var _s = $RefreshSig$();\n// src/isRestoring.ts\n\nvar IsRestoringContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(false);\nvar useIsRestoring = ()=>{\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsRestoringContext);\n};\n_s(useIsRestoring, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar IsRestoringProvider = IsRestoringContext.Provider;\n //# sourceMappingURL=isRestoring.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL2lzUmVzdG9yaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ3VCO0FBRXZCLElBQU1DLG1DQUEyQkQsZ0RBQUEsQ0FBYztBQUV4QyxJQUFNRyxpQkFBaUI7O0lBQVlILE9BQUFBLDZDQUFBLENBQVdDO0FBQWtCO0dBQTFERTtBQUNOLElBQU1FLHNCQUFzQkosbUJBQW1CSyxRQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvaXNSZXN0b3JpbmcudHM/NjJhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBJc1Jlc3RvcmluZ0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KGZhbHNlKVxuXG5leHBvcnQgY29uc3QgdXNlSXNSZXN0b3JpbmcgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KElzUmVzdG9yaW5nQ29udGV4dClcbmV4cG9ydCBjb25zdCBJc1Jlc3RvcmluZ1Byb3ZpZGVyID0gSXNSZXN0b3JpbmdDb250ZXh0LlByb3ZpZGVyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJJc1Jlc3RvcmluZ0NvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlSXNSZXN0b3JpbmciLCJ1c2VDb250ZXh0IiwiSXNSZXN0b3JpbmdQcm92aWRlciIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/isRestoring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/suspense.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/suspense.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultThrowOnError: function() { return /* binding */ defaultThrowOnError; },\n/* harmony export */   ensureSuspenseTimers: function() { return /* binding */ ensureSuspenseTimers; },\n/* harmony export */   fetchOptimistic: function() { return /* binding */ fetchOptimistic; },\n/* harmony export */   shouldSuspend: function() { return /* binding */ shouldSuspend; },\n/* harmony export */   willFetch: function() { return /* binding */ willFetch; }\n/* harmony export */ });\n// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    if (typeof defaultedOptions.staleTime !== \"number\") {\n      defaultedOptions.staleTime = 1e3;\n    }\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\n\n//# sourceMappingURL=suspense.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3N1c3BlbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBT0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi9zdXNwZW5zZS5qcz9kZjQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zdXNwZW5zZS50c1xudmFyIGRlZmF1bHRUaHJvd09uRXJyb3IgPSAoX2Vycm9yLCBxdWVyeSkgPT4gcXVlcnkuc3RhdGUuZGF0YSA9PT0gdm9pZCAwO1xudmFyIGVuc3VyZVN1c3BlbnNlVGltZXJzID0gKGRlZmF1bHRlZE9wdGlvbnMpID0+IHtcbiAgaWYgKGRlZmF1bHRlZE9wdGlvbnMuc3VzcGVuc2UpIHtcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRlZE9wdGlvbnMuc3RhbGVUaW1lICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBkZWZhdWx0ZWRPcHRpb25zLnN0YWxlVGltZSA9IDFlMztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0ZWRPcHRpb25zLmdjVGltZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZGVmYXVsdGVkT3B0aW9ucy5nY1RpbWUgPSBNYXRoLm1heChkZWZhdWx0ZWRPcHRpb25zLmdjVGltZSwgMWUzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgd2lsbEZldGNoID0gKHJlc3VsdCwgaXNSZXN0b3JpbmcpID0+IHJlc3VsdC5pc0xvYWRpbmcgJiYgcmVzdWx0LmlzRmV0Y2hpbmcgJiYgIWlzUmVzdG9yaW5nO1xudmFyIHNob3VsZFN1c3BlbmQgPSAoZGVmYXVsdGVkT3B0aW9ucywgcmVzdWx0KSA9PiBkZWZhdWx0ZWRPcHRpb25zPy5zdXNwZW5zZSAmJiByZXN1bHQuaXNQZW5kaW5nO1xudmFyIGZldGNoT3B0aW1pc3RpYyA9IChkZWZhdWx0ZWRPcHRpb25zLCBvYnNlcnZlciwgZXJyb3JSZXNldEJvdW5kYXJ5KSA9PiBvYnNlcnZlci5mZXRjaE9wdGltaXN0aWMoZGVmYXVsdGVkT3B0aW9ucykuY2F0Y2goKCkgPT4ge1xuICBlcnJvclJlc2V0Qm91bmRhcnkuY2xlYXJSZXNldCgpO1xufSk7XG5leHBvcnQge1xuICBkZWZhdWx0VGhyb3dPbkVycm9yLFxuICBlbnN1cmVTdXNwZW5zZVRpbWVycyxcbiAgZmV0Y2hPcHRpbWlzdGljLFxuICBzaG91bGRTdXNwZW5kLFxuICB3aWxsRmV0Y2hcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXNwZW5zZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/suspense.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBaseQuery: function() { return /* binding */ useBaseQuery; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QueryErrorResetBoundary.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js\");\n/* harmony import */ var _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QueryClientProvider.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var _isRestoring_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isRestoring.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/isRestoring.js\");\n/* harmony import */ var _errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errorBoundaryUtils.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js\");\n/* harmony import */ var _suspense_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./suspense.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/suspense.js\");\n/* __next_internal_client_entry_do_not_use__ useBaseQuery auto */ var _s = $RefreshSig$();\n// src/useBaseQuery.ts\n\n\n\n\n\n\n\nfunction useBaseQuery(options, Observer, queryClient) {\n    var _client_getDefaultOptions_queries__experimental_beforeQuery, _client_getDefaultOptions_queries, _client_getDefaultOptions_queries__experimental_afterQuery, _client_getDefaultOptions_queries1;\n    _s();\n    if (true) {\n        if (typeof options !== \"object\" || Array.isArray(options)) {\n            throw new Error('Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object');\n        }\n    }\n    const client = (0,_QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient)(queryClient);\n    const isRestoring = (0,_isRestoring_js__WEBPACK_IMPORTED_MODULE_2__.useIsRestoring)();\n    const errorResetBoundary = (0,_QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__.useQueryErrorResetBoundary)();\n    const defaultedOptions = client.defaultQueryOptions(options);\n    (_client_getDefaultOptions_queries = client.getDefaultOptions().queries) === null || _client_getDefaultOptions_queries === void 0 ? void 0 : (_client_getDefaultOptions_queries__experimental_beforeQuery = _client_getDefaultOptions_queries._experimental_beforeQuery) === null || _client_getDefaultOptions_queries__experimental_beforeQuery === void 0 ? void 0 : _client_getDefaultOptions_queries__experimental_beforeQuery.call(_client_getDefaultOptions_queries, defaultedOptions);\n    defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n    (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.ensureSuspenseTimers)(defaultedOptions);\n    (0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.ensurePreventErrorBoundaryRetry)(defaultedOptions, errorResetBoundary);\n    (0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.useClearResetErrorBoundary)(errorResetBoundary);\n    const [observer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new Observer(client, defaultedOptions));\n    const result = observer.getOptimisticResult(defaultedOptions);\n    react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>{\n        const unsubscribe = isRestoring ? ()=>void 0 : observer.subscribe(_tanstack_query_core__WEBPACK_IMPORTED_MODULE_6__.notifyManager.batchCalls(onStoreChange));\n        observer.updateResult();\n        return unsubscribe;\n    }, [\n        observer,\n        isRestoring\n    ]), ()=>observer.getCurrentResult(), ()=>observer.getCurrentResult());\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        observer.setOptions(defaultedOptions, {\n            listeners: false\n        });\n    }, [\n        defaultedOptions,\n        observer\n    ]);\n    if ((0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.shouldSuspend)(defaultedOptions, result)) {\n        throw (0,_suspense_js__WEBPACK_IMPORTED_MODULE_4__.fetchOptimistic)(defaultedOptions, observer, errorResetBoundary);\n    }\n    if ((0,_errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.getHasError)({\n        result,\n        errorResetBoundary,\n        throwOnError: defaultedOptions.throwOnError,\n        query: client.getQueryCache().get(defaultedOptions.queryHash)\n    })) {\n        throw result.error;\n    }\n    ;\n    (_client_getDefaultOptions_queries1 = client.getDefaultOptions().queries) === null || _client_getDefaultOptions_queries1 === void 0 ? void 0 : (_client_getDefaultOptions_queries__experimental_afterQuery = _client_getDefaultOptions_queries1._experimental_afterQuery) === null || _client_getDefaultOptions_queries__experimental_afterQuery === void 0 ? void 0 : _client_getDefaultOptions_queries__experimental_afterQuery.call(_client_getDefaultOptions_queries1, defaultedOptions, result);\n    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\n_s(useBaseQuery, \"RdnjPuVKRWykd09y/1yZ8ZcDrqw=\", false, function() {\n    return [\n        _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient,\n        _isRestoring_js__WEBPACK_IMPORTED_MODULE_2__.useIsRestoring,\n        _QueryErrorResetBoundary_js__WEBPACK_IMPORTED_MODULE_3__.useQueryErrorResetBoundary,\n        _errorBoundaryUtils_js__WEBPACK_IMPORTED_MODULE_5__.useClearResetErrorBoundary\n    ];\n});\n //# sourceMappingURL=useBaseQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3VzZUJhc2VRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQ3VCO0FBRU87QUFDYTtBQUNaO0FBQ0E7QUFLeEI7QUFLQTtBQVNBLFNBQVNXLGFBT2RDLE9BQUEsRUFPQUMsUUFBQSxFQUNBQyxXQUFBO1FBZUVDLDZEQUFBQSxtQ0F5RUFBLDREQUFBQTs7SUF0RkYsSUFBSUMsSUFBeUIsRUFBYztRQUN6QyxJQUFJLE9BQU9KLFlBQVksWUFBWUssTUFBTUMsT0FBQSxDQUFRTixVQUFVO1lBQ3pELE1BQU0sSUFBSU8sTUFDUjtRQUVKO0lBQ0Y7SUFFQSxNQUFNSixTQUFTWix1RUFBY0EsQ0FBQ1c7SUFDOUIsTUFBTU0sY0FBY2hCLCtEQUFjQTtJQUNsQyxNQUFNaUIscUJBQXFCbkIsdUZBQTBCQTtJQUNyRCxNQUFNb0IsbUJBQW1CUCxPQUFPUSxtQkFBQSxDQUFvQlg7S0FFbERHLG9DQUFBQSxPQUFPUyxpQkFBQSxHQUFvQkMsT0FBQSxjQUEzQlYseURBQUFBLDhEQUFBQSxrQ0FBNENXLHlCQUFBLGNBQTVDWCxrRkFBQUEsaUVBQUFBLG1DQUNBTztJQUlGQSxpQkFBaUJLLGtCQUFBLEdBQXFCUCxjQUNsQyxnQkFDQTtJQUVKWixrRUFBb0JBLENBQUNjO0lBQ3JCakIsdUZBQStCQSxDQUFDaUIsa0JBQWtCRDtJQUVsRGQsa0ZBQTBCQSxDQUFDYztJQUUzQixNQUFNLENBQUNPLFNBQVEsR0FBVTVCLDJDQUFBLENBQ3ZCLElBQ0UsSUFBSWEsU0FDRkUsUUFDQU87SUFJTixNQUFNUSxTQUFTRixTQUFTRyxtQkFBQSxDQUFvQlQ7SUFFdEN0Qix1REFBQSxDQUNFQSw4Q0FBQSxDQUNKLENBQUNrQztRQUNDLE1BQU1DLGNBQWNmLGNBQ2hCLElBQU0sU0FDTlEsU0FBU1EsU0FBQSxDQUFVbkMsK0RBQWFBLENBQUNvQyxVQUFBLENBQVdIO1FBSWhETixTQUFTVSxZQUFBO1FBRVQsT0FBT0g7SUFDVCxHQUNBO1FBQUNQO1FBQVVSO0tBQVcsR0FFeEIsSUFBTVEsU0FBU1csZ0JBQUEsSUFDZixJQUFNWCxTQUFTVyxnQkFBQTtJQUdYdkMsNENBQUEsQ0FBVTtRQUdkNEIsU0FBU2EsVUFBQSxDQUFXbkIsa0JBQWtCO1lBQUVvQixXQUFXO1FBQU07SUFDM0QsR0FBRztRQUFDcEI7UUFBa0JNO0tBQVM7SUFHL0IsSUFBSWxCLDJEQUFhQSxDQUFDWSxrQkFBa0JRLFNBQVM7UUFDM0MsTUFBTXJCLDZEQUFlQSxDQUFDYSxrQkFBa0JNLFVBQVVQO0lBQ3BEO0lBR0EsSUFDRWYsbUVBQVdBLENBQUM7UUFDVndCO1FBQ0FUO1FBQ0FzQixjQUFjckIsaUJBQWlCcUIsWUFBQTtRQUMvQkMsT0FBTzdCLE9BQ0o4QixhQUFBLEdBQ0FDLEdBQUEsQ0FLQ3hCLGlCQUFpQnlCLFNBQVM7SUFDaEMsSUFDQTtRQUNBLE1BQU1qQixPQUFPa0IsS0FBQTtJQUNmOztLQUVFakMscUNBQUFBLE9BQU9TLGlCQUFBLEdBQW9CQyxPQUFBLGNBQTNCViwwREFBQUEsNkRBQUFBLG1DQUE0Q2tDLHdCQUFBLGNBQTVDbEMsaUZBQUFBLGdFQUFBQSxvQ0FDQU8sa0JBQ0FRO0lBSUYsT0FBTyxDQUFDUixpQkFBaUI0QixtQkFBQSxHQUNyQnRCLFNBQVN1QixXQUFBLENBQVlyQixVQUNyQkE7QUFDTjtHQWhIZ0JuQjs7UUF5QkNSLG1FQUFjQTtRQUNUQywyREFBY0E7UUFDUEYsbUZBQTBCQTtRQWVyREssOEVBQTBCQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL3VzZUJhc2VRdWVyeS50cz8yOGI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IG5vdGlmeU1hbmFnZXIgfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcbmltcG9ydCB7IHVzZVF1ZXJ5RXJyb3JSZXNldEJvdW5kYXJ5IH0gZnJvbSAnLi9RdWVyeUVycm9yUmVzZXRCb3VuZGFyeSdcbmltcG9ydCB7IHVzZVF1ZXJ5Q2xpZW50IH0gZnJvbSAnLi9RdWVyeUNsaWVudFByb3ZpZGVyJ1xuaW1wb3J0IHsgdXNlSXNSZXN0b3JpbmcgfSBmcm9tICcuL2lzUmVzdG9yaW5nJ1xuaW1wb3J0IHtcbiAgZW5zdXJlUHJldmVudEVycm9yQm91bmRhcnlSZXRyeSxcbiAgZ2V0SGFzRXJyb3IsXG4gIHVzZUNsZWFyUmVzZXRFcnJvckJvdW5kYXJ5LFxufSBmcm9tICcuL2Vycm9yQm91bmRhcnlVdGlscydcbmltcG9ydCB7XG4gIGVuc3VyZVN1c3BlbnNlVGltZXJzLFxuICBmZXRjaE9wdGltaXN0aWMsXG4gIHNob3VsZFN1c3BlbmQsXG59IGZyb20gJy4vc3VzcGVuc2UnXG5pbXBvcnQgdHlwZSB7IFVzZUJhc2VRdWVyeU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBRdWVyeUNsaWVudCxcbiAgUXVlcnlLZXksXG4gIFF1ZXJ5T2JzZXJ2ZXIsXG4gIFF1ZXJ5T2JzZXJ2ZXJSZXN1bHQsXG59IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFzZVF1ZXJ5PFxuICBUUXVlcnlGbkRhdGEsXG4gIFRFcnJvcixcbiAgVERhdGEsXG4gIFRRdWVyeURhdGEsXG4gIFRRdWVyeUtleSBleHRlbmRzIFF1ZXJ5S2V5LFxuPihcbiAgb3B0aW9uczogVXNlQmFzZVF1ZXJ5T3B0aW9uczxcbiAgICBUUXVlcnlGbkRhdGEsXG4gICAgVEVycm9yLFxuICAgIFREYXRhLFxuICAgIFRRdWVyeURhdGEsXG4gICAgVFF1ZXJ5S2V5XG4gID4sXG4gIE9ic2VydmVyOiB0eXBlb2YgUXVlcnlPYnNlcnZlcixcbiAgcXVlcnlDbGllbnQ/OiBRdWVyeUNsaWVudCxcbik6IFF1ZXJ5T2JzZXJ2ZXJSZXN1bHQ8VERhdGEsIFRFcnJvcj4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQmFkIGFyZ3VtZW50IHR5cGUuIFN0YXJ0aW5nIHdpdGggdjUsIG9ubHkgdGhlIFwiT2JqZWN0XCIgZm9ybSBpcyBhbGxvd2VkIHdoZW4gY2FsbGluZyBxdWVyeSByZWxhdGVkIGZ1bmN0aW9ucy4gUGxlYXNlIHVzZSB0aGUgZXJyb3Igc3RhY2sgdG8gZmluZCB0aGUgY3VscHJpdCBjYWxsLiBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly90YW5zdGFjay5jb20vcXVlcnkvbGF0ZXN0L2RvY3MvcmVhY3QvZ3VpZGVzL21pZ3JhdGluZy10by12NSNzdXBwb3J0cy1hLXNpbmdsZS1zaWduYXR1cmUtb25lLW9iamVjdCcsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2xpZW50ID0gdXNlUXVlcnlDbGllbnQocXVlcnlDbGllbnQpXG4gIGNvbnN0IGlzUmVzdG9yaW5nID0gdXNlSXNSZXN0b3JpbmcoKVxuICBjb25zdCBlcnJvclJlc2V0Qm91bmRhcnkgPSB1c2VRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSgpXG4gIGNvbnN0IGRlZmF1bHRlZE9wdGlvbnMgPSBjbGllbnQuZGVmYXVsdFF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gIDsoY2xpZW50LmdldERlZmF1bHRPcHRpb25zKCkucXVlcmllcyBhcyBhbnkpPy5fZXhwZXJpbWVudGFsX2JlZm9yZVF1ZXJ5Py4oXG4gICAgZGVmYXVsdGVkT3B0aW9ucyxcbiAgKVxuXG4gIC8vIE1ha2Ugc3VyZSByZXN1bHRzIGFyZSBvcHRpbWlzdGljYWxseSBzZXQgaW4gZmV0Y2hpbmcgc3RhdGUgYmVmb3JlIHN1YnNjcmliaW5nIG9yIHVwZGF0aW5nIG9wdGlvbnNcbiAgZGVmYXVsdGVkT3B0aW9ucy5fb3B0aW1pc3RpY1Jlc3VsdHMgPSBpc1Jlc3RvcmluZ1xuICAgID8gJ2lzUmVzdG9yaW5nJ1xuICAgIDogJ29wdGltaXN0aWMnXG5cbiAgZW5zdXJlU3VzcGVuc2VUaW1lcnMoZGVmYXVsdGVkT3B0aW9ucylcbiAgZW5zdXJlUHJldmVudEVycm9yQm91bmRhcnlSZXRyeShkZWZhdWx0ZWRPcHRpb25zLCBlcnJvclJlc2V0Qm91bmRhcnkpXG5cbiAgdXNlQ2xlYXJSZXNldEVycm9yQm91bmRhcnkoZXJyb3JSZXNldEJvdW5kYXJ5KVxuXG4gIGNvbnN0IFtvYnNlcnZlcl0gPSBSZWFjdC51c2VTdGF0ZShcbiAgICAoKSA9PlxuICAgICAgbmV3IE9ic2VydmVyPFRRdWVyeUZuRGF0YSwgVEVycm9yLCBURGF0YSwgVFF1ZXJ5RGF0YSwgVFF1ZXJ5S2V5PihcbiAgICAgICAgY2xpZW50LFxuICAgICAgICBkZWZhdWx0ZWRPcHRpb25zLFxuICAgICAgKSxcbiAgKVxuXG4gIGNvbnN0IHJlc3VsdCA9IG9ic2VydmVyLmdldE9wdGltaXN0aWNSZXN1bHQoZGVmYXVsdGVkT3B0aW9ucylcblxuICBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIChvblN0b3JlQ2hhbmdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gaXNSZXN0b3JpbmdcbiAgICAgICAgICA/ICgpID0+IHVuZGVmaW5lZFxuICAgICAgICAgIDogb2JzZXJ2ZXIuc3Vic2NyaWJlKG5vdGlmeU1hbmFnZXIuYmF0Y2hDYWxscyhvblN0b3JlQ2hhbmdlKSlcblxuICAgICAgICAvLyBVcGRhdGUgcmVzdWx0IHRvIG1ha2Ugc3VyZSB3ZSBkaWQgbm90IG1pc3MgYW55IHF1ZXJ5IHVwZGF0ZXNcbiAgICAgICAgLy8gYmV0d2VlbiBjcmVhdGluZyB0aGUgb2JzZXJ2ZXIgYW5kIHN1YnNjcmliaW5nIHRvIGl0LlxuICAgICAgICBvYnNlcnZlci51cGRhdGVSZXN1bHQoKVxuXG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZVxuICAgICAgfSxcbiAgICAgIFtvYnNlcnZlciwgaXNSZXN0b3JpbmddLFxuICAgICksXG4gICAgKCkgPT4gb2JzZXJ2ZXIuZ2V0Q3VycmVudFJlc3VsdCgpLFxuICAgICgpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKSxcbiAgKVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRG8gbm90IG5vdGlmeSBvbiB1cGRhdGVzIGJlY2F1c2Ugb2YgY2hhbmdlcyBpbiB0aGUgb3B0aW9ucyBiZWNhdXNlXG4gICAgLy8gdGhlc2UgY2hhbmdlcyBzaG91bGQgYWxyZWFkeSBiZSByZWZsZWN0ZWQgaW4gdGhlIG9wdGltaXN0aWMgcmVzdWx0LlxuICAgIG9ic2VydmVyLnNldE9wdGlvbnMoZGVmYXVsdGVkT3B0aW9ucywgeyBsaXN0ZW5lcnM6IGZhbHNlIH0pXG4gIH0sIFtkZWZhdWx0ZWRPcHRpb25zLCBvYnNlcnZlcl0pXG5cbiAgLy8gSGFuZGxlIHN1c3BlbnNlXG4gIGlmIChzaG91bGRTdXNwZW5kKGRlZmF1bHRlZE9wdGlvbnMsIHJlc3VsdCkpIHtcbiAgICB0aHJvdyBmZXRjaE9wdGltaXN0aWMoZGVmYXVsdGVkT3B0aW9ucywgb2JzZXJ2ZXIsIGVycm9yUmVzZXRCb3VuZGFyeSlcbiAgfVxuXG4gIC8vIEhhbmRsZSBlcnJvciBib3VuZGFyeVxuICBpZiAoXG4gICAgZ2V0SGFzRXJyb3Ioe1xuICAgICAgcmVzdWx0LFxuICAgICAgZXJyb3JSZXNldEJvdW5kYXJ5LFxuICAgICAgdGhyb3dPbkVycm9yOiBkZWZhdWx0ZWRPcHRpb25zLnRocm93T25FcnJvcixcbiAgICAgIHF1ZXJ5OiBjbGllbnRcbiAgICAgICAgLmdldFF1ZXJ5Q2FjaGUoKVxuICAgICAgICAuZ2V0PFxuICAgICAgICAgIFRRdWVyeUZuRGF0YSxcbiAgICAgICAgICBURXJyb3IsXG4gICAgICAgICAgVFF1ZXJ5RGF0YSxcbiAgICAgICAgICBUUXVlcnlLZXlcbiAgICAgICAgPihkZWZhdWx0ZWRPcHRpb25zLnF1ZXJ5SGFzaCksXG4gICAgfSlcbiAgKSB7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yXG4gIH1cblxuICA7KGNsaWVudC5nZXREZWZhdWx0T3B0aW9ucygpLnF1ZXJpZXMgYXMgYW55KT8uX2V4cGVyaW1lbnRhbF9hZnRlclF1ZXJ5Py4oXG4gICAgZGVmYXVsdGVkT3B0aW9ucyxcbiAgICByZXN1bHQsXG4gIClcblxuICAvLyBIYW5kbGUgcmVzdWx0IHByb3BlcnR5IHVzYWdlIHRyYWNraW5nXG4gIHJldHVybiAhZGVmYXVsdGVkT3B0aW9ucy5ub3RpZnlPbkNoYW5nZVByb3BzXG4gICAgPyBvYnNlcnZlci50cmFja1Jlc3VsdChyZXN1bHQpXG4gICAgOiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIm5vdGlmeU1hbmFnZXIiLCJ1c2VRdWVyeUVycm9yUmVzZXRCb3VuZGFyeSIsInVzZVF1ZXJ5Q2xpZW50IiwidXNlSXNSZXN0b3JpbmciLCJlbnN1cmVQcmV2ZW50RXJyb3JCb3VuZGFyeVJldHJ5IiwiZ2V0SGFzRXJyb3IiLCJ1c2VDbGVhclJlc2V0RXJyb3JCb3VuZGFyeSIsImVuc3VyZVN1c3BlbnNlVGltZXJzIiwiZmV0Y2hPcHRpbWlzdGljIiwic2hvdWxkU3VzcGVuZCIsInVzZUJhc2VRdWVyeSIsIm9wdGlvbnMiLCJPYnNlcnZlciIsInF1ZXJ5Q2xpZW50IiwiY2xpZW50IiwicHJvY2VzcyIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiaXNSZXN0b3JpbmciLCJlcnJvclJlc2V0Qm91bmRhcnkiLCJkZWZhdWx0ZWRPcHRpb25zIiwiZGVmYXVsdFF1ZXJ5T3B0aW9ucyIsImdldERlZmF1bHRPcHRpb25zIiwicXVlcmllcyIsIl9leHBlcmltZW50YWxfYmVmb3JlUXVlcnkiLCJfb3B0aW1pc3RpY1Jlc3VsdHMiLCJvYnNlcnZlciIsInVzZVN0YXRlIiwicmVzdWx0IiwiZ2V0T3B0aW1pc3RpY1Jlc3VsdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlQ2FsbGJhY2siLCJvblN0b3JlQ2hhbmdlIiwidW5zdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJiYXRjaENhbGxzIiwidXBkYXRlUmVzdWx0IiwiZ2V0Q3VycmVudFJlc3VsdCIsInVzZUVmZmVjdCIsInNldE9wdGlvbnMiLCJsaXN0ZW5lcnMiLCJ0aHJvd09uRXJyb3IiLCJxdWVyeSIsImdldFF1ZXJ5Q2FjaGUiLCJnZXQiLCJxdWVyeUhhc2giLCJlcnJvciIsIl9leHBlcmltZW50YWxfYWZ0ZXJRdWVyeSIsIm5vdGlmeU9uQ2hhbmdlUHJvcHMiLCJ0cmFja1Jlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useMutation.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/useMutation.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMutation: function() { return /* binding */ useMutation; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/mutationObserver.js\");\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/notifyManager.js\");\n/* harmony import */ var _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QueryClientProvider.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js\");\n/* __next_internal_client_entry_do_not_use__ useMutation auto */ var _s = $RefreshSig$();\n// src/useMutation.ts\n\n\n\n\nfunction useMutation(options, queryClient) {\n    _s();\n    const client = (0,_QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient)(queryClient);\n    const [observer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new _tanstack_query_core__WEBPACK_IMPORTED_MODULE_2__.MutationObserver(client, options));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        observer.setOptions(options);\n    }, [\n        observer,\n        options\n    ]);\n    const result = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(react__WEBPACK_IMPORTED_MODULE_0__.useCallback((onStoreChange)=>observer.subscribe(_tanstack_query_core__WEBPACK_IMPORTED_MODULE_3__.notifyManager.batchCalls(onStoreChange)), [\n        observer\n    ]), ()=>observer.getCurrentResult(), ()=>observer.getCurrentResult());\n    const mutate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((variables, mutateOptions)=>{\n        observer.mutate(variables, mutateOptions).catch(_utils_js__WEBPACK_IMPORTED_MODULE_4__.noop);\n    }, [\n        observer\n    ]);\n    if (result.error && (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.shouldThrowError)(observer.options.throwOnError, [\n        result.error\n    ])) {\n        throw result.error;\n    }\n    return {\n        ...result,\n        mutate,\n        mutateAsync: result.mutate\n    };\n}\n_s(useMutation, \"um7gJg726YUPST6vQMXsXZ5di7M=\", false, function() {\n    return [\n        _QueryClientProvider_js__WEBPACK_IMPORTED_MODULE_1__.useQueryClient\n    ];\n});\n //# sourceMappingURL=useMutation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3VzZU11dGF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ3VCO0FBQ3lCO0FBQ2pCO0FBQ1E7QUFVaEMsU0FBU00sWUFNZEMsT0FBQSxFQUNBQyxXQUFBOztJQUVBLE1BQU1DLFNBQVNOLHVFQUFjQSxDQUFDSztJQUU5QixNQUFNLENBQUNFLFNBQVEsR0FBVVYsMkNBQUEsQ0FDdkIsSUFDRSxJQUFJQyxrRUFBZ0JBLENBQ2xCUSxRQUNBRjtJQUlBUCw0Q0FBQSxDQUFVO1FBQ2RVLFNBQVNHLFVBQUEsQ0FBV047SUFDdEIsR0FBRztRQUFDRztRQUFVSDtLQUFRO0lBRXRCLE1BQU1PLFNBQWVkLHVEQUFBLENBQ2JBLDhDQUFBLENBQ0osQ0FBQ2lCLGdCQUNDUCxTQUFTUSxTQUFBLENBQVVoQiwrREFBYUEsQ0FBQ2lCLFVBQUEsQ0FBV0YsaUJBQzlDO1FBQUNQO0tBQVEsR0FFWCxJQUFNQSxTQUFTVSxnQkFBQSxJQUNmLElBQU1WLFNBQVNVLGdCQUFBO0lBR2pCLE1BQU1DLFNBQWVyQiw4Q0FBQSxDQUduQixDQUFDc0IsV0FBV0M7UUFDVmIsU0FBU1csTUFBQSxDQUFPQyxXQUFXQyxlQUFlQyxLQUFBLENBQU1wQiwyQ0FBSUE7SUFDdEQsR0FDQTtRQUFDTTtLQUFRO0lBR1gsSUFDRUksT0FBT1csS0FBQSxJQUNQcEIsMkRBQWdCQSxDQUFDSyxTQUFTSCxPQUFBLENBQVFtQixZQUFBLEVBQWM7UUFBQ1osT0FBT1csS0FBSztLQUFDLEdBQzlEO1FBQ0EsTUFBTVgsT0FBT1csS0FBQTtJQUNmO0lBRUEsT0FBTztRQUFFLEdBQUdYLE1BQUE7UUFBUU87UUFBUU0sYUFBYWIsT0FBT08sTUFBQTtJQUFPO0FBQ3pEO0dBbERnQmY7O1FBU0NILG1FQUFjQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL3VzZU11dGF0aW9uLnRzP2MzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE11dGF0aW9uT2JzZXJ2ZXIsIG5vdGlmeU1hbmFnZXIgfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSdcbmltcG9ydCB7IHVzZVF1ZXJ5Q2xpZW50IH0gZnJvbSAnLi9RdWVyeUNsaWVudFByb3ZpZGVyJ1xuaW1wb3J0IHsgbm9vcCwgc2hvdWxkVGhyb3dFcnJvciB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgdHlwZSB7XG4gIFVzZU11dGF0ZUZ1bmN0aW9uLFxuICBVc2VNdXRhdGlvbk9wdGlvbnMsXG4gIFVzZU11dGF0aW9uUmVzdWx0LFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBEZWZhdWx0RXJyb3IsIFF1ZXJ5Q2xpZW50IH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5cbi8vIEhPT0tcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU11dGF0aW9uPFxuICBURGF0YSA9IHVua25vd24sXG4gIFRFcnJvciA9IERlZmF1bHRFcnJvcixcbiAgVFZhcmlhYmxlcyA9IHZvaWQsXG4gIFRDb250ZXh0ID0gdW5rbm93bixcbj4oXG4gIG9wdGlvbnM6IFVzZU11dGF0aW9uT3B0aW9uczxURGF0YSwgVEVycm9yLCBUVmFyaWFibGVzLCBUQ29udGV4dD4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBVc2VNdXRhdGlvblJlc3VsdDxURGF0YSwgVEVycm9yLCBUVmFyaWFibGVzLCBUQ29udGV4dD4ge1xuICBjb25zdCBjbGllbnQgPSB1c2VRdWVyeUNsaWVudChxdWVyeUNsaWVudClcblxuICBjb25zdCBbb2JzZXJ2ZXJdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgKCkgPT5cbiAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyPFREYXRhLCBURXJyb3IsIFRWYXJpYWJsZXMsIFRDb250ZXh0PihcbiAgICAgICAgY2xpZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgKSxcbiAgKVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgb2JzZXJ2ZXIuc2V0T3B0aW9ucyhvcHRpb25zKVxuICB9LCBbb2JzZXJ2ZXIsIG9wdGlvbnNdKVxuXG4gIGNvbnN0IHJlc3VsdCA9IFJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICAgKG9uU3RvcmVDaGFuZ2UpID0+XG4gICAgICAgIG9ic2VydmVyLnN1YnNjcmliZShub3RpZnlNYW5hZ2VyLmJhdGNoQ2FsbHMob25TdG9yZUNoYW5nZSkpLFxuICAgICAgW29ic2VydmVyXSxcbiAgICApLFxuICAgICgpID0+IG9ic2VydmVyLmdldEN1cnJlbnRSZXN1bHQoKSxcbiAgICAoKSA9PiBvYnNlcnZlci5nZXRDdXJyZW50UmVzdWx0KCksXG4gIClcblxuICBjb25zdCBtdXRhdGUgPSBSZWFjdC51c2VDYWxsYmFjazxcbiAgICBVc2VNdXRhdGVGdW5jdGlvbjxURGF0YSwgVEVycm9yLCBUVmFyaWFibGVzLCBUQ29udGV4dD5cbiAgPihcbiAgICAodmFyaWFibGVzLCBtdXRhdGVPcHRpb25zKSA9PiB7XG4gICAgICBvYnNlcnZlci5tdXRhdGUodmFyaWFibGVzLCBtdXRhdGVPcHRpb25zKS5jYXRjaChub29wKVxuICAgIH0sXG4gICAgW29ic2VydmVyXSxcbiAgKVxuXG4gIGlmIChcbiAgICByZXN1bHQuZXJyb3IgJiZcbiAgICBzaG91bGRUaHJvd0Vycm9yKG9ic2VydmVyLm9wdGlvbnMudGhyb3dPbkVycm9yLCBbcmVzdWx0LmVycm9yXSlcbiAgKSB7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yXG4gIH1cblxuICByZXR1cm4geyAuLi5yZXN1bHQsIG11dGF0ZSwgbXV0YXRlQXN5bmM6IHJlc3VsdC5tdXRhdGUgfVxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiTXV0YXRpb25PYnNlcnZlciIsIm5vdGlmeU1hbmFnZXIiLCJ1c2VRdWVyeUNsaWVudCIsIm5vb3AiLCJzaG91bGRUaHJvd0Vycm9yIiwidXNlTXV0YXRpb24iLCJvcHRpb25zIiwicXVlcnlDbGllbnQiLCJjbGllbnQiLCJvYnNlcnZlciIsInVzZVN0YXRlIiwidXNlRWZmZWN0Iiwic2V0T3B0aW9ucyIsInJlc3VsdCIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwidXNlQ2FsbGJhY2siLCJvblN0b3JlQ2hhbmdlIiwic3Vic2NyaWJlIiwiYmF0Y2hDYWxscyIsImdldEN1cnJlbnRSZXN1bHQiLCJtdXRhdGUiLCJ2YXJpYWJsZXMiLCJtdXRhdGVPcHRpb25zIiwiY2F0Y2giLCJlcnJvciIsInRocm93T25FcnJvciIsIm11dGF0ZUFzeW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useMutation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/useQuery.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useQuery: function() { return /* binding */ useQuery; }\n/* harmony export */ });\n/* harmony import */ var _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/query-core */ \"(app-pages-browser)/./node_modules/@tanstack/query-core/build/modern/queryObserver.js\");\n/* harmony import */ var _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useBaseQuery.js */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js\");\n/* __next_internal_client_entry_do_not_use__ useQuery auto */ var _s = $RefreshSig$();\n// src/useQuery.ts\n\n\nfunction useQuery(options, queryClient) {\n    _s();\n    return (0,_useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery)(options, _tanstack_query_core__WEBPACK_IMPORTED_MODULE_1__.QueryObserver, queryClient);\n}\n_s(useQuery, \"KQLwJ9Hz54v54vEsUujw5Lh1nqo=\", false, function() {\n    return [\n        _useBaseQuery_js__WEBPACK_IMPORTED_MODULE_0__.useBaseQuery\n    ];\n});\n //# sourceMappingURL=useQuery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3VzZVF1ZXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQzhCO0FBQ0Q7QUEwQ3RCLFNBQVNFLFNBQVNDLE9BQUEsRUFBMEJDLFdBQUE7O0lBQ2pELE9BQU9ILDhEQUFZQSxDQUFDRSxTQUFTSCwrREFBYUEsRUFBRUk7QUFDOUM7R0FGZ0JGOztRQUNQRCwwREFBWUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy91c2VRdWVyeS50cz9iZGJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IHsgUXVlcnlPYnNlcnZlciB9IGZyb20gJ0B0YW5zdGFjay9xdWVyeS1jb3JlJ1xuaW1wb3J0IHsgdXNlQmFzZVF1ZXJ5IH0gZnJvbSAnLi91c2VCYXNlUXVlcnknXG5pbXBvcnQgdHlwZSB7IERlZmF1bHRFcnJvciwgUXVlcnlDbGllbnQsIFF1ZXJ5S2V5IH0gZnJvbSAnQHRhbnN0YWNrL3F1ZXJ5LWNvcmUnXG5pbXBvcnQgdHlwZSB7XG4gIERlZmluZWRVc2VRdWVyeVJlc3VsdCxcbiAgVXNlUXVlcnlPcHRpb25zLFxuICBVc2VRdWVyeVJlc3VsdCxcbn0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB0eXBlIHtcbiAgRGVmaW5lZEluaXRpYWxEYXRhT3B0aW9ucyxcbiAgVW5kZWZpbmVkSW5pdGlhbERhdGFPcHRpb25zLFxufSBmcm9tICcuL3F1ZXJ5T3B0aW9ucydcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVF1ZXJ5PFxuICBUUXVlcnlGbkRhdGEgPSB1bmtub3duLFxuICBURXJyb3IgPSBEZWZhdWx0RXJyb3IsXG4gIFREYXRhID0gVFF1ZXJ5Rm5EYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSA9IFF1ZXJ5S2V5LFxuPihcbiAgb3B0aW9uczogRGVmaW5lZEluaXRpYWxEYXRhT3B0aW9uczxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeUtleT4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBEZWZpbmVkVXNlUXVlcnlSZXN1bHQ8VERhdGEsIFRFcnJvcj5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVF1ZXJ5PFxuICBUUXVlcnlGbkRhdGEgPSB1bmtub3duLFxuICBURXJyb3IgPSBEZWZhdWx0RXJyb3IsXG4gIFREYXRhID0gVFF1ZXJ5Rm5EYXRhLFxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSA9IFF1ZXJ5S2V5LFxuPihcbiAgb3B0aW9uczogVW5kZWZpbmVkSW5pdGlhbERhdGFPcHRpb25zPFRRdWVyeUZuRGF0YSwgVEVycm9yLCBURGF0YSwgVFF1ZXJ5S2V5PixcbiAgcXVlcnlDbGllbnQ/OiBRdWVyeUNsaWVudCxcbik6IFVzZVF1ZXJ5UmVzdWx0PFREYXRhLCBURXJyb3I+XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VRdWVyeTxcbiAgVFF1ZXJ5Rm5EYXRhID0gdW5rbm93bixcbiAgVEVycm9yID0gRGVmYXVsdEVycm9yLFxuICBURGF0YSA9IFRRdWVyeUZuRGF0YSxcbiAgVFF1ZXJ5S2V5IGV4dGVuZHMgUXVlcnlLZXkgPSBRdWVyeUtleSxcbj4oXG4gIG9wdGlvbnM6IFVzZVF1ZXJ5T3B0aW9uczxUUXVlcnlGbkRhdGEsIFRFcnJvciwgVERhdGEsIFRRdWVyeUtleT4sXG4gIHF1ZXJ5Q2xpZW50PzogUXVlcnlDbGllbnQsXG4pOiBVc2VRdWVyeVJlc3VsdDxURGF0YSwgVEVycm9yPlxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUXVlcnkob3B0aW9uczogVXNlUXVlcnlPcHRpb25zLCBxdWVyeUNsaWVudD86IFF1ZXJ5Q2xpZW50KSB7XG4gIHJldHVybiB1c2VCYXNlUXVlcnkob3B0aW9ucywgUXVlcnlPYnNlcnZlciwgcXVlcnlDbGllbnQpXG59XG4iXSwibmFtZXMiOlsiUXVlcnlPYnNlcnZlciIsInVzZUJhc2VRdWVyeSIsInVzZVF1ZXJ5Iiwib3B0aW9ucyIsInF1ZXJ5Q2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tanstack/react-query/build/modern/utils.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   shouldThrowError: function() { return /* binding */ shouldThrowError; }\n/* harmony export */ });\n// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\n\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtcXVlcnkvYnVpbGQvbW9kZXJuL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXF1ZXJ5L2J1aWxkL21vZGVybi91dGlscy5qcz80ZjlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy50c1xuZnVuY3Rpb24gc2hvdWxkVGhyb3dFcnJvcih0aHJvd0Vycm9yLCBwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiB0aHJvd0Vycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdGhyb3dFcnJvciguLi5wYXJhbXMpO1xuICB9XG4gIHJldHVybiAhIXRocm93RXJyb3I7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuZXhwb3J0IHtcbiAgbm9vcCxcbiAgc2hvdWxkVGhyb3dFcnJvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs":
/*!*****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: function() { return /* binding */ clsx; }\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ __webpack_exports__[\"default\"] = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsYUFBYSwrQ0FBK0MsZ0RBQWdELGVBQWUsUUFBUSxJQUFJLDBDQUEwQyx5Q0FBeUMsU0FBZ0IsZ0JBQWdCLHdDQUF3QyxJQUFJLG1EQUFtRCxTQUFTLCtEQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcz82YzNkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/eventemitter3/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/eventemitter3/index.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: function() { return /* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(app-pages-browser)/./node_modules/eventemitter3/index.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFZDtBQUN2QiwrREFBZSxzQ0FBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanM/MTc4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vaW5kZXguanMnXG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/eventemitter3/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fetch-cookie/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/fetch-cookie/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ fetchCookie; }\n/* harmony export */ });\n/* harmony import */ var tough_cookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tough-cookie */ \"(app-pages-browser)/./node_modules/tough-cookie/lib/cookie.js\");\n/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! set-cookie-parser */ \"(app-pages-browser)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\n\n\nfunction isDomainOrSubdomain(destination, original) {\n  const orig = new URL(original).hostname;\n  const dest = new URL(destination).hostname;\n  return orig === dest || orig.endsWith(`.${dest}`);\n}\nconst referrerPolicy = /* @__PURE__ */ new Set([\n  \"\",\n  \"no-referrer\",\n  \"no-referrer-when-downgrade\",\n  \"same-origin\",\n  \"origin\",\n  \"strict-origin\",\n  \"origin-when-cross-origin\",\n  \"strict-origin-when-cross-origin\",\n  \"unsafe-url\"\n]);\nfunction parseReferrerPolicy(policyHeader) {\n  const policyTokens = policyHeader.split(/[,\\s]+/);\n  let policy = \"\";\n  for (const token of policyTokens) {\n    if (token !== \"\" && referrerPolicy.has(token)) {\n      policy = token;\n    }\n  }\n  return policy;\n}\nfunction doNothing(init, name) {\n}\nfunction callDeleteMethod(init, name) {\n  init.headers.delete(name);\n}\nfunction deleteFromObject(init, name) {\n  const headers = init.headers;\n  for (const key of Object.keys(headers)) {\n    if (key.toLowerCase() === name) {\n      delete headers[key];\n    }\n  }\n}\nfunction identifyDeleteHeader(init) {\n  if (init.headers == null) {\n    return doNothing;\n  }\n  if (typeof init.headers.delete === \"function\") {\n    return callDeleteMethod;\n  }\n  return deleteFromObject;\n}\nconst redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);\nfunction isRedirect(status) {\n  return redirectStatus.has(status);\n}\nasync function handleRedirect(fetchImpl, init, response) {\n  switch (init.redirect ?? \"follow\") {\n    case \"error\":\n      throw new TypeError(`URI requested responded with a redirect and redirect mode is set to error: ${response.url}`);\n    case \"manual\":\n      return response;\n    case \"follow\":\n      break;\n    default:\n      throw new TypeError(`Invalid redirect option: ${init.redirect}`);\n  }\n  const locationUrl = response.headers.get(\"location\");\n  if (locationUrl === null) {\n    return response;\n  }\n  const requestUrl = response.url;\n  const redirectUrl = new URL(locationUrl, requestUrl).toString();\n  const redirectCount = init.redirectCount ?? 0;\n  const maxRedirect = init.maxRedirect ?? 20;\n  if (redirectCount >= maxRedirect) {\n    throw new TypeError(`Reached maximum redirect of ${maxRedirect} for URL: ${requestUrl}`);\n  }\n  init = {\n    ...init,\n    redirectCount: redirectCount + 1\n  };\n  const deleteHeader = identifyDeleteHeader(init);\n  if (!isDomainOrSubdomain(requestUrl, redirectUrl)) {\n    for (const name of [\"authorization\", \"www-authenticate\", \"cookie\", \"cookie2\"]) {\n      deleteHeader(init, name);\n    }\n  }\n  const maybeNodeStreamBody = init.body;\n  const maybeStreamBody = init.body;\n  if (response.status !== 303 && init.body != null && (typeof maybeNodeStreamBody.pipe === \"function\" || typeof maybeStreamBody.pipeTo === \"function\")) {\n    throw new TypeError(\"Cannot follow redirect with body being a readable stream\");\n  }\n  if (response.status === 303 || (response.status === 301 || response.status === 302) && init.method === \"POST\") {\n    init.method = \"GET\";\n    init.body = void 0;\n    deleteHeader(init, \"content-length\");\n  }\n  if (response.headers.has(\"referrer-policy\")) {\n    init.referrerPolicy = parseReferrerPolicy(response.headers.get(\"referrer-policy\"));\n  }\n  return await fetchImpl(redirectUrl, init);\n}\nfunction addCookiesToRequest(input, init, cookie) {\n  if (cookie === \"\") {\n    return init;\n  }\n  const maybeRequest = input;\n  const maybeHeaders = init.headers;\n  if (maybeRequest.headers && typeof maybeRequest.headers.append === \"function\") {\n    maybeRequest.headers.append(\"cookie\", cookie);\n  } else if (maybeHeaders && typeof maybeHeaders.append === \"function\") {\n    maybeHeaders.append(\"cookie\", cookie);\n  } else {\n    init = { ...init, headers: { ...init.headers, cookie } };\n  }\n  return init;\n}\nfunction getCookiesFromResponse(response) {\n  const maybeNodeFetchHeaders = response.headers;\n  if (typeof maybeNodeFetchHeaders.getAll === \"function\") {\n    return maybeNodeFetchHeaders.getAll(\"set-cookie\");\n  }\n  if (typeof maybeNodeFetchHeaders.raw === \"function\") {\n    const headers = maybeNodeFetchHeaders.raw();\n    if (Array.isArray(headers[\"set-cookie\"])) {\n      return headers[\"set-cookie\"];\n    }\n    return [];\n  }\n  const cookieString = response.headers.get(\"set-cookie\");\n  if (cookieString !== null) {\n    return (0,set_cookie_parser__WEBPACK_IMPORTED_MODULE_1__.splitCookiesString)(cookieString);\n  }\n  return [];\n}\nfunction fetchCookie(fetch, jar, ignoreError = true) {\n  const actualFetch = fetch;\n  const actualJar = jar ?? new tough_cookie__WEBPACK_IMPORTED_MODULE_0__.CookieJar();\n  async function fetchCookieWrapper(input, init) {\n    const originalInit = init ?? {};\n    init = { ...init, redirect: \"manual\" };\n    const requestUrl = typeof input === \"string\" ? input : input.url ?? input.href;\n    const cookie = await actualJar.getCookieString(requestUrl);\n    init = addCookiesToRequest(input, init, cookie);\n    const response = await actualFetch(input, init);\n    const cookies = getCookiesFromResponse(response);\n    await Promise.all(cookies.map(async (cookie2) => await actualJar.setCookie(cookie2, response.url, { ignoreError })));\n    if ((init.redirectCount ?? 0) > 0) {\n      Object.defineProperty(response, \"redirected\", { value: true });\n    }\n    if (!isRedirect(response.status)) {\n      return response;\n    }\n    return await handleRedirect(fetchCookieWrapper, originalInit, response);\n  }\n  fetchCookieWrapper.toughCookie = /*#__PURE__*/ (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(tough_cookie__WEBPACK_IMPORTED_MODULE_0__, 2)));\n  return fetchCookieWrapper;\n}\nfetchCookie.toughCookie = /*#__PURE__*/ (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (tough_cookie__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(tough_cookie__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mZXRjaC1jb29raWUvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0M7QUFDaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLGFBQWE7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWEsV0FBVyxXQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFlO0FBQzlDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxhQUFhO0FBQ3JIO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhNQUFLO0FBQ3hDO0FBQ0E7QUFDQSwwQkFBMEIsOE1BQUs7QUFHN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZldGNoLWNvb2tpZS9lc20vaW5kZXguanM/NmMxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0b3VnaCBmcm9tIFwidG91Z2gtY29va2llXCI7XG5pbXBvcnQgeyBzcGxpdENvb2tpZXNTdHJpbmcgfSBmcm9tIFwic2V0LWNvb2tpZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGlzRG9tYWluT3JTdWJkb21haW4oZGVzdGluYXRpb24sIG9yaWdpbmFsKSB7XG4gIGNvbnN0IG9yaWcgPSBuZXcgVVJMKG9yaWdpbmFsKS5ob3N0bmFtZTtcbiAgY29uc3QgZGVzdCA9IG5ldyBVUkwoZGVzdGluYXRpb24pLmhvc3RuYW1lO1xuICByZXR1cm4gb3JpZyA9PT0gZGVzdCB8fCBvcmlnLmVuZHNXaXRoKGAuJHtkZXN0fWApO1xufVxuY29uc3QgcmVmZXJyZXJQb2xpY3kgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiXCIsXG4gIFwibm8tcmVmZXJyZXJcIixcbiAgXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiLFxuICBcInNhbWUtb3JpZ2luXCIsXG4gIFwib3JpZ2luXCIsXG4gIFwic3RyaWN0LW9yaWdpblwiLFxuICBcIm9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiLFxuICBcInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIixcbiAgXCJ1bnNhZmUtdXJsXCJcbl0pO1xuZnVuY3Rpb24gcGFyc2VSZWZlcnJlclBvbGljeShwb2xpY3lIZWFkZXIpIHtcbiAgY29uc3QgcG9saWN5VG9rZW5zID0gcG9saWN5SGVhZGVyLnNwbGl0KC9bLFxcc10rLyk7XG4gIGxldCBwb2xpY3kgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHBvbGljeVRva2Vucykge1xuICAgIGlmICh0b2tlbiAhPT0gXCJcIiAmJiByZWZlcnJlclBvbGljeS5oYXModG9rZW4pKSB7XG4gICAgICBwb2xpY3kgPSB0b2tlbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvbGljeTtcbn1cbmZ1bmN0aW9uIGRvTm90aGluZyhpbml0LCBuYW1lKSB7XG59XG5mdW5jdGlvbiBjYWxsRGVsZXRlTWV0aG9kKGluaXQsIG5hbWUpIHtcbiAgaW5pdC5oZWFkZXJzLmRlbGV0ZShuYW1lKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZyb21PYmplY3QoaW5pdCwgbmFtZSkge1xuICBjb25zdCBoZWFkZXJzID0gaW5pdC5oZWFkZXJzO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xuICAgICAgZGVsZXRlIGhlYWRlcnNba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlkZW50aWZ5RGVsZXRlSGVhZGVyKGluaXQpIHtcbiAgaWYgKGluaXQuaGVhZGVycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRvTm90aGluZztcbiAgfVxuICBpZiAodHlwZW9mIGluaXQuaGVhZGVycy5kZWxldGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjYWxsRGVsZXRlTWV0aG9kO1xuICB9XG4gIHJldHVybiBkZWxldGVGcm9tT2JqZWN0O1xufVxuY29uc3QgcmVkaXJlY3RTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmZ1bmN0aW9uIGlzUmVkaXJlY3Qoc3RhdHVzKSB7XG4gIHJldHVybiByZWRpcmVjdFN0YXR1cy5oYXMoc3RhdHVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlZGlyZWN0KGZldGNoSW1wbCwgaW5pdCwgcmVzcG9uc2UpIHtcbiAgc3dpdGNoIChpbml0LnJlZGlyZWN0ID8/IFwiZm9sbG93XCIpIHtcbiAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVSSSByZXF1ZXN0ZWQgcmVzcG9uZGVkIHdpdGggYSByZWRpcmVjdCBhbmQgcmVkaXJlY3QgbW9kZSBpcyBzZXQgdG8gZXJyb3I6ICR7cmVzcG9uc2UudXJsfWApO1xuICAgIGNhc2UgXCJtYW51YWxcIjpcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICBjYXNlIFwiZm9sbG93XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByZWRpcmVjdCBvcHRpb246ICR7aW5pdC5yZWRpcmVjdH1gKTtcbiAgfVxuICBjb25zdCBsb2NhdGlvblVybCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwibG9jYXRpb25cIik7XG4gIGlmIChsb2NhdGlvblVybCA9PT0gbnVsbCkge1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBjb25zdCByZXF1ZXN0VXJsID0gcmVzcG9uc2UudXJsO1xuICBjb25zdCByZWRpcmVjdFVybCA9IG5ldyBVUkwobG9jYXRpb25VcmwsIHJlcXVlc3RVcmwpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHJlZGlyZWN0Q291bnQgPSBpbml0LnJlZGlyZWN0Q291bnQgPz8gMDtcbiAgY29uc3QgbWF4UmVkaXJlY3QgPSBpbml0Lm1heFJlZGlyZWN0ID8/IDIwO1xuICBpZiAocmVkaXJlY3RDb3VudCA+PSBtYXhSZWRpcmVjdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlYWNoZWQgbWF4aW11bSByZWRpcmVjdCBvZiAke21heFJlZGlyZWN0fSBmb3IgVVJMOiAke3JlcXVlc3RVcmx9YCk7XG4gIH1cbiAgaW5pdCA9IHtcbiAgICAuLi5pbml0LFxuICAgIHJlZGlyZWN0Q291bnQ6IHJlZGlyZWN0Q291bnQgKyAxXG4gIH07XG4gIGNvbnN0IGRlbGV0ZUhlYWRlciA9IGlkZW50aWZ5RGVsZXRlSGVhZGVyKGluaXQpO1xuICBpZiAoIWlzRG9tYWluT3JTdWJkb21haW4ocmVxdWVzdFVybCwgcmVkaXJlY3RVcmwpKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIFtcImF1dGhvcml6YXRpb25cIiwgXCJ3d3ctYXV0aGVudGljYXRlXCIsIFwiY29va2llXCIsIFwiY29va2llMlwiXSkge1xuICAgICAgZGVsZXRlSGVhZGVyKGluaXQsIG5hbWUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXliZU5vZGVTdHJlYW1Cb2R5ID0gaW5pdC5ib2R5O1xuICBjb25zdCBtYXliZVN0cmVhbUJvZHkgPSBpbml0LmJvZHk7XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDMwMyAmJiBpbml0LmJvZHkgIT0gbnVsbCAmJiAodHlwZW9mIG1heWJlTm9kZVN0cmVhbUJvZHkucGlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBtYXliZVN0cmVhbUJvZHkucGlwZVRvID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtXCIpO1xuICB9XG4gIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDMwMyB8fCAocmVzcG9uc2Uuc3RhdHVzID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAzMDIpICYmIGluaXQubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgIGluaXQubWV0aG9kID0gXCJHRVRcIjtcbiAgICBpbml0LmJvZHkgPSB2b2lkIDA7XG4gICAgZGVsZXRlSGVhZGVyKGluaXQsIFwiY29udGVudC1sZW5ndGhcIik7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuaGFzKFwicmVmZXJyZXItcG9saWN5XCIpKSB7XG4gICAgaW5pdC5yZWZlcnJlclBvbGljeSA9IHBhcnNlUmVmZXJyZXJQb2xpY3kocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJyZWZlcnJlci1wb2xpY3lcIikpO1xuICB9XG4gIHJldHVybiBhd2FpdCBmZXRjaEltcGwocmVkaXJlY3RVcmwsIGluaXQpO1xufVxuZnVuY3Rpb24gYWRkQ29va2llc1RvUmVxdWVzdChpbnB1dCwgaW5pdCwgY29va2llKSB7XG4gIGlmIChjb29raWUgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuICBjb25zdCBtYXliZVJlcXVlc3QgPSBpbnB1dDtcbiAgY29uc3QgbWF5YmVIZWFkZXJzID0gaW5pdC5oZWFkZXJzO1xuICBpZiAobWF5YmVSZXF1ZXN0LmhlYWRlcnMgJiYgdHlwZW9mIG1heWJlUmVxdWVzdC5oZWFkZXJzLmFwcGVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbWF5YmVSZXF1ZXN0LmhlYWRlcnMuYXBwZW5kKFwiY29va2llXCIsIGNvb2tpZSk7XG4gIH0gZWxzZSBpZiAobWF5YmVIZWFkZXJzICYmIHR5cGVvZiBtYXliZUhlYWRlcnMuYXBwZW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBtYXliZUhlYWRlcnMuYXBwZW5kKFwiY29va2llXCIsIGNvb2tpZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5pdCA9IHsgLi4uaW5pdCwgaGVhZGVyczogeyAuLi5pbml0LmhlYWRlcnMsIGNvb2tpZSB9IH07XG4gIH1cbiAgcmV0dXJuIGluaXQ7XG59XG5mdW5jdGlvbiBnZXRDb29raWVzRnJvbVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIGNvbnN0IG1heWJlTm9kZUZldGNoSGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG4gIGlmICh0eXBlb2YgbWF5YmVOb2RlRmV0Y2hIZWFkZXJzLmdldEFsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG1heWJlTm9kZUZldGNoSGVhZGVycy5nZXRBbGwoXCJzZXQtY29va2llXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgbWF5YmVOb2RlRmV0Y2hIZWFkZXJzLnJhdyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG1heWJlTm9kZUZldGNoSGVhZGVycy5yYXcoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzW1wic2V0LWNvb2tpZVwiXSkpIHtcbiAgICAgIHJldHVybiBoZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGNvb2tpZVN0cmluZyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwic2V0LWNvb2tpZVwiKTtcbiAgaWYgKGNvb2tpZVN0cmluZyAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBmZXRjaENvb2tpZShmZXRjaCwgamFyLCBpZ25vcmVFcnJvciA9IHRydWUpIHtcbiAgY29uc3QgYWN0dWFsRmV0Y2ggPSBmZXRjaDtcbiAgY29uc3QgYWN0dWFsSmFyID0gamFyID8/IG5ldyB0b3VnaC5Db29raWVKYXIoKTtcbiAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDb29raWVXcmFwcGVyKGlucHV0LCBpbml0KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxJbml0ID0gaW5pdCA/PyB7fTtcbiAgICBpbml0ID0geyAuLi5pbml0LCByZWRpcmVjdDogXCJtYW51YWxcIiB9O1xuICAgIGNvbnN0IHJlcXVlc3RVcmwgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBpbnB1dCA6IGlucHV0LnVybCA/PyBpbnB1dC5ocmVmO1xuICAgIGNvbnN0IGNvb2tpZSA9IGF3YWl0IGFjdHVhbEphci5nZXRDb29raWVTdHJpbmcocmVxdWVzdFVybCk7XG4gICAgaW5pdCA9IGFkZENvb2tpZXNUb1JlcXVlc3QoaW5wdXQsIGluaXQsIGNvb2tpZSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhY3R1YWxGZXRjaChpbnB1dCwgaW5pdCk7XG4gICAgY29uc3QgY29va2llcyA9IGdldENvb2tpZXNGcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGNvb2tpZXMubWFwKGFzeW5jIChjb29raWUyKSA9PiBhd2FpdCBhY3R1YWxKYXIuc2V0Q29va2llKGNvb2tpZTIsIHJlc3BvbnNlLnVybCwgeyBpZ25vcmVFcnJvciB9KSkpO1xuICAgIGlmICgoaW5pdC5yZWRpcmVjdENvdW50ID8/IDApID4gMCkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCBcInJlZGlyZWN0ZWRcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgaWYgKCFpc1JlZGlyZWN0KHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGhhbmRsZVJlZGlyZWN0KGZldGNoQ29va2llV3JhcHBlciwgb3JpZ2luYWxJbml0LCByZXNwb25zZSk7XG4gIH1cbiAgZmV0Y2hDb29raWVXcmFwcGVyLnRvdWdoQ29va2llID0gdG91Z2g7XG4gIHJldHVybiBmZXRjaENvb2tpZVdyYXBwZXI7XG59XG5mZXRjaENvb2tpZS50b3VnaENvb2tpZSA9IHRvdWdoO1xuZXhwb3J0IHtcbiAgZmV0Y2hDb29raWUgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fetch-cookie/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js":
/*!**************************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/LosslessNumber.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: function() { return /* binding */ LosslessNumber; },\n/* harmony export */   isLosslessNumber: function() { return /* binding */ isLosslessNumber; },\n/* harmony export */   toLosslessNumber: function() { return /* binding */ toLosslessNumber; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nclass LosslessNumber {\n  // numeric value as string\n\n  // type information\n  isLosslessNumber = true;\n  constructor(value) {\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(value)) {\n      throw new Error('Invalid number (value: \"' + value + '\")');\n    }\n    this.value = value;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf() {\n    const unsafeReason = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getUnsafeNumberReason)(this.value);\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === _utils_js__WEBPACK_IMPORTED_MODULE_0__.UnsafeNumberReason.truncate_float) {\n      return parseFloat(this.value);\n    }\n\n    // truncate_integer\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isInteger)(this.value)) {\n      return BigInt(this.value);\n    }\n\n    // overflow or underflow\n    throw new Error('Cannot safely convert to number: ' + `the value '${this.value}' would ${unsafeReason} and become ${parseFloat(this.value)}`);\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString() {\n    return this.value;\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nfunction isLosslessNumber(value) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return value && typeof value === 'object' && value.isLosslessNumber === true || false;\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nfunction toLosslessNumber(value) {\n  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.extractSignificantDigits)(value + '').length > 15) {\n    throw new Error('Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself ' + `(value: ${value})`);\n  }\n  if (isNaN(value)) {\n    throw new Error('Invalid number: NaN');\n  }\n  if (!isFinite(value)) {\n    throw new Error('Invalid number: ' + value);\n  }\n  return new LosslessNumber(String(value));\n}\n//# sourceMappingURL=LosslessNumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vTG9zc2xlc3NOdW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzSDs7QUFFdEg7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnRUFBcUI7O0FBRTlDO0FBQ0EsdURBQXVELHlEQUFrQjtBQUN6RTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxvREFBUztBQUNqQjtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLFdBQVcsVUFBVSxjQUFjLGFBQWEsdUJBQXVCO0FBQy9JOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxNQUFNLG1FQUF3QjtBQUM5QixtSUFBbUksTUFBTTtBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL0xvc3NsZXNzTnVtYmVyLmpzP2FkMTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzLCBnZXRVbnNhZmVOdW1iZXJSZWFzb24sIGlzSW50ZWdlciwgaXNOdW1iZXIsIFVuc2FmZU51bWJlclJlYXNvbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgbG9zc2xlc3MgbnVtYmVyLiBTdG9yZXMgaXRzIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBMb3NzbGVzc051bWJlciB7XG4gIC8vIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXG5cbiAgLy8gdHlwZSBpbmZvcm1hdGlvblxuICBpc0xvc3NsZXNzTnVtYmVyID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciAodmFsdWU6IFwiJyArIHZhbHVlICsgJ1wiKScpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgTG9zc2xlc3NOdW1iZXIgYXMgbnVtYmVyIG9yIGJpZ2ludC5cbiAgICpcbiAgICogLSBhIG51bWJlciBpcyByZXR1cm5lZCBmb3Igc2FmZSBudW1iZXJzIGFuZCBkZWNpbWFsIHZhbHVlcyB0aGF0IG9ubHkgbG9zZSBzb21lIGluc2lnbmlmaWNhbnQgZGlnaXRzXG4gICAqIC0gYSBiaWdpbnQgaXMgcmV0dXJuZWQgZm9yIGJpZyBpbnRlZ2VyIG51bWJlcnNcbiAgICogLSBhbiBFcnJvciBpcyB0aHJvd24gZm9yIHZhbHVlcyB0aGF0IHdpbGwgb3ZlcmZsb3cgb3IgdW5kZXJmbG93XG4gICAqXG4gICAqIE5vdGUgdGhhdCB5b3UgY2FuIGltcGxlbWVudCB5b3VyIG93biBzdHJhdGVneSBmb3IgY29udmVyc2lvbiBieSBqdXN0IGdldHRpbmcgdGhlIHZhbHVlIGFzIHN0cmluZ1xuICAgKiB2aWEgLnRvU3RyaW5nKCksIGFuZCB1c2luZyB1dGlsIGZ1bmN0aW9ucyBsaWtlIGlzSW50ZWdlciwgaXNTYWZlTnVtYmVyLCBnZXRVbnNhZmVOdW1iZXJSZWFzb24sXG4gICAqIGFuZCB0b1NhZmVOdW1iZXJPclRocm93IHRvIGNvbnZlcnQgaXQgdG8gYSBudW1lcmljIHZhbHVlLlxuICAgKi9cbiAgdmFsdWVPZigpIHtcbiAgICBjb25zdCB1bnNhZmVSZWFzb24gPSBnZXRVbnNhZmVOdW1iZXJSZWFzb24odGhpcy52YWx1ZSk7XG5cbiAgICAvLyBzYWZlIG9yIHRydW5jYXRlX2Zsb2F0XG4gICAgaWYgKHVuc2FmZVJlYXNvbiA9PT0gdW5kZWZpbmVkIHx8IHVuc2FmZVJlYXNvbiA9PT0gVW5zYWZlTnVtYmVyUmVhc29uLnRydW5jYXRlX2Zsb2F0KSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyB0cnVuY2F0ZV9pbnRlZ2VyXG4gICAgaWYgKGlzSW50ZWdlcih0aGlzLnZhbHVlKSkge1xuICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBvdmVyZmxvdyBvciB1bmRlcmZsb3dcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzYWZlbHkgY29udmVydCB0byBudW1iZXI6ICcgKyBgdGhlIHZhbHVlICcke3RoaXMudmFsdWV9JyB3b3VsZCAke3Vuc2FmZVJlYXNvbn0gYW5kIGJlY29tZSAke3BhcnNlRmxvYXQodGhpcy52YWx1ZSl9YCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgTG9zc2xlc3NOdW1iZXIgYXMgc3RyaW5nLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvLyBOb3RlOiB3ZSBkbyBOT1QgaW1wbGVtZW50IGEgLnRvSlNPTigpIG1ldGhvZCwgYW5kIHlvdSBzaG91bGQgbm90IGltcGxlbWVudFxuICAvLyBvciB1c2UgdGhhdCwgaXQgY2Fubm90IHNhZmVseSB0dXJuIHRoZSBudW1lcmljIHZhbHVlIGluIHRoZSBzdHJpbmcgaW50b1xuICAvLyBzdHJpbmdpZmllZCBKU09OIHNpbmNlIGl0IGhhcyB0byBiZSBwYXJzZWQgaW50byBhIG51bWJlciBmaXJzdC5cbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBhIExvc3NsZXNzTnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvc3NsZXNzTnVtYmVyKHZhbHVlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5pc0xvc3NsZXNzTnVtYmVyID09PSB0cnVlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgaW50byBhIExvc3NsZXNzTnVtYmVyIGlmIHRoaXMgaXMgcG9zc2libGUgaW4gYSBzYWZlIHdheVxuICogSWYgdGhlIHZhbHVlIGhhcyB0b28gbWFueSBkaWdpdHMsIG9yIGlzIE5hTiBvciBJbmZpbml0eSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTG9zc2xlc3NOdW1iZXIodmFsdWUpIHtcbiAgaWYgKGV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh2YWx1ZSArICcnKS5sZW5ndGggPiAxNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXI6IGNvbnRhaW5zIG1vcmUgdGhhbiAxNSBkaWdpdHMgYW5kIGlzIG1vc3QgbGlrZWx5IHRydW5jYXRlZCBhbmQgdW5zYWZlIGJ5IGl0c2VsZiAnICsgYCh2YWx1ZTogJHt2YWx1ZX0pYCk7XG4gIH1cbiAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXI6IE5hTicpO1xuICB9XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlcjogJyArIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbmV3IExvc3NsZXNzTnVtYmVyKFN0cmluZyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9zc2xlc3NOdW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/config.js":
/*!******************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/config.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: function() { return /* binding */ config; }\n/* harmony export */ });\n/**\n * Get and/or set configuration options\n * @deprecated There is no config anymore\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction config(options) {\n  // Backward compatibility warning for v1.x\n  throw new Error('config is deprecated, support for circularRefs is removed from the library. ' + 'If you encounter circular references in your data structures, ' + 'please rethink your datastructures: ' + 'better prevent circular references in the first place.');\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vY29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9zc2xlc3MtanNvbi9saWIvZXNtL2NvbmZpZy5qcz9iZDA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2V0IGFuZC9vciBzZXQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAZGVwcmVjYXRlZCBUaGVyZSBpcyBubyBjb25maWcgYW55bW9yZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5leHBvcnQgZnVuY3Rpb24gY29uZmlnKG9wdGlvbnMpIHtcbiAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSB3YXJuaW5nIGZvciB2MS54XG4gIHRocm93IG5ldyBFcnJvcignY29uZmlnIGlzIGRlcHJlY2F0ZWQsIHN1cHBvcnQgZm9yIGNpcmN1bGFyUmVmcyBpcyByZW1vdmVkIGZyb20gdGhlIGxpYnJhcnkuICcgKyAnSWYgeW91IGVuY291bnRlciBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgZGF0YSBzdHJ1Y3R1cmVzLCAnICsgJ3BsZWFzZSByZXRoaW5rIHlvdXIgZGF0YXN0cnVjdHVyZXM6ICcgKyAnYmV0dGVyIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB0aGUgZmlyc3QgcGxhY2UuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LosslessNumber: function() { return /* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.LosslessNumber; },\n/* harmony export */   UnsafeNumberReason: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.UnsafeNumberReason; },\n/* harmony export */   config: function() { return /* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_0__.config; },\n/* harmony export */   getUnsafeNumberReason: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.getUnsafeNumberReason; },\n/* harmony export */   isInteger: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isInteger; },\n/* harmony export */   isLosslessNumber: function() { return /* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.isLosslessNumber; },\n/* harmony export */   isNumber: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isNumber; },\n/* harmony export */   isSafeNumber: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.isSafeNumber; },\n/* harmony export */   parse: function() { return /* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_1__.parse; },\n/* harmony export */   parseLosslessNumber: function() { return /* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseLosslessNumber; },\n/* harmony export */   parseNumberAndBigInt: function() { return /* reexport safe */ _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__.parseNumberAndBigInt; },\n/* harmony export */   reviveDate: function() { return /* reexport safe */ _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__.reviveDate; },\n/* harmony export */   stringify: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify; },\n/* harmony export */   toLosslessNumber: function() { return /* reexport safe */ _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__.toLosslessNumber; },\n/* harmony export */   toSafeNumberOrThrow: function() { return /* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_6__.toSafeNumberOrThrow; }\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/config.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/stringify.js\");\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _reviveDate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reviveDate.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/reviveDate.js\");\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./numberParsers.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/types.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDRjtBQUNRO0FBQzhDO0FBQzVDO0FBQ2tDO0FBQ2dEO0FBQ3BHO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vaW5kZXguanM/MTBjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZy5qcyc7XG5leHBvcnQgeyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnO1xuZXhwb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgTG9zc2xlc3NOdW1iZXIsIGlzTG9zc2xlc3NOdW1iZXIsIHRvTG9zc2xlc3NOdW1iZXIgfSBmcm9tICcuL0xvc3NsZXNzTnVtYmVyLmpzJztcbmV4cG9ydCB7IHJldml2ZURhdGUgfSBmcm9tICcuL3Jldml2ZURhdGUuanMnO1xuZXhwb3J0IHsgcGFyc2VMb3NzbGVzc051bWJlciwgcGFyc2VOdW1iZXJBbmRCaWdJbnQgfSBmcm9tICcuL251bWJlclBhcnNlcnMuanMnO1xuZXhwb3J0IHsgVW5zYWZlTnVtYmVyUmVhc29uLCBpc0ludGVnZXIsIGlzTnVtYmVyLCBpc1NhZmVOdW1iZXIsIHRvU2FmZU51bWJlck9yVGhyb3csIGdldFVuc2FmZU51bWJlclJlYXNvbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js":
/*!*************************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/numberParsers.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseLosslessNumber: function() { return /* binding */ parseLosslessNumber; },\n/* harmony export */   parseNumberAndBigInt: function() { return /* binding */ parseNumberAndBigInt; }\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n\n\nfunction parseLosslessNumber(value) {\n  return new _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.LosslessNumber(value);\n}\nfunction parseNumberAndBigInt(value) {\n  return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isInteger)(value) ? BigInt(value) : parseFloat(value);\n}\n//# sourceMappingURL=numberParsers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vbnVtYmVyUGFyc2Vycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXFEO0FBQ2Q7QUFDaEM7QUFDUCxhQUFhLDhEQUFjO0FBQzNCO0FBQ087QUFDUCxTQUFTLG9EQUFTO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9udW1iZXJQYXJzZXJzLmpzP2FiMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9zc2xlc3NOdW1iZXIgfSBmcm9tICcuL0xvc3NsZXNzTnVtYmVyLmpzJztcbmltcG9ydCB7IGlzSW50ZWdlciB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTG9zc2xlc3NOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBMb3NzbGVzc051bWJlcih2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VOdW1iZXJBbmRCaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgPyBCaWdJbnQodmFsdWUpIDogcGFyc2VGbG9hdCh2YWx1ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXJQYXJzZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/parse.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codeLowercaseA: function() { return /* binding */ codeLowercaseA; },\n/* harmony export */   codeLowercaseE: function() { return /* binding */ codeLowercaseE; },\n/* harmony export */   codeLowercaseF: function() { return /* binding */ codeLowercaseF; },\n/* harmony export */   codeUppercaseA: function() { return /* binding */ codeUppercaseA; },\n/* harmony export */   codeUppercaseE: function() { return /* binding */ codeUppercaseE; },\n/* harmony export */   codeUppercaseF: function() { return /* binding */ codeUppercaseF; },\n/* harmony export */   isDeepEqual: function() { return /* binding */ isDeepEqual; },\n/* harmony export */   isValidStringCharacter: function() { return /* binding */ isValidStringCharacter; },\n/* harmony export */   parse: function() { return /* binding */ parse; }\n/* harmony export */ });\n/* harmony import */ var _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberParsers.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/numberParsers.js\");\n/* harmony import */ var _revive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./revive.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/revive.js\");\n\n\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nfunction parse(text, reviver) {\n  let parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _numberParsers_js__WEBPACK_IMPORTED_MODULE_0__.parseLosslessNumber;\n  let i = 0;\n  const value = parseValue();\n  expectValue(value);\n  expectEndOfInput();\n  return reviver ? (0,_revive_js__WEBPACK_IMPORTED_MODULE_1__.revive)(value, reviver) : value;\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++;\n      skipWhitespace();\n      const object = {};\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma();\n          skipWhitespace();\n        } else {\n          initial = false;\n        }\n        const start = i;\n        const key = parseString();\n        if (key === undefined) {\n          throwObjectKeyExpected();\n          return; // To make TS happy\n        }\n        skipWhitespace();\n        eatColon();\n        const value = parseValue();\n        if (value === undefined) {\n          throwObjectValueExpected();\n          return; // To make TS happy\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1);\n        }\n        object[key] = value;\n      }\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected();\n      }\n      i++;\n      return object;\n    }\n  }\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++;\n      skipWhitespace();\n      const array = [];\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma();\n        } else {\n          initial = false;\n        }\n        const value = parseValue();\n        expectArrayItem(value);\n        array.push(value);\n      }\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected();\n      }\n      i++;\n      return array;\n    }\n  }\n  function parseValue() {\n    skipWhitespace();\n    const value = parseString() ?? parseNumeric() ?? parseObject() ?? parseArray() ?? parseKeyword('true', true) ?? parseKeyword('false', false) ?? parseKeyword('null', null);\n    skipWhitespace();\n    return value;\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length;\n      return value;\n    }\n  }\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++;\n    }\n  }\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++;\n      let result = '';\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1];\n          const escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            result += escapeChar;\n            i++;\n          } else if (char === 'u') {\n            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));\n              i += 5;\n            } else {\n              throwInvalidUnicodeCharacter(i);\n            }\n          } else {\n            throwInvalidEscapeCharacter(i);\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i];\n          } else {\n            throwInvalidCharacter(text[i]);\n          }\n        }\n        i++;\n      }\n      expectEndOfString();\n      i++;\n      return result;\n    }\n  }\n  function parseNumeric() {\n    const start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      expectDigit(start);\n    }\n    if (text.charCodeAt(i) === codeZero) {\n      i++;\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++;\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (i > start) {\n      return parseNumber(text.slice(start, i));\n    }\n  }\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`);\n    }\n    i++;\n  }\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`);\n    }\n    i++;\n  }\n  function expectValue(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`);\n    }\n  }\n  function expectArrayItem(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`);\n    }\n  }\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`);\n    }\n  }\n  function expectDigit(start) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i);\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`);\n    }\n  }\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`);\n    }\n  }\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`);\n  }\n  function throwDuplicateKey(key, pos) {\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`);\n  }\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`);\n  }\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`);\n  }\n  function throwInvalidCharacter(char) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`);\n  }\n  function throwInvalidEscapeCharacter(start) {\n    const chars = text.slice(start, start + 2);\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`);\n  }\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`);\n  }\n  function throwInvalidUnicodeCharacter(start) {\n    const chars = text.slice(start, start + 6);\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`);\n  }\n\n  // zero based character position\n  function pos() {\n    return `at position ${i}`;\n  }\n  function got() {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input';\n  }\n  function gotAt() {\n    return got() + ' ' + pos();\n  }\n}\nfunction isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n  return code >= codeOne && code <= codeNine;\n}\nfunction isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nfunction isDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]));\n  }\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])];\n    return keys.every(key => isDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\n// map with all escape characters\nconst escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\nconst codeBackslash = 0x5c; // \"\\\"\nconst codeOpeningBrace = 0x7b; // \"{\"\nconst codeClosingBrace = 0x7d; // \"}\"\nconst codeOpeningBracket = 0x5b; // \"[\"\nconst codeClosingBracket = 0x5d; // \"]\"\nconst codeSpace = 0x20; // \" \"\nconst codeNewline = 0xa; // \"\\n\"\nconst codeTab = 0x9; // \"\\t\"\nconst codeReturn = 0xd; // \"\\r\"\nconst codeDoubleQuote = 0x0022; // \"\nconst codePlus = 0x2b; // \"+\"\nconst codeMinus = 0x2d; // \"-\"\nconst codeZero = 0x30;\nconst codeOne = 0x31;\nconst codeNine = 0x39;\nconst codeComma = 0x2c; // \",\"\nconst codeDot = 0x2e; // \".\" (dot, period)\nconst codeColon = 0x3a; // \":\"\nconst codeUppercaseA = 0x41; // \"A\"\nconst codeLowercaseA = 0x61; // \"a\"\nconst codeUppercaseE = 0x45; // \"E\"\nconst codeLowercaseE = 0x65; // \"e\"\nconst codeUppercaseF = 0x46; // \"F\"\nconst codeLowercaseF = 0x66; // \"f\"\n//# sourceMappingURL=parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBeUQ7QUFDcEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdGQUF3RixrRUFBbUI7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEUsbURBQW1ELElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFFBQVE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVMsdUJBQXVCLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0EsNENBQTRDLElBQUksNEJBQTRCLElBQUk7QUFDaEY7QUFDQTtBQUNBLGdFQUFnRSxhQUFhLFFBQVE7QUFDckY7QUFDQTtBQUNBLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSyxJQUFJLE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE1BQU0sSUFBSSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTSxJQUFJLE1BQU07QUFDeEU7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLCtCQUErQixLQUFLO0FBQ3BDLCtCQUErQixLQUFLO0FBQ3BDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ2pCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcGFyc2UuanM/YTdjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZUxvc3NsZXNzTnVtYmVyIH0gZnJvbSAnLi9udW1iZXJQYXJzZXJzLmpzJztcbmltcG9ydCB7IHJldml2ZSB9IGZyb20gJy4vcmV2aXZlLmpzJztcbi8qKlxuICogVGhlIExvc3NsZXNzSlNPTi5wYXJzZSgpIG1ldGhvZCBwYXJzZXMgYSBzdHJpbmcgYXMgSlNPTiwgb3B0aW9uYWxseSB0cmFuc2Zvcm1pbmdcbiAqIHRoZSB2YWx1ZSBwcm9kdWNlZCBieSBwYXJzaW5nLlxuICpcbiAqIFRoZSBwYXJzZXIgaXMgYmFzZWQgb24gdGhlIHBhcnNlciBvZiBUYW4gTGkgSG91IHNoYXJlZCBpblxuICogaHR0cHM6Ly9saWhhdXRhbi5jb20vanNvbi1wYXJzZXItd2l0aC1qYXZhc2NyaXB0L1xuICpcbiAqIEBwYXJhbSB0ZXh0XG4gKiBUaGUgc3RyaW5nIHRvIHBhcnNlIGFzIEpTT04uIFNlZSB0aGUgSlNPTiBvYmplY3QgZm9yIGEgZGVzY3JpcHRpb24gb2YgSlNPTiBzeW50YXguXG4gKlxuICogQHBhcmFtIFtyZXZpdmVyXVxuICogSWYgYSBmdW5jdGlvbiwgcHJlc2NyaWJlcyBob3cgdGhlIHZhbHVlIG9yaWdpbmFsbHkgcHJvZHVjZWQgYnkgcGFyc2luZyBpc1xuICogdHJhbnNmb3JtZWQsIGJlZm9yZSBiZWluZyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gW3BhcnNlTnVtYmVyPXBhcnNlTG9zc2xlc3NOdW1iZXJdXG4gKiBQYXNzIGEgY3VzdG9tIG51bWJlciBwYXJzZXIuIElucHV0IGlzIGEgc3RyaW5nLCBhbmQgdGhlIG91dHB1dCBjYW4gYmUgdW5rbm93blxuICogbnVtZXJpYyB2YWx1ZTogbnVtYmVyLCBiaWdpbnQsIExvc3NsZXNzTnVtYmVyLCBvciBhIGN1c3RvbSBCaWdOdW1iZXIgbGlicmFyeS5cbiAqXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRoZSBPYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gSlNPTiB0ZXh0LlxuICpcbiAqIEB0aHJvd3MgVGhyb3dzIGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uIGlmIHRoZSBzdHJpbmcgdG8gcGFyc2UgaXMgbm90IHZhbGlkIEpTT04uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0LCByZXZpdmVyKSB7XG4gIGxldCBwYXJzZU51bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcGFyc2VMb3NzbGVzc051bWJlcjtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlVmFsdWUoKTtcbiAgZXhwZWN0VmFsdWUodmFsdWUpO1xuICBleHBlY3RFbmRPZklucHV0KCk7XG4gIHJldHVybiByZXZpdmVyID8gcmV2aXZlKHZhbHVlLCByZXZpdmVyKSA6IHZhbHVlO1xuICBmdW5jdGlvbiBwYXJzZU9iamVjdCgpIHtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlT3BlbmluZ0JyYWNlKSB7XG4gICAgICBpKys7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG4gICAgICBsZXQgaW5pdGlhbCA9IHRydWU7XG4gICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFjZSkge1xuICAgICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgICBlYXRDb21tYSgpO1xuICAgICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VTdHJpbmcoKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3dPYmplY3RLZXlFeHBlY3RlZCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gVG8gbWFrZSBUUyBoYXBweVxuICAgICAgICB9XG4gICAgICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgICAgIGVhdENvbG9uKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VWYWx1ZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93T2JqZWN0VmFsdWVFeHBlY3RlZCgpO1xuICAgICAgICAgIHJldHVybjsgLy8gVG8gbWFrZSBUUyBoYXBweVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogdGVzdCBkZWVwIGVxdWFsIGluc3RlYWQgb2Ygc3RyaWN0IGVxdWFsXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmICFpc0RlZXBFcXVhbCh2YWx1ZSwgb2JqZWN0W2tleV0pKSB7XG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNvdWxkIGFsc28gdGVzdCBgaWYoa2V5IGluIG9iamVjdCkgey4uLn1gXG4gICAgICAgICAgLy8gb3IgYGlmIChvYmplY3Rba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHsuLi59YCwgYnV0IHRoYXQgaXMgc2xvd2VyLlxuICAgICAgICAgIHRocm93RHVwbGljYXRlS2V5KGtleSwgc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFjZSkge1xuICAgICAgICB0aHJvd09iamVjdEtleU9yRW5kRXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gY29kZU9wZW5pbmdCcmFja2V0KSB7XG4gICAgICBpKys7XG4gICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgIGxldCBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlQ2xvc2luZ0JyYWNrZXQpIHtcbiAgICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgICAgZWF0Q29tbWEoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZVZhbHVlKCk7XG4gICAgICAgIGV4cGVjdEFycmF5SXRlbSh2YWx1ZSk7XG4gICAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNsb3NpbmdCcmFja2V0KSB7XG4gICAgICAgIHRocm93QXJyYXlJdGVtT3JFbmRFeHBlY3RlZCgpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXJzZVZhbHVlKCkge1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZVN0cmluZygpID8/IHBhcnNlTnVtZXJpYygpID8/IHBhcnNlT2JqZWN0KCkgPz8gcGFyc2VBcnJheSgpID8/IHBhcnNlS2V5d29yZCgndHJ1ZScsIHRydWUpID8/IHBhcnNlS2V5d29yZCgnZmFsc2UnLCBmYWxzZSkgPz8gcGFyc2VLZXl3b3JkKCdudWxsJywgbnVsbCk7XG4gICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VLZXl3b3JkKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRleHQuc2xpY2UoaSwgaSArIG5hbWUubGVuZ3RoKSA9PT0gbmFtZSkge1xuICAgICAgaSArPSBuYW1lLmxlbmd0aDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgaSsrO1xuICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgd2hpbGUgKGkgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlQmFja3NsYXNoKSB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgICAgIGNvbnN0IGVzY2FwZUNoYXIgPSBlc2NhcGVDaGFyYWN0ZXJzW2NoYXJdO1xuICAgICAgICAgIGlmIChlc2NhcGVDaGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3UnKSB7XG4gICAgICAgICAgICBpZiAoaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyAyKSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyAzKSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyA0KSkgJiYgaXNIZXgodGV4dC5jaGFyQ29kZUF0KGkgKyA1KSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodGV4dC5zbGljZShpICsgMiwgaSArIDYpLCAxNikpO1xuICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvd0ludmFsaWRVbmljb2RlQ2hhcmFjdGVyKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0ludmFsaWRFc2NhcGVDaGFyYWN0ZXIoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1ZhbGlkU3RyaW5nQ2hhcmFjdGVyKHRleHQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0W2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0ludmFsaWRDaGFyYWN0ZXIodGV4dFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGV4cGVjdEVuZE9mU3RyaW5nKCk7XG4gICAgICBpKys7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXJzZU51bWVyaWMoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVNaW51cykge1xuICAgICAgaSsrO1xuICAgICAgZXhwZWN0RGlnaXQoc3RhcnQpO1xuICAgIH1cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlWmVybykge1xuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoaXNOb25aZXJvRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVEb3QpIHtcbiAgICAgIGkrKztcbiAgICAgIGV4cGVjdERpZ2l0KHN0YXJ0KTtcbiAgICAgIHdoaWxlIChpc0RpZ2l0KHRleHQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlTG93ZXJjYXNlRSB8fCB0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IGNvZGVVcHBlcmNhc2VFKSB7XG4gICAgICBpKys7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlTWludXMgfHwgdGV4dC5jaGFyQ29kZUF0KGkpID09PSBjb2RlUGx1cykge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBleHBlY3REaWdpdChzdGFydCk7XG4gICAgICB3aGlsZSAoaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiBzdGFydCkge1xuICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHRleHQuc2xpY2Uoc3RhcnQsIGkpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZWF0Q29tbWEoKSB7XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSAhPT0gY29kZUNvbW1hKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENvbW1hICcsJyBleHBlY3RlZCBhZnRlciB2YWx1ZSAke2dvdEF0KCl9YCk7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICBmdW5jdGlvbiBlYXRDb2xvbigpIHtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpICE9PSBjb2RlQ29sb24pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgQ29sb24gJzonIGV4cGVjdGVkIGFmdGVyIHByb3BlcnR5IG5hbWUgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBKU09OIHZhbHVlIGV4cGVjdGVkICR7Z290QXQoKX1gKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXhwZWN0QXJyYXlJdGVtKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgQXJyYXkgaXRlbSBleHBlY3RlZCAke2dvdEF0KCl9YCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4cGVjdEVuZE9mSW5wdXQoKSB7XG4gICAgaWYgKGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBlbmQgb2YgaW5wdXQgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHBlY3REaWdpdChzdGFydCkge1xuICAgIGlmICghaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICBjb25zdCBudW1Tb0ZhciA9IHRleHQuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIG51bWJlciAnJHtudW1Tb0Zhcn0nLCBleHBlY3RpbmcgYSBkaWdpdCAke2dvdEF0KCl9YCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV4cGVjdEVuZE9mU3RyaW5nKCkge1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgIT09IGNvZGVEb3VibGVRdW90ZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFbmQgb2Ygc3RyaW5nICdcIicgZXhwZWN0ZWQgJHtnb3RBdCgpfWApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0aHJvd09iamVjdEtleUV4cGVjdGVkKCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgUXVvdGVkIG9iamVjdCBrZXkgZXhwZWN0ZWQgJHtnb3RBdCgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93RHVwbGljYXRlS2V5KGtleSwgcG9zKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBEdXBsaWNhdGUga2V5ICcke2tleX0nIGVuY291bnRlcmVkIGF0IHBvc2l0aW9uICR7cG9zfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93T2JqZWN0S2V5T3JFbmRFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFF1b3RlZCBvYmplY3Qga2V5IG9yIGVuZCBvZiBvYmplY3QgJ30nIGV4cGVjdGVkICR7Z290QXQoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0FycmF5SXRlbU9yRW5kRXhwZWN0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBBcnJheSBpdGVtIG9yIGVuZCBvZiBhcnJheSAnXScgZXhwZWN0ZWQgJHtnb3RBdCgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93SW52YWxpZENoYXJhY3RlcihjaGFyKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciAnJHtjaGFyfScgJHtwb3MoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0ludmFsaWRFc2NhcGVDaGFyYWN0ZXIoc3RhcnQpIHtcbiAgICBjb25zdCBjaGFycyA9IHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgMik7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIGVzY2FwZSBjaGFyYWN0ZXIgJyR7Y2hhcnN9JyAke3BvcygpfWApO1xuICB9XG4gIGZ1bmN0aW9uIHRocm93T2JqZWN0VmFsdWVFeHBlY3RlZCgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE9iamVjdCB2YWx1ZSBleHBlY3RlZCBhZnRlciAnOicgJHtwb3MoKX1gKTtcbiAgfVxuICBmdW5jdGlvbiB0aHJvd0ludmFsaWRVbmljb2RlQ2hhcmFjdGVyKHN0YXJ0KSB7XG4gICAgY29uc3QgY2hhcnMgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIDYpO1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCB1bmljb2RlIGNoYXJhY3RlciAnJHtjaGFyc30nICR7cG9zKCl9YCk7XG4gIH1cblxuICAvLyB6ZXJvIGJhc2VkIGNoYXJhY3RlciBwb3NpdGlvblxuICBmdW5jdGlvbiBwb3MoKSB7XG4gICAgcmV0dXJuIGBhdCBwb3NpdGlvbiAke2l9YDtcbiAgfVxuICBmdW5jdGlvbiBnb3QoKSB7XG4gICAgcmV0dXJuIGkgPCB0ZXh0Lmxlbmd0aCA/IGBidXQgZ290ICcke3RleHRbaV19J2AgOiAnYnV0IHJlYWNoZWQgZW5kIG9mIGlucHV0JztcbiAgfVxuICBmdW5jdGlvbiBnb3RBdCgpIHtcbiAgICByZXR1cm4gZ290KCkgKyAnICcgKyBwb3MoKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IGNvZGVTcGFjZSB8fCBjb2RlID09PSBjb2RlTmV3bGluZSB8fCBjb2RlID09PSBjb2RlVGFiIHx8IGNvZGUgPT09IGNvZGVSZXR1cm47XG59XG5mdW5jdGlvbiBpc0hleChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IGNvZGVaZXJvICYmIGNvZGUgPD0gY29kZU5pbmUgfHwgY29kZSA+PSBjb2RlVXBwZXJjYXNlQSAmJiBjb2RlIDw9IGNvZGVVcHBlcmNhc2VGIHx8IGNvZGUgPj0gY29kZUxvd2VyY2FzZUEgJiYgY29kZSA8PSBjb2RlTG93ZXJjYXNlRjtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSBjb2RlWmVybyAmJiBjb2RlIDw9IGNvZGVOaW5lO1xufVxuZnVuY3Rpb24gaXNOb25aZXJvRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSBjb2RlT25lICYmIGNvZGUgPD0gY29kZU5pbmU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFN0cmluZ0NoYXJhY3Rlcihjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDB4MjAgJiYgY29kZSA8PSAweDEwZmZmZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGlzRGVlcEVxdWFsKGl0ZW0sIGJbaW5kZXhdKSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpKSB7XG4gICAgY29uc3Qga2V5cyA9IFsuLi5uZXcgU2V0KFsuLi5PYmplY3Qua2V5cyhhKSwgLi4uT2JqZWN0LmtleXMoYildKV07XG4gICAgcmV0dXJuIGtleXMuZXZlcnkoa2V5ID0+IGlzRGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8vIG1hcCB3aXRoIGFsbCBlc2NhcGUgY2hhcmFjdGVyc1xuY29uc3QgZXNjYXBlQ2hhcmFjdGVycyA9IHtcbiAgJ1wiJzogJ1wiJyxcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gICcvJzogJy8nLFxuICBiOiAnXFxiJyxcbiAgZjogJ1xcZicsXG4gIG46ICdcXG4nLFxuICByOiAnXFxyJyxcbiAgdDogJ1xcdCdcbiAgLy8gbm90ZSB0aGF0IFxcdSBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgaW4gcGFyc2VTdHJpbmcoKVxufTtcbmNvbnN0IGNvZGVCYWNrc2xhc2ggPSAweDVjOyAvLyBcIlxcXCJcbmNvbnN0IGNvZGVPcGVuaW5nQnJhY2UgPSAweDdiOyAvLyBcIntcIlxuY29uc3QgY29kZUNsb3NpbmdCcmFjZSA9IDB4N2Q7IC8vIFwifVwiXG5jb25zdCBjb2RlT3BlbmluZ0JyYWNrZXQgPSAweDViOyAvLyBcIltcIlxuY29uc3QgY29kZUNsb3NpbmdCcmFja2V0ID0gMHg1ZDsgLy8gXCJdXCJcbmNvbnN0IGNvZGVTcGFjZSA9IDB4MjA7IC8vIFwiIFwiXG5jb25zdCBjb2RlTmV3bGluZSA9IDB4YTsgLy8gXCJcXG5cIlxuY29uc3QgY29kZVRhYiA9IDB4OTsgLy8gXCJcXHRcIlxuY29uc3QgY29kZVJldHVybiA9IDB4ZDsgLy8gXCJcXHJcIlxuY29uc3QgY29kZURvdWJsZVF1b3RlID0gMHgwMDIyOyAvLyBcIlxuY29uc3QgY29kZVBsdXMgPSAweDJiOyAvLyBcIitcIlxuY29uc3QgY29kZU1pbnVzID0gMHgyZDsgLy8gXCItXCJcbmNvbnN0IGNvZGVaZXJvID0gMHgzMDtcbmNvbnN0IGNvZGVPbmUgPSAweDMxO1xuY29uc3QgY29kZU5pbmUgPSAweDM5O1xuY29uc3QgY29kZUNvbW1hID0gMHgyYzsgLy8gXCIsXCJcbmNvbnN0IGNvZGVEb3QgPSAweDJlOyAvLyBcIi5cIiAoZG90LCBwZXJpb2QpXG5jb25zdCBjb2RlQ29sb24gPSAweDNhOyAvLyBcIjpcIlxuZXhwb3J0IGNvbnN0IGNvZGVVcHBlcmNhc2VBID0gMHg0MTsgLy8gXCJBXCJcbmV4cG9ydCBjb25zdCBjb2RlTG93ZXJjYXNlQSA9IDB4NjE7IC8vIFwiYVwiXG5leHBvcnQgY29uc3QgY29kZVVwcGVyY2FzZUUgPSAweDQ1OyAvLyBcIkVcIlxuZXhwb3J0IGNvbnN0IGNvZGVMb3dlcmNhc2VFID0gMHg2NTsgLy8gXCJlXCJcbmV4cG9ydCBjb25zdCBjb2RlVXBwZXJjYXNlRiA9IDB4NDY7IC8vIFwiRlwiXG5leHBvcnQgY29uc3QgY29kZUxvd2VyY2FzZUYgPSAweDY2OyAvLyBcImZcIlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/parse.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/revive.js":
/*!******************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/revive.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   revive: function() { return /* binding */ revive; }\n/* harmony export */ });\n/* harmony import */ var _LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LosslessNumber.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/LosslessNumber.js\");\n\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nfunction revive(json, reviver) {\n  return reviveValue({\n    '': json\n  }, '', json, reviver);\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  } else if (value && typeof value === 'object' && !(0,_LosslessNumber_js__WEBPACK_IMPORTED_MODULE_0__.isLosslessNumber)(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver));\n  } else {\n    return reviver.call(context, key, value);\n  }\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object, reviver) {\n  Object.keys(object).forEach(key => {\n    const value = reviveValue(object, key, object[key], reviver);\n    if (value !== undefined) {\n      object[key] = value;\n    } else {\n      delete object[key];\n    }\n  });\n  return object;\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array, reviver) {\n  for (let i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, i + '', array[i], reviver);\n  }\n  return array;\n}\n//# sourceMappingURL=revive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcmV2aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQWdELG9FQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcmV2aXZlLmpzP2M0MzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNMb3NzbGVzc051bWJlciB9IGZyb20gJy4vTG9zc2xlc3NOdW1iZXIuanMnO1xuLyoqXG4gKiBSZXZpdmUgYSBqc29uIG9iamVjdC5cbiAqIEFwcGxpZXMgdGhlIHJldml2ZXIgZnVuY3Rpb24gcmVjdXJzaXZlbHkgb24gYWxsIHZhbHVlcyBpbiB0aGUgSlNPTiBvYmplY3QuXG4gKiBAcGFyYW0ganNvbiAgIEEgSlNPTiBPYmplY3QsIEFycmF5LCBvciB2YWx1ZVxuICogQHBhcmFtIHJldml2ZXJcbiAqICAgICAgICAgICAgICBBIHJldml2ZXIgZnVuY3Rpb24gaW52b2tlZCB3aXRoIGFyZ3VtZW50cyBga2V5YCBhbmQgYHZhbHVlYCxcbiAqICAgICAgICAgICAgICB3aGljaCBtdXN0IHJldHVybiBhIHJlcGxhY2VtZW50IHZhbHVlLiBUaGUgZnVuY3Rpb24gY29udGV4dFxuICogICAgICAgICAgICAgIChgdGhpc2ApIGlzIHRoZSBPYmplY3Qgb3IgQXJyYXkgdGhhdCBjb250YWlucyB0aGUgY3VycmVudGx5XG4gKiAgICAgICAgICAgICAgaGFuZGxlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldml2ZShqc29uLCByZXZpdmVyKSB7XG4gIHJldHVybiByZXZpdmVWYWx1ZSh7XG4gICAgJyc6IGpzb25cbiAgfSwgJycsIGpzb24sIHJldml2ZXIpO1xufVxuXG4vKipcbiAqIFJldml2ZSBhIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHJldml2ZVZhbHVlKGNvbnRleHQsIGtleSwgdmFsdWUsIHJldml2ZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChjb250ZXh0LCBrZXksIHJldml2ZUFycmF5KHZhbHVlLCByZXZpdmVyKSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhaXNMb3NzbGVzc051bWJlcih2YWx1ZSkpIHtcbiAgICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2UgZm9yIExvc3NsZXNzTnVtYmVyLFxuICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBpbnRlcm5hbHMgb2YgYSBMb3NzbGVzc051bWJlclxuICAgIHJldHVybiByZXZpdmVyLmNhbGwoY29udGV4dCwga2V5LCByZXZpdmVPYmplY3QodmFsdWUsIHJldml2ZXIpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV2aXZlci5jYWxsKGNvbnRleHQsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogUmV2aXZlIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiByZXZpdmVPYmplY3Qob2JqZWN0LCByZXZpdmVyKSB7XG4gIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcmV2aXZlVmFsdWUob2JqZWN0LCBrZXksIG9iamVjdFtrZXldLCByZXZpdmVyKTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG9iamVjdFtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogUmV2aXZlIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIEFycmF5XG4gKi9cbmZ1bmN0aW9uIHJldml2ZUFycmF5KGFycmF5LCByZXZpdmVyKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHJldml2ZVZhbHVlKGFycmF5LCBpICsgJycsIGFycmF5W2ldLCByZXZpdmVyKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZpdmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/revive.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/reviveDate.js":
/*!**********************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/reviveDate.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reviveDate: function() { return /* binding */ reviveDate; }\n/* harmony export */ });\n/**\n * Revive a string containing an ISO 8601 date string into a JavaScript `Date` object\n */\nfunction reviveDate(key, value) {\n  return typeof value === 'string' && isoDateRegex.test(value) ? new Date(value) : value;\n}\n\n// Matches strings like \"2022-08-25T09:39:19.288Z\"\nconst isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;\n//# sourceMappingURL=reviveDate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vcmV2aXZlRGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDakUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS9yZXZpdmVEYXRlLmpzPzZlNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXZpdmUgYSBzdHJpbmcgY29udGFpbmluZyBhbiBJU08gODYwMSBkYXRlIHN0cmluZyBpbnRvIGEgSmF2YVNjcmlwdCBgRGF0ZWAgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXZpdmVEYXRlKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgaXNvRGF0ZVJlZ2V4LnRlc3QodmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogdmFsdWU7XG59XG5cbi8vIE1hdGNoZXMgc3RyaW5ncyBsaWtlIFwiMjAyMi0wOC0yNVQwOTozOToxOS4yODhaXCJcbmNvbnN0IGlzb0RhdGVSZWdleCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn1cXC5cXGR7M31aJC87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZpdmVEYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/reviveDate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/stringify.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringify: function() { return /* binding */ stringify; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\");\n\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */\nfunction stringify(value, replacer, space, numberStringifiers) {\n  const resolvedSpace = resolveSpace(space);\n  const replacedValue = typeof replacer === 'function' ? replacer.call({\n    '': value\n  }, '', value) : value;\n  return stringifyValue(replacedValue, '');\n\n  /**\n   * Stringify a value\n   */\n  function stringifyValue(value, indent) {\n    if (Array.isArray(numberStringifiers)) {\n      const stringifier = numberStringifiers.find(item => item.test(value));\n      if (stringifier) {\n        const str = stringifier.stringify(value);\n        if (typeof str !== 'string' || !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isNumber)(str)) {\n          throw new Error('Invalid JSON number: ' + 'output of a number stringifier must be a string containing a JSON number ' + `(output: ${str})`);\n        }\n        return str;\n      }\n    }\n\n    // boolean, null, number, string, or date\n    if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value === null || value instanceof Date || value instanceof Boolean || value instanceof Number || value instanceof String) {\n      return JSON.stringify(value);\n    }\n\n    // lossless number, the secret ingredient :)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (value && value.isLosslessNumber) {\n      return value.toString();\n    }\n\n    // BigInt\n    if (typeof value === 'bigint') {\n      return value.toString();\n    }\n\n    // Array\n    if (Array.isArray(value)) {\n      return stringifyArray(value, indent);\n    }\n\n    // Object (test lastly!)\n    if (value && typeof value === 'object') {\n      return stringifyObject(value, indent);\n    }\n    return undefined;\n  }\n\n  /**\n   * Stringify an array\n   */\n  function stringifyArray(array, indent) {\n    if (array.length === 0) {\n      return '[]';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let str = resolvedSpace ? '[\\n' : '[';\n    for (let i = 0; i < array.length; i++) {\n      const item = typeof replacer === 'function' ? replacer.call(array, String(i), array[i]) : array[i];\n      if (resolvedSpace) {\n        str += childIndent;\n      }\n      if (typeof item !== 'undefined' && typeof item !== 'function') {\n        str += stringifyValue(item, childIndent);\n      } else {\n        str += 'null';\n      }\n      if (i < array.length - 1) {\n        str += resolvedSpace ? ',\\n' : ',';\n      }\n    }\n    str += resolvedSpace ? '\\n' + indent + ']' : ']';\n    return str;\n  }\n\n  /**\n   * Stringify an object\n   */\n  function stringifyObject(object, indent) {\n    if (typeof object.toJSON === 'function') {\n      return stringify(object.toJSON(), replacer, space, undefined);\n    }\n    const keys = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);\n    if (keys.length === 0) {\n      return '{}';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let first = true;\n    let str = resolvedSpace ? '{\\n' : '{';\n    keys.forEach(key => {\n      const value = typeof replacer === 'function' ? replacer.call(object, key, object[key]) : object[key];\n      if (includeProperty(key, value)) {\n        if (first) {\n          first = false;\n        } else {\n          str += resolvedSpace ? ',\\n' : ',';\n        }\n        const keyStr = JSON.stringify(key);\n        str += resolvedSpace ? childIndent + keyStr + ': ' : keyStr + ':';\n        str += stringifyValue(value, childIndent);\n      }\n    });\n    str += resolvedSpace ? '\\n' + indent + '}' : '}';\n    return str;\n  }\n\n  /**\n   * Test whether to include a property in a stringified object or not.\n   */\n  function includeProperty(key, value) {\n    return typeof value !== 'undefined' && typeof value !== 'function' && typeof value !== 'symbol';\n  }\n}\n\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */\nfunction resolveSpace(space) {\n  if (typeof space === 'number') {\n    return ' '.repeat(space);\n  }\n  if (typeof space === 'string' && space !== '') {\n    return space;\n  }\n  return undefined;\n}\n//# sourceMappingURL=stringify.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtREFBUTtBQUNoRCw4SUFBOEksSUFBSTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vc3RyaW5naWZ5LmpzPzA4NzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBUaGUgTG9zc2xlc3NKU09OLnN0cmluZ2lmeSgpIG1ldGhvZCBjb252ZXJ0cyBhIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBKU09OIHN0cmluZyxcbiAqIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHZhbHVlcyBpZiBhIHJlcGxhY2VyIGZ1bmN0aW9uIGlzIHNwZWNpZmllZCwgb3JcbiAqIG9wdGlvbmFsbHkgaW5jbHVkaW5nIG9ubHkgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGlmIGEgcmVwbGFjZXIgYXJyYXkgaXMgc3BlY2lmaWVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICogVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBKU09OIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gW3JlcGxhY2VyXVxuICogQSBmdW5jdGlvbiB0aGF0IGFsdGVycyB0aGUgYmVoYXZpb3Igb2YgdGhlIHN0cmluZ2lmaWNhdGlvbiBwcm9jZXNzLFxuICogb3IgYW4gYXJyYXkgb2YgU3RyaW5nIGFuZCBOdW1iZXIgb2JqZWN0cyB0aGF0IHNlcnZlIGFzIGEgd2hpdGVsaXN0IGZvclxuICogc2VsZWN0aW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2YWx1ZSBvYmplY3QgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIEpTT04gc3RyaW5nLlxuICogSWYgdGhpcyB2YWx1ZSBpcyBudWxsIG9yIG5vdCBwcm92aWRlZCwgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBhcmVcbiAqIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIFtzcGFjZV1cbiAqIEEgU3RyaW5nIG9yIE51bWJlciBvYmplY3QgdGhhdCdzIHVzZWQgdG8gaW5zZXJ0IHdoaXRlIHNwYWNlIGludG8gdGhlIG91dHB1dFxuICogSlNPTiBzdHJpbmcgZm9yIHJlYWRhYmlsaXR5IHB1cnBvc2VzLiBJZiB0aGlzIGlzIGEgTnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlXG4gKiBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycyB0byB1c2UgYXMgd2hpdGUgc3BhY2U7IHRoaXMgbnVtYmVyIGlzIGNhcHBlZCBhdCAxMFxuICogaWYgaXQncyBsYXJnZXIgdGhhbiB0aGF0LiBWYWx1ZXMgbGVzcyB0aGFuIDEgaW5kaWNhdGUgdGhhdCBubyBzcGFjZSBzaG91bGQgYmVcbiAqIHVzZWQuIElmIHRoaXMgaXMgYSBTdHJpbmcsIHRoZSBzdHJpbmcgKG9yIHRoZSBmaXJzdCAxMCBjaGFyYWN0ZXJzIG9mIHRoZSBzdHJpbmcsXG4gKiBpZiBpdCdzIGxvbmdlciB0aGFuIHRoYXQpIGlzIHVzZWQgYXMgd2hpdGUgc3BhY2UuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG5vdFxuICogcHJvdmlkZWQgKG9yIGlzIG51bGwpLCBubyB3aGl0ZSBzcGFjZSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbbnVtYmVyU3RyaW5naWZpZXJzXVxuICogQW4gb3B0aW9uYWwgbGlzdCB3aXRoIGFkZGl0aW9uYWwgbnVtYmVyIHN0cmluZ2lmaWVycywgZm9yIGV4YW1wbGUgdG8gc2VyaWFsaXplXG4gKiBhIEJpZ051bWJlci4gVGhlIG91dHB1dCBvZiB0aGUgZnVuY3Rpb24gbXVzdCBiZSB2YWxpZCBzdHJpbmdpZmllZCBKU09OLlxuICogV2hlbiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCwgdGhlIHByb3BlcnR5IHdpbGwgYmUgZGVsZXRlZCBmcm9tIHRoZSBvYmplY3QuXG4gKiBUaGUgZGlmZmVyZW5jZSB3aXRoIHVzaW5nIGEgYHJlcGxhY2VyYCBpcyB0aGF0IHRoZSBvdXRwdXQgb2YgYSBgcmVwbGFjZXJgXG4gKiBtdXN0IGJlIEpTT04gYW5kIHdpbGwgYmUgc3RyaW5naWZpZWQgYWZ0ZXJ3YXJkcywgd2hlcmVhcyB0aGUgb3V0cHV0IG9mIHRoZVxuICogYG51bWJlclN0cmluZ2lmaWVyc2AgaXMgYWxyZWFkeSBzdHJpbmdpZmllZCBKU09OLlxuICpcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKSB7XG4gIGNvbnN0IHJlc29sdmVkU3BhY2UgPSByZXNvbHZlU3BhY2Uoc3BhY2UpO1xuICBjb25zdCByZXBsYWNlZFZhbHVlID0gdHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nID8gcmVwbGFjZXIuY2FsbCh7XG4gICAgJyc6IHZhbHVlXG4gIH0sICcnLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgcmV0dXJuIHN0cmluZ2lmeVZhbHVlKHJlcGxhY2VkVmFsdWUsICcnKTtcblxuICAvKipcbiAgICogU3RyaW5naWZ5IGEgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVZhbHVlKHZhbHVlLCBpbmRlbnQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShudW1iZXJTdHJpbmdpZmllcnMpKSB7XG4gICAgICBjb25zdCBzdHJpbmdpZmllciA9IG51bWJlclN0cmluZ2lmaWVycy5maW5kKGl0ZW0gPT4gaXRlbS50ZXN0KHZhbHVlKSk7XG4gICAgICBpZiAoc3RyaW5naWZpZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gc3RyaW5naWZpZXIuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8ICFpc051bWJlcihzdHIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gbnVtYmVyOiAnICsgJ291dHB1dCBvZiBhIG51bWJlciBzdHJpbmdpZmllciBtdXN0IGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBKU09OIG51bWJlciAnICsgYChvdXRwdXQ6ICR7c3RyfSlgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJvb2xlYW4sIG51bGwsIG51bWJlciwgc3RyaW5nLCBvciBkYXRlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIGxvc3NsZXNzIG51bWJlciwgdGhlIHNlY3JldCBpbmdyZWRpZW50IDopXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNMb3NzbGVzc051bWJlcikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gQmlnSW50XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8vIEFycmF5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUsIGluZGVudCk7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0ICh0ZXN0IGxhc3RseSEpXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUsIGluZGVudCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5naWZ5IGFuIGFycmF5XG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdpZnlBcnJheShhcnJheSwgaW5kZW50KSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdbXSc7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkSW5kZW50ID0gcmVzb2x2ZWRTcGFjZSA/IGluZGVudCArIHJlc29sdmVkU3BhY2UgOiB1bmRlZmluZWQ7XG4gICAgbGV0IHN0ciA9IHJlc29sdmVkU3BhY2UgPyAnW1xcbicgOiAnWyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlcGxhY2VyLmNhbGwoYXJyYXksIFN0cmluZyhpKSwgYXJyYXlbaV0pIDogYXJyYXlbaV07XG4gICAgICBpZiAocmVzb2x2ZWRTcGFjZSkge1xuICAgICAgICBzdHIgKz0gY2hpbGRJbmRlbnQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpdGVtICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0ciArPSBzdHJpbmdpZnlWYWx1ZShpdGVtLCBjaGlsZEluZGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gJ251bGwnO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBhcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHN0ciArPSByZXNvbHZlZFNwYWNlID8gJyxcXG4nIDogJywnO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/ICdcXG4nICsgaW5kZW50ICsgJ10nIDogJ10nO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICAvKipcbiAgICogU3RyaW5naWZ5IGFuIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iamVjdCwgaW5kZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KG9iamVjdC50b0pTT04oKSwgcmVwbGFjZXIsIHNwYWNlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShyZXBsYWNlcikgPyByZXBsYWNlci5tYXAoU3RyaW5nKSA6IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ3t9JztcbiAgICB9XG4gICAgY29uc3QgY2hpbGRJbmRlbnQgPSByZXNvbHZlZFNwYWNlID8gaW5kZW50ICsgcmVzb2x2ZWRTcGFjZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzdHIgPSByZXNvbHZlZFNwYWNlID8gJ3tcXG4nIDogJ3snO1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgPyByZXBsYWNlci5jYWxsKG9iamVjdCwga2V5LCBvYmplY3Rba2V5XSkgOiBvYmplY3Rba2V5XTtcbiAgICAgIGlmIChpbmNsdWRlUHJvcGVydHkoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/ICcsXFxuJyA6ICcsJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlTdHIgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgICBzdHIgKz0gcmVzb2x2ZWRTcGFjZSA/IGNoaWxkSW5kZW50ICsga2V5U3RyICsgJzogJyA6IGtleVN0ciArICc6JztcbiAgICAgICAgc3RyICs9IHN0cmluZ2lmeVZhbHVlKHZhbHVlLCBjaGlsZEluZGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RyICs9IHJlc29sdmVkU3BhY2UgPyAnXFxuJyArIGluZGVudCArICd9JyA6ICd9JztcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0byBpbmNsdWRlIGEgcHJvcGVydHkgaW4gYSBzdHJpbmdpZmllZCBvYmplY3Qgb3Igbm90LlxuICAgKi9cbiAgZnVuY3Rpb24gaW5jbHVkZVByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3ltYm9sJztcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgYSBKU09OIHN0cmluZ2lmeSBzcGFjZTpcbiAqIHJlcGxhY2UgYSBudW1iZXIgd2l0aCBhIHN0cmluZyBjb250YWluaW5nIHRoYXQgbnVtYmVyIG9mIHNwYWNlc1xuICovXG5mdW5jdGlvbiByZXNvbHZlU3BhY2Uoc3BhY2UpIHtcbiAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyAnLnJlcGVhdChzcGFjZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycgJiYgc3BhY2UgIT09ICcnKSB7XG4gICAgcmV0dXJuIHNwYWNlO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/stringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/types.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/types.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6IjtBQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS90eXBlcy5qcz85MjgzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/lossless-json/lib/esm/utils.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnsafeNumberReason: function() { return /* binding */ UnsafeNumberReason; },\n/* harmony export */   extractSignificantDigits: function() { return /* binding */ extractSignificantDigits; },\n/* harmony export */   getUnsafeNumberReason: function() { return /* binding */ getUnsafeNumberReason; },\n/* harmony export */   isInteger: function() { return /* binding */ isInteger; },\n/* harmony export */   isNumber: function() { return /* binding */ isNumber; },\n/* harmony export */   isSafeNumber: function() { return /* binding */ isSafeNumber; },\n/* harmony export */   toSafeNumberOrThrow: function() { return /* binding */ toSafeNumberOrThrow; }\n/* harmony export */ });\n/**\n * Test whether a string contains an integer number\n */\nfunction isInteger(value) {\n  return INTEGER_REGEX.test(value);\n}\nconst INTEGER_REGEX = /^-?[0-9]+$/;\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nfunction isNumber(value) {\n  return NUMBER_REGEX.test(value);\n}\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/;\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nfunction isSafeNumber(value, config) {\n  const num = parseFloat(value);\n  const str = String(num);\n  const v = extractSignificantDigits(value);\n  const s = extractSignificantDigits(str);\n  if (v === s) {\n    return true;\n  }\n  if (config?.approx === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    const requiredDigits = 14;\n    if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {\n      return true;\n    }\n  }\n  return false;\n}\nlet UnsafeNumberReason = /*#__PURE__*/function (UnsafeNumberReason) {\n  UnsafeNumberReason[\"underflow\"] = \"underflow\";\n  UnsafeNumberReason[\"overflow\"] = \"overflow\";\n  UnsafeNumberReason[\"truncate_integer\"] = \"truncate_integer\";\n  UnsafeNumberReason[\"truncate_float\"] = \"truncate_float\";\n  return UnsafeNumberReason;\n}({});\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nfunction getUnsafeNumberReason(value) {\n  if (isSafeNumber(value, {\n    approx: false\n  })) {\n    return undefined;\n  }\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer;\n  }\n  const num = parseFloat(value);\n  if (!isFinite(num)) {\n    return UnsafeNumberReason.overflow;\n  }\n  if (num === 0) {\n    return UnsafeNumberReason.underflow;\n  }\n  return UnsafeNumberReason.truncate_float;\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nfunction toSafeNumberOrThrow(value, config) {\n  const number = parseFloat(value);\n  const unsafeReason = getUnsafeNumberReason(value);\n  if (config?.approx === true ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float : unsafeReason) {\n    const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, '');\n    throw new Error('Cannot safely convert to number: ' + `the value '${value}' would ${unsafeReasonText} and become ${number}`);\n  }\n  return number;\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nfunction extractSignificantDigits(value) {\n  return value\n  // from \"-0.250e+30\" to \"-0.250\"\n  .replace(EXPONENTIAL_PART_REGEX, '')\n\n  // from \"-0.250\" to \"-0250\"\n  .replace(DOT_REGEX, '')\n\n  // from \"-0250\" to \"-025\"\n  .replace(TRAILING_ZEROS_REGEX, '')\n\n  // from \"-025\" to \"25\"\n  .replace(LEADING_MINUS_AND_ZEROS_REGEX, '');\n}\nconst EXPONENTIAL_PART_REGEX = /[eE][+-]?\\d+$/;\nconst LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;\nconst DOT_REGEX = /\\./;\nconst TRAILING_ZEROS_REGEX = /0+$/;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3NzbGVzcy1qc29uL2xpYi9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNLFVBQVUsa0JBQWtCLGFBQWEsT0FBTztBQUM5SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvc3NsZXNzLWpzb24vbGliL2VzbS91dGlscy5qcz9lMmM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdCB3aGV0aGVyIGEgc3RyaW5nIGNvbnRhaW5zIGFuIGludGVnZXIgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIElOVEVHRVJfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5jb25zdCBJTlRFR0VSX1JFR0VYID0gL14tP1swLTldKyQvO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBjb250YWlucyBhIG51bWJlclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM0MDcxNy9qc29uLW51bWJlcnMtcmVndWxhci1leHByZXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gTlVNQkVSX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuY29uc3QgTlVNQkVSX1JFR0VYID0gL14tPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPyQvO1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHN0cmluZyBjYW4gYmUgc2FmZWx5IHJlcHJlc2VudGVkIHdpdGggYSBudW1iZXJcbiAqIHdpdGhvdXQgaW5mb3JtYXRpb24gbG9zcy5cbiAqXG4gKiBXaGVuIGFwcHJveCBpcyB0cnVlLCBmbG9hdGluZyBwb2ludCBudW1iZXJzIHRoYXQgbG9zZSBhIGZldyBkaWdpdHMgYnV0XG4gKiBhcmUgc3RpbGwgYXBwcm94aW1hdGVseSBlcXVhbCBpbiB2YWx1ZSBhcmUgY29uc2lkZXJlZCBzYWZlIHRvby5cbiAqIEludGVnZXIgbnVtYmVycyBtdXN0IHN0aWxsIGJlIGV4YWN0bHkgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmVOdW1iZXIodmFsdWUsIGNvbmZpZykge1xuICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgY29uc3Qgc3RyID0gU3RyaW5nKG51bSk7XG4gIGNvbnN0IHYgPSBleHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUpO1xuICBjb25zdCBzID0gZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHN0cik7XG4gIGlmICh2ID09PSBzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGNvbmZpZz8uYXBwcm94ID09PSB0cnVlKSB7XG4gICAgLy8gQSB2YWx1ZSBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHdoZW46XG4gICAgLy8gMS4gaXQgaXMgYSBmbG9hdGluZyBwb2ludCBudW1iZXIsIG5vdCBhbiBpbnRlZ2VyXG4gICAgLy8gMi4gaXQgaGFzIGF0IGxlYXN0IDE0IGRpZ2l0c1xuICAgIC8vIDMuIHRoZSBmaXJzdCAxNCBkaWdpdHMgYXJlIGVxdWFsXG4gICAgY29uc3QgcmVxdWlyZWREaWdpdHMgPSAxNDtcbiAgICBpZiAoIWlzSW50ZWdlcih2YWx1ZSkgJiYgcy5sZW5ndGggPj0gcmVxdWlyZWREaWdpdHMgJiYgdi5zdGFydHNXaXRoKHMuc3Vic3RyaW5nKDAsIHJlcXVpcmVkRGlnaXRzKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgbGV0IFVuc2FmZU51bWJlclJlYXNvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVW5zYWZlTnVtYmVyUmVhc29uKSB7XG4gIFVuc2FmZU51bWJlclJlYXNvbltcInVuZGVyZmxvd1wiXSA9IFwidW5kZXJmbG93XCI7XG4gIFVuc2FmZU51bWJlclJlYXNvbltcIm92ZXJmbG93XCJdID0gXCJvdmVyZmxvd1wiO1xuICBVbnNhZmVOdW1iZXJSZWFzb25bXCJ0cnVuY2F0ZV9pbnRlZ2VyXCJdID0gXCJ0cnVuY2F0ZV9pbnRlZ2VyXCI7XG4gIFVuc2FmZU51bWJlclJlYXNvbltcInRydW5jYXRlX2Zsb2F0XCJdID0gXCJ0cnVuY2F0ZV9mbG9hdFwiO1xuICByZXR1cm4gVW5zYWZlTnVtYmVyUmVhc29uO1xufSh7fSk7XG5cbi8qKlxuICogV2hlbiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYW4gdW5zYWZlIG51bWJlciwgZGVzY3JpYmUgd2hhdCB0aGUgcmVhc29uIGlzOlxuICogb3ZlcmZsb3csIHVuZGVyZmxvdywgdHJ1bmNhdGVfaW50ZWdlciwgb3IgdHJ1bmNhdGVfZmxvYXQuXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIHRoZSB2YWx1ZSBpcyBzYWZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5zYWZlTnVtYmVyUmVhc29uKHZhbHVlKSB7XG4gIGlmIChpc1NhZmVOdW1iZXIodmFsdWUsIHtcbiAgICBhcHByb3g6IGZhbHNlXG4gIH0pKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgIHJldHVybiBVbnNhZmVOdW1iZXJSZWFzb24udHJ1bmNhdGVfaW50ZWdlcjtcbiAgfVxuICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgaWYgKCFpc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi5vdmVyZmxvdztcbiAgfVxuICBpZiAobnVtID09PSAwKSB7XG4gICAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi51bmRlcmZsb3c7XG4gIH1cbiAgcmV0dXJuIFVuc2FmZU51bWJlclJlYXNvbi50cnVuY2F0ZV9mbG9hdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludG8gYSBudW1iZXIgd2hlbiBpdCBpcyBzYWZlIHRvIGRvIHNvLlxuICogVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZSwgZXhwbGFpbmluZyB0aGUgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TYWZlTnVtYmVyT3JUaHJvdyh2YWx1ZSwgY29uZmlnKSB7XG4gIGNvbnN0IG51bWJlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICBjb25zdCB1bnNhZmVSZWFzb24gPSBnZXRVbnNhZmVOdW1iZXJSZWFzb24odmFsdWUpO1xuICBpZiAoY29uZmlnPy5hcHByb3ggPT09IHRydWUgPyB1bnNhZmVSZWFzb24gJiYgdW5zYWZlUmVhc29uICE9PSBVbnNhZmVOdW1iZXJSZWFzb24udHJ1bmNhdGVfZmxvYXQgOiB1bnNhZmVSZWFzb24pIHtcbiAgICBjb25zdCB1bnNhZmVSZWFzb25UZXh0ID0gdW5zYWZlUmVhc29uPy5yZXBsYWNlKC9fXFx3KyQvLCAnJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2FmZWx5IGNvbnZlcnQgdG8gbnVtYmVyOiAnICsgYHRoZSB2YWx1ZSAnJHt2YWx1ZX0nIHdvdWxkICR7dW5zYWZlUmVhc29uVGV4dH0gYW5kIGJlY29tZSAke251bWJlcn1gKTtcbiAgfVxuICByZXR1cm4gbnVtYmVyO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2lnbmlmaWNhbnQgZGlnaXRzIG9mIGEgbnVtYmVyLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICogICAnMi4zNCcgcmV0dXJucyAnMjM0J1xuICogICAnLTc3JyByZXR1cm5zICc3NydcbiAqICAgJzAuMDAzNDAwJyByZXR1cm5zICczNCdcbiAqICAgJzEyMC41ZSszMCcgcmV0dXJucyAnMTIwNSdcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0U2lnbmlmaWNhbnREaWdpdHModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlXG4gIC8vIGZyb20gXCItMC4yNTBlKzMwXCIgdG8gXCItMC4yNTBcIlxuICAucmVwbGFjZShFWFBPTkVOVElBTF9QQVJUX1JFR0VYLCAnJylcblxuICAvLyBmcm9tIFwiLTAuMjUwXCIgdG8gXCItMDI1MFwiXG4gIC5yZXBsYWNlKERPVF9SRUdFWCwgJycpXG5cbiAgLy8gZnJvbSBcIi0wMjUwXCIgdG8gXCItMDI1XCJcbiAgLnJlcGxhY2UoVFJBSUxJTkdfWkVST1NfUkVHRVgsICcnKVxuXG4gIC8vIGZyb20gXCItMDI1XCIgdG8gXCIyNVwiXG4gIC5yZXBsYWNlKExFQURJTkdfTUlOVVNfQU5EX1pFUk9TX1JFR0VYLCAnJyk7XG59XG5jb25zdCBFWFBPTkVOVElBTF9QQVJUX1JFR0VYID0gL1tlRV1bKy1dP1xcZCskLztcbmNvbnN0IExFQURJTkdfTUlOVVNfQU5EX1pFUk9TX1JFR0VYID0gL14tPygwKik/LztcbmNvbnN0IERPVF9SRUdFWCA9IC9cXC4vO1xuY29uc3QgVFJBSUxJTkdfWkVST1NfUkVHRVggPSAvMCskLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lossless-json/lib/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/pako/dist/pako.esm.mjs":
/*!*********************************************!*\
  !*** ./node_modules/pako/dist/pako.esm.mjs ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deflate: function() { return /* binding */ Deflate_1; },\n/* harmony export */   Inflate: function() { return /* binding */ Inflate_1; },\n/* harmony export */   constants: function() { return /* binding */ constants_1; },\n/* harmony export */   \"default\": function() { return /* binding */ pako; },\n/* harmony export */   deflate: function() { return /* binding */ deflate_1; },\n/* harmony export */   deflateRaw: function() { return /* binding */ deflateRaw_1; },\n/* harmony export */   gzip: function() { return /* binding */ gzip_1; },\n/* harmony export */   inflate: function() { return /* binding */ inflate_1; },\n/* harmony export */   inflateRaw: function() { return /* binding */ inflateRaw_1; },\n/* harmony export */   ungzip: function() { return /* binding */ ungzip_1; }\n/* harmony export */ });\n\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED$1               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN$1             = 2;\n\n/*============================================================================*/\n\n\nfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH$1    = 3;\nconst MAX_MATCH$1    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES$1  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS$1      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES$1       = 30;\n/* number of distance codes */\n\nconst BL_CODES$1      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n/* maximum heap size */\n\nconst MAX_BITS$1      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES$1);\nzero$1(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES$1);\nzero$1(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Tracev((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) => {\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n\n  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    code = (code + bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.sym_next = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) => {\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) => {\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let sx = 0;         /* running index in sym_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.sym_next !== 0) {\n    do {\n      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;\n      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;\n      lc = s.pending_buf[s.sym_buf + sx++];\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and sym_buf is ok: */\n      //Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n\n    } while (sx < s.sym_next);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) => {\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"block list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* block_mask is the bit mask of block-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let block_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"block-listed\") bytes. */\n  for (n = 0; n <= 31; n++, block_mask >>>= 1) {\n    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"allow-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"block-listed\" or \"allow-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init$1 = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  bi_windup(s);        /* align on byte boundary */\n  put_short(s, stored_len);\n  put_short(s, ~stored_len);\n  if (stored_len) {\n    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);\n  }\n  s.pending += stored_len;\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align$1 = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nconst _tr_flush_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN$1) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->sym_next / 3));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block$1(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally$1 = (s, dist, lc) => {\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist;\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;\n  s.pending_buf[s.sym_buf + s.sym_next++] = lc;\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n  return (s.sym_next === s.sym_end);\n};\n\nvar _tr_init_1  = _tr_init$1;\nvar _tr_stored_block_1 = _tr_stored_block$1;\nvar _tr_flush_block_1  = _tr_flush_block$1;\nvar _tr_tally_1 = _tr_tally$1;\nvar _tr_align_1 = _tr_align$1;\n\nvar trees = {\n\t_tr_init: _tr_init_1,\n\t_tr_stored_block: _tr_stored_block_1,\n\t_tr_flush_block: _tr_flush_block_1,\n\t_tr_tally: _tr_tally_1,\n\t_tr_align: _tr_align_1\n};\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nvar adler32_1 = adler32;\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nvar crc32_1 = crc32;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar constants$2 = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_UNKNOWN,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants$2;\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS$1 = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n//#ifdef GZIP\nconst GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n//#endif\nconst EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\nconst NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\nconst COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\nconst HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\nconst BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\nconst FINISH_STATE  = 666;    /* stream complete */\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) * 2) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\nconst slide_hash = (s) => {\n  let n, m;\n  let p;\n  let wsize = s.w_size;\n\n  n = s.hash_size;\n  p = n;\n  do {\n    m = s.head[--p];\n    s.head[p] = (m >= wsize ? m - wsize : 0);\n  } while (--n);\n  n = wsize;\n//#ifndef FASTEST\n  p = n;\n  do {\n    m = s.prev[--p];\n    s.prev[p] = (m >= wsize ? m - wsize : 0);\n    /* If n is not on any hash chain, prev[n] is garbage but\n     * its value will never be used.\n     */\n  } while (--n);\n//#endif\n};\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out  += len;\n  s.pending_out  += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending      -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let n, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n      slide_hash(s);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Smallest worthy block size when not flushing or finishing. By default\n   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n   * large input and output buffers, the stored block size will be larger.\n   */\n  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n  /* Copy as many min_block or larger stored blocks directly to next_out as\n   * possible. If flushing, copy the remaining available input to next_out as\n   * stored blocks, if there is enough space.\n   */\n  let len, left, have, last = 0;\n  let used = s.strm.avail_in;\n  do {\n    /* Set len to the maximum size block that we can copy directly with the\n     * available input data and output space. Set left to how much of that\n     * would be copied from what's left in the window.\n     */\n    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    if (s.strm.avail_out < have) {         /* need room for header */\n      break;\n    }\n      /* maximum stored block length that will fit in avail_out: */\n    have = s.strm.avail_out - have;\n    left = s.strstart - s.block_start;  /* bytes left in window */\n    if (len > left + s.strm.avail_in) {\n      len = left + s.strm.avail_in;   /* limit len to the input */\n    }\n    if (len > have) {\n      len = have;             /* limit len to the output */\n    }\n\n    /* If the stored block would be less than min_block in length, or if\n     * unable to copy all of the available input when flushing, then try\n     * copying to the window and the pending buffer instead. Also don't\n     * write an empty block when flushing -- deflate() does that.\n     */\n    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||\n                        flush === Z_NO_FLUSH$2 ||\n                        len !== left + s.strm.avail_in)) {\n      break;\n    }\n\n    /* Make a dummy stored block in pending to get the header bytes,\n     * including any pending bits. This also updates the debugging counts.\n     */\n    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;\n    _tr_stored_block(s, 0, 0, last);\n\n    /* Replace the lengths in the dummy stored block with len. */\n    s.pending_buf[s.pending - 4] = len;\n    s.pending_buf[s.pending - 3] = len >> 8;\n    s.pending_buf[s.pending - 2] = ~len;\n    s.pending_buf[s.pending - 1] = ~len >> 8;\n\n    /* Write the stored block header bytes. */\n    flush_pending(s.strm);\n\n//#ifdef ZLIB_DEBUG\n//    /* Update debugging counts for the data about to be copied. */\n//    s->compressed_len += len << 3;\n//    s->bits_sent += len << 3;\n//#endif\n\n    /* Copy uncompressed bytes from the window to next_out. */\n    if (left) {\n      if (left > len) {\n        left = len;\n      }\n      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n      s.strm.next_out += left;\n      s.strm.avail_out -= left;\n      s.strm.total_out += left;\n      s.block_start += left;\n      len -= left;\n    }\n\n    /* Copy uncompressed bytes directly from next_in to next_out, updating\n     * the check value.\n     */\n    if (len) {\n      read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n      s.strm.next_out += len;\n      s.strm.avail_out -= len;\n      s.strm.total_out += len;\n    }\n  } while (last === 0);\n\n  /* Update the sliding window with the last s->w_size bytes of the copied\n   * data, or append all of the copied data to the existing window if less\n   * than s->w_size bytes were copied. Also update the number of bytes to\n   * insert in the hash tables, in the event that deflateParams() switches to\n   * a non-zero compression level.\n   */\n  used -= s.strm.avail_in;    /* number of input bytes directly copied */\n  if (used) {\n    /* If any input was used, then no unused input remains in the window,\n     * therefore s->block_start == s->strstart.\n     */\n    if (used >= s.w_size) {  /* supplant the previous history */\n      s.matches = 2;     /* clear hash */\n      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n      s.strstart = s.w_size;\n      s.insert = s.strstart;\n    }\n    else {\n      if (s.window_size - s.strstart <= used) {\n        /* Slide the window down. */\n        s.strstart -= s.w_size;\n        //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n        if (s.matches < 2) {\n          s.matches++;   /* add a pending slide_hash() */\n        }\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n      }\n      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n      s.strstart += used;\n      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n    }\n    s.block_start = s.strstart;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* If the last block was written to next_out, then done. */\n  if (last) {\n    return BS_FINISH_DONE;\n  }\n\n  /* If flushing and all input has been consumed, then done. */\n  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&\n    s.strm.avail_in === 0 && s.strstart === s.block_start) {\n    return BS_BLOCK_DONE;\n  }\n\n  /* Fill the window with any remaining input. */\n  have = s.window_size - s.strstart;\n  if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n    /* Slide the window down. */\n    s.block_start -= s.w_size;\n    s.strstart -= s.w_size;\n    //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n    if (s.matches < 2) {\n      s.matches++;       /* add a pending slide_hash() */\n    }\n    have += s.w_size;      /* more space now */\n    if (s.insert > s.strstart) {\n      s.insert = s.strstart;\n    }\n  }\n  if (have > s.strm.avail_in) {\n    have = s.strm.avail_in;\n  }\n  if (have) {\n    read_buf(s.strm, s.window, s.strstart, have);\n    s.strstart += have;\n    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* There was not enough avail_out to write a complete worthy or flushed\n   * stored block to next_out. Write a stored block to pending instead, if we\n   * have enough input for a worthy block, or if flushing and there is enough\n   * room for the remaining input as a stored block in the pending buffer.\n   */\n  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    /* maximum stored block length that will fit in pending: */\n  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n  min_block = have > s.w_size ? s.w_size : have;\n  left = s.strstart - s.block_start;\n  if (left >= min_block ||\n     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&\n     s.strm.avail_in === 0 && left <= have)) {\n    len = left > have ? have : left;\n    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&\n         len === left ? 1 : 0;\n    _tr_stored_block(s, s.block_start, len, last);\n    s.block_start += len;\n    flush_pending(s.strm);\n  }\n\n  /* We've done all we can with the available input and output. */\n  return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n};\n\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$2) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.sym_next = 0;      /* running index in sym_buf */\n  this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nconst deflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const s = strm.state;\n  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n//#ifdef GZIP\n                                s.status !== GZIP_STATE &&\n//#endif\n                                s.status !== EXTRA_STATE &&\n                                s.status !== NAME_STATE &&\n                                s.status !== COMMENT_STATE &&\n                                s.status !== HCRC_STATE &&\n                                s.status !== BUSY_STATE &&\n                                s.status !== FINISH_STATE)) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status =\n//#ifdef GZIP\n    s.wrap === 2 ? GZIP_STATE :\n//#endif\n    s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = -2;\n  _tr_init(s);\n  return Z_OK$3;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK$3) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR$2;\n  }\n  strm.state.gzhead = head;\n  return Z_OK$3;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR$2;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n  s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  /* We overlay pending_buf and sym_buf. This works since the average size\n   * for length/distance pairs over any compressed block is assured to be 31\n   * bits or less.\n   *\n   * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n   * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n   * possible fixed-codes length/distance pair is then 31 bits total.\n   *\n   * sym_buf starts one-fourth of the way into pending_buf. So there are\n   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n   * in sym_buf is three bytes -- two for the distance and one for the\n   * literal/length. As each symbol is consumed, the pointer to the next\n   * sym_buf value to read moves forward three bytes. From that symbol, up to\n   * 31 bits are written to pending_buf. The closest the written pending_buf\n   * bits gets to the next sym_buf symbol to read is just before the last\n   * code is written. At that time, 31*(n-2) bits have been written, just\n   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n   * symbols are written.) The closest the writing gets to what is unread is\n   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n   * can range from 128 to 32768.\n   *\n   * Therefore, at a minimum, there are 142 bits of space between what is\n   * written and what is read in the overlain buffers, so the symbols cannot\n   * be overwritten by the compressed data. That space is actually 139 bits,\n   * due to the three-bit fixed-code block header.\n   *\n   * That covers the case where either Z_FIXED is specified, forcing fixed\n   * codes, or when the use of fixed codes is chosen, because that choice\n   * results in a smaller compressed block than dynamic codes. That latter\n   * condition then assures that the above analysis also covers all dynamic\n   * blocks. A dynamic-code block will only be chosen to be emitted if it has\n   * fewer bits than a fixed-code block would for the same set of symbols.\n   * Therefore its average symbol length is assured to be less than 31. So\n   * the compressed data for a dynamic block also cannot overwrite the\n   * symbols from which it is being constructed.\n   */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->sym_buf = s->pending_buf + s->lit_bufsize;\n  s.sym_buf = s.lit_bufsize;\n\n  //s->sym_end = (s->lit_bufsize - 1) * 3;\n  s.sym_end = (s.lit_bufsize - 1) * 3;\n  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n};\n\n\n/* ========================================================================= */\nconst deflate$2 = (strm, flush) => {\n\n  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (strm.avail_in !== 0 && !strm.input) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n  }\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH$3) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* Write the header */\n  if (s.status === INIT_STATE && s.wrap === 0) {\n    s.status = BUSY_STATE;\n  }\n  if (s.status === INIT_STATE) {\n    /* zlib header */\n    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n    let level_flags = -1;\n\n    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n      level_flags = 0;\n    } else if (s.level < 6) {\n      level_flags = 1;\n    } else if (s.level === 6) {\n      level_flags = 2;\n    } else {\n      level_flags = 3;\n    }\n    header |= (level_flags << 6);\n    if (s.strstart !== 0) { header |= PRESET_DICT; }\n    header += 31 - (header % 31);\n\n    putShortMSB(s, header);\n\n    /* Save the adler32 of the preset dictionary: */\n    if (s.strstart !== 0) {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#ifdef GZIP\n  if (s.status === GZIP_STATE) {\n    /* gzip header */\n    strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n    put_byte(s, 31);\n    put_byte(s, 139);\n    put_byte(s, 8);\n    if (!s.gzhead) { // s->gzhead == Z_NULL\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, OS_CODE);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$3;\n      }\n    }\n    else {\n      put_byte(s, (s.gzhead.text ? 1 : 0) +\n                  (s.gzhead.hcrc ? 2 : 0) +\n                  (!s.gzhead.extra ? 0 : 4) +\n                  (!s.gzhead.name ? 0 : 8) +\n                  (!s.gzhead.comment ? 0 : 16)\n      );\n      put_byte(s, s.gzhead.time & 0xff);\n      put_byte(s, (s.gzhead.time >> 8) & 0xff);\n      put_byte(s, (s.gzhead.time >> 16) & 0xff);\n      put_byte(s, (s.gzhead.time >> 24) & 0xff);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, s.gzhead.os & 0xff);\n      if (s.gzhead.extra && s.gzhead.extra.length) {\n        put_byte(s, s.gzhead.extra.length & 0xff);\n        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n      }\n      if (s.gzhead.hcrc) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n      }\n      s.gzindex = 0;\n      s.status = EXTRA_STATE;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n      while (s.pending + left > s.pending_buf_size) {\n        let copy = s.pending_buf_size - s.pending;\n        // zmemcpy(s.pending_buf + s.pending,\n        //    s.gzhead.extra + s.gzindex, copy);\n        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n        s.pending = s.pending_buf_size;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex += copy;\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n        beg = 0;\n        left -= copy;\n      }\n      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n      let gzhead_extra = new Uint8Array(s.gzhead.extra);\n      // zmemcpy(s->pending_buf + s->pending,\n      //     s->gzhead->extra + s->gzindex, left);\n      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n      s.pending += left;\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = NAME_STATE;\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = COMMENT_STATE;\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n    }\n    s.status = HCRC_STATE;\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n      }\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n    }\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#endif\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n    let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                 configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK$3;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH$1) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK$3;\n      }\n    }\n  }\n\n  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const status = strm.state.status;\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK$3;\n};\n\n\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2$1 = deflate$2;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateGetDictionary = deflateGetDictionary;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n\nvar deflate_1$2 = {\n\tdeflateInit: deflateInit_1,\n\tdeflateInit2: deflateInit2_1,\n\tdeflateReset: deflateReset_1,\n\tdeflateResetKeep: deflateResetKeep_1,\n\tdeflateSetHeader: deflateSetHeader_1,\n\tdeflate: deflate_2$1,\n\tdeflateEnd: deflateEnd_1,\n\tdeflateSetDictionary: deflateSetDictionary_1,\n\tdeflateInfo: deflateInfo\n};\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nvar flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n\nvar common = {\n\tassign: assign,\n\tflattenChunks: flattenChunks\n};\n\n// String encode/decode helpers\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nvar string2buf = (str) => {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nvar buf2string = (buf, max) => {\n  const len = max || buf.length;\n\n  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n\n  let i, out;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\nvar strings = {\n\tstring2buf: string2buf,\n\tbuf2string: buf2string,\n\tutf8border: utf8border\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nvar zstream = ZStream;\n\nconst toString$1 = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate$1(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  let status = deflate_1$2.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK$2) {\n    throw new Error(messages[status]);\n  }\n\n  if (opt.header) {\n    deflate_1$2.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = deflate_1$2.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK$2) {\n      throw new Error(messages[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = deflate_1$2.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END$2) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1$2.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$2;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$2) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate$1(input, options) {\n  const deflator = new Deflate$1(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate$1(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip$1(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate$1(input, options);\n}\n\n\nvar Deflate_1$1 = Deflate$1;\nvar deflate_2 = deflate$1;\nvar deflateRaw_1$1 = deflateRaw$1;\nvar gzip_1$1 = gzip$1;\nvar constants$1 = constants$2;\n\nvar deflate_1$1 = {\n\tDeflate: Deflate_1$1,\n\tdeflate: deflate_2,\n\tdeflateRaw: deflateRaw_1$1,\n\tgzip: gzip_1$1,\n\tconstants: constants$1\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD$1 = 16209;       /* got a data error -- remain here until reset */\nconst TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvar inffast = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD$1;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD$1;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE$1;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD$1;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS$1 = 852;\nconst ENOUGH_DISTS$1 = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES$1 = 0;\nconst LENS$1 = 1;\nconst DISTS$1 = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n//  let shoextra;    /* extra bits table to use */\n  let match;                  /* use base and extra for symbol >= match */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES$1) {\n    base = extra = work;    /* dummy value--not used */\n    match = 20;\n\n  } else if (type === LENS$1) {\n    base = lbase;\n    extra = lext;\n    match = 257;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    match = 0;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] + 1 < match) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] >= match) {\n      here_op = extra[work[sym] - match];\n      here_val = base[work[sym] - match];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nvar inftrees = inflate_table;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n\n\n\n\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n  Z_DEFLATED\n} = constants$2;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 16180;       /* i: waiting for magic header */\nconst    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 16182;       /* i: waiting for modification time (gzip) */\nconst    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 16184;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 16186;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 16188;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 16189;    /* i: waiting for dictionary check value */\nconst    DICT = 16190;      /* waiting for inflateSetDictionary() call */\nconst        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 16193;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 16196;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 16197;   /* i: waiting for code length code lengths */\nconst        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 16199;      /* i: same as LEN below, but only first time in */\nconst            LEN = 16200;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 16201;    /* i: waiting for length extra bits */\nconst            DIST = 16202;      /* i: waiting for distance code */\nconst            DISTEXT = 16203;   /* i: waiting for distance extra bits */\nconst            MATCH = 16204;     /* o: waiting for output space to copy string */\nconst            LIT = 16205;       /* o: waiting for output space to write literal */\nconst    CHECK = 16206;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 16208;      /* finished check, done -- remain here until reset */\nconst    BAD = 16209;       /* got a data error -- remain here until reset */\nconst    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.strm = null;           /* pointer back to this zlib stream */\n  this.mode = 0;              /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,\n                                 bit 2 true to validate check value */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib), or\n                                 -1 if raw or no header yet */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const state = strm.state;\n  if (!state || state.strm !== strm ||\n    state.mode < HEAD || state.mode > SYNC) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.flags = -1;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$1;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 5;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR$1; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.strm = strm;\n  state.window = null/*Z_NULL*/;\n  state.mode = HEAD;     /* to pass state test in inflateReset2() */\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate$2 = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (inflateStateCheck(strm) || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          if (state.wbits === 0) {\n            state.wbits = 15;\n          }\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        if (len > 15 || len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        state.flags = 0;               /* indicate zlib header */\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if ((state.flags & 0x0200) && (state.wrap & 4)) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT$1;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inffast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if ((state.wrap & 4) && _out) {\n            strm.adler = state.check =\n                /*UPDATE_CHECK(state.check, put - _out, _out);*/\n                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$1;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR$1;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH$1))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if ((state.wrap & 4) && _out) {\n    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (inflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK$1;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR$1;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK$1;\n};\n\n\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2$1 = inflate$2;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCodesUsed = inflateCodesUsed;\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\nmodule.exports.inflateValidate = inflateValidate;\n*/\n\nvar inflate_1$2 = {\n\tinflateReset: inflateReset_1,\n\tinflateReset2: inflateReset2_1,\n\tinflateResetKeep: inflateResetKeep_1,\n\tinflateInit: inflateInit_1,\n\tinflateInit2: inflateInit2_1,\n\tinflate: inflate_2$1,\n\tinflateEnd: inflateEnd_1,\n\tinflateGetHeader: inflateGetHeader_1,\n\tinflateSetDictionary: inflateSetDictionary_1,\n\tinflateInfo: inflateInfo\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nvar gzheader = GZheader;\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate$1(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  let status  = inflate_1$2.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(messages[status]);\n  }\n\n  this.header = new gzheader();\n\n  inflate_1$2.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = inflate_1$2.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT && dictionary) {\n      status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK) {\n        status = inflate_1$2.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      inflate_1$2.inflateReset(strm);\n      status = inflate_1$2.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END) {\n      status = inflate_1$2.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err) {\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate$1(input, options) {\n  const inflator = new Inflate$1(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || messages[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nvar Inflate_1$1 = Inflate$1;\nvar inflate_2 = inflate$1;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip$1 = inflate$1;\nvar constants = constants$2;\n\nvar inflate_1$1 = {\n\tInflate: Inflate_1$1,\n\tinflate: inflate_2,\n\tinflateRaw: inflateRaw_1$1,\n\tungzip: ungzip$1,\n\tconstants: constants\n};\n\nconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n\nconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n\n\n\nvar Deflate_1 = Deflate;\nvar deflate_1 = deflate;\nvar deflateRaw_1 = deflateRaw;\nvar gzip_1 = gzip;\nvar Inflate_1 = Inflate;\nvar inflate_1 = inflate;\nvar inflateRaw_1 = inflateRaw;\nvar ungzip_1 = ungzip;\nvar constants_1 = constants$2;\n\nvar pako = {\n\tDeflate: Deflate_1,\n\tdeflate: deflate_1,\n\tdeflateRaw: deflateRaw_1,\n\tgzip: gzip_1,\n\tInflate: Inflate_1,\n\tinflate: inflate_1,\n\tinflateRaw: inflateRaw_1,\n\tungzip: ungzip_1,\n\tconstants: constants_1\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYWtvL2Rpc3QvcGFrby5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTs7O0FBR0EsdUJBQXVCLHNCQUFzQixxQkFBcUI7O0FBRWxFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDOzs7O0FBSUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QixpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRCwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFlBQVk7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDOztBQUVqQywrQ0FBK0M7QUFDL0MsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBLGNBQWMsZ0JBQWdCLE9BQU87QUFDckMsY0FBYyxnQkFBZ0IsT0FBTztBQUNyQyxjQUFjLGdCQUFnQixPQUFPOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCOztBQUU1QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxPQUFPOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7O0FBRXZCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3Qix5Q0FBeUM7O0FBRXpDLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUEsTUFBTTs7QUFFTixnQ0FBZ0M7QUFDaEM7O0FBRUEsTUFBTTtBQUNOOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsMEJBQTBCOztBQUUxQiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0IseUNBQXlDOztBQUV6Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZUFBZTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOLFdBQVcsbUNBQW1DOztBQUU5QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxpQ0FBaUM7QUFDakMsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJLE1BQU0sR0FBRyxNQUFNLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLEtBQUssR0FBRyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQiw0REFBNEQ7QUFDNUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQiw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkMsSUFBSTtBQUNKO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsb0VBQW9FOzs7OztBQUs1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2Qjs7QUFFN0Isc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEIsbUJBQW1COztBQUVuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qyx5QkFBeUI7QUFDekIsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkIsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCOzs7QUFHQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWU7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHFDQUFxQzs7QUFFN0MsUUFBUSx1Q0FBdUM7Ozs7QUFJL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wYWtvL2Rpc3QvcGFrby5lc20ubWpzPzIyZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiEgcGFrbyAyLjEuMCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28gQGxpY2Vuc2UgKE1JVCBBTkQgWmxpYikgKi9cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vY29uc3QgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL2NvbnN0IFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy9jb25zdCBaX1JMRSAgICAgICAgICAgICAgID0gMztcbmNvbnN0IFpfRklYRUQkMSAgICAgICAgICAgICAgID0gNDtcbi8vY29uc3QgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbmNvbnN0IFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG5jb25zdCBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbmNvbnN0IFpfVU5LTk9XTiQxICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvJDEoYnVmKSB7IGxldCBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxuY29uc3QgU1RPUkVEX0JMT0NLID0gMDtcbmNvbnN0IFNUQVRJQ19UUkVFUyA9IDE7XG5jb25zdCBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxuY29uc3QgTUlOX01BVENIJDEgICAgPSAzO1xuY29uc3QgTUFYX01BVENIJDEgICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbmNvbnN0IExFTkdUSF9DT0RFUyQxICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IExJVEVSQUxTJDEgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG5jb25zdCBMX0NPREVTJDEgICAgICAgPSBMSVRFUkFMUyQxICsgMSArIExFTkdUSF9DT0RFUyQxO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbmNvbnN0IERfQ09ERVMkMSAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbmNvbnN0IEJMX0NPREVTJDEgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbmNvbnN0IEhFQVBfU0laRSQxICAgICA9IDIgKiBMX0NPREVTJDEgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxuY29uc3QgTUFYX0JJVFMkMSAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxuY29uc3QgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG5jb25zdCBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxuY29uc3QgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG5jb25zdCBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbmNvbnN0IGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdKTtcblxuY29uc3QgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pO1xuXG5jb25zdCBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKTtcblxuY29uc3QgYmxfb3JkZXIgPVxuICBuZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxuY29uc3QgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG5jb25zdCBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTJDEgKyAyKSAqIDIpO1xuemVybyQxKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbmNvbnN0IHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxICogMik7XG56ZXJvJDEoc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxuY29uc3QgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8kMShfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbmNvbnN0IF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIJDEgLSBNSU5fTUFUQ0gkMSArIDEpO1xuemVybyQxKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTJDEpO1xuemVybyQxKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbmNvbnN0IGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyQxKTtcbnplcm8kMShiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxubGV0IHN0YXRpY19sX2Rlc2M7XG5sZXQgc3RhdGljX2RfZGVzYztcbmxldCBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5jb25zdCBkX2NvZGUgPSAoZGlzdCkgPT4ge1xuXG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuY29uc3QgcHV0X3Nob3J0ID0gKHMsIHcpID0+IHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuY29uc3Qgc2VuZF9iaXRzID0gKHMsIHZhbHVlLCBsZW5ndGgpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59O1xuXG5cbmNvbnN0IHNlbmRfY29kZSA9IChzLCBjLCB0cmVlKSA9PiB7XG5cbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuY29uc3QgYmlfcmV2ZXJzZSA9IChjb2RlLCBsZW4pID0+IHtcblxuICBsZXQgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmNvbnN0IGJpX2ZsdXNoID0gKHMpID0+IHtcblxuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuY29uc3QgZ2VuX2JpdGxlbiA9IChzLCBkZXNjKSA9PiB7XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG5cbiAgY29uc3QgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3QgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgY29uc3Qgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgY29uc3QgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgY29uc3QgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgbGV0IGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIGxldCBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICBsZXQgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgbGV0IGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgbGV0IG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkUkMTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNldigoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuY29uc3QgZ2VuX2NvZGVzID0gKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudCkgPT4ge1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xuXG4gIGNvbnN0IG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyQxICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIGxldCBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7XG4gICAgY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGU7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgbGV0IGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmNvbnN0IHRyX3N0YXRpY19pbml0ID0gKCkgPT4ge1xuXG4gIGxldCBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgbGV0IGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgbGV0IGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIGxldCBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgY29uc3QgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMkMSArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyQxIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTJDE7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUyQxOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMkMSArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMkMSArIDEsIExfQ09ERVMkMSwgTUFYX0JJVFMkMSk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUyQxLCBNQVhfQklUUyQxKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMkMSwgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuY29uc3QgaW5pdF9ibG9jayA9IChzKSA9PiB7XG5cbiAgbGV0IG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUyQxOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVMkMTsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUyQxOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMuc3ltX25leHQgPSBzLm1hdGNoZXMgPSAwO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5jb25zdCBiaV93aW5kdXAgPSAocykgPT5cbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuY29uc3Qgc21hbGxlciA9ICh0cmVlLCBuLCBtLCBkZXB0aCkgPT4ge1xuXG4gIGNvbnN0IF9uMiA9IG4gKiAyO1xuICBjb25zdCBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmNvbnN0IHBxZG93bmhlYXAgPSAocywgdHJlZSwgaykgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xuXG4gIGNvbnN0IHYgPSBzLmhlYXBba107XG4gIGxldCBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn07XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gY29uc3QgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5jb25zdCBjb21wcmVzc19ibG9jayA9IChzLCBsdHJlZSwgZHRyZWUpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuXG4gIGxldCBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgbGV0IHN4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIHN5bV9idWYgKi9cbiAgbGV0IGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIGxldCBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLnN5bV9uZXh0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IHMucGVuZGluZ19idWZbcy5zeW1fYnVmICsgc3grK10gJiAweGZmO1xuICAgICAgZGlzdCArPSAocy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzeCsrXSAmIDB4ZmYpIDw8IDg7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5zeW1fYnVmICsgc3grK107XG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMkMSArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBzeW1fYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQocy0+cGVuZGluZyA8IHMtPmxpdF9idWZzaXplICsgc3gsIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKHN4IDwgcy5zeW1fbmV4dCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5jb25zdCBidWlsZF90cmVlID0gKHMsIGRlc2MpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cblxuICBjb25zdCB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIGNvbnN0IHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgbGV0IG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIGxldCBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgbGV0IG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkUkMTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmNvbnN0IHNjYW5fdHJlZSA9IChzLCB0cmVlLCBtYXhfY29kZSkgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cblxuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuY29uc3Qgc2VuZF90cmVlID0gKHMsIHRyZWUsIG1heF9jb2RlKSA9PiB7XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cblxuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmNvbnN0IGJ1aWxkX2JsX3RyZWUgPSAocykgPT4ge1xuXG4gIGxldCBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyQxIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuY29uc3Qgc2VuZF9hbGxfdHJlZXMgPSAocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpID0+IHtcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG5cbiAgbGV0IHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibG9jayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYWxsb3cgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuY29uc3QgZGV0ZWN0X2RhdGFfdHlwZSA9IChzKSA9PiB7XG4gIC8qIGJsb2NrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsb2NrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgbGV0IGJsb2NrX21hc2sgPSAweGYzZmZjMDdmO1xuICBsZXQgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxvY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsb2NrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibG9ja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJhbGxvdy1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUyQxOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsb2NrLWxpc3RlZFwiIG9yIFwiYWxsb3ctbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59O1xuXG5cbmxldCBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5jb25zdCBfdHJfaW5pdCQxID0gKHMpID0+XG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuY29uc3QgX3RyX3N0b3JlZF9ibG9jayQxID0gKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCkgPT4ge1xuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG5cbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG4gIHB1dF9zaG9ydChzLCBzdG9yZWRfbGVuKTtcbiAgcHV0X3Nob3J0KHMsIH5zdG9yZWRfbGVuKTtcbiAgaWYgKHN0b3JlZF9sZW4pIHtcbiAgICBzLnBlbmRpbmdfYnVmLnNldChzLndpbmRvdy5zdWJhcnJheShidWYsIGJ1ZiArIHN0b3JlZF9sZW4pLCBzLnBlbmRpbmcpO1xuICB9XG4gIHMucGVuZGluZyArPSBzdG9yZWRfbGVuO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuY29uc3QgX3RyX2FsaWduJDEgPSAocykgPT4ge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgd3JpdGUgb3V0IHRoZSBlbmNvZGVkIGJsb2NrLlxuICovXG5jb25zdCBfdHJfZmx1c2hfYmxvY2skMSA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+IHtcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG5cbiAgbGV0IG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgbGV0IG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOJDEpIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zeW1fbmV4dCAvIDMpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayQxKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEJDEgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5jb25zdCBfdHJfdGFsbHkkMSA9IChzLCBkaXN0LCBsYykgPT4ge1xuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG5cbiAgcy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzLnN5bV9uZXh0KytdID0gZGlzdDtcbiAgcy5wZW5kaW5nX2J1ZltzLnN5bV9idWYgKyBzLnN5bV9uZXh0KytdID0gZGlzdCA+PiA4O1xuICBzLnBlbmRpbmdfYnVmW3Muc3ltX2J1ZiArIHMuc3ltX25leHQrK10gPSBsYztcbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyQxICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuICByZXR1cm4gKHMuc3ltX25leHQgPT09IHMuc3ltX2VuZCk7XG59O1xuXG52YXIgX3RyX2luaXRfMSAgPSBfdHJfaW5pdCQxO1xudmFyIF90cl9zdG9yZWRfYmxvY2tfMSA9IF90cl9zdG9yZWRfYmxvY2skMTtcbnZhciBfdHJfZmx1c2hfYmxvY2tfMSAgPSBfdHJfZmx1c2hfYmxvY2skMTtcbnZhciBfdHJfdGFsbHlfMSA9IF90cl90YWxseSQxO1xudmFyIF90cl9hbGlnbl8xID0gX3RyX2FsaWduJDE7XG5cbnZhciB0cmVlcyA9IHtcblx0X3RyX2luaXQ6IF90cl9pbml0XzEsXG5cdF90cl9zdG9yZWRfYmxvY2s6IF90cl9zdG9yZWRfYmxvY2tfMSxcblx0X3RyX2ZsdXNoX2Jsb2NrOiBfdHJfZmx1c2hfYmxvY2tfMSxcblx0X3RyX3RhbGx5OiBfdHJfdGFsbHlfMSxcblx0X3RyX2FsaWduOiBfdHJfYWxpZ25fMVxufTtcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgYWRsZXIzMiA9IChhZGxlciwgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBsZXQgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufTtcblxuXG52YXIgYWRsZXIzMl8xID0gYWRsZXIzMjtcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5jb25zdCBtYWtlVGFibGUgPSAoKSA9PiB7XG4gIGxldCBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTtcblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbmNvbnN0IGNyY1RhYmxlID0gbmV3IFVpbnQzMkFycmF5KG1ha2VUYWJsZSgpKTtcblxuXG5jb25zdCBjcmMzMiA9IChjcmMsIGJ1ZiwgbGVuLCBwb3MpID0+IHtcbiAgY29uc3QgdCA9IGNyY1RhYmxlO1xuICBjb25zdCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAobGV0IGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59O1xuXG5cbnZhciBjcmMzMl8xID0gY3JjMzI7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIG1lc3NhZ2VzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgY29uc3RhbnRzJDIgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgWl9NRU1fRVJST1I6ICAgICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IHsgX3RyX2luaXQsIF90cl9zdG9yZWRfYmxvY2ssIF90cl9mbHVzaF9ibG9jaywgX3RyX3RhbGx5LCBfdHJfYWxpZ24gfSA9IHRyZWVzO1xuXG5cblxuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX05PX0ZMVVNIOiBaX05PX0ZMVVNIJDIsIFpfUEFSVElBTF9GTFVTSCwgWl9GVUxMX0ZMVVNIOiBaX0ZVTExfRkxVU0gkMSwgWl9GSU5JU0g6IFpfRklOSVNIJDMsIFpfQkxPQ0s6IFpfQkxPQ0skMSxcbiAgWl9PSzogWl9PSyQzLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQzLCBaX1NUUkVBTV9FUlJPUjogWl9TVFJFQU1fRVJST1IkMiwgWl9EQVRBX0VSUk9SOiBaX0RBVEFfRVJST1IkMiwgWl9CVUZfRVJST1I6IFpfQlVGX0VSUk9SJDEsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogWl9ERUZBVUxUX0NPTVBSRVNTSU9OJDEsXG4gIFpfRklMVEVSRUQsIFpfSFVGRk1BTl9PTkxZLCBaX1JMRSwgWl9GSVhFRCwgWl9ERUZBVUxUX1NUUkFURUdZOiBaX0RFRkFVTFRfU1RSQVRFR1kkMSxcbiAgWl9VTktOT1dOLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDJcbn0gPSBjb25zdGFudHMkMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xuY29uc3QgTUFYX1dCSVRTJDEgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX01FTV9MRVZFTCA9IDg7XG5cblxuY29uc3QgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5jb25zdCBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5jb25zdCBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbmNvbnN0IEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuY29uc3QgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5jb25zdCBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG5jb25zdCBNSU5fTUFUQ0ggPSAzO1xuY29uc3QgTUFYX01BVENIID0gMjU4O1xuY29uc3QgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxuY29uc3QgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG5jb25zdCBJTklUX1NUQVRFICAgID0gIDQyOyAgICAvKiB6bGliIGhlYWRlciAtPiBCVVNZX1NUQVRFICovXG4vLyNpZmRlZiBHWklQXG5jb25zdCBHWklQX1NUQVRFICAgID0gIDU3OyAgICAvKiBnemlwIGhlYWRlciAtPiBCVVNZX1NUQVRFIHwgRVhUUkFfU1RBVEUgKi9cbi8vI2VuZGlmXG5jb25zdCBFWFRSQV9TVEFURSAgID0gIDY5OyAgICAvKiBnemlwIGV4dHJhIGJsb2NrIC0+IE5BTUVfU1RBVEUgKi9cbmNvbnN0IE5BTUVfU1RBVEUgICAgPSAgNzM7ICAgIC8qIGd6aXAgZmlsZSBuYW1lIC0+IENPTU1FTlRfU1RBVEUgKi9cbmNvbnN0IENPTU1FTlRfU1RBVEUgPSAgOTE7ICAgIC8qIGd6aXAgY29tbWVudCAtPiBIQ1JDX1NUQVRFICovXG5jb25zdCBIQ1JDX1NUQVRFICAgID0gMTAzOyAgICAvKiBnemlwIGhlYWRlciBDUkMgLT4gQlVTWV9TVEFURSAqL1xuY29uc3QgQlVTWV9TVEFURSAgICA9IDExMzsgICAgLyogZGVmbGF0ZSAtPiBGSU5JU0hfU1RBVEUgKi9cbmNvbnN0IEZJTklTSF9TVEFURSAgPSA2NjY7ICAgIC8qIHN0cmVhbSBjb21wbGV0ZSAqL1xuXG5jb25zdCBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xuY29uc3QgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbmNvbnN0IEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbmNvbnN0IEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG5jb25zdCBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuY29uc3QgZXJyID0gKHN0cm0sIGVycm9yQ29kZSkgPT4ge1xuICBzdHJtLm1zZyA9IG1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59O1xuXG5jb25zdCByYW5rID0gKGYpID0+IHtcbiAgcmV0dXJuICgoZikgKiAyKSAtICgoZikgPiA0ID8gOSA6IDApO1xufTtcblxuY29uc3QgemVybyA9IChidWYpID0+IHtcbiAgbGV0IGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfVxufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSB3aGVuIHNsaWRpbmcgdGhlIHdpbmRvdyBkb3duIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzJcbiAqIGJpdCB2YWx1ZXMgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDAgdG9cbiAqIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDAgbGF0ZXIuXG4gKi9cbmNvbnN0IHNsaWRlX2hhc2ggPSAocykgPT4ge1xuICBsZXQgbiwgbTtcbiAgbGV0IHA7XG4gIGxldCB3c2l6ZSA9IHMud19zaXplO1xuXG4gIG4gPSBzLmhhc2hfc2l6ZTtcbiAgcCA9IG47XG4gIGRvIHtcbiAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgcy5oZWFkW3BdID0gKG0gPj0gd3NpemUgPyBtIC0gd3NpemUgOiAwKTtcbiAgfSB3aGlsZSAoLS1uKTtcbiAgbiA9IHdzaXplO1xuLy8jaWZuZGVmIEZBU1RFU1RcbiAgcCA9IG47XG4gIGRvIHtcbiAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgcy5wcmV2W3BdID0gKG0gPj0gd3NpemUgPyBtIC0gd3NpemUgOiAwKTtcbiAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICovXG4gIH0gd2hpbGUgKC0tbik7XG4vLyNlbmRpZlxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xubGV0IEhBU0hfWkxJQiA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgcy5oYXNoX3NoaWZ0KSBeIGRhdGEpICYgcy5oYXNoX21hc2s7XG4vLyBUaGlzIGhhc2ggY2F1c2VzIGxlc3MgY29sbGlzaW9ucywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL2lzc3Vlcy8xMzVcbi8vIEJ1dCBicmVha3MgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vbGV0IEhBU0hfRkFTVCA9IChzLCBwcmV2LCBkYXRhKSA9PiAoKHByZXYgPDwgOCkgKyAocHJldiA+PiA4KSArIChkYXRhIDw8IDQpKSAmIHMuaGFzaF9tYXNrO1xubGV0IEhBU0ggPSBIQVNIX1pMSUI7XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQsIGV4Y2VwdCBmb3JcbiAqIHNvbWUgZGVmbGF0ZV9zdG9yZWQoKSBvdXRwdXQsIGdvZXMgdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWVcbiAqIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlXG4gKiBzdHJtLT5uZXh0X291dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC4gKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5jb25zdCBmbHVzaF9wZW5kaW5nID0gKHN0cm0pID0+IHtcbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgbGV0IGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICBzdHJtLm91dHB1dC5zZXQocy5wZW5kaW5nX2J1Zi5zdWJhcnJheShzLnBlbmRpbmdfb3V0LCBzLnBlbmRpbmdfb3V0ICsgbGVuKSwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCAgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nICAgICAgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn07XG5cblxuY29uc3QgZmx1c2hfYmxvY2tfb25seSA9IChzLCBsYXN0KSA9PiB7XG4gIF90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufTtcblxuXG5jb25zdCBwdXRfYnl0ZSA9IChzLCBiKSA9PiB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBwdXRTaG9ydE1TQiA9IChzLCBiKSA9PiB7XG5cbiAgLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmNvbnN0IHJlYWRfYnVmID0gKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpID0+IHtcblxuICBsZXQgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgYnVmLnNldChzdHJtLmlucHV0LnN1YmFycmF5KHN0cm0ubmV4dF9pbiwgc3RybS5uZXh0X2luICsgbGVuKSwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuY29uc3QgbG9uZ2VzdF9tYXRjaCA9IChzLCBjdXJfbWF0Y2gpID0+IHtcblxuICBsZXQgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICBsZXQgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIGxldCBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgbGV0IGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICBsZXQgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICBjb25zdCBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIGNvbnN0IF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICBjb25zdCB3bWFzayA9IHMud19tYXNrO1xuICBjb25zdCBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICBjb25zdCBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICBsZXQgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIGxldCBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5jb25zdCBmaWxsX3dpbmRvdyA9IChzKSA9PiB7XG5cbiAgY29uc3QgX3dfc2l6ZSA9IHMud19zaXplO1xuICBsZXQgbiwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkoX3dfc2l6ZSwgX3dfc2l6ZSArIF93X3NpemUgLSBtb3JlKSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuICAgICAgaWYgKHMuaW5zZXJ0ID4gcy5zdHJzdGFydCkge1xuICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQ7XG4gICAgICB9XG4gICAgICBzbGlkZV9oYXNoKHMpO1xuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbc3RyICsgMV0pO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKTtcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIGNvbnN0IGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICBsZXQgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICpcbiAqIEluIGNhc2UgZGVmbGF0ZVBhcmFtcygpIGlzIHVzZWQgdG8gbGF0ZXIgc3dpdGNoIHRvIGEgbm9uLXplcm8gY29tcHJlc3Npb25cbiAqIGxldmVsLCBzLT5tYXRjaGVzIChvdGhlcndpc2UgdW51c2VkIHdoZW4gc3RvcmluZykga2VlcHMgdHJhY2sgb2YgdGhlIG51bWJlclxuICogb2YgaGFzaCB0YWJsZSBzbGlkZXMgdG8gcGVyZm9ybS4gSWYgcy0+bWF0Y2hlcyBpcyAxLCB0aGVuIG9uZSBoYXNoIHRhYmxlXG4gKiBzbGlkZSB3aWxsIGJlIGRvbmUgd2hlbiBzd2l0Y2hpbmcuIElmIHMtPm1hdGNoZXMgaXMgMiwgdGhlIG1heGltdW0gdmFsdWVcbiAqIGFsbG93ZWQgaGVyZSwgdGhlbiB0aGUgaGFzaCB0YWJsZSB3aWxsIGJlIGNsZWFyZWQsIHNpbmNlIHR3byBvciBtb3JlIHNsaWRlc1xuICogaXMgdGhlIHNhbWUgYXMgYSBjbGVhci5cbiAqXG4gKiBkZWZsYXRlX3N0b3JlZCgpIGlzIHdyaXR0ZW4gdG8gbWluaW1pemUgdGhlIG51bWJlciBvZiB0aW1lcyBhbiBpbnB1dCBieXRlIGlzXG4gKiBjb3BpZWQuIEl0IGlzIG1vc3QgZWZmaWNpZW50IHdpdGggbGFyZ2UgaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzLCB3aGljaFxuICogbWF4aW1pemVzIHRoZSBvcHBvcnR1bml0ZXMgdG8gaGF2ZSBhIHNpbmdsZSBjb3B5IGZyb20gbmV4dF9pbiB0byBuZXh0X291dC5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zdG9yZWQgPSAocywgZmx1c2gpID0+IHtcblxuICAvKiBTbWFsbGVzdCB3b3J0aHkgYmxvY2sgc2l6ZSB3aGVuIG5vdCBmbHVzaGluZyBvciBmaW5pc2hpbmcuIEJ5IGRlZmF1bHRcbiAgICogdGhpcyBpcyAzMksuIFRoaXMgY2FuIGJlIGFzIHNtYWxsIGFzIDUwNyBieXRlcyBmb3IgbWVtTGV2ZWwgPT0gMS4gRm9yXG4gICAqIGxhcmdlIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycywgdGhlIHN0b3JlZCBibG9jayBzaXplIHdpbGwgYmUgbGFyZ2VyLlxuICAgKi9cbiAgbGV0IG1pbl9ibG9jayA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDUgPiBzLndfc2l6ZSA/IHMud19zaXplIDogcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcblxuICAvKiBDb3B5IGFzIG1hbnkgbWluX2Jsb2NrIG9yIGxhcmdlciBzdG9yZWQgYmxvY2tzIGRpcmVjdGx5IHRvIG5leHRfb3V0IGFzXG4gICAqIHBvc3NpYmxlLiBJZiBmbHVzaGluZywgY29weSB0aGUgcmVtYWluaW5nIGF2YWlsYWJsZSBpbnB1dCB0byBuZXh0X291dCBhc1xuICAgKiBzdG9yZWQgYmxvY2tzLCBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UuXG4gICAqL1xuICBsZXQgbGVuLCBsZWZ0LCBoYXZlLCBsYXN0ID0gMDtcbiAgbGV0IHVzZWQgPSBzLnN0cm0uYXZhaWxfaW47XG4gIGRvIHtcbiAgICAvKiBTZXQgbGVuIHRvIHRoZSBtYXhpbXVtIHNpemUgYmxvY2sgdGhhdCB3ZSBjYW4gY29weSBkaXJlY3RseSB3aXRoIHRoZVxuICAgICAqIGF2YWlsYWJsZSBpbnB1dCBkYXRhIGFuZCBvdXRwdXQgc3BhY2UuIFNldCBsZWZ0IHRvIGhvdyBtdWNoIG9mIHRoYXRcbiAgICAgKiB3b3VsZCBiZSBjb3BpZWQgZnJvbSB3aGF0J3MgbGVmdCBpbiB0aGUgd2luZG93LlxuICAgICAqL1xuICAgIGxlbiA9IDY1NTM1LyogTUFYX1NUT1JFRCAqLzsgICAgIC8qIG1heGltdW0gZGVmbGF0ZSBzdG9yZWQgYmxvY2sgbGVuZ3RoICovXG4gICAgaGF2ZSA9IChzLmJpX3ZhbGlkICsgNDIpID4+IDM7ICAgICAvKiBudW1iZXIgb2YgaGVhZGVyIGJ5dGVzICovXG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPCBoYXZlKSB7ICAgICAgICAgLyogbmVlZCByb29tIGZvciBoZWFkZXIgKi9cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAgIC8qIG1heGltdW0gc3RvcmVkIGJsb2NrIGxlbmd0aCB0aGF0IHdpbGwgZml0IGluIGF2YWlsX291dDogKi9cbiAgICBoYXZlID0gcy5zdHJtLmF2YWlsX291dCAtIGhhdmU7XG4gICAgbGVmdCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0OyAgLyogYnl0ZXMgbGVmdCBpbiB3aW5kb3cgKi9cbiAgICBpZiAobGVuID4gbGVmdCArIHMuc3RybS5hdmFpbF9pbikge1xuICAgICAgbGVuID0gbGVmdCArIHMuc3RybS5hdmFpbF9pbjsgICAvKiBsaW1pdCBsZW4gdG8gdGhlIGlucHV0ICovXG4gICAgfVxuICAgIGlmIChsZW4gPiBoYXZlKSB7XG4gICAgICBsZW4gPSBoYXZlOyAgICAgICAgICAgICAvKiBsaW1pdCBsZW4gdG8gdGhlIG91dHB1dCAqL1xuICAgIH1cblxuICAgIC8qIElmIHRoZSBzdG9yZWQgYmxvY2sgd291bGQgYmUgbGVzcyB0aGFuIG1pbl9ibG9jayBpbiBsZW5ndGgsIG9yIGlmXG4gICAgICogdW5hYmxlIHRvIGNvcHkgYWxsIG9mIHRoZSBhdmFpbGFibGUgaW5wdXQgd2hlbiBmbHVzaGluZywgdGhlbiB0cnlcbiAgICAgKiBjb3B5aW5nIHRvIHRoZSB3aW5kb3cgYW5kIHRoZSBwZW5kaW5nIGJ1ZmZlciBpbnN0ZWFkLiBBbHNvIGRvbid0XG4gICAgICogd3JpdGUgYW4gZW1wdHkgYmxvY2sgd2hlbiBmbHVzaGluZyAtLSBkZWZsYXRlKCkgZG9lcyB0aGF0LlxuICAgICAqL1xuICAgIGlmIChsZW4gPCBtaW5fYmxvY2sgJiYgKChsZW4gPT09IDAgJiYgZmx1c2ggIT09IFpfRklOSVNIJDMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaCA9PT0gWl9OT19GTFVTSCQyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gIT09IGxlZnQgKyBzLnN0cm0uYXZhaWxfaW4pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBNYWtlIGEgZHVtbXkgc3RvcmVkIGJsb2NrIGluIHBlbmRpbmcgdG8gZ2V0IHRoZSBoZWFkZXIgYnl0ZXMsXG4gICAgICogaW5jbHVkaW5nIGFueSBwZW5kaW5nIGJpdHMuIFRoaXMgYWxzbyB1cGRhdGVzIHRoZSBkZWJ1Z2dpbmcgY291bnRzLlxuICAgICAqL1xuICAgIGxhc3QgPSBmbHVzaCA9PT0gWl9GSU5JU0gkMyAmJiBsZW4gPT09IGxlZnQgKyBzLnN0cm0uYXZhaWxfaW4gPyAxIDogMDtcbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGxhc3QpO1xuXG4gICAgLyogUmVwbGFjZSB0aGUgbGVuZ3RocyBpbiB0aGUgZHVtbXkgc3RvcmVkIGJsb2NrIHdpdGggbGVuLiAqL1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nIC0gNF0gPSBsZW47XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcgLSAzXSA9IGxlbiA+PiA4O1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nIC0gMl0gPSB+bGVuO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nIC0gMV0gPSB+bGVuID4+IDg7XG5cbiAgICAvKiBXcml0ZSB0aGUgc3RvcmVkIGJsb2NrIGhlYWRlciBieXRlcy4gKi9cbiAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG5cbi8vI2lmZGVmIFpMSUJfREVCVUdcbi8vICAgIC8qIFVwZGF0ZSBkZWJ1Z2dpbmcgY291bnRzIGZvciB0aGUgZGF0YSBhYm91dCB0byBiZSBjb3BpZWQuICovXG4vLyAgICBzLT5jb21wcmVzc2VkX2xlbiArPSBsZW4gPDwgMztcbi8vICAgIHMtPmJpdHNfc2VudCArPSBsZW4gPDwgMztcbi8vI2VuZGlmXG5cbiAgICAvKiBDb3B5IHVuY29tcHJlc3NlZCBieXRlcyBmcm9tIHRoZSB3aW5kb3cgdG8gbmV4dF9vdXQuICovXG4gICAgaWYgKGxlZnQpIHtcbiAgICAgIGlmIChsZWZ0ID4gbGVuKSB7XG4gICAgICAgIGxlZnQgPSBsZW47XG4gICAgICB9XG4gICAgICAvL3ptZW1jcHkocy0+c3RybS0+bmV4dF9vdXQsIHMtPndpbmRvdyArIHMtPmJsb2NrX3N0YXJ0LCBsZWZ0KTtcbiAgICAgIHMuc3RybS5vdXRwdXQuc2V0KHMud2luZG93LnN1YmFycmF5KHMuYmxvY2tfc3RhcnQsIHMuYmxvY2tfc3RhcnQgKyBsZWZ0KSwgcy5zdHJtLm5leHRfb3V0KTtcbiAgICAgIHMuc3RybS5uZXh0X291dCArPSBsZWZ0O1xuICAgICAgcy5zdHJtLmF2YWlsX291dCAtPSBsZWZ0O1xuICAgICAgcy5zdHJtLnRvdGFsX291dCArPSBsZWZ0O1xuICAgICAgcy5ibG9ja19zdGFydCArPSBsZWZ0O1xuICAgICAgbGVuIC09IGxlZnQ7XG4gICAgfVxuXG4gICAgLyogQ29weSB1bmNvbXByZXNzZWQgYnl0ZXMgZGlyZWN0bHkgZnJvbSBuZXh0X2luIHRvIG5leHRfb3V0LCB1cGRhdGluZ1xuICAgICAqIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgKi9cbiAgICBpZiAobGVuKSB7XG4gICAgICByZWFkX2J1ZihzLnN0cm0sIHMuc3RybS5vdXRwdXQsIHMuc3RybS5uZXh0X291dCwgbGVuKTtcbiAgICAgIHMuc3RybS5uZXh0X291dCArPSBsZW47XG4gICAgICBzLnN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgICAgIHMuc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICAgIH1cbiAgfSB3aGlsZSAobGFzdCA9PT0gMCk7XG5cbiAgLyogVXBkYXRlIHRoZSBzbGlkaW5nIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHMtPndfc2l6ZSBieXRlcyBvZiB0aGUgY29waWVkXG4gICAqIGRhdGEsIG9yIGFwcGVuZCBhbGwgb2YgdGhlIGNvcGllZCBkYXRhIHRvIHRoZSBleGlzdGluZyB3aW5kb3cgaWYgbGVzc1xuICAgKiB0aGFuIHMtPndfc2l6ZSBieXRlcyB3ZXJlIGNvcGllZC4gQWxzbyB1cGRhdGUgdGhlIG51bWJlciBvZiBieXRlcyB0b1xuICAgKiBpbnNlcnQgaW4gdGhlIGhhc2ggdGFibGVzLCBpbiB0aGUgZXZlbnQgdGhhdCBkZWZsYXRlUGFyYW1zKCkgc3dpdGNoZXMgdG9cbiAgICogYSBub24temVybyBjb21wcmVzc2lvbiBsZXZlbC5cbiAgICovXG4gIHVzZWQgLT0gcy5zdHJtLmF2YWlsX2luOyAgICAvKiBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgZGlyZWN0bHkgY29waWVkICovXG4gIGlmICh1c2VkKSB7XG4gICAgLyogSWYgYW55IGlucHV0IHdhcyB1c2VkLCB0aGVuIG5vIHVudXNlZCBpbnB1dCByZW1haW5zIGluIHRoZSB3aW5kb3csXG4gICAgICogdGhlcmVmb3JlIHMtPmJsb2NrX3N0YXJ0ID09IHMtPnN0cnN0YXJ0LlxuICAgICAqL1xuICAgIGlmICh1c2VkID49IHMud19zaXplKSB7ICAvKiBzdXBwbGFudCB0aGUgcHJldmlvdXMgaGlzdG9yeSAqL1xuICAgICAgcy5tYXRjaGVzID0gMjsgICAgIC8qIGNsZWFyIGhhc2ggKi9cbiAgICAgIC8vem1lbWNweShzLT53aW5kb3csIHMtPnN0cm0tPm5leHRfaW4gLSBzLT53X3NpemUsIHMtPndfc2l6ZSk7XG4gICAgICBzLndpbmRvdy5zZXQocy5zdHJtLmlucHV0LnN1YmFycmF5KHMuc3RybS5uZXh0X2luIC0gcy53X3NpemUsIHMuc3RybS5uZXh0X2luKSwgMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gcy53X3NpemU7XG4gICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHMud2luZG93X3NpemUgLSBzLnN0cnN0YXJ0IDw9IHVzZWQpIHtcbiAgICAgICAgLyogU2xpZGUgdGhlIHdpbmRvdyBkb3duLiAqL1xuICAgICAgICBzLnN0cnN0YXJ0IC09IHMud19zaXplO1xuICAgICAgICAvL3ptZW1jcHkocy0+d2luZG93LCBzLT53aW5kb3cgKyBzLT53X3NpemUsIHMtPnN0cnN0YXJ0KTtcbiAgICAgICAgcy53aW5kb3cuc2V0KHMud2luZG93LnN1YmFycmF5KHMud19zaXplLCBzLndfc2l6ZSArIHMuc3Ryc3RhcnQpLCAwKTtcbiAgICAgICAgaWYgKHMubWF0Y2hlcyA8IDIpIHtcbiAgICAgICAgICBzLm1hdGNoZXMrKzsgICAvKiBhZGQgYSBwZW5kaW5nIHNsaWRlX2hhc2goKSAqL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmluc2VydCA+IHMuc3Ryc3RhcnQpIHtcbiAgICAgICAgICBzLmluc2VydCA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vem1lbWNweShzLT53aW5kb3cgKyBzLT5zdHJzdGFydCwgcy0+c3RybS0+bmV4dF9pbiAtIHVzZWQsIHVzZWQpO1xuICAgICAgcy53aW5kb3cuc2V0KHMuc3RybS5pbnB1dC5zdWJhcnJheShzLnN0cm0ubmV4dF9pbiAtIHVzZWQsIHMuc3RybS5uZXh0X2luKSwgcy5zdHJzdGFydCk7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHVzZWQ7XG4gICAgICBzLmluc2VydCArPSB1c2VkID4gcy53X3NpemUgLSBzLmluc2VydCA/IHMud19zaXplIC0gcy5pbnNlcnQgOiB1c2VkO1xuICAgIH1cbiAgICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgfVxuICBpZiAocy5oaWdoX3dhdGVyIDwgcy5zdHJzdGFydCkge1xuICAgIHMuaGlnaF93YXRlciA9IHMuc3Ryc3RhcnQ7XG4gIH1cblxuICAvKiBJZiB0aGUgbGFzdCBibG9jayB3YXMgd3JpdHRlbiB0byBuZXh0X291dCwgdGhlbiBkb25lLiAqL1xuICBpZiAobGFzdCkge1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIC8qIElmIGZsdXNoaW5nIGFuZCBhbGwgaW5wdXQgaGFzIGJlZW4gY29uc3VtZWQsIHRoZW4gZG9uZS4gKi9cbiAgaWYgKGZsdXNoICE9PSBaX05PX0ZMVVNIJDIgJiYgZmx1c2ggIT09IFpfRklOSVNIJDMgJiZcbiAgICBzLnN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcy5zdHJzdGFydCA9PT0gcy5ibG9ja19zdGFydCkge1xuICAgIHJldHVybiBCU19CTE9DS19ET05FO1xuICB9XG5cbiAgLyogRmlsbCB0aGUgd2luZG93IHdpdGggYW55IHJlbWFpbmluZyBpbnB1dC4gKi9cbiAgaGF2ZSA9IHMud2luZG93X3NpemUgLSBzLnN0cnN0YXJ0O1xuICBpZiAocy5zdHJtLmF2YWlsX2luID4gaGF2ZSAmJiBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSB7XG4gICAgLyogU2xpZGUgdGhlIHdpbmRvdyBkb3duLiAqL1xuICAgIHMuYmxvY2tfc3RhcnQgLT0gcy53X3NpemU7XG4gICAgcy5zdHJzdGFydCAtPSBzLndfc2l6ZTtcbiAgICAvL3ptZW1jcHkocy0+d2luZG93LCBzLT53aW5kb3cgKyBzLT53X3NpemUsIHMtPnN0cnN0YXJ0KTtcbiAgICBzLndpbmRvdy5zZXQocy53aW5kb3cuc3ViYXJyYXkocy53X3NpemUsIHMud19zaXplICsgcy5zdHJzdGFydCksIDApO1xuICAgIGlmIChzLm1hdGNoZXMgPCAyKSB7XG4gICAgICBzLm1hdGNoZXMrKzsgICAgICAgLyogYWRkIGEgcGVuZGluZyBzbGlkZV9oYXNoKCkgKi9cbiAgICB9XG4gICAgaGF2ZSArPSBzLndfc2l6ZTsgICAgICAvKiBtb3JlIHNwYWNlIG5vdyAqL1xuICAgIGlmIChzLmluc2VydCA+IHMuc3Ryc3RhcnQpIHtcbiAgICAgIHMuaW5zZXJ0ID0gcy5zdHJzdGFydDtcbiAgICB9XG4gIH1cbiAgaWYgKGhhdmUgPiBzLnN0cm0uYXZhaWxfaW4pIHtcbiAgICBoYXZlID0gcy5zdHJtLmF2YWlsX2luO1xuICB9XG4gIGlmIChoYXZlKSB7XG4gICAgcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCwgaGF2ZSk7XG4gICAgcy5zdHJzdGFydCArPSBoYXZlO1xuICAgIHMuaW5zZXJ0ICs9IGhhdmUgPiBzLndfc2l6ZSAtIHMuaW5zZXJ0ID8gcy53X3NpemUgLSBzLmluc2VydCA6IGhhdmU7XG4gIH1cbiAgaWYgKHMuaGlnaF93YXRlciA8IHMuc3Ryc3RhcnQpIHtcbiAgICBzLmhpZ2hfd2F0ZXIgPSBzLnN0cnN0YXJ0O1xuICB9XG5cbiAgLyogVGhlcmUgd2FzIG5vdCBlbm91Z2ggYXZhaWxfb3V0IHRvIHdyaXRlIGEgY29tcGxldGUgd29ydGh5IG9yIGZsdXNoZWRcbiAgICogc3RvcmVkIGJsb2NrIHRvIG5leHRfb3V0LiBXcml0ZSBhIHN0b3JlZCBibG9jayB0byBwZW5kaW5nIGluc3RlYWQsIGlmIHdlXG4gICAqIGhhdmUgZW5vdWdoIGlucHV0IGZvciBhIHdvcnRoeSBibG9jaywgb3IgaWYgZmx1c2hpbmcgYW5kIHRoZXJlIGlzIGVub3VnaFxuICAgKiByb29tIGZvciB0aGUgcmVtYWluaW5nIGlucHV0IGFzIGEgc3RvcmVkIGJsb2NrIGluIHRoZSBwZW5kaW5nIGJ1ZmZlci5cbiAgICovXG4gIGhhdmUgPSAocy5iaV92YWxpZCArIDQyKSA+PiAzOyAgICAgLyogbnVtYmVyIG9mIGhlYWRlciBieXRlcyAqL1xuICAgIC8qIG1heGltdW0gc3RvcmVkIGJsb2NrIGxlbmd0aCB0aGF0IHdpbGwgZml0IGluIHBlbmRpbmc6ICovXG4gIGhhdmUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSBoYXZlID4gNjU1MzUvKiBNQVhfU1RPUkVEICovID8gNjU1MzUvKiBNQVhfU1RPUkVEICovIDogcy5wZW5kaW5nX2J1Zl9zaXplIC0gaGF2ZTtcbiAgbWluX2Jsb2NrID0gaGF2ZSA+IHMud19zaXplID8gcy53X3NpemUgOiBoYXZlO1xuICBsZWZ0ID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4gIGlmIChsZWZ0ID49IG1pbl9ibG9jayB8fFxuICAgICAoKGxlZnQgfHwgZmx1c2ggPT09IFpfRklOSVNIJDMpICYmIGZsdXNoICE9PSBaX05PX0ZMVVNIJDIgJiZcbiAgICAgcy5zdHJtLmF2YWlsX2luID09PSAwICYmIGxlZnQgPD0gaGF2ZSkpIHtcbiAgICBsZW4gPSBsZWZ0ID4gaGF2ZSA/IGhhdmUgOiBsZWZ0O1xuICAgIGxhc3QgPSBmbHVzaCA9PT0gWl9GSU5JU0gkMyAmJiBzLnN0cm0uYXZhaWxfaW4gPT09IDAgJiZcbiAgICAgICAgIGxlbiA9PT0gbGVmdCA/IDEgOiAwO1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgcy5ibG9ja19zdGFydCwgbGVuLCBsYXN0KTtcbiAgICBzLmJsb2NrX3N0YXJ0ICs9IGxlbjtcbiAgICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG4gIH1cblxuICAvKiBXZSd2ZSBkb25lIGFsbCB3ZSBjYW4gd2l0aCB0aGUgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQuICovXG4gIHJldHVybiBsYXN0ID8gQlNfRklOSVNIX1NUQVJURUQgOiBCU19ORUVEX01PUkU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5jb25zdCBkZWZsYXRlX2Zhc3QgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICBsZXQgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSk7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuY29uc3QgZGVmbGF0ZV9zbG93ID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBsZXQgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKTtcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmNvbnN0IGRlZmxhdGVfcmxlID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgbGV0IHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICBsZXQgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICBjb25zdCBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9odWZmID0gKHMsIGZsdXNoKSA9PiB7XG5cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIJDMpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5zeW1fbmV4dCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn07XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuXG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG5jb25zdCBjb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmNvbnN0IGxtX2luaXQgPSAocykgPT4ge1xuXG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59O1xuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRCQyOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgVWludDE2QXJyYXkoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgVWludDE2QXJyYXkoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgVWludDE2QXJyYXkoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5zeW1fYnVmID0gMDsgICAgICAgIC8qIGJ1ZmZlciBmb3IgZGlzdGFuY2VzIGFuZCBsaXRlcmFscy9sZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMuc3ltX25leHQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gc3ltX2J1ZiAqL1xuICB0aGlzLnN5bV9lbmQgPSAwOyAgICAgICAvKiBzeW1ib2wgdGFibGUgZnVsbCB3aGVuIHN5bV9uZXh0IHJlYWNoZXMgdGhpcyAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBmb3IgYSB2YWxpZCBkZWZsYXRlIHN0cmVhbSBzdGF0ZS4gUmV0dXJuIDAgaWYgb2ssIDEgaWYgbm90LlxuICovXG5jb25zdCBkZWZsYXRlU3RhdGVDaGVjayA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIGlmICghcyB8fCBzLnN0cm0gIT09IHN0cm0gfHwgKHMuc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4vLyNpZmRlZiBHWklQXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuc3RhdHVzICE9PSBHWklQX1NUQVRFICYmXG4vLyNlbmRpZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0S2VlcCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKGRlZmxhdGVTdGF0ZUNoZWNrKHN0cm0pKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9XG4vLyNpZmRlZiBHWklQXG4gICAgcy53cmFwID09PSAyID8gR1pJUF9TVEFURSA6XG4vLyNlbmRpZlxuICAgIHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSAtMjtcbiAgX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LJDM7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVSZXNldCA9IChzdHJtKSA9PiB7XG5cbiAgY29uc3QgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSyQzKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBkZWZsYXRlU2V0SGVhZGVyID0gKHN0cm0sIGhlYWQpID0+IHtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkgfHwgc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSyQzO1xufTtcblxuXG5jb25zdCBkZWZsYXRlSW5pdDIgPSAoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSA9PiB7XG5cbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuICBsZXQgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSkge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEJDIgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQgfHwgKHdpbmRvd0JpdHMgPT09IDggJiYgd3JhcCAhPT0gMSkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICBjb25zdCBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuICBzLnN0YXR1cyA9IElOSVRfU1RBVEU7ICAgICAvKiB0byBwYXNzIHN0YXRlIHRlc3QgaW4gZGVmbGF0ZVJlc2V0KCkgKi9cblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IFVpbnQxNkFycmF5KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IFVpbnQxNkFycmF5KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICAvKiBXZSBvdmVybGF5IHBlbmRpbmdfYnVmIGFuZCBzeW1fYnVmLiBUaGlzIHdvcmtzIHNpbmNlIHRoZSBhdmVyYWdlIHNpemVcbiAgICogZm9yIGxlbmd0aC9kaXN0YW5jZSBwYWlycyBvdmVyIGFueSBjb21wcmVzc2VkIGJsb2NrIGlzIGFzc3VyZWQgdG8gYmUgMzFcbiAgICogYml0cyBvciBsZXNzLlxuICAgKlxuICAgKiBBbmFseXNpczogVGhlIGxvbmdlc3QgZml4ZWQgY29kZXMgYXJlIGEgbGVuZ3RoIGNvZGUgb2YgOCBiaXRzIHBsdXMgNVxuICAgKiBleHRyYSBiaXRzLCBmb3IgbGVuZ3RocyAxMzEgdG8gMjU3LiBUaGUgbG9uZ2VzdCBmaXhlZCBkaXN0YW5jZSBjb2RlcyBhcmVcbiAgICogNSBiaXRzIHBsdXMgMTMgZXh0cmEgYml0cywgZm9yIGRpc3RhbmNlcyAxNjM4NSB0byAzMjc2OC4gVGhlIGxvbmdlc3RcbiAgICogcG9zc2libGUgZml4ZWQtY29kZXMgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgdGhlbiAzMSBiaXRzIHRvdGFsLlxuICAgKlxuICAgKiBzeW1fYnVmIHN0YXJ0cyBvbmUtZm91cnRoIG9mIHRoZSB3YXkgaW50byBwZW5kaW5nX2J1Zi4gU28gdGhlcmUgYXJlXG4gICAqIHRocmVlIGJ5dGVzIGluIHN5bV9idWYgZm9yIGV2ZXJ5IGZvdXIgYnl0ZXMgaW4gcGVuZGluZ19idWYuIEVhY2ggc3ltYm9sXG4gICAqIGluIHN5bV9idWYgaXMgdGhyZWUgYnl0ZXMgLS0gdHdvIGZvciB0aGUgZGlzdGFuY2UgYW5kIG9uZSBmb3IgdGhlXG4gICAqIGxpdGVyYWwvbGVuZ3RoLiBBcyBlYWNoIHN5bWJvbCBpcyBjb25zdW1lZCwgdGhlIHBvaW50ZXIgdG8gdGhlIG5leHRcbiAgICogc3ltX2J1ZiB2YWx1ZSB0byByZWFkIG1vdmVzIGZvcndhcmQgdGhyZWUgYnl0ZXMuIEZyb20gdGhhdCBzeW1ib2wsIHVwIHRvXG4gICAqIDMxIGJpdHMgYXJlIHdyaXR0ZW4gdG8gcGVuZGluZ19idWYuIFRoZSBjbG9zZXN0IHRoZSB3cml0dGVuIHBlbmRpbmdfYnVmXG4gICAqIGJpdHMgZ2V0cyB0byB0aGUgbmV4dCBzeW1fYnVmIHN5bWJvbCB0byByZWFkIGlzIGp1c3QgYmVmb3JlIHRoZSBsYXN0XG4gICAqIGNvZGUgaXMgd3JpdHRlbi4gQXQgdGhhdCB0aW1lLCAzMSoobi0yKSBiaXRzIGhhdmUgYmVlbiB3cml0dGVuLCBqdXN0XG4gICAqIGFmdGVyIDI0KihuLTIpIGJpdHMgaGF2ZSBiZWVuIGNvbnN1bWVkIGZyb20gc3ltX2J1Zi4gc3ltX2J1ZiBzdGFydHMgYXRcbiAgICogOCpuIGJpdHMgaW50byBwZW5kaW5nX2J1Zi4gKE5vdGUgdGhhdCB0aGUgc3ltYm9sIGJ1ZmZlciBmaWxscyB3aGVuIG4tMVxuICAgKiBzeW1ib2xzIGFyZSB3cml0dGVuLikgVGhlIGNsb3Nlc3QgdGhlIHdyaXRpbmcgZ2V0cyB0byB3aGF0IGlzIHVucmVhZCBpc1xuICAgKiB0aGVuIG4rMTQgYml0cy4gSGVyZSBuIGlzIGxpdF9idWZzaXplLCB3aGljaCBpcyAxNjM4NCBieSBkZWZhdWx0LCBhbmRcbiAgICogY2FuIHJhbmdlIGZyb20gMTI4IHRvIDMyNzY4LlxuICAgKlxuICAgKiBUaGVyZWZvcmUsIGF0IGEgbWluaW11bSwgdGhlcmUgYXJlIDE0MiBiaXRzIG9mIHNwYWNlIGJldHdlZW4gd2hhdCBpc1xuICAgKiB3cml0dGVuIGFuZCB3aGF0IGlzIHJlYWQgaW4gdGhlIG92ZXJsYWluIGJ1ZmZlcnMsIHNvIHRoZSBzeW1ib2xzIGNhbm5vdFxuICAgKiBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29tcHJlc3NlZCBkYXRhLiBUaGF0IHNwYWNlIGlzIGFjdHVhbGx5IDEzOSBiaXRzLFxuICAgKiBkdWUgdG8gdGhlIHRocmVlLWJpdCBmaXhlZC1jb2RlIGJsb2NrIGhlYWRlci5cbiAgICpcbiAgICogVGhhdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgZWl0aGVyIFpfRklYRUQgaXMgc3BlY2lmaWVkLCBmb3JjaW5nIGZpeGVkXG4gICAqIGNvZGVzLCBvciB3aGVuIHRoZSB1c2Ugb2YgZml4ZWQgY29kZXMgaXMgY2hvc2VuLCBiZWNhdXNlIHRoYXQgY2hvaWNlXG4gICAqIHJlc3VsdHMgaW4gYSBzbWFsbGVyIGNvbXByZXNzZWQgYmxvY2sgdGhhbiBkeW5hbWljIGNvZGVzLiBUaGF0IGxhdHRlclxuICAgKiBjb25kaXRpb24gdGhlbiBhc3N1cmVzIHRoYXQgdGhlIGFib3ZlIGFuYWx5c2lzIGFsc28gY292ZXJzIGFsbCBkeW5hbWljXG4gICAqIGJsb2Nrcy4gQSBkeW5hbWljLWNvZGUgYmxvY2sgd2lsbCBvbmx5IGJlIGNob3NlbiB0byBiZSBlbWl0dGVkIGlmIGl0IGhhc1xuICAgKiBmZXdlciBiaXRzIHRoYW4gYSBmaXhlZC1jb2RlIGJsb2NrIHdvdWxkIGZvciB0aGUgc2FtZSBzZXQgb2Ygc3ltYm9scy5cbiAgICogVGhlcmVmb3JlIGl0cyBhdmVyYWdlIHN5bWJvbCBsZW5ndGggaXMgYXNzdXJlZCB0byBiZSBsZXNzIHRoYW4gMzEuIFNvXG4gICAqIHRoZSBjb21wcmVzc2VkIGRhdGEgZm9yIGEgZHluYW1pYyBibG9jayBhbHNvIGNhbm5vdCBvdmVyd3JpdGUgdGhlXG4gICAqIHN5bWJvbHMgZnJvbSB3aGljaCBpdCBpcyBiZWluZyBjb25zdHJ1Y3RlZC5cbiAgICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgVWludDhBcnJheShzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPnN5bV9idWYgPSBzLT5wZW5kaW5nX2J1ZiArIHMtPmxpdF9idWZzaXplO1xuICBzLnN5bV9idWYgPSBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+c3ltX2VuZCA9IChzLT5saXRfYnVmc2l6ZSAtIDEpICogMztcbiAgcy5zeW1fZW5kID0gKHMubGl0X2J1ZnNpemUgLSAxKSAqIDM7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUqMyBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn07XG5cbmNvbnN0IGRlZmxhdGVJbml0ID0gKHN0cm0sIGxldmVsKSA9PiB7XG5cbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCQyLCBNQVhfV0JJVFMkMSwgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZJDEpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5jb25zdCBkZWZsYXRlJDIgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkgfHwgZmx1c2ggPiBaX0JMT0NLJDEgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMikgOiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKHN0cm0uYXZhaWxfaW4gIT09IDAgJiYgIXN0cm0uaW5wdXQpIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gkMykpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiQxIDogWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBjb25zdCBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LJDM7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gkMykge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IkMSk7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUiQxKTtcbiAgfVxuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFICYmIHMud3JhcCA9PT0gMCkge1xuICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcbiAgICAvKiB6bGliIGhlYWRlciAqL1xuICAgIGxldCBoZWFkZXIgPSAoWl9ERUZMQVRFRCQyICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgIGxldCBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICB9XG4gICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICB9XG4gICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuXG4gICAgLyogQ29tcHJlc3Npb24gbXVzdCBzdGFydCB3aXRoIGFuIGVtcHR5IHBlbmRpbmcgYnVmZmVyICovXG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LJDM7XG4gICAgfVxuICB9XG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gR1pJUF9TVEFURSkge1xuICAgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG5cbiAgICAgIC8qIENvbXByZXNzaW9uIG11c3Qgc3RhcnQgd2l0aCBhbiBlbXB0eSBwZW5kaW5nIGJ1ZmZlciAqL1xuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIHJldHVybiBaX09LJDM7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgKTtcbiAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgIH1cbiAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGxldCBiZWcgPSBzLnBlbmRpbmc7ICAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgbGV0IGxlZnQgPSAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSAtIHMuZ3ppbmRleDtcbiAgICAgIHdoaWxlIChzLnBlbmRpbmcgKyBsZWZ0ID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGxldCBjb3B5ID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gcy5wZW5kaW5nO1xuICAgICAgICAvLyB6bWVtY3B5KHMucGVuZGluZ19idWYgKyBzLnBlbmRpbmcsXG4gICAgICAgIC8vICAgIHMuZ3poZWFkLmV4dHJhICsgcy5nemluZGV4LCBjb3B5KTtcbiAgICAgICAgcy5wZW5kaW5nX2J1Zi5zZXQocy5nemhlYWQuZXh0cmEuc3ViYXJyYXkocy5nemluZGV4LCBzLmd6aW5kZXggKyBjb3B5KSwgcy5wZW5kaW5nKTtcbiAgICAgICAgcy5wZW5kaW5nID0gcy5wZW5kaW5nX2J1Zl9zaXplO1xuICAgICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHMuZ3ppbmRleCArPSBjb3B5O1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgICAgcmV0dXJuIFpfT0skMztcbiAgICAgICAgfVxuICAgICAgICBiZWcgPSAwO1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICB9XG4gICAgICAvLyBKUyBzcGVjaWZpYzogcy5nemhlYWQuZXh0cmEgbWF5IGJlIFR5cGVkQXJyYXkgb3IgQXJyYXkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vICAgICAgICAgICAgICBUeXBlZEFycmF5LnNsaWNlIGFuZCBUeXBlZEFycmF5LmZyb20gZG9uJ3QgZXhpc3QgaW4gSUUxMC1JRTExXG4gICAgICBsZXQgZ3poZWFkX2V4dHJhID0gbmV3IFVpbnQ4QXJyYXkocy5nemhlYWQuZXh0cmEpO1xuICAgICAgLy8gem1lbWNweShzLT5wZW5kaW5nX2J1ZiArIHMtPnBlbmRpbmcsXG4gICAgICAvLyAgICAgcy0+Z3poZWFkLT5leHRyYSArIHMtPmd6aW5kZXgsIGxlZnQpO1xuICAgICAgcy5wZW5kaW5nX2J1Zi5zZXQoZ3poZWFkX2V4dHJhLnN1YmFycmF5KHMuZ3ppbmRleCwgcy5nemluZGV4ICsgbGVmdCksIHMucGVuZGluZyk7XG4gICAgICBzLnBlbmRpbmcgKz0gbGVmdDtcbiAgICAgIC8vLS0tIEhDUkNfVVBEQVRFKGJlZykgLS0tLy9cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICAvLy0tLS8vXG4gICAgICBzLmd6aW5kZXggPSAwO1xuICAgIH1cbiAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgbGV0IGJlZyA9IHMucGVuZGluZzsgICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICBsZXQgdmFsO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAgICAgcmV0dXJuIFpfT0skMztcbiAgICAgICAgICB9XG4gICAgICAgICAgYmVnID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuICAgICAgLy8tLS0gSENSQ19VUERBVEUoYmVnKSAtLS0vL1xuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIC8vLS0tLy9cbiAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgfVxuICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBsZXQgYmVnID0gcy5wZW5kaW5nOyAgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIGxldCB2YWw7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIC8vLS0tIEhDUkNfVVBEQVRFKGJlZykgLS0tLy9cbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgICAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiZWcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG4gICAgICAvLy0tLSBIQ1JDX1VQREFURShiZWcpIC0tLS8vXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgLy8tLS0vL1xuICAgIH1cbiAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcblxuICAgIC8qIENvbXByZXNzaW9uIG11c3Qgc3RhcnQgd2l0aCBhbiBlbXB0eSBwZW5kaW5nIGJ1ZmZlciAqL1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSyQzO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCQyICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgbGV0IGJzdGF0ZSA9IHMubGV2ZWwgPT09IDAgPyBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkgOlxuICAgICAgICAgICAgICAgICBzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgICAgICAgICAgICBzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSyQzO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIF90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLJDEpIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCQxKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LJDM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCQzKSB7IHJldHVybiBaX09LJDM7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQkMzsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LJDMgOiBaX1NUUkVBTV9FTkQkMztcbn07XG5cblxuY29uc3QgZGVmbGF0ZUVuZCA9IChzdHJtKSA9PiB7XG5cbiAgaWYgKGRlZmxhdGVTdGF0ZUNoZWNrKHN0cm0pKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUiQyKSA6IFpfT0skMztcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5jb25zdCBkZWZsYXRlU2V0RGljdGlvbmFyeSA9IChzdHJtLCBkaWN0aW9uYXJ5KSA9PiB7XG5cbiAgbGV0IGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICBpZiAoZGVmbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBjb25zdCB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIGxldCB0bXBEaWN0ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUpO1xuICAgIHRtcERpY3Quc2V0KGRpY3Rpb25hcnkuc3ViYXJyYXkoZGljdExlbmd0aCAtIHMud19zaXplLCBkaWN0TGVuZ3RoKSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGNvbnN0IGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgY29uc3QgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgY29uc3QgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgbGV0IHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbGV0IG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0skMztcbn07XG5cblxudmFyIGRlZmxhdGVJbml0XzEgPSBkZWZsYXRlSW5pdDtcbnZhciBkZWZsYXRlSW5pdDJfMSA9IGRlZmxhdGVJbml0MjtcbnZhciBkZWZsYXRlUmVzZXRfMSA9IGRlZmxhdGVSZXNldDtcbnZhciBkZWZsYXRlUmVzZXRLZWVwXzEgPSBkZWZsYXRlUmVzZXRLZWVwO1xudmFyIGRlZmxhdGVTZXRIZWFkZXJfMSA9IGRlZmxhdGVTZXRIZWFkZXI7XG52YXIgZGVmbGF0ZV8yJDEgPSBkZWZsYXRlJDI7XG52YXIgZGVmbGF0ZUVuZF8xID0gZGVmbGF0ZUVuZDtcbnZhciBkZWZsYXRlU2V0RGljdGlvbmFyeV8xID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVHZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZUdldERpY3Rpb25hcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUGFyYW1zID0gZGVmbGF0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZsYXRlVHVuZSA9IGRlZmxhdGVUdW5lO1xuKi9cblxudmFyIGRlZmxhdGVfMSQyID0ge1xuXHRkZWZsYXRlSW5pdDogZGVmbGF0ZUluaXRfMSxcblx0ZGVmbGF0ZUluaXQyOiBkZWZsYXRlSW5pdDJfMSxcblx0ZGVmbGF0ZVJlc2V0OiBkZWZsYXRlUmVzZXRfMSxcblx0ZGVmbGF0ZVJlc2V0S2VlcDogZGVmbGF0ZVJlc2V0S2VlcF8xLFxuXHRkZWZsYXRlU2V0SGVhZGVyOiBkZWZsYXRlU2V0SGVhZGVyXzEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMiQxLFxuXHRkZWZsYXRlRW5kOiBkZWZsYXRlRW5kXzEsXG5cdGRlZmxhdGVTZXREaWN0aW9uYXJ5OiBkZWZsYXRlU2V0RGljdGlvbmFyeV8xLFxuXHRkZWZsYXRlSW5mbzogZGVmbGF0ZUluZm9cbn07XG5cbmNvbnN0IF9oYXMgPSAob2JqLCBrZXkpID0+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59O1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIGNvbnN0IHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxudmFyIGZsYXR0ZW5DaHVua3MgPSAoY2h1bmtzKSA9PiB7XG4gIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICBsZXQgbGVuID0gMDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGpvaW4gY2h1bmtzXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgY29tbW9uID0ge1xuXHRhc3NpZ246IGFzc2lnbixcblx0ZmxhdHRlbkNodW5rczogZmxhdHRlbkNodW5rc1xufTtcblxuLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbmxldCBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxuY29uc3QgX3V0ZjhsZW4gPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbnZhciBzdHJpbmcyYnVmID0gKHN0cikgPT4ge1xuICBpZiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nICYmIFRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG4gIH1cblxuICBsZXQgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlclxuY29uc3QgYnVmMmJpbnN0cmluZyA9IChidWYsIGxlbikgPT4ge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmIChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmLmxlbmd0aCA9PT0gbGVuID8gYnVmIDogYnVmLnN1YmFycmF5KDAsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbnZhciBidWYyc3RyaW5nID0gKGJ1ZiwgbWF4KSA9PiB7XG4gIGNvbnN0IGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgJiYgVGV4dERlY29kZXIucHJvdG90eXBlLmRlY29kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmLnN1YmFycmF5KDAsIG1heCkpO1xuICB9XG5cbiAgbGV0IGksIG91dDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICBjb25zdCB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGxldCBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgbGV0IGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gKGJ1ZiwgbWF4KSA9PiB7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgbGV0IHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG5cbnZhciBzdHJpbmdzID0ge1xuXHRzdHJpbmcyYnVmOiBzdHJpbmcyYnVmLFxuXHRidWYyc3RyaW5nOiBidWYyc3RyaW5nLFxuXHR1dGY4Ym9yZGVyOiB1dGY4Ym9yZGVyXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbnZhciB6c3RyZWFtID0gWlN0cmVhbTtcblxuY29uc3QgdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMSwgWl9TWU5DX0ZMVVNILCBaX0ZVTExfRkxVU0gsIFpfRklOSVNIOiBaX0ZJTklTSCQyLFxuICBaX09LOiBaX09LJDIsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDIsXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgWl9ERUZBVUxUX1NUUkFURUdZLFxuICBaX0RFRkxBVEVEOiBaX0RFRkxBVEVEJDFcbn0gPSBjb25zdGFudHMkMjtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gbmV3IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogY29uc3QgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUkMShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGNvbW1vbi5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVEJDEsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGxldCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IHpzdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgbGV0IHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0skMikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgZGVmbGF0ZV8xJDIuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgbGV0IGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZyQxLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0skMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgZmx1c2hfbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gZmx1c2hfbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3RcbiAqIGhhdmUgYGZsdXNoX21vZGVgIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZ1xuICogYnVmZmVycyBhbmQgY2FsbCBbW0RlZmxhdGUjb25FbmRdXS5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZSQxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZsdXNoX21vZGUpIHtcbiAgY29uc3Qgc3RybSA9IHRoaXMuc3RybTtcbiAgY29uc3QgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgbGV0IHN0YXR1cywgX2ZsdXNoX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKGZsdXNoX21vZGUgPT09IH5+Zmx1c2hfbW9kZSkgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlO1xuICBlbHNlIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZSA9PT0gdHJ1ZSA/IFpfRklOSVNIJDIgOiBaX05PX0ZMVVNIJDE7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nJDEuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhdmFpbF9vdXQgPiA2IHRvIGF2b2lkIHJlcGVhdGluZyBtYXJrZXJzXG4gICAgaWYgKChfZmx1c2hfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIIHx8IF9mbHVzaF9tb2RlID09PSBaX0ZVTExfRkxVU0gpICYmIHN0cm0uYXZhaWxfb3V0IDw9IDYpIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0LnN1YmFycmF5KDAsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGRlZmxhdGVfMSQyLmRlZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgLy8gRW5kZWQgPT4gZmx1c2ggYW5kIGZpbmlzaFxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCQyKSB7XG4gICAgICBpZiAoc3RybS5uZXh0X291dCA+IDApIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RhdHVzID09PSBaX09LJDI7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggaWYgb3V0IGJ1ZmZlciBmdWxsXG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiByZXF1ZXN0ZWQgYW5kIGhhcyBkYXRhXG4gICAgaWYgKF9mbHVzaF9tb2RlID4gMCAmJiBzdHJtLm5leHRfb3V0ID4gMCkge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDApIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXkpOiBvdXRwdXQgZGF0YS5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUkMS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKS4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlJDEucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LJDIpIHtcbiAgICB0aGlzLnJlc3VsdCA9IGNvbW1vbi5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmxhdG9yID0gbmV3IERlZmxhdGUkMShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtZXNzYWdlc1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXckMShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5XG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcCQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZSQxKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG52YXIgRGVmbGF0ZV8xJDEgPSBEZWZsYXRlJDE7XG52YXIgZGVmbGF0ZV8yID0gZGVmbGF0ZSQxO1xudmFyIGRlZmxhdGVSYXdfMSQxID0gZGVmbGF0ZVJhdyQxO1xudmFyIGd6aXBfMSQxID0gZ3ppcCQxO1xudmFyIGNvbnN0YW50cyQxID0gY29uc3RhbnRzJDI7XG5cbnZhciBkZWZsYXRlXzEkMSA9IHtcblx0RGVmbGF0ZTogRGVmbGF0ZV8xJDEsXG5cdGRlZmxhdGU6IGRlZmxhdGVfMixcblx0ZGVmbGF0ZVJhdzogZGVmbGF0ZVJhd18xJDEsXG5cdGd6aXA6IGd6aXBfMSQxLFxuXHRjb25zdGFudHM6IGNvbnN0YW50cyQxXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xuY29uc3QgQkFEJDEgPSAxNjIwOTsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgVFlQRSQxID0gMTYxOTE7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG52YXIgaW5mZmFzdCA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICBsZXQgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICBsZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIGxldCBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICBsZXQgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBsZXQgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICBsZXQgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIGxldCB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIGxldCB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgbGV0IHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICBsZXQgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgbGV0IGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICBsZXQgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICBsZXQgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIGxldCBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICBsZXQgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIGxldCBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIGxldCBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICBsZXQgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgbGV0IGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICBsZXQgZnJvbV9zb3VyY2U7XG5cblxuICBsZXQgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBNQVhCSVRTID0gMTU7XG5jb25zdCBFTk9VR0hfTEVOUyQxID0gODUyO1xuY29uc3QgRU5PVUdIX0RJU1RTJDEgPSA1OTI7XG4vL2NvbnN0IEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBDT0RFUyQxID0gMDtcbmNvbnN0IExFTlMkMSA9IDE7XG5jb25zdCBESVNUUyQxID0gMjtcblxuY29uc3QgbGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXSk7XG5cbmNvbnN0IGxleHQgPSBuZXcgVWludDhBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXSk7XG5cbmNvbnN0IGRiYXNlID0gbmV3IFVpbnQxNkFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXSk7XG5cbmNvbnN0IGRleHQgPSBuZXcgVWludDhBcnJheShbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXSk7XG5cbmNvbnN0IGluZmxhdGVfdGFibGUgPSAodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykgPT5cbntcbiAgY29uc3QgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgbGV0IGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgbGV0IHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIGxldCBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICBsZXQgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICBsZXQgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICBsZXQgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIGxldCBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgbGV0IHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgbGV0IGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIGxldCBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICBsZXQgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIGxldCBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICBsZXQgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgbGV0IG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIGxldCBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4vLyAgbGV0IHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICBsZXQgbWF0Y2g7ICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPj0gbWF0Y2ggKi9cbiAgY29uc3QgY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgY29uc3Qgb2ZmcyA9IG5ldyBVaW50MTZBcnJheShNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICBsZXQgZXh0cmEgPSBudWxsO1xuXG4gIGxldCBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyQxIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUyQxKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgbWF0Y2ggPSAyMDtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMkMSkge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgbWF0Y2ggPSAyNTc7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBtYXRjaCA9IDA7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyQxICYmIHVzZWQgPiBFTk9VR0hfTEVOUyQxKSB8fFxuICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSArIDEgPCBtYXRjaCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID49IG1hdGNoKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbd29ya1tzeW1dIC0gbWF0Y2hdO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW3dvcmtbc3ltXSAtIG1hdGNoXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMkMSAmJiB1c2VkID4gRU5PVUdIX0xFTlMkMSkgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTJDEgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUyQxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcblxuXG52YXIgaW5mdHJlZXMgPSBpbmZsYXRlX3RhYmxlO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cblxuXG5cblxuXG5jb25zdCBDT0RFUyA9IDA7XG5jb25zdCBMRU5TID0gMTtcbmNvbnN0IERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9GSU5JU0g6IFpfRklOSVNIJDEsIFpfQkxPQ0ssIFpfVFJFRVMsXG4gIFpfT0s6IFpfT0skMSwgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMSwgWl9ORUVEX0RJQ1Q6IFpfTkVFRF9ESUNUJDEsIFpfU1RSRUFNX0VSUk9SOiBaX1NUUkVBTV9FUlJPUiQxLCBaX0RBVEFfRVJST1I6IFpfREFUQV9FUlJPUiQxLCBaX01FTV9FUlJPUjogWl9NRU1fRVJST1IkMSwgWl9CVUZfRVJST1IsXG4gIFpfREVGTEFURURcbn0gPSBjb25zdGFudHMkMjtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5jb25zdCAgICBIRUFEID0gMTYxODA7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xuY29uc3QgICAgRkxBR1MgPSAxNjE4MTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xuY29uc3QgICAgVElNRSA9IDE2MTgyOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbmNvbnN0ICAgIE9TID0gMTYxODM7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG5jb25zdCAgICBFWExFTiA9IDE2MTg0OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYVFJBID0gMTYxODU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG5jb25zdCAgICBOQU1FID0gMTYxODY7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG5jb25zdCAgICBDT01NRU5UID0gMTYxODc7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xuY29uc3QgICAgSENSQyA9IDE2MTg4OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xuY29uc3QgICAgRElDVElEID0gMTYxODk7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIERJQ1QgPSAxNjE5MDsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbmNvbnN0ICAgICAgICBUWVBFID0gMTYxOTE7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuY29uc3QgICAgICAgIFRZUEVETyA9IDE2MTkyOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG5jb25zdCAgICAgICAgU1RPUkVEID0gMTYxOTM7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG5jb25zdCAgICAgICAgQ09QWV8gPSAxNjE5NDsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgQ09QWSA9IDE2MTk1OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG5jb25zdCAgICAgICAgVEFCTEUgPSAxNjE5NjsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIExFTkxFTlMgPSAxNjE5NzsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICBDT0RFTEVOUyA9IDE2MTk4OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgICAgIExFTl8gPSAxNjE5OTsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xuY29uc3QgICAgICAgICAgICBMRU4gPSAxNjIwMDsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBMRU5FWFQgPSAxNjIwMTsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVCA9IDE2MjAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbmNvbnN0ICAgICAgICAgICAgRElTVEVYVCA9IDE2MjAzOyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbmNvbnN0ICAgICAgICAgICAgTUFUQ0ggPSAxNjIwNDsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xuY29uc3QgICAgICAgICAgICBMSVQgPSAxNjIwNTsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbmNvbnN0ICAgIENIRUNLID0gMTYyMDY7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbmNvbnN0ICAgIExFTkdUSCA9IDE2MjA3OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xuY29uc3QgICAgRE9ORSA9IDE2MjA4OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBCQUQgPSAxNjIwOTsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xuY29uc3QgICAgTUVNID0gMTYyMTA7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBTWU5DID0gMTYyMTE7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG5jb25zdCBFTk9VR0hfTEVOUyA9IDg1MjtcbmNvbnN0IEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG5jb25zdCBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xuY29uc3QgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmNvbnN0IHpzd2FwMzIgPSAocSkgPT4ge1xuXG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufTtcblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0IDIgdHJ1ZSB0byB2YWxpZGF0ZSBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpLCBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgaWYgcmF3IG9yIG5vIGhlYWRlciB5ZXQgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyBVaW50MTZBcnJheSgzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgSW50MzJBcnJheShFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5cbmNvbnN0IGluZmxhdGVTdGF0ZUNoZWNrID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0pIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICghc3RhdGUgfHwgc3RhdGUuc3RybSAhPT0gc3RybSB8fFxuICAgIHN0YXRlLm1vZGUgPCBIRUFEIHx8IHN0YXRlLm1vZGUgPiBTWU5DKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5mbGFncyA9IC0xO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBpZiAoaW5mbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcbiAgbGV0IHdyYXA7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoaW5mbGF0ZVN0YXRlQ2hlY2soc3RybSkpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDU7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUuc3RybSA9IHN0cm07XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5tb2RlID0gSEVBRDsgICAgIC8qIHRvIHBhc3Mgc3RhdGUgdGVzdCBpbiBpbmZsYXRlUmVzZXQyKCkgKi9cbiAgY29uc3QgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSyQxKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVJbml0ID0gKHN0cm0pID0+IHtcblxuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59O1xuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbmxldCB2aXJnaW4gPSB0cnVlO1xuXG5sZXQgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5cbmNvbnN0IGZpeGVkdGFibGVzID0gKHN0YXRlKSA9PiB7XG5cbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIGxlbmZpeCA9IG5ldyBJbnQzMkFycmF5KDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyBJbnQzMkFycmF5KDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgbGV0IHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZnRyZWVzKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mdHJlZXMoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59O1xuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5jb25zdCB1cGRhdGV3aW5kb3cgPSAoc3RybSwgc3JjLCBlbmQsIGNvcHkpID0+IHtcblxuICBsZXQgZGlzdDtcbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gc3RhdGUud3NpemUsIGVuZCksIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQgLSBjb3B5ICsgZGlzdCksIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIGNvcHksIGVuZCksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5cbmNvbnN0IGluZmxhdGUkMiA9IChzdHJtLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBzdGF0ZTtcbiAgbGV0IGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIGxldCBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIGxldCBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICBsZXQgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICBsZXQgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICBsZXQgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIGxldCBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgbGV0IGZyb21fc291cmNlO1xuICBsZXQgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy9sZXQgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIGxldCBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICBsZXQgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICBsZXQgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgY29uc3QgaGJ1ZiA9IG5ldyBVaW50OEFycmF5KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICBsZXQgb3B0cztcblxuICBsZXQgbjsgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIGZvciBORUVEX0JJVFNcblxuICBjb25zdCBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIG5ldyBVaW50OEFycmF5KFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdKTtcblxuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LJDE7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgc3RhdGUud2JpdHMgPSAxNTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gMTUgfHwgbGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gISEhIHBha28gcGF0Y2guIEZvcmNlIHVzZSBgb3B0aW9ucy53aW5kb3dCaXRzYCBpZiBwYXNzZWQuXG4gICAgICAgIC8vIFJlcXVpcmVkIHRvIGFsd2F5cyB1c2UgbWF4IHdpbmRvdyBzaXplIGJ5IGRlZmF1bHQuXG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgICAgICAvL3N0YXRlLmRtYXggPSAxIDw8IGxlbjtcblxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAgICAgLyogaW5kaWNhdGUgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHgwMjAwKSAmJiAoc3RhdGUud3JhcCAmIDQpKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEuc2V0KFxuICAgICAgICAgICAgICAgIGlucHV0LnN1YmFycmF5KFxuICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgICBuZXh0ICsgY29weVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweDAyMDApICYmIChzdGF0ZS53cmFwICYgNCkpIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweDAyMDApICYmIChzdGF0ZS53cmFwICYgNCkpIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgJiYgKHN0YXRlLndyYXAgJiA0KSkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDQpICYmIGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUJDE7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICBvdXRwdXQuc2V0KGlucHV0LnN1YmFycmF5KG5leHQsIG5leHQgKyBjb3B5KSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmZhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgNCkgJiYgX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURV9DSEVDSyhzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDQpICYmIChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiA0KSAmJiBob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQkMTtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUiQxO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCQxKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSA7XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoKHN0YXRlLndyYXAgJiA0KSAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEVfQ0hFQ0soc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzJfMShzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCQxKSAmJiByZXQgPT09IFpfT0skMSkge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LJDE7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVHZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuICBjb25zdCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgZGljdGlkO1xuICBsZXQgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmIChpbmZsYXRlU3RhdGVDaGVjayhzdHJtKSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzJfMShkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SJDE7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SJDE7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxudmFyIGluZmxhdGVSZXNldF8xID0gaW5mbGF0ZVJlc2V0O1xudmFyIGluZmxhdGVSZXNldDJfMSA9IGluZmxhdGVSZXNldDI7XG52YXIgaW5mbGF0ZVJlc2V0S2VlcF8xID0gaW5mbGF0ZVJlc2V0S2VlcDtcbnZhciBpbmZsYXRlSW5pdF8xID0gaW5mbGF0ZUluaXQ7XG52YXIgaW5mbGF0ZUluaXQyXzEgPSBpbmZsYXRlSW5pdDI7XG52YXIgaW5mbGF0ZV8yJDEgPSBpbmZsYXRlJDI7XG52YXIgaW5mbGF0ZUVuZF8xID0gaW5mbGF0ZUVuZDtcbnZhciBpbmZsYXRlR2V0SGVhZGVyXzEgPSBpbmZsYXRlR2V0SGVhZGVyO1xudmFyIGluZmxhdGVTZXREaWN0aW9uYXJ5XzEgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbnZhciBpbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlQ29kZXNVc2VkID0gaW5mbGF0ZUNvZGVzVXNlZDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZVZhbGlkYXRlID0gaW5mbGF0ZVZhbGlkYXRlO1xuKi9cblxudmFyIGluZmxhdGVfMSQyID0ge1xuXHRpbmZsYXRlUmVzZXQ6IGluZmxhdGVSZXNldF8xLFxuXHRpbmZsYXRlUmVzZXQyOiBpbmZsYXRlUmVzZXQyXzEsXG5cdGluZmxhdGVSZXNldEtlZXA6IGluZmxhdGVSZXNldEtlZXBfMSxcblx0aW5mbGF0ZUluaXQ6IGluZmxhdGVJbml0XzEsXG5cdGluZmxhdGVJbml0MjogaW5mbGF0ZUluaXQyXzEsXG5cdGluZmxhdGU6IGluZmxhdGVfMiQxLFxuXHRpbmZsYXRlRW5kOiBpbmZsYXRlRW5kXzEsXG5cdGluZmxhdGVHZXRIZWFkZXI6IGluZmxhdGVHZXRIZWFkZXJfMSxcblx0aW5mbGF0ZVNldERpY3Rpb25hcnk6IGluZmxhdGVTZXREaWN0aW9uYXJ5XzEsXG5cdGluZmxhdGVJbmZvOiBpbmZsYXRlSW5mb1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxudmFyIGd6aGVhZGVyID0gR1poZWFkZXI7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9GSU5JU0gsXG4gIFpfT0ssIFpfU1RSRUFNX0VORCwgWl9ORUVEX0RJQ1QsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfTUVNX0VSUk9SXG59ID0gY29uc3RhbnRzJDI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqIGNvbnN0IGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiBjb25zdCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZSQxKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxMDI0ICogNjQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBnemhlYWRlcigpO1xuXG4gIGluZmxhdGVfMSQyLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUVcbiAqICAgZmx1c2ggbW9kZXMuIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILFxuICogICBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBJZiBlbmQgb2Ygc3RyZWFtIGRldGVjdGVkLFxuICogW1tJbmZsYXRlI29uRW5kXV0gd2lsbCBiZSBjYWxsZWQuXG4gKlxuICogYGZsdXNoX21vZGVgIGlzIG5vdCBuZWVkZWQgZm9yIG5vcm1hbCBvcGVyYXRpb24sIGJlY2F1c2UgZW5kIG9mIHN0cmVhbVxuICogZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gWW91IG1heSB0cnkgdG8gdXNlIGl0IGZvciBhZHZhbmNlZCB0aGluZ3MsIGJ1dFxuICogdGhpcyBmdW5jdGlvbmFsaXR5IHdhcyBub3QgdGVzdGVkLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlJDEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBjb25zdCBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlLCBsYXN0X2F2YWlsX291dDtcblxuICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSk7XG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gWl9EQVRBX0VSUk9SKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgY29kZSB3aXRoIG1vcmUgdmVyYm9zZVxuICAgICAgICBzdGF0dXMgPSBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTa2lwIHNueWMgbWFya2VycyBpZiBtb3JlIGRhdGEgZm9sbG93cyBhbmQgbm90IHJhdyBtb2RlXG4gICAgd2hpbGUgKHN0cm0uYXZhaWxfaW4gPiAwICYmXG4gICAgICAgICAgIHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EICYmXG4gICAgICAgICAgIHN0cm0uc3RhdGUud3JhcCA+IDAgJiZcbiAgICAgICAgICAgZGF0YVtzdHJtLm5leHRfaW5dICE9PSAwKVxuICAgIHtcbiAgICAgIGluZmxhdGVfMSQyLmluZmxhdGVSZXNldChzdHJtKTtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFpfU1RSRUFNX0VSUk9SOlxuICAgICAgY2FzZSBaX0RBVEFfRVJST1I6XG4gICAgICBjYXNlIFpfTkVFRF9ESUNUOlxuICAgICAgY2FzZSBaX01FTV9FUlJPUjpcbiAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbWVtYmVyIHJlYWwgYGF2YWlsX291dGAgdmFsdWUsIGJlY2F1c2Ugd2UgbWF5IHBhdGNoIG91dCBidWZmZXIgY29udGVudFxuICAgIC8vIHRvIGFsaWduIHV0Zjggc3RyaW5ncyBib3VuZGFyaWVzLlxuICAgIGxhc3RfYXZhaWxfb3V0ID0gc3RybS5hdmFpbF9vdXQ7XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIGxldCBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIGxldCB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgbGV0IHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsICYgcmVhbGlnbiBjb3VudGVyc1xuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgc3RybS5vdXRwdXQuc2V0KHN0cm0ub3V0cHV0LnN1YmFycmF5KG5leHRfb3V0X3V0ZjgsIG5leHRfb3V0X3V0ZjggKyB0YWlsKSwgMCk7XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0Lmxlbmd0aCA9PT0gc3RybS5uZXh0X291dCA/IHN0cm0ub3V0cHV0IDogc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTXVzdCByZXBlYXQgaXRlcmF0aW9uIGlmIG91dCBidWZmZXIgaXMgZnVsbFxuICAgIGlmIChzdGF0dXMgPT09IFpfT0sgJiYgbGFzdF9hdmFpbF9vdXQgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluYWxpemUgaWYgZW5kIG9mIHN0cmVhbSByZWFjaGVkLlxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgZWFjaCBjaHVuayB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xuICogY29uc3QgaW5wdXQgPSBwYWtvLmRlZmxhdGUobmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSkpO1xuICogbGV0IG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBpbmZsYXRvciA9IG5ldyBJbmZsYXRlJDEob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2luZmxhdG9yLmVycl07XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheUJ1ZmZlcik6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG52YXIgSW5mbGF0ZV8xJDEgPSBJbmZsYXRlJDE7XG52YXIgaW5mbGF0ZV8yID0gaW5mbGF0ZSQxO1xudmFyIGluZmxhdGVSYXdfMSQxID0gaW5mbGF0ZVJhdyQxO1xudmFyIHVuZ3ppcCQxID0gaW5mbGF0ZSQxO1xudmFyIGNvbnN0YW50cyA9IGNvbnN0YW50cyQyO1xuXG52YXIgaW5mbGF0ZV8xJDEgPSB7XG5cdEluZmxhdGU6IEluZmxhdGVfMSQxLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzIsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSQxLFxuXHR1bmd6aXA6IHVuZ3ppcCQxLFxuXHRjb25zdGFudHM6IGNvbnN0YW50c1xufTtcblxuY29uc3QgeyBEZWZsYXRlLCBkZWZsYXRlLCBkZWZsYXRlUmF3LCBnemlwIH0gPSBkZWZsYXRlXzEkMTtcblxuY29uc3QgeyBJbmZsYXRlLCBpbmZsYXRlLCBpbmZsYXRlUmF3LCB1bmd6aXAgfSA9IGluZmxhdGVfMSQxO1xuXG5cblxudmFyIERlZmxhdGVfMSA9IERlZmxhdGU7XG52YXIgZGVmbGF0ZV8xID0gZGVmbGF0ZTtcbnZhciBkZWZsYXRlUmF3XzEgPSBkZWZsYXRlUmF3O1xudmFyIGd6aXBfMSA9IGd6aXA7XG52YXIgSW5mbGF0ZV8xID0gSW5mbGF0ZTtcbnZhciBpbmZsYXRlXzEgPSBpbmZsYXRlO1xudmFyIGluZmxhdGVSYXdfMSA9IGluZmxhdGVSYXc7XG52YXIgdW5nemlwXzEgPSB1bmd6aXA7XG52YXIgY29uc3RhbnRzXzEgPSBjb25zdGFudHMkMjtcblxudmFyIHBha28gPSB7XG5cdERlZmxhdGU6IERlZmxhdGVfMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8xLFxuXHRkZWZsYXRlUmF3OiBkZWZsYXRlUmF3XzEsXG5cdGd6aXA6IGd6aXBfMSxcblx0SW5mbGF0ZTogSW5mbGF0ZV8xLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzEsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSxcblx0dW5nemlwOiB1bmd6aXBfMSxcblx0Y29uc3RhbnRzOiBjb25zdGFudHNfMVxufTtcblxuZXhwb3J0IHsgRGVmbGF0ZV8xIGFzIERlZmxhdGUsIEluZmxhdGVfMSBhcyBJbmZsYXRlLCBjb25zdGFudHNfMSBhcyBjb25zdGFudHMsIHBha28gYXMgZGVmYXVsdCwgZGVmbGF0ZV8xIGFzIGRlZmxhdGUsIGRlZmxhdGVSYXdfMSBhcyBkZWZsYXRlUmF3LCBnemlwXzEgYXMgZ3ppcCwgaW5mbGF0ZV8xIGFzIGluZmxhdGUsIGluZmxhdGVSYXdfMSBhcyBpbmZsYXRlUmF3LCB1bmd6aXBfMSBhcyB1bmd6aXAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/pako/dist/pako.esm.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/components.js":
/*!*******************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/components.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// TODO: To be completed in future revisions\n// This is in API SPEC extracted from starknetjs RPC 0.7 components.ts\n\n//# sourceMappingURL=components.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvY29tcG9uZW50cy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0LXR5cGVzLTA3L2Rpc3QvZXNtL2FwaS9jb21wb25lbnRzLmpzP2EwY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogVG8gYmUgY29tcGxldGVkIGluIGZ1dHVyZSByZXZpc2lvbnNcbi8vIFRoaXMgaXMgaW4gQVBJIFNQRUMgZXh0cmFjdGVkIGZyb20gc3RhcmtuZXRqcyBSUEMgMC43IGNvbXBvbmVudHMudHNcbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/components.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/errors.js":
/*!***************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/errors.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvZXJyb3JzLmpzP2E4M2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EBlockTag: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.EBlockTag; },\n/* harmony export */   EDAMode: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.EDAMode; },\n/* harmony export */   EDataAvailabilityMode: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.EDataAvailabilityMode; },\n/* harmony export */   ESimulationFlag: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ESimulationFlag; },\n/* harmony export */   ETransactionExecutionStatus: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionExecutionStatus; },\n/* harmony export */   ETransactionFinalityStatus: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionFinalityStatus; },\n/* harmony export */   ETransactionStatus: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionStatus; },\n/* harmony export */   ETransactionType: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionType; },\n/* harmony export */   ETransactionVersion: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionVersion; },\n/* harmony export */   ETransactionVersion2: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionVersion2; },\n/* harmony export */   ETransactionVersion3: function() { return /* reexport safe */ _nonspec_js__WEBPACK_IMPORTED_MODULE_2__.ETransactionVersion3; },\n/* harmony export */   Errors: function() { return /* reexport module object */ _errors_js__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   SPEC: function() { return /* reexport module object */ _components_js__WEBPACK_IMPORTED_MODULE_1__; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/errors.js\");\n/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/components.js\");\n/* harmony import */ var _nonspec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonspec.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNVO0FBQ1Y7QUFDWTtBQUNoQjtBQUNHO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvaW5kZXguanM/OGQxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NvbnRyYWN0LmpzJztcbmltcG9ydCAqIGFzIEVycm9yc18xIGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCB7IEVycm9yc18xIGFzIEVycm9ycyB9O1xuaW1wb3J0ICogYXMgU1BFQ18xIGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5leHBvcnQgeyBTUEVDXzEgYXMgU1BFQyB9O1xuZXhwb3J0ICogZnJvbSAnLi9ub25zcGVjLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js":
/*!****************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/api/nonspec.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EBlockTag: function() { return /* binding */ EBlockTag; },\n/* harmony export */   EDAMode: function() { return /* binding */ EDAMode; },\n/* harmony export */   EDataAvailabilityMode: function() { return /* binding */ EDataAvailabilityMode; },\n/* harmony export */   ESimulationFlag: function() { return /* binding */ ESimulationFlag; },\n/* harmony export */   ETransactionExecutionStatus: function() { return /* binding */ ETransactionExecutionStatus; },\n/* harmony export */   ETransactionFinalityStatus: function() { return /* binding */ ETransactionFinalityStatus; },\n/* harmony export */   ETransactionStatus: function() { return /* binding */ ETransactionStatus; },\n/* harmony export */   ETransactionType: function() { return /* binding */ ETransactionType; },\n/* harmony export */   ETransactionVersion: function() { return /* binding */ ETransactionVersion; },\n/* harmony export */   ETransactionVersion2: function() { return /* binding */ ETransactionVersion2; },\n/* harmony export */   ETransactionVersion3: function() { return /* binding */ ETransactionVersion3; }\n/* harmony export */ });\n// Enums Derived From Spec Types (require manual check for changes)\nconst ETransactionType = {\n    DECLARE: 'DECLARE',\n    DEPLOY: 'DEPLOY',\n    DEPLOY_ACCOUNT: 'DEPLOY_ACCOUNT',\n    INVOKE: 'INVOKE',\n    L1_HANDLER: 'L1_HANDLER',\n};\nconst ESimulationFlag = {\n    SKIP_VALIDATE: 'SKIP_VALIDATE',\n    SKIP_FEE_CHARGE: 'SKIP_FEE_CHARGE',\n};\nconst ETransactionStatus = {\n    RECEIVED: 'RECEIVED',\n    REJECTED: 'REJECTED',\n    ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n    ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n};\nconst ETransactionFinalityStatus = {\n    ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',\n    ACCEPTED_ON_L1: 'ACCEPTED_ON_L1',\n};\nconst ETransactionExecutionStatus = {\n    SUCCEEDED: 'SUCCEEDED',\n    REVERTED: 'REVERTED',\n};\nconst EBlockTag = {\n    LATEST: 'latest',\n    PENDING: 'pending',\n};\n// 'L1' | 'L2'\nconst EDataAvailabilityMode = {\n    L1: 'L1',\n    L2: 'L2',\n};\n// 0 | 1\nconst EDAMode = {\n    L1: 0,\n    L2: 1,\n};\n/**\n * V_ Transaction versions HexString\n * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)\n */\nconst ETransactionVersion = {\n    V0: '0x0',\n    V1: '0x1',\n    V2: '0x2',\n    V3: '0x3',\n    F0: '0x100000000000000000000000000000000',\n    F1: '0x100000000000000000000000000000001',\n    F2: '0x100000000000000000000000000000002',\n    F3: '0x100000000000000000000000000000003',\n};\n/**\n * Old Transaction Versions\n */\nconst ETransactionVersion2 = {\n    V0: '0x0',\n    V1: '0x1',\n    V2: '0x2',\n    F0: '0x100000000000000000000000000000000',\n    F1: '0x100000000000000000000000000000001',\n    F2: '0x100000000000000000000000000000002',\n};\n/**\n * V3 Transaction Versions\n */\nconst ETransactionVersion3 = {\n    V3: '0x3',\n    F3: '0x100000000000000000000000000000003',\n};\n//# sourceMappingURL=nonspec.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvbm9uc3BlYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9hcGkvbm9uc3BlYy5qcz84YWU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudW1zIERlcml2ZWQgRnJvbSBTcGVjIFR5cGVzIChyZXF1aXJlIG1hbnVhbCBjaGVjayBmb3IgY2hhbmdlcylcbmV4cG9ydCBjb25zdCBFVHJhbnNhY3Rpb25UeXBlID0ge1xuICAgIERFQ0xBUkU6ICdERUNMQVJFJyxcbiAgICBERVBMT1k6ICdERVBMT1knLFxuICAgIERFUExPWV9BQ0NPVU5UOiAnREVQTE9ZX0FDQ09VTlQnLFxuICAgIElOVk9LRTogJ0lOVk9LRScsXG4gICAgTDFfSEFORExFUjogJ0wxX0hBTkRMRVInLFxufTtcbmV4cG9ydCBjb25zdCBFU2ltdWxhdGlvbkZsYWcgPSB7XG4gICAgU0tJUF9WQUxJREFURTogJ1NLSVBfVkFMSURBVEUnLFxuICAgIFNLSVBfRkVFX0NIQVJHRTogJ1NLSVBfRkVFX0NIQVJHRScsXG59O1xuZXhwb3J0IGNvbnN0IEVUcmFuc2FjdGlvblN0YXR1cyA9IHtcbiAgICBSRUNFSVZFRDogJ1JFQ0VJVkVEJyxcbiAgICBSRUpFQ1RFRDogJ1JFSkVDVEVEJyxcbiAgICBBQ0NFUFRFRF9PTl9MMjogJ0FDQ0VQVEVEX09OX0wyJyxcbiAgICBBQ0NFUFRFRF9PTl9MMTogJ0FDQ0VQVEVEX09OX0wxJyxcbn07XG5leHBvcnQgY29uc3QgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSB7XG4gICAgQUNDRVBURURfT05fTDI6ICdBQ0NFUFRFRF9PTl9MMicsXG4gICAgQUNDRVBURURfT05fTDE6ICdBQ0NFUFRFRF9PTl9MMScsXG59O1xuZXhwb3J0IGNvbnN0IEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IHtcbiAgICBTVUNDRUVERUQ6ICdTVUNDRUVERUQnLFxuICAgIFJFVkVSVEVEOiAnUkVWRVJURUQnLFxufTtcbmV4cG9ydCBjb25zdCBFQmxvY2tUYWcgPSB7XG4gICAgTEFURVNUOiAnbGF0ZXN0JyxcbiAgICBQRU5ESU5HOiAncGVuZGluZycsXG59O1xuLy8gJ0wxJyB8ICdMMidcbmV4cG9ydCBjb25zdCBFRGF0YUF2YWlsYWJpbGl0eU1vZGUgPSB7XG4gICAgTDE6ICdMMScsXG4gICAgTDI6ICdMMicsXG59O1xuLy8gMCB8IDFcbmV4cG9ydCBjb25zdCBFREFNb2RlID0ge1xuICAgIEwxOiAwLFxuICAgIEwyOiAxLFxufTtcbi8qKlxuICogVl8gVHJhbnNhY3Rpb24gdmVyc2lvbnMgSGV4U3RyaW5nXG4gKiBGXyBGZWUgVHJhbnNhY3Rpb24gVmVyc2lvbnMgSGV4U3RyaW5nICgyICoqIDEyOCArIFRSQU5TQUNUSU9OX1ZFUlNJT04pXG4gKi9cbmV4cG9ydCBjb25zdCBFVHJhbnNhY3Rpb25WZXJzaW9uID0ge1xuICAgIFYwOiAnMHgwJyxcbiAgICBWMTogJzB4MScsXG4gICAgVjI6ICcweDInLFxuICAgIFYzOiAnMHgzJyxcbiAgICBGMDogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICBGMTogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAgICBGMjogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyJyxcbiAgICBGMzogJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzJyxcbn07XG4vKipcbiAqIE9sZCBUcmFuc2FjdGlvbiBWZXJzaW9uc1xuICovXG5leHBvcnQgY29uc3QgRVRyYW5zYWN0aW9uVmVyc2lvbjIgPSB7XG4gICAgVjA6ICcweDAnLFxuICAgIFYxOiAnMHgxJyxcbiAgICBWMjogJzB4MicsXG4gICAgRjA6ICcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgRjE6ICcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gICAgRjI6ICcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMicsXG59O1xuLyoqXG4gKiBWMyBUcmFuc2FjdGlvbiBWZXJzaW9uc1xuICovXG5leHBvcnQgY29uc3QgRVRyYW5zYWN0aW9uVmVyc2lvbjMgPSB7XG4gICAgVjM6ICcweDMnLFxuICAgIEYzOiAnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDMnLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbnNwZWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API: function() { return /* reexport module object */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   EBlockTag: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.EBlockTag; },\n/* harmony export */   EDAMode: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.EDAMode; },\n/* harmony export */   EDataAvailabilityMode: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.EDataAvailabilityMode; },\n/* harmony export */   ESimulationFlag: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ESimulationFlag; },\n/* harmony export */   ETransactionExecutionStatus: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionExecutionStatus; },\n/* harmony export */   ETransactionFinalityStatus: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionFinalityStatus; },\n/* harmony export */   ETransactionStatus: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionStatus; },\n/* harmony export */   ETransactionType: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionType; },\n/* harmony export */   ETransactionVersion: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionVersion; },\n/* harmony export */   ETransactionVersion2: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionVersion2; },\n/* harmony export */   ETransactionVersion3: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.ETransactionVersion3; },\n/* harmony export */   Errors: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.Errors; },\n/* harmony export */   Permission: function() { return /* reexport safe */ _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__.Permission; },\n/* harmony export */   SPEC: function() { return /* reexport safe */ _api_index_js__WEBPACK_IMPORTED_MODULE_0__.SPEC; },\n/* harmony export */   TypedDataRevision: function() { return /* reexport safe */ _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__.TypedDataRevision; },\n/* harmony export */   WALLET_API: function() { return /* reexport module object */ _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__; }\n/* harmony export */ });\n/* harmony import */ var _api_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api/index.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/index.js\");\n/* harmony import */ var _wallet_api_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wallet-api/index.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/index.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ1M7QUFDaEI7QUFDYztBQUNnQjtBQUNoQjtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQtdHlwZXMtMDcvZGlzdC9lc20vaW5kZXguanM/ZTRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FwaS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBBUElfMSBmcm9tICcuL2FwaS9pbmRleC5qcyc7XG5leHBvcnQgeyBBUElfMSBhcyBBUEkgfTtcbmV4cG9ydCAqIGZyb20gJy4vd2FsbGV0LWFwaS9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBXQUxMRVRfQVBJXzEgZnJvbSAnLi93YWxsZXQtYXBpL2luZGV4LmpzJztcbmV4cG9ydCB7IFdBTExFVF9BUElfMSBhcyBXQUxMRVRfQVBJIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Permission: function() { return /* binding */ Permission; }\n/* harmony export */ });\nconst Permission = {\n    ACCOUNTS: 'accounts',\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS93YWxsZXQtYXBpL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0LXR5cGVzLTA3L2Rpc3QvZXNtL3dhbGxldC1hcGkvY29uc3RhbnRzLmpzP2I3YzgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFBlcm1pc3Npb24gPSB7XG4gICAgQUNDT1VOVFM6ICdhY2NvdW50cycsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/wallet-api/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Permission: function() { return /* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.Permission; },\n/* harmony export */   TypedDataRevision: function() { return /* reexport safe */ _typedData_js__WEBPACK_IMPORTED_MODULE_1__.TypedDataRevision; }\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/constants.js\");\n/* harmony import */ var _typedData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typedData.js */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS93YWxsZXQtYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNXO0FBQ1Y7QUFDSDtBQUNEO0FBQ0E7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0YXJrbmV0LXR5cGVzLTA3L2Rpc3QvZXNtL3dhbGxldC1hcGkvaW5kZXguanM/YjBjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVkRGF0YS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1N0YXJrbmV0V2luZG93T2JqZWN0LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL21ldGhvZHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ldmVudHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js":
/*!*************************************************************************!*\
  !*** ./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataRevision: function() { return /* binding */ TypedDataRevision; }\n/* harmony export */ });\nconst TypedDataRevision = {\n    ACTIVE: '1',\n    LEGACY: '0',\n};\n//# sourceMappingURL=typedData.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC10eXBlcy0wNy9kaXN0L2VzbS93YWxsZXQtYXBpL3R5cGVkRGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3RhcmtuZXQtdHlwZXMtMDcvZGlzdC9lc20vd2FsbGV0LWFwaS90eXBlZERhdGEuanM/Njk3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVHlwZWREYXRhUmV2aXNpb24gPSB7XG4gICAgQUNUSVZFOiAnMScsXG4gICAgTEVHQUNZOiAnMCcsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWREYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/starknet/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/starknet/dist/index.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: function() { return /* binding */ Account; },\n/* harmony export */   AccountInterface: function() { return /* binding */ AccountInterface; },\n/* harmony export */   BlockStatus: function() { return /* binding */ BlockStatus; },\n/* harmony export */   BlockTag: function() { return /* binding */ BlockTag; },\n/* harmony export */   CairoCustomEnum: function() { return /* binding */ CairoCustomEnum; },\n/* harmony export */   CairoOption: function() { return /* binding */ CairoOption; },\n/* harmony export */   CairoOptionVariant: function() { return /* binding */ CairoOptionVariant; },\n/* harmony export */   CairoResult: function() { return /* binding */ CairoResult; },\n/* harmony export */   CairoResultVariant: function() { return /* binding */ CairoResultVariant; },\n/* harmony export */   CairoUint256: function() { return /* binding */ CairoUint256; },\n/* harmony export */   CairoUint512: function() { return /* binding */ CairoUint512; },\n/* harmony export */   CallData: function() { return /* binding */ CallData; },\n/* harmony export */   Contract: function() { return /* binding */ Contract; },\n/* harmony export */   ContractFactory: function() { return /* binding */ ContractFactory; },\n/* harmony export */   ContractInterface: function() { return /* binding */ ContractInterface; },\n/* harmony export */   CustomError: function() { return /* binding */ CustomError; },\n/* harmony export */   EntryPointType: function() { return /* binding */ EntryPointType; },\n/* harmony export */   EthSigner: function() { return /* binding */ EthSigner; },\n/* harmony export */   GatewayError: function() { return /* binding */ GatewayError; },\n/* harmony export */   HttpError: function() { return /* binding */ HttpError; },\n/* harmony export */   LedgerSigner: function() { return /* binding */ LedgerSigner; },\n/* harmony export */   LibraryError: function() { return /* binding */ LibraryError; },\n/* harmony export */   Literal: function() { return /* binding */ Literal; },\n/* harmony export */   Provider: function() { return /* binding */ RpcProvider2; },\n/* harmony export */   ProviderInterface: function() { return /* binding */ ProviderInterface; },\n/* harmony export */   RPC: function() { return /* binding */ api_exports; },\n/* harmony export */   RPC06: function() { return /* binding */ rpc_0_6_exports; },\n/* harmony export */   RPC07: function() { return /* binding */ rpc_0_7_exports; },\n/* harmony export */   RPCResponseParser: function() { return /* binding */ RPCResponseParser; },\n/* harmony export */   ReceiptTx: function() { return /* binding */ ReceiptTx; },\n/* harmony export */   ResponseParser: function() { return /* binding */ ResponseParser; },\n/* harmony export */   RpcChannel: function() { return /* binding */ RpcChannel2; },\n/* harmony export */   RpcProvider: function() { return /* binding */ RpcProvider2; },\n/* harmony export */   Signer: function() { return /* binding */ Signer; },\n/* harmony export */   SignerInterface: function() { return /* binding */ SignerInterface; },\n/* harmony export */   TransactionExecutionStatus: function() { return /* binding */ TransactionExecutionStatus; },\n/* harmony export */   TransactionFinalityStatus: function() { return /* binding */ TransactionFinalityStatus; },\n/* harmony export */   TransactionStatus: function() { return /* binding */ TransactionStatus; },\n/* harmony export */   TransactionType: function() { return /* binding */ TransactionType; },\n/* harmony export */   TypedDataRevision: function() { return /* reexport safe */ starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision; },\n/* harmony export */   UINT_128_MAX: function() { return /* binding */ UINT_128_MAX; },\n/* harmony export */   UINT_128_MIN: function() { return /* binding */ UINT_128_MIN; },\n/* harmony export */   UINT_256_HIGH_MAX: function() { return /* binding */ UINT_256_HIGH_MAX; },\n/* harmony export */   UINT_256_HIGH_MIN: function() { return /* binding */ UINT_256_HIGH_MIN; },\n/* harmony export */   UINT_256_LOW_MAX: function() { return /* binding */ UINT_256_LOW_MAX; },\n/* harmony export */   UINT_256_LOW_MIN: function() { return /* binding */ UINT_256_LOW_MIN; },\n/* harmony export */   UINT_256_MAX: function() { return /* binding */ UINT_256_MAX; },\n/* harmony export */   UINT_256_MIN: function() { return /* binding */ UINT_256_MIN; },\n/* harmony export */   UINT_512_MAX: function() { return /* binding */ UINT_512_MAX; },\n/* harmony export */   UINT_512_MIN: function() { return /* binding */ UINT_512_MIN; },\n/* harmony export */   Uint: function() { return /* binding */ Uint; },\n/* harmony export */   ValidateType: function() { return /* binding */ ValidateType; },\n/* harmony export */   WalletAccount: function() { return /* binding */ WalletAccount; },\n/* harmony export */   addAddressPadding: function() { return /* binding */ addAddressPadding; },\n/* harmony export */   buildUrl: function() { return /* binding */ buildUrl; },\n/* harmony export */   byteArray: function() { return /* binding */ byteArray_exports; },\n/* harmony export */   cairo: function() { return /* binding */ cairo_exports; },\n/* harmony export */   constants: function() { return /* binding */ constants_exports; },\n/* harmony export */   contractClassResponseToLegacyCompiledContract: function() { return /* binding */ contractClassResponseToLegacyCompiledContract; },\n/* harmony export */   defaultProvider: function() { return /* binding */ defaultProvider; },\n/* harmony export */   ec: function() { return /* binding */ ec_exports; },\n/* harmony export */   encode: function() { return /* binding */ encode_exports; },\n/* harmony export */   eth: function() { return /* binding */ eth_exports; },\n/* harmony export */   events: function() { return /* binding */ events_exports; },\n/* harmony export */   extractContractHashes: function() { return /* binding */ extractContractHashes; },\n/* harmony export */   fixProto: function() { return /* binding */ fixProto; },\n/* harmony export */   fixStack: function() { return /* binding */ fixStack; },\n/* harmony export */   getCalldata: function() { return /* binding */ getCalldata; },\n/* harmony export */   getChecksumAddress: function() { return /* binding */ getChecksumAddress; },\n/* harmony export */   getLedgerPathBuffer: function() { return /* binding */ getLedgerPathBuffer; },\n/* harmony export */   hash: function() { return /* binding */ hash_exports; },\n/* harmony export */   isSierra: function() { return /* binding */ isSierra; },\n/* harmony export */   isUrl: function() { return /* binding */ isUrl; },\n/* harmony export */   json: function() { return /* binding */ json_exports; },\n/* harmony export */   merkle: function() { return /* binding */ merkle_exports; },\n/* harmony export */   num: function() { return /* binding */ num_exports; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   parseCalldataField: function() { return /* binding */ parseCalldataField; },\n/* harmony export */   provider: function() { return /* binding */ provider_exports; },\n/* harmony export */   selector: function() { return /* binding */ selector_exports; },\n/* harmony export */   shortString: function() { return /* binding */ shortString_exports; },\n/* harmony export */   splitArgsAndOptions: function() { return /* binding */ splitArgsAndOptions; },\n/* harmony export */   stark: function() { return /* binding */ stark_exports; },\n/* harmony export */   starknetId: function() { return /* binding */ starknetId_exports; },\n/* harmony export */   transaction: function() { return /* binding */ transaction_exports; },\n/* harmony export */   typedData: function() { return /* binding */ typedData_exports; },\n/* harmony export */   types: function() { return /* binding */ types_exports; },\n/* harmony export */   uint256: function() { return /* binding */ uint256_exports; },\n/* harmony export */   v2hash: function() { return /* binding */ v2_exports; },\n/* harmony export */   v3hash: function() { return /* binding */ v3_exports; },\n/* harmony export */   validateAndParseAddress: function() { return /* binding */ validateAndParseAddress; },\n/* harmony export */   validateChecksumAddress: function() { return /* binding */ validateChecksumAddress; },\n/* harmony export */   wallet: function() { return /* binding */ connect_exports; }\n/* harmony export */ });\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! starknet-types-07 */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! starknet-types-07 */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/api/nonspec.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var starknet_types_07__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! starknet-types-07 */ \"(app-pages-browser)/./node_modules/starknet-types-07/dist/esm/wallet-api/typedData.js\");\n/* harmony import */ var lossless_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lossless-json */ \"(app-pages-browser)/./node_modules/lossless-json/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_starknet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @scure/starknet */ \"(app-pages-browser)/./node_modules/@scure/starknet/lib/esm/index.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/curves/abstract/poseidon */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/poseidon.js\");\n/* harmony import */ var _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/abstract/weierstrass */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! pako */ \"(app-pages-browser)/./node_modules/pako/dist/pako.esm.mjs\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var fetch_cookie__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! fetch-cookie */ \"(app-pages-browser)/./node_modules/fetch-cookie/esm/index.js\");\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! isomorphic-fetch */ \"(app-pages-browser)/./node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\n/* harmony import */ var ts_mixer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ts-mixer */ \"(app-pages-browser)/./node_modules/ts-mixer/dist/esm/index.js\");\n/* harmony import */ var url_join__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! url-join */ \"(app-pages-browser)/./node_modules/url-join/lib/url-join.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/constants.ts\nvar constants_exports = {};\n__export(constants_exports, {\n  ADDR_BOUND: () => ADDR_BOUND,\n  API_VERSION: () => API_VERSION,\n  BaseUrl: () => BaseUrl,\n  FeeMarginPercentage: () => FeeMarginPercentage,\n  IS_BROWSER: () => IS_BROWSER,\n  MASK_250: () => MASK_250,\n  MASK_31: () => MASK_31,\n  MAX_STORAGE_ITEM_SIZE: () => MAX_STORAGE_ITEM_SIZE,\n  NetworkName: () => NetworkName,\n  PRIME: () => PRIME,\n  RANGE_FELT: () => RANGE_FELT,\n  RANGE_I128: () => RANGE_I128,\n  RANGE_U128: () => RANGE_U128,\n  RPC_DEFAULT_VERSION: () => RPC_DEFAULT_VERSION,\n  RPC_NODES: () => RPC_NODES,\n  StarknetChainId: () => StarknetChainId,\n  TEXT_TO_FELT_MAX_LEN: () => TEXT_TO_FELT_MAX_LEN,\n  TRANSACTION_VERSION: () => api_exports.ETransactionVersion,\n  TransactionHashPrefix: () => TransactionHashPrefix,\n  UDC: () => UDC,\n  ZERO: () => ZERO\n});\n\n// src/types/api/index.ts\nvar api_exports = {};\n__export(api_exports, {\n  JRPC: () => jsonrpc_exports,\n  RPCSPEC06: () => rpcspec_0_6_exports,\n  RPCSPEC07: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_0__\n});\n\n// src/types/api/jsonrpc/index.ts\nvar jsonrpc_exports = {};\n\n// src/types/api/rpcspec_0_6/index.ts\nvar rpcspec_0_6_exports = {};\n__export(rpcspec_0_6_exports, {\n  EBlockTag: () => EBlockTag,\n  EDAMode: () => EDAMode,\n  EDataAvailabilityMode: () => EDataAvailabilityMode,\n  ESimulationFlag: () => ESimulationFlag,\n  ETransactionExecutionStatus: () => ETransactionExecutionStatus,\n  ETransactionFinalityStatus: () => ETransactionFinalityStatus,\n  ETransactionStatus: () => ETransactionStatus,\n  ETransactionType: () => ETransactionType,\n  ETransactionVersion: () => ETransactionVersion,\n  ETransactionVersion2: () => ETransactionVersion2,\n  ETransactionVersion3: () => ETransactionVersion3,\n  Errors: () => errors_exports,\n  SPEC: () => components_exports\n});\n\n// src/types/api/rpcspec_0_6/errors.ts\nvar errors_exports = {};\n\n// src/types/api/rpcspec_0_6/components.ts\nvar components_exports = {};\n\n// src/types/api/rpcspec_0_6/nonspec.ts\nvar ETransactionType = /* @__PURE__ */ ((ETransactionType2) => {\n  ETransactionType2[\"DECLARE\"] = \"DECLARE\";\n  ETransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  ETransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  ETransactionType2[\"INVOKE\"] = \"INVOKE\";\n  ETransactionType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  return ETransactionType2;\n})(ETransactionType || {});\nvar ESimulationFlag = /* @__PURE__ */ ((ESimulationFlag2) => {\n  ESimulationFlag2[\"SKIP_VALIDATE\"] = \"SKIP_VALIDATE\";\n  ESimulationFlag2[\"SKIP_FEE_CHARGE\"] = \"SKIP_FEE_CHARGE\";\n  return ESimulationFlag2;\n})(ESimulationFlag || {});\nvar ETransactionStatus = /* @__PURE__ */ ((ETransactionStatus2) => {\n  ETransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  ETransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  ETransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionStatus2;\n})(ETransactionStatus || {});\nvar ETransactionFinalityStatus = /* @__PURE__ */ ((ETransactionFinalityStatus2) => {\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  ETransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return ETransactionFinalityStatus2;\n})(ETransactionFinalityStatus || {});\nvar ETransactionExecutionStatus = /* @__PURE__ */ ((ETransactionExecutionStatus2) => {\n  ETransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  ETransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return ETransactionExecutionStatus2;\n})(ETransactionExecutionStatus || {});\nvar EBlockTag = /* @__PURE__ */ ((EBlockTag2) => {\n  EBlockTag2[\"PENDING\"] = \"pending\";\n  EBlockTag2[\"LATEST\"] = \"latest\";\n  return EBlockTag2;\n})(EBlockTag || {});\nvar EDataAvailabilityMode = /* @__PURE__ */ ((EDataAvailabilityMode3) => {\n  EDataAvailabilityMode3[\"L1\"] = \"L1\";\n  EDataAvailabilityMode3[\"L2\"] = \"L2\";\n  return EDataAvailabilityMode3;\n})(EDataAvailabilityMode || {});\nvar EDAMode = /* @__PURE__ */ ((EDAMode4) => {\n  EDAMode4[EDAMode4[\"L1\"] = 0] = \"L1\";\n  EDAMode4[EDAMode4[\"L2\"] = 1] = \"L2\";\n  return EDAMode4;\n})(EDAMode || {});\nvar ETransactionVersion = /* @__PURE__ */ ((ETransactionVersion10) => {\n  ETransactionVersion10[\"V0\"] = \"0x0\";\n  ETransactionVersion10[\"V1\"] = \"0x1\";\n  ETransactionVersion10[\"V2\"] = \"0x2\";\n  ETransactionVersion10[\"V3\"] = \"0x3\";\n  ETransactionVersion10[\"F0\"] = \"0x100000000000000000000000000000000\";\n  ETransactionVersion10[\"F1\"] = \"0x100000000000000000000000000000001\";\n  ETransactionVersion10[\"F2\"] = \"0x100000000000000000000000000000002\";\n  ETransactionVersion10[\"F3\"] = \"0x100000000000000000000000000000003\";\n  return ETransactionVersion10;\n})(ETransactionVersion || {});\nvar ETransactionVersion2 = /* @__PURE__ */ ((ETransactionVersion25) => {\n  ETransactionVersion25[\"V0\"] = \"0x0\";\n  ETransactionVersion25[\"V1\"] = \"0x1\";\n  ETransactionVersion25[\"V2\"] = \"0x2\";\n  ETransactionVersion25[\"F0\"] = \"0x100000000000000000000000000000000\";\n  ETransactionVersion25[\"F1\"] = \"0x100000000000000000000000000000001\";\n  ETransactionVersion25[\"F2\"] = \"0x100000000000000000000000000000002\";\n  return ETransactionVersion25;\n})(ETransactionVersion2 || {});\nvar ETransactionVersion3 = /* @__PURE__ */ ((ETransactionVersion37) => {\n  ETransactionVersion37[\"V3\"] = \"0x3\";\n  ETransactionVersion37[\"F3\"] = \"0x100000000000000000000000000000003\";\n  return ETransactionVersion37;\n})(ETransactionVersion3 || {});\n\n// src/types/api/index.ts\n__reExport(api_exports, starknet_types_07__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n// src/utils/encode.ts\nvar encode_exports = {};\n__export(encode_exports, {\n  IS_BROWSER: () => IS_BROWSER,\n  addHexPrefix: () => addHexPrefix,\n  arrayBufferToString: () => arrayBufferToString,\n  atobUniversal: () => atobUniversal,\n  btoaUniversal: () => btoaUniversal,\n  buf2hex: () => buf2hex,\n  calcByteLength: () => calcByteLength,\n  concatenateArrayBuffer: () => concatenateArrayBuffer,\n  padLeft: () => padLeft,\n  pascalToSnake: () => pascalToSnake,\n  removeHexPrefix: () => removeHexPrefix,\n  sanitizeBytes: () => sanitizeBytes,\n  sanitizeHex: () => sanitizeHex,\n  stringToArrayBuffer: () => stringToArrayBuffer,\n  utf8ToArray: () => utf8ToArray\n});\n\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar STRING_ZERO = \"0\";\nfunction arrayBufferToString(array) {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), \"\");\n}\nfunction utf8ToArray(str) {\n  return new TextEncoder().encode(str);\n}\nfunction stringToArrayBuffer(str) {\n  return utf8ToArray(str);\n}\nfunction atobUniversal(a) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.decode(a);\n}\nfunction btoaUniversal(b) {\n  return _scure_base__WEBPACK_IMPORTED_MODULE_1__.base64.encode(new Uint8Array(b));\n}\nfunction buf2hex(buffer) {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction removeHexPrefix(hex) {\n  return hex.replace(/^0x/i, \"\");\n}\nfunction addHexPrefix(hex) {\n  return `0x${removeHexPrefix(hex)}`;\n}\nfunction padString(str, length, left, padding = STRING_ZERO) {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\nfunction padLeft(str, length, padding = STRING_ZERO) {\n  return padString(str, length, true, padding);\n}\nfunction calcByteLength(str, byteSize = 8) {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;\n}\nfunction sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\nfunction sanitizeHex(hex) {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n  return hex;\n}\nvar pascalToSnake = (text) => /[a-z]/.test(text) ? text.split(/(?=[A-Z])/).join(\"_\").toUpperCase() : text;\nfunction concatenateArrayBuffer(uint8arrays) {\n  const totalLength = uint8arrays.reduce((total, uint8array) => total + uint8array.byteLength, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  uint8arrays.forEach((uint8array) => {\n    result.set(uint8array, offset);\n    offset += uint8array.byteLength;\n  });\n  return result;\n}\n\n// src/constants.ts\nvar TEXT_TO_FELT_MAX_LEN = 31;\nvar ZERO = 0n;\nvar MASK_250 = 2n ** 250n - 1n;\nvar MASK_31 = 2n ** 31n - 1n;\nvar API_VERSION = ZERO;\nvar PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;\nvar MAX_STORAGE_ITEM_SIZE = 256n;\nvar ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\nvar range = (min, max) => ({ min, max });\nvar RANGE_FELT = range(ZERO, PRIME - 1n);\nvar RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);\nvar RANGE_U128 = range(ZERO, 2n ** 128n - 1n);\nvar BaseUrl = /* @__PURE__ */ ((BaseUrl2) => {\n  BaseUrl2[\"SN_MAIN\"] = \"https://alpha-mainnet.starknet.io\";\n  BaseUrl2[\"SN_SEPOLIA\"] = \"https://alpha-sepolia.starknet.io\";\n  return BaseUrl2;\n})(BaseUrl || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"SN_MAIN\"] = \"SN_MAIN\";\n  NetworkName2[\"SN_SEPOLIA\"] = \"SN_SEPOLIA\";\n  return NetworkName2;\n})(NetworkName || {});\nvar StarknetChainId = /* @__PURE__ */ ((StarknetChainId6) => {\n  StarknetChainId6[\"SN_MAIN\"] = \"0x534e5f4d41494e\";\n  StarknetChainId6[\"SN_SEPOLIA\"] = \"0x534e5f5345504f4c4941\";\n  return StarknetChainId6;\n})(StarknetChainId || {});\nvar TransactionHashPrefix = /* @__PURE__ */ ((TransactionHashPrefix2) => {\n  TransactionHashPrefix2[\"DECLARE\"] = \"0x6465636c617265\";\n  TransactionHashPrefix2[\"DEPLOY\"] = \"0x6465706c6f79\";\n  TransactionHashPrefix2[\"DEPLOY_ACCOUNT\"] = \"0x6465706c6f795f6163636f756e74\";\n  TransactionHashPrefix2[\"INVOKE\"] = \"0x696e766f6b65\";\n  TransactionHashPrefix2[\"L1_HANDLER\"] = \"0x6c315f68616e646c6572\";\n  return TransactionHashPrefix2;\n})(TransactionHashPrefix || {});\nvar FeeMarginPercentage = /* @__PURE__ */ ((FeeMarginPercentage2) => {\n  FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_AMOUNT\"] = 50] = \"L1_BOUND_MAX_AMOUNT\";\n  FeeMarginPercentage2[FeeMarginPercentage2[\"L1_BOUND_MAX_PRICE_PER_UNIT\"] = 50] = \"L1_BOUND_MAX_PRICE_PER_UNIT\";\n  FeeMarginPercentage2[FeeMarginPercentage2[\"MAX_FEE\"] = 50] = \"MAX_FEE\";\n  return FeeMarginPercentage2;\n})(FeeMarginPercentage || {});\nvar UDC = {\n  ADDRESS: \"0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\",\n  ENTRYPOINT: \"deployContract\"\n};\nvar RPC_DEFAULT_VERSION = \"v0_7\";\nvar RPC_NODES = {\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`\n  ]\n};\n\n// src/channel/rpc_0_6.ts\nvar rpc_0_6_exports = {};\n__export(rpc_0_6_exports, {\n  RpcChannel: () => RpcChannel\n});\n\n// src/provider/errors.ts\nfunction fixStack(target, fn = target.constructor) {\n  const { captureStackTrace } = Error;\n  captureStackTrace && captureStackTrace(target, fn);\n}\nfunction fixProto(target, prototype) {\n  const { setPrototypeOf } = Object;\n  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;\n}\nvar CustomError = class extends Error {\n  name;\n  constructor(message) {\n    super(message);\n    Object.defineProperty(this, \"name\", {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n    fixProto(this, new.target.prototype);\n    fixStack(this);\n  }\n};\nvar LibraryError = class extends CustomError {\n};\nvar GatewayError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\nvar HttpError = class extends LibraryError {\n  constructor(message, errorCode) {\n    super(message);\n    this.errorCode = errorCode;\n  }\n};\n\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n  BlockStatus: () => BlockStatus,\n  BlockTag: () => BlockTag,\n  EntryPointType: () => EntryPointType,\n  Literal: () => Literal,\n  RPC: () => api_exports,\n  TransactionExecutionStatus: () => TransactionExecutionStatus,\n  TransactionFinalityStatus: () => TransactionFinalityStatus,\n  TransactionStatus: () => TransactionStatus,\n  TransactionType: () => TransactionType,\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n  Uint: () => Uint,\n  ValidateType: () => ValidateType\n});\n\n// src/types/calldata.ts\nvar ValidateType = /* @__PURE__ */ ((ValidateType2) => {\n  ValidateType2[\"DEPLOY\"] = \"DEPLOY\";\n  ValidateType2[\"CALL\"] = \"CALL\";\n  ValidateType2[\"INVOKE\"] = \"INVOKE\";\n  return ValidateType2;\n})(ValidateType || {});\nvar Uint = /* @__PURE__ */ ((Uint2) => {\n  Uint2[\"u8\"] = \"core::integer::u8\";\n  Uint2[\"u16\"] = \"core::integer::u16\";\n  Uint2[\"u32\"] = \"core::integer::u32\";\n  Uint2[\"u64\"] = \"core::integer::u64\";\n  Uint2[\"u128\"] = \"core::integer::u128\";\n  Uint2[\"u256\"] = \"core::integer::u256\";\n  Uint2[\"u512\"] = \"core::integer::u512\";\n  return Uint2;\n})(Uint || {});\nvar Literal = /* @__PURE__ */ ((Literal2) => {\n  Literal2[\"ClassHash\"] = \"core::starknet::class_hash::ClassHash\";\n  Literal2[\"ContractAddress\"] = \"core::starknet::contract_address::ContractAddress\";\n  Literal2[\"Secp256k1Point\"] = \"core::starknet::secp256k1::Secp256k1Point\";\n  return Literal2;\n})(Literal || {});\n\n// src/types/lib/contract/index.ts\nvar EntryPointType = /* @__PURE__ */ ((EntryPointType2) => {\n  EntryPointType2[\"EXTERNAL\"] = \"EXTERNAL\";\n  EntryPointType2[\"L1_HANDLER\"] = \"L1_HANDLER\";\n  EntryPointType2[\"CONSTRUCTOR\"] = \"CONSTRUCTOR\";\n  return EntryPointType2;\n})(EntryPointType || {});\n\n// src/types/lib/index.ts\nvar TransactionType = /* @__PURE__ */ ((TransactionType2) => {\n  TransactionType2[\"DECLARE\"] = \"DECLARE\";\n  TransactionType2[\"DEPLOY\"] = \"DEPLOY\";\n  TransactionType2[\"DEPLOY_ACCOUNT\"] = \"DEPLOY_ACCOUNT\";\n  TransactionType2[\"INVOKE\"] = \"INVOKE_FUNCTION\";\n  return TransactionType2;\n})(TransactionType || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {\n  TransactionStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  TransactionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionStatus2[\"REVERTED\"] = \"REVERTED\";\n  return TransactionStatus2;\n})(TransactionStatus || {});\nvar TransactionFinalityStatus = /* @__PURE__ */ ((TransactionFinalityStatus2) => {\n  TransactionFinalityStatus2[\"NOT_RECEIVED\"] = \"NOT_RECEIVED\";\n  TransactionFinalityStatus2[\"RECEIVED\"] = \"RECEIVED\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  TransactionFinalityStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  return TransactionFinalityStatus2;\n})(TransactionFinalityStatus || {});\nvar TransactionExecutionStatus = /* @__PURE__ */ ((TransactionExecutionStatus2) => {\n  TransactionExecutionStatus2[\"REJECTED\"] = \"REJECTED\";\n  TransactionExecutionStatus2[\"REVERTED\"] = \"REVERTED\";\n  TransactionExecutionStatus2[\"SUCCEEDED\"] = \"SUCCEEDED\";\n  return TransactionExecutionStatus2;\n})(TransactionExecutionStatus || {});\nvar BlockStatus = /* @__PURE__ */ ((BlockStatus2) => {\n  BlockStatus2[\"PENDING\"] = \"PENDING\";\n  BlockStatus2[\"ACCEPTED_ON_L1\"] = \"ACCEPTED_ON_L1\";\n  BlockStatus2[\"ACCEPTED_ON_L2\"] = \"ACCEPTED_ON_L2\";\n  BlockStatus2[\"REJECTED\"] = \"REJECTED\";\n  return BlockStatus2;\n})(BlockStatus || {});\nvar BlockTag = /* @__PURE__ */ ((BlockTag2) => {\n  BlockTag2[\"PENDING\"] = \"pending\";\n  BlockTag2[\"LATEST\"] = \"latest\";\n  return BlockTag2;\n})(BlockTag || {});\n\n// src/types/typedData.ts\n\n\n// src/utils/json.ts\nvar json_exports = {};\n__export(json_exports, {\n  parse: () => parse2,\n  parseAlwaysAsBig: () => parseAlwaysAsBig,\n  stringify: () => stringify2,\n  stringifyAlwaysAsBig: () => stringifyAlwaysAsBig\n});\n\nvar parseIntAsNumberOrBigInt = (str) => {\n  if (!lossless_json__WEBPACK_IMPORTED_MODULE_3__.isInteger(str)) return parseFloat(str);\n  const num = parseInt(str, 10);\n  return Number.isSafeInteger(num) ? num : BigInt(str);\n};\nvar parse2 = (str) => lossless_json__WEBPACK_IMPORTED_MODULE_3__.parse(String(str), void 0, parseIntAsNumberOrBigInt);\nvar parseAlwaysAsBig = (str) => lossless_json__WEBPACK_IMPORTED_MODULE_3__.parse(String(str), void 0, lossless_json__WEBPACK_IMPORTED_MODULE_3__.parseNumberAndBigInt);\nvar stringify2 = (value, replacer, space, numberStringifiers) => lossless_json__WEBPACK_IMPORTED_MODULE_3__.stringify(value, replacer, space, numberStringifiers);\nvar stringifyAlwaysAsBig = stringify2;\n\n// src/utils/batch/index.ts\nvar BatchClient = class {\n  nodeUrl;\n  headers;\n  interval;\n  requestId = 0;\n  pendingRequests = {};\n  batchPromises = {};\n  delayTimer;\n  delayPromise;\n  delayPromiseResolve;\n  constructor(options) {\n    this.nodeUrl = options.nodeUrl;\n    this.headers = options.headers;\n    this.interval = options.interval;\n  }\n  async wait() {\n    if (!this.delayPromise || !this.delayPromiseResolve) {\n      this.delayPromise = new Promise((resolve) => {\n        this.delayPromiseResolve = resolve;\n      });\n    }\n    if (this.delayTimer) {\n      clearTimeout(this.delayTimer);\n      this.delayTimer = void 0;\n    }\n    this.delayTimer = setTimeout(() => {\n      if (this.delayPromiseResolve) {\n        this.delayPromiseResolve();\n        this.delayPromise = void 0;\n        this.delayPromiseResolve = void 0;\n      }\n    }, this.interval);\n    return this.delayPromise;\n  }\n  addPendingRequest(method, params, id) {\n    const request = {\n      id: id ?? `batched_${this.requestId += 1}`,\n      jsonrpc: \"2.0\",\n      method,\n      params: params ?? void 0\n    };\n    this.pendingRequests[request.id] = request;\n    return request.id;\n  }\n  async sendBatch(requests) {\n    const raw = await fetch(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(requests),\n      headers: this.headers\n    });\n    return raw.json();\n  }\n  /**\n   * Automatically batches and fetches JSON-RPC calls in a single request.\n   * @param method Method to call\n   * @param params Method parameters\n   * @param id JSON-RPC Request ID\n   * @returns JSON-RPC Response\n   */\n  async fetch(method, params, id) {\n    const requestId = this.addPendingRequest(method, params, id);\n    await this.wait();\n    const requests = this.pendingRequests;\n    this.pendingRequests = {};\n    if (!this.batchPromises[requestId]) {\n      const promise = this.sendBatch(Object.values(requests));\n      Object.keys(requests).forEach((key) => {\n        this.batchPromises[key] = promise;\n      });\n    }\n    const results = await this.batchPromises[requestId];\n    delete this.batchPromises[requestId];\n    const result = results.find((res) => res.id === requestId);\n    if (!result) throw new Error(`Couldn't find the result for the request. Method: ${method}`);\n    return result;\n  }\n};\n\n// src/utils/assert.ts\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failure\");\n  }\n}\n\n// src/utils/num.ts\nvar num_exports = {};\n__export(num_exports, {\n  addPercent: () => addPercent,\n  assertInRange: () => assertInRange,\n  bigNumberishArrayToDecimalStringArray: () => bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray: () => bigNumberishArrayToHexadecimalStringArray,\n  cleanHex: () => cleanHex,\n  getDecimalString: () => getDecimalString,\n  getHexString: () => getHexString,\n  getHexStringArray: () => getHexStringArray,\n  hexToBytes: () => hexToBytes,\n  hexToDecimalString: () => hexToDecimalString,\n  isBigInt: () => isBigInt,\n  isBoolean: () => isBoolean,\n  isHex: () => isHex,\n  isNumber: () => isNumber,\n  isStringWholeNumber: () => isStringWholeNumber,\n  stringToSha256ToArrayBuff4: () => stringToSha256ToArrayBuff4,\n  toBigInt: () => toBigInt,\n  toCairoBool: () => toCairoBool,\n  toHex: () => toHex,\n  toHexString: () => toHexString,\n  toStorageKey: () => toStorageKey\n});\n\n\nfunction isHex(hex) {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\nfunction toBigInt(value) {\n  return BigInt(value);\n}\nfunction isBigInt(value) {\n  return typeof value === \"bigint\";\n}\nfunction toHex(value) {\n  return addHexPrefix(toBigInt(value).toString(16));\n}\nvar toHexString = toHex;\nfunction toStorageKey(number2) {\n  return addHexPrefix(toBigInt(number2).toString(16).padStart(64, \"0\"));\n}\nfunction hexToDecimalString(hex) {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\nfunction cleanHex(hex) {\n  return hex.toLowerCase().replace(/^(0x)0+/, \"$1\");\n}\nfunction assertInRange(input, lowerBound, upperBound, inputName = \"\") {\n  const messageSuffix = inputName === \"\" ? \"invalid length\" : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\nfunction bigNumberishArrayToDecimalStringArray(data) {\n  return data.map((x) => toBigInt(x).toString(10));\n}\nfunction bigNumberishArrayToHexadecimalStringArray(data) {\n  return data.map((x) => toHex(x));\n}\nfunction isStringWholeNumber(str) {\n  return /^\\d+$/.test(str);\n}\nfunction getDecimalString(str) {\n  if (isHex(str)) {\n    return hexToDecimalString(str);\n  }\n  if (isStringWholeNumber(str)) {\n    return str;\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexString(str) {\n  if (isHex(str)) {\n    return str;\n  }\n  if (isStringWholeNumber(str)) {\n    return toHexString(str);\n  }\n  throw new Error(`${str} needs to be a hex-string or whole-number-string`);\n}\nfunction getHexStringArray(array) {\n  return array.map(getHexString);\n}\nfunction toCairoBool(value) {\n  return (+value).toString();\n}\nfunction hexToBytes(str) {\n  if (!isHex(str)) throw new Error(`${str} needs to be a hex-string`);\n  let adaptedValue = removeHexPrefix(str);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.hexToBytes)(adaptedValue);\n}\nfunction addPercent(number2, percent) {\n  const bigIntNum = BigInt(number2);\n  return bigIntNum + bigIntNum * BigInt(percent) / 100n;\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction stringToSha256ToArrayBuff4(str) {\n  const int31 = (n) => Number(n & MASK_31);\n  const result = int31(BigInt(addHexPrefix(buf2hex((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_5__.sha256)(str)))));\n  return hexToBytes(toHex(result));\n}\n\n// src/utils/hash/selector.ts\nvar selector_exports = {};\n__export(selector_exports, {\n  getL2MessageHash: () => getL2MessageHash,\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  keccakBn: () => keccakBn,\n  solidityUint256PackedKeccak256: () => solidityUint256PackedKeccak256,\n  starknetKeccak: () => starknetKeccak\n});\n\n\n\nfunction keccakBn(value) {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak)(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\nfunction keccakHex(str) {\n  return addHexPrefix((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak)(utf8ToArray(str)).toString(16));\n}\nfunction starknetKeccak(str) {\n  const hash = BigInt(keccakHex(str));\n  return hash & MASK_250;\n}\nfunction getSelectorFromName(funcName) {\n  return toHex(starknetKeccak(funcName));\n}\nfunction getSelector(value) {\n  if (isNumber(value) || isBigInt(value)) return toHex(value);\n  if (isHex(value)) return value;\n  if (isStringWholeNumber(value)) return toHex(value);\n  return getSelectorFromName(value);\n}\nfunction solidityUint256PackedKeccak256(params) {\n  const myEncode = addHexPrefix(\n    params.reduce(\n      (res, par) => res + removeHexPrefix(toHex(par)).padStart(64, \"0\"),\n      \"\"\n    )\n  );\n  return addHexPrefix((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.bytesToHex)((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_7__.keccak_256)(hexToBytes(myEncode))));\n}\nfunction getL2MessageHash(l1FromAddress, l2ToAddress, l2Selector, l2Calldata, l1Nonce) {\n  return solidityUint256PackedKeccak256([\n    l1FromAddress,\n    l2ToAddress,\n    l1Nonce,\n    l2Selector,\n    l2Calldata.length,\n    ...l2Calldata\n  ]);\n}\n\n// src/utils/shortString.ts\nvar shortString_exports = {};\n__export(shortString_exports, {\n  decodeShortString: () => decodeShortString,\n  encodeShortString: () => encodeShortString,\n  isASCII: () => isASCII,\n  isDecimalString: () => isDecimalString,\n  isLongText: () => isLongText,\n  isShortString: () => isShortString,\n  isShortText: () => isShortText,\n  isString: () => isString,\n  isText: () => isText,\n  splitLongString: () => splitLongString\n});\nfunction isASCII(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\nfunction isShortString(str) {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\nfunction isDecimalString(str) {\n  return /^[0-9]*$/i.test(str);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isText(val) {\n  return isString(val) && !isHex(val) && !isStringWholeNumber(val);\n}\nvar isShortText = (val) => isText(val) && isShortString(val);\nvar isLongText = (val) => isText(val) && !isShortString(val);\nfunction splitLongString(longStr) {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, \"g\");\n  return longStr.match(regex) || [];\n}\nfunction encodeShortString(str) {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str)) throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\nfunction decodeShortString(str) {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString(\"0X\".concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n\n// src/utils/calldata/byteArray.ts\nvar byteArray_exports = {};\n__export(byteArray_exports, {\n  byteArrayFromString: () => byteArrayFromString,\n  stringFromByteArray: () => stringFromByteArray\n});\nfunction stringFromByteArray(myByteArray) {\n  const pending_word = BigInt(myByteArray.pending_word) === 0n ? \"\" : decodeShortString(toHex(myByteArray.pending_word));\n  return myByteArray.data.reduce((cumuledString, encodedString) => {\n    const add = BigInt(encodedString) === 0n ? \"\" : decodeShortString(toHex(encodedString));\n    return cumuledString + add;\n  }, \"\") + pending_word;\n}\nfunction byteArrayFromString(targetString) {\n  const shortStrings = splitLongString(targetString);\n  const remainder = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded = shortStrings.map(encodeShortString);\n  const [pendingWord, pendingWordLength] = remainder === void 0 || remainder.length === 31 ? [\"0x00\", 0] : [shortStringsEncoded.pop(), remainder.length];\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength\n  };\n}\n\n// src/utils/calldata/cairo.ts\nvar cairo_exports = {};\n__export(cairo_exports, {\n  felt: () => felt,\n  getAbiContractVersion: () => getAbiContractVersion,\n  getArrayType: () => getArrayType,\n  isCairo1Abi: () => isCairo1Abi,\n  isCairo1Type: () => isCairo1Type,\n  isLen: () => isLen,\n  isTypeArray: () => isTypeArray,\n  isTypeBool: () => isTypeBool,\n  isTypeByteArray: () => isTypeByteArray,\n  isTypeBytes31: () => isTypeBytes31,\n  isTypeContractAddress: () => isTypeContractAddress,\n  isTypeEnum: () => isTypeEnum,\n  isTypeEthAddress: () => isTypeEthAddress,\n  isTypeFelt: () => isTypeFelt,\n  isTypeLiteral: () => isTypeLiteral,\n  isTypeNamedTuple: () => isTypeNamedTuple,\n  isTypeNonZero: () => isTypeNonZero,\n  isTypeOption: () => isTypeOption,\n  isTypeResult: () => isTypeResult,\n  isTypeSecp256k1Point: () => isTypeSecp256k1Point,\n  isTypeStruct: () => isTypeStruct,\n  isTypeTuple: () => isTypeTuple,\n  isTypeUint: () => isTypeUint,\n  isTypeUint256: () => isTypeUint256,\n  tuple: () => tuple,\n  uint256: () => uint256,\n  uint512: () => uint512\n});\n\n// src/utils/cairoDataTypes/felt.ts\nfunction CairoFelt(it) {\n  if (isBigInt(it) || Number.isInteger(it)) {\n    return it.toString();\n  }\n  if (isString(it)) {\n    if (isHex(it)) {\n      return BigInt(it).toString();\n    }\n    if (isText(it)) {\n      if (!isShortString(it)) {\n        throw new Error(\n          `${it} is a long string > 31 chars. Please split it into an array of short strings.`\n        );\n      }\n      return BigInt(encodeShortString(it)).toString();\n    }\n    if (isStringWholeNumber(it)) {\n      return it;\n    }\n  }\n  if (isBoolean(it)) {\n    return `${+it}`;\n  }\n  throw new Error(`${it} can't be computed by felt()`);\n}\n\n// src/utils/cairoDataTypes/uint256.ts\nvar UINT_128_MAX = (1n << 128n) - 1n;\nvar UINT_256_MAX = (1n << 256n) - 1n;\nvar UINT_256_MIN = 0n;\nvar UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nvar UINT_256_LOW_MIN = 0n;\nvar UINT_256_HIGH_MIN = 0n;\nvar CairoUint256 = class _CairoUint256 {\n  low;\n  high;\n  static abiSelector = \"core::integer::u256\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"low\" in arr[0] && \"high\" in arr[0]) {\n      const props = _CairoUint256.validateProps(arr[0].low, arr[0].high);\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = _CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error(\"Incorrect constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_256_MIN) throw Error(\"bigNumberish is smaller than UINT_256_MIN\");\n    if (bigInt > UINT_256_MAX) throw new Error(\"bigNumberish is bigger than UINT_256_MAX\");\n    return bigInt;\n  }\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low, high) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n      throw new Error(\"low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX\");\n    }\n    if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n      throw new Error(\"high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX\");\n    }\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint256.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16))\n    };\n  }\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n};\n\n// src/utils/cairoDataTypes/uint512.ts\nvar UINT_512_MAX = (1n << 512n) - 1n;\nvar UINT_512_MIN = 0n;\nvar UINT_128_MIN = 0n;\nvar CairoUint512 = class _CairoUint512 {\n  limb0;\n  limb1;\n  limb2;\n  limb3;\n  static abiSelector = \"core::integer::u512\";\n  constructor(...arr) {\n    if (typeof arr[0] === \"object\" && arr.length === 1 && \"limb0\" in arr[0] && \"limb1\" in arr[0] && \"limb2\" in arr[0] && \"limb3\" in arr[0]) {\n      const props = _CairoUint512.validateProps(\n        arr[0].limb0,\n        arr[0].limb1,\n        arr[0].limb2,\n        arr[0].limb3\n      );\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else if (arr.length === 1) {\n      const bigInt = _CairoUint512.validate(arr[0]);\n      this.limb0 = bigInt & UINT_128_MAX;\n      this.limb1 = (bigInt & UINT_128_MAX << 128n) >> 128n;\n      this.limb2 = (bigInt & UINT_128_MAX << 256n) >> 256n;\n      this.limb3 = bigInt >> 384n;\n    } else if (arr.length === 4) {\n      const props = _CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);\n      this.limb0 = props.limb0;\n      this.limb1 = props.limb1;\n      this.limb2 = props.limb2;\n      this.limb3 = props.limb3;\n    } else {\n      throw Error(\"Incorrect Uint512 constructor parameters\");\n    }\n  }\n  /**\n   * Validate if BigNumberish can be represented as Uint512\n   */\n  static validate(bigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_512_MIN) throw Error(\"bigNumberish is smaller than UINT_512_MIN.\");\n    if (bigInt > UINT_512_MAX) throw Error(\"bigNumberish is bigger than UINT_512_MAX.\");\n    return bigInt;\n  }\n  /**\n   * Validate if limbs can be represented as Uint512\n   */\n  static validateProps(limb0, limb1, limb2, limb3) {\n    const l0 = BigInt(limb0);\n    const l1 = BigInt(limb1);\n    const l2 = BigInt(limb2);\n    const l3 = BigInt(limb3);\n    [l0, l1, l2, l3].forEach((value, index) => {\n      if (value < UINT_128_MIN || value > UINT_128_MAX) {\n        throw Error(`limb${index} is not in the range of a u128 number`);\n      }\n    });\n    return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };\n  }\n  /**\n   * Check if BigNumberish can be represented as Uint512\n   */\n  static is(bigNumberish) {\n    try {\n      _CairoUint512.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType) {\n    return abiType === _CairoUint512.abiSelector;\n  }\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;\n  }\n  /**\n   * Return Uint512 structure with HexString props\n   * limbx: HexString\n   */\n  toUint512HexString() {\n    return {\n      limb0: addHexPrefix(this.limb0.toString(16)),\n      limb1: addHexPrefix(this.limb1.toString(16)),\n      limb2: addHexPrefix(this.limb2.toString(16)),\n      limb3: addHexPrefix(this.limb3.toString(16))\n    };\n  }\n  /**\n   * Return Uint512 structure with DecimalString props\n   * limbx DecString\n   */\n  toUint512DecimalString() {\n    return {\n      limb0: this.limb0.toString(10),\n      limb1: this.limb1.toString(10),\n      limb2: this.limb2.toString(10),\n      limb3: this.limb3.toString(10)\n    };\n  }\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [\n      CairoFelt(this.limb0),\n      CairoFelt(this.limb1),\n      CairoFelt(this.limb2),\n      CairoFelt(this.limb3)\n    ];\n  }\n};\n\n// src/utils/calldata/cairo.ts\nvar isLen = (name) => /_len$/.test(name);\nvar isTypeFelt = (type) => type === \"felt\" || type === \"core::felt252\";\nvar isTypeArray = (type) => /\\*/.test(type) || type.startsWith(\"core::array::Array::\") || type.startsWith(\"core::array::Span::\");\nvar isTypeTuple = (type) => /^\\(.*\\)$/i.test(type);\nvar isTypeNamedTuple = (type) => /\\(.*\\)/i.test(type) && type.includes(\":\");\nvar isTypeStruct = (type, structs) => type in structs;\nvar isTypeEnum = (type, enums) => type in enums;\nvar isTypeOption = (type) => type.startsWith(\"core::option::Option::\");\nvar isTypeResult = (type) => type.startsWith(\"core::result::Result::\");\nvar isTypeUint = (type) => Object.values(Uint).includes(type);\nvar isTypeUint256 = (type) => CairoUint256.isAbiType(type);\nvar isTypeLiteral = (type) => Object.values(Literal).includes(type);\nvar isTypeBool = (type) => type === \"core::bool\";\nvar isTypeContractAddress = (type) => type === \"core::starknet::contract_address::ContractAddress\";\nvar isTypeEthAddress = (type) => type === \"core::starknet::eth_address::EthAddress\";\nvar isTypeBytes31 = (type) => type === \"core::bytes_31::bytes31\";\nvar isTypeByteArray = (type) => type === \"core::byte_array::ByteArray\";\nvar isTypeSecp256k1Point = (type) => type === \"core::starknet::secp256k1::Secp256k1Point\";\nvar isCairo1Type = (type) => type.includes(\"::\");\nvar getArrayType = (type) => {\n  if (isCairo1Type(type)) {\n    return type.substring(type.indexOf(\"<\") + 1, type.lastIndexOf(\">\"));\n  }\n  return type.replace(\"*\", \"\");\n};\nfunction isCairo1Abi(abi) {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === void 0) {\n    throw Error(\"Unable to determine Cairo version\");\n  }\n  return cairo === \"1\";\n}\nfunction isTypeNonZero(type) {\n  return type.startsWith(\"core::zeroable::NonZero::\");\n}\nfunction getAbiContractVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\")) {\n    return { cairo: \"1\", compiler: \"2\" };\n  }\n  const testFunction = abi.find(\n    (it) => it.type === \"function\" && (it.inputs.length || it.outputs.length)\n  );\n  if (!testFunction) {\n    return { cairo: void 0, compiler: void 0 };\n  }\n  const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: \"1\", compiler: \"1\" };\n  }\n  return { cairo: \"0\", compiler: \"0\" };\n}\nvar uint256 = (it) => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\nvar uint512 = (it) => {\n  return new CairoUint512(it).toUint512DecimalString();\n};\nvar tuple = (...args) => ({ ...args });\nfunction felt(it) {\n  return CairoFelt(it);\n}\n\n// src/utils/calldata/enum/CairoCustomEnum.ts\nvar CairoCustomEnum = class {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  variant;\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error(\"This Enum must have at least 1 variant\");\n    }\n    const nbActiveVariants = variantsList.filter(\n      (content) => typeof content !== \"undefined\"\n    ).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error(\"This Enum must have exactly one active variant\");\n    }\n    this.variant = enumContent;\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  unwrap() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return void 0;\n    }\n    return activeVariant[1];\n  }\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  activeVariant() {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== \"undefined\");\n    if (typeof activeVariant === \"undefined\") {\n      return \"\";\n    }\n    return activeVariant[0];\n  }\n};\n\n// src/utils/calldata/enum/CairoOption.ts\nvar CairoOptionVariant = /* @__PURE__ */ ((CairoOptionVariant2) => {\n  CairoOptionVariant2[CairoOptionVariant2[\"Some\"] = 0] = \"Some\";\n  CairoOptionVariant2[CairoOptionVariant2[\"None\"] = 1] = \"None\";\n  return CairoOptionVariant2;\n})(CairoOptionVariant || {});\nvar CairoOption = class {\n  Some;\n  None;\n  constructor(variant, someContent) {\n    if (!(variant in CairoOptionVariant)) {\n      throw new Error(\"Wrong variant : should be CairoOptionVariant.Some or .None.\");\n    }\n    if (variant === 0 /* Some */) {\n      if (typeof someContent === \"undefined\") {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = someContent;\n      this.None = void 0;\n    } else {\n      this.Some = void 0;\n      this.None = true;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  unwrap() {\n    if (this.None) {\n      return void 0;\n    }\n    return this.Some;\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  isSome() {\n    return !(typeof this.Some === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  isNone() {\n    return this.None === true;\n  }\n};\n\n// src/utils/calldata/enum/CairoResult.ts\nvar CairoResultVariant = /* @__PURE__ */ ((CairoResultVariant2) => {\n  CairoResultVariant2[CairoResultVariant2[\"Ok\"] = 0] = \"Ok\";\n  CairoResultVariant2[CairoResultVariant2[\"Err\"] = 1] = \"Err\";\n  return CairoResultVariant2;\n})(CairoResultVariant || {});\nvar CairoResult = class {\n  Ok;\n  Err;\n  constructor(variant, resultContent) {\n    if (!(variant in CairoResultVariant)) {\n      throw new Error(\"Wrong variant : should be CairoResultVariant.Ok or .Err.\");\n    }\n    if (variant === 0 /* Ok */) {\n      this.Ok = resultContent;\n      this.Err = void 0;\n    } else {\n      this.Ok = void 0;\n      this.Err = resultContent;\n    }\n  }\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  unwrap() {\n    if (typeof this.Ok !== \"undefined\") {\n      return this.Ok;\n    }\n    if (typeof this.Err !== \"undefined\") {\n      return this.Err;\n    }\n    throw new Error(\"Both Result.Ok and .Err are undefined. Not authorized.\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  isOk() {\n    return !(typeof this.Ok === \"undefined\");\n  }\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  isErr() {\n    return !(typeof this.Err === \"undefined\");\n  }\n};\n\n// src/utils/calldata/formatter.ts\nvar guard = {\n  isBN: (data, type, key) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${data[key]} to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  unknown: (data, type, key) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  }\n};\nfunction formatter(data, type, sameType) {\n  return Object.entries(data).reduce(\n    (acc, [key, value]) => {\n      const elType = sameType ?? type[key];\n      if (!(key in type) && !sameType) {\n        acc[key] = value;\n        return acc;\n      }\n      if (elType === \"string\") {\n        if (Array.isArray(data[key])) {\n          const arrayStr = formatter(\n            data[key],\n            data[key].map((_) => elType)\n          );\n          acc[key] = Object.values(arrayStr).join(\"\");\n          return acc;\n        }\n        guard.isBN(data, type, key);\n        acc[key] = decodeShortString(value);\n        return acc;\n      }\n      if (elType === \"number\") {\n        guard.isBN(data, type, key);\n        acc[key] = Number(value);\n        return acc;\n      }\n      if (typeof elType === \"function\") {\n        acc[key] = elType(value);\n        return acc;\n      }\n      if (Array.isArray(elType)) {\n        const arrayObj = formatter(data[key], elType, elType[0]);\n        acc[key] = Object.values(arrayObj);\n        return acc;\n      }\n      if (typeof elType === \"object\") {\n        acc[key] = formatter(data[key], elType);\n        return acc;\n      }\n      guard.unknown(data, type, key);\n      return acc;\n    },\n    {}\n  );\n}\n\n// src/utils/calldata/parser/parser-0-1.1.0.ts\nvar AbiParser1 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.reduce((acc, input) => !isLen(input.name) ? acc + 1 : acc, 0);\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    return this.abi.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi;\n  }\n};\n\n// src/utils/calldata/parser/parser-2.0.0.ts\nvar AbiParser2 = class {\n  abi;\n  constructor(abi) {\n    this.abi = abi;\n  }\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  methodInputsLength(abiMethod) {\n    return abiMethod.inputs.length;\n  }\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  getMethod(name) {\n    const intf = this.abi.find(\n      (it) => it.type === \"interface\"\n    );\n    return intf.items.find((it) => it.name === name);\n  }\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  getLegacyFormat() {\n    return this.abi.flatMap((e) => {\n      if (e.type === \"interface\") {\n        return e.items;\n      }\n      return e;\n    });\n  }\n};\n\n// src/utils/calldata/parser/index.ts\nfunction createAbiParser(abi) {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\nfunction getAbiVersion(abi) {\n  if (abi.find((it) => it.type === \"interface\")) return 2;\n  if (isCairo1Abi(abi)) return 1;\n  return 0;\n}\nfunction isNoConstructorValid(method, argsCalldata, abiMethod) {\n  return method === \"constructor\" && !abiMethod && !argsCalldata.length;\n}\n\n// src/utils/calldata/tuple.ts\nfunction parseNamedTuple(namedTuple) {\n  const name = namedTuple.substring(0, namedTuple.indexOf(\":\"));\n  const type = namedTuple.substring(name.length + \":\".length);\n  return { name, type };\n}\nfunction parseSubTuple(s) {\n  if (!s.includes(\"(\")) return { subTuple: [], result: s };\n  const subTuple = [];\n  let result = \"\";\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === \"(\") {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === \")\") counter--;\n        if (s[i] === \"(\") counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += \" \";\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n  return {\n    subTuple,\n    result\n  };\n}\nfunction extractCairo0Tuple(type) {\n  const cleanType = type.replace(/\\s/g, \"\").slice(1, -1);\n  const { subTuple, result } = parseSubTuple(cleanType);\n  let recomposed = result.split(\",\").map((it) => {\n    return subTuple.length ? it.replace(\" \", subTuple.shift()) : it;\n  });\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n  return recomposed;\n}\nfunction getClosureOffset(input, open, close) {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\nfunction extractCairo1Tuple(type) {\n  const input = type.slice(1, -1);\n  const result = [];\n  let currentIndex = 0;\n  let limitIndex;\n  while (currentIndex < input.length) {\n    switch (true) {\n      case input[currentIndex] === \"(\": {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"(\", \")\") + 1;\n        break;\n      }\n      case (input.startsWith(\"core::result::Result::<\", currentIndex) || input.startsWith(\"core::array::Array::<\", currentIndex) || input.startsWith(\"core::option::Option::<\", currentIndex)): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), \"<\", \">\") + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(\",\", currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2;\n  }\n  return result;\n}\nfunction extractTupleMemberTypes(type) {\n  if (isCairo1Type(type)) {\n    return extractCairo1Tuple(type);\n  }\n  return extractCairo0Tuple(type);\n}\n\n// src/utils/calldata/propertyOrder.ts\nfunction errorU256(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\nfunction errorU512(key) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint512 object without the 'limb0' to 'limb3' keys.`\n  );\n}\nfunction orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {\n  const orderInput = (unorderedItem, abiType) => {\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeNonZero(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeByteArray(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeSecp256k1Point(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== \"object\") {\n        return u256;\n      }\n      if (!(\"low\" in u256 && \"high\" in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (CairoUint512.isAbiType(abiType)) {\n      const u512 = unorderedItem;\n      if (typeof u512 !== \"object\") {\n        return u512;\n      }\n      if (![\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in u512)) {\n        throw errorU512(abiType);\n      }\n      return { limb0: u512.limb0, limb1: u512.limb1, limb2: u512.limb2, limb3: u512.limb3 };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    return unorderedItem;\n  };\n  const orderStruct = (unorderedObject2, abiObject) => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value: value ?? unorderedObject2[abiParam.name]\n      });\n      if (unorderedObject2[abiParam.name] === \"undefined\") {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n  function orderArray(myArray, abiParam) {\n    const typeInArray = getArrayType(abiParam);\n    if (isString(myArray)) {\n      return myArray;\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n  function orderTuple(unorderedObject2, abiParam) {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject, abiTypeCairoX, index) => {\n      const myObjKeys = Object.keys(unorderedObject2);\n      const setProperty = (value) => Object.defineProperty(orderedObject, index.toString(), {\n        enumerable: true,\n        value: value ?? unorderedObject2[myObjKeys[index]]\n      });\n      const abiType = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX;\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n  const orderEnum = (unorderedObject2, abiObject) => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2;\n      const resultOkType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\",\")\n      );\n      const resultErrType = abiObject.name.substring(\n        abiObject.name.indexOf(\",\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult(\n          0 /* Ok */,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult(\n        1 /* Err */,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2;\n      const resultSomeType = abiObject.name.substring(\n        abiObject.name.indexOf(\"<\") + 1,\n        abiObject.name.lastIndexOf(\">\")\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption(\n          0 /* Some */,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      return new CairoOption(1 /* None */, {});\n    }\n    const unorderedCustomEnum = unorderedObject2;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (typeof variant[1] === \"undefined\") {\n        return variant;\n      }\n      const variantType = abiObject.type.substring(\n        abiObject.type.lastIndexOf(\"<\") + 1,\n        abiObject.type.lastIndexOf(\">\")\n      );\n      if (variantType === \"()\") {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value) => Object.defineProperty(orderedObject, abiParam.name, {\n      enumerable: true,\n      value\n    });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n\n// src/utils/calldata/requestParser.ts\nfunction parseBaseTypes(type, val) {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return new CairoUint256(val).toApiRequest();\n    case CairoUint512.isAbiType(type):\n      return new CairoUint512(val).toApiRequest();\n    case isTypeBytes31(type):\n      return encodeShortString(val.toString());\n    case isTypeSecp256k1Point(type): {\n      const pubKeyETH = removeHexPrefix(toHex(val)).padStart(128, \"0\");\n      const pubKeyETHy = uint256(addHexPrefix(pubKeyETH.slice(-64)));\n      const pubKeyETHx = uint256(addHexPrefix(pubKeyETH.slice(0, -64)));\n      return [\n        felt(pubKeyETHx.low),\n        felt(pubKeyETHx.high),\n        felt(pubKeyETHy.low),\n        felt(pubKeyETHy.high)\n      ];\n    }\n    default:\n      return felt(val);\n  }\n}\nfunction parseTuple(element, typeStr) {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`\n    );\n  }\n  return memberTypes.map((it, dx) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it\n    };\n  });\n}\nfunction parseByteArray(element) {\n  const myByteArray = byteArrayFromString(element);\n  return [\n    myByteArray.data.length.toString(),\n    ...myByteArray.data.map((bn) => bn.toString()),\n    myByteArray.pending_word.toString(),\n    myByteArray.pending_word_len.toString()\n  ];\n}\nfunction parseCalldataValue(element, type, structs, enums) {\n  if (element === void 0) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n  if (Array.isArray(element)) {\n    const result = [];\n    result.push(felt(element.length));\n    const arrayType = getArrayType(type);\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n  if (structs[type] && structs[type].members.length) {\n    if (CairoUint256.isAbiType(type)) {\n      return new CairoUint256(element).toApiRequest();\n    }\n    if (CairoUint512.isAbiType(type)) {\n      return new CairoUint512(element).toApiRequest();\n    }\n    if (type === \"core::starknet::eth_address::EthAddress\")\n      return parseBaseTypes(type, element);\n    if (type === \"core::byte_array::ByteArray\") return parseByteArray(element);\n    const { members } = structs[type];\n    const subElement = element;\n    return members.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, []);\n  }\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element, type);\n    return tupled.reduce((acc, it) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, []);\n  }\n  if (CairoUint256.isAbiType(type)) {\n    return new CairoUint256(element).toApiRequest();\n  }\n  if (CairoUint512.isAbiType(type)) {\n    return new CairoUint512(element).toApiRequest();\n  }\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    if (isTypeOption(type)) {\n      const myOption = element;\n      if (myOption.isSome()) {\n        const listTypeVariant2 = variants.find((variant) => variant.name === \"Some\");\n        if (typeof listTypeVariant2 === \"undefined\") {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant2.type;\n        if (typeVariantSome === \"()\") {\n          return 0 /* Some */.toString();\n        }\n        const parsedParameter2 = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter2)) {\n          return [0 /* Some */.toString(), ...parsedParameter2];\n        }\n        return [0 /* Some */.toString(), parsedParameter2];\n      }\n      return 1 /* None */.toString();\n    }\n    if (isTypeResult(type)) {\n      const myResult = element;\n      if (myResult.isOk()) {\n        const listTypeVariant3 = variants.find((variant) => variant.name === \"Ok\");\n        if (typeof listTypeVariant3 === \"undefined\") {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant3.type;\n        if (typeVariantOk === \"()\") {\n          return 0 /* Ok */.toString();\n        }\n        const parsedParameter3 = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter3)) {\n          return [0 /* Ok */.toString(), ...parsedParameter3];\n        }\n        return [0 /* Ok */.toString(), parsedParameter3];\n      }\n      const listTypeVariant2 = variants.find((variant) => variant.name === \"Err\");\n      if (typeof listTypeVariant2 === \"undefined\") {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant2.type;\n      if (typeVariantErr === \"()\") {\n        return 1 /* Err */.toString();\n      }\n      const parsedParameter2 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter2)) {\n        return [1 /* Err */.toString(), ...parsedParameter2];\n      }\n      return [1 /* Err */.toString(), parsedParameter2];\n    }\n    const myEnum = element;\n    const activeVariant = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (typeof listTypeVariant === \"undefined\") {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant);\n    if (typeActiveVariant === \"()\") {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n  if (isTypeNonZero(type)) {\n    return parseBaseTypes(getArrayType(type), element);\n  }\n  if (typeof element === \"object\") {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\nfunction parseCalldataField(argsIterator, input, structs, enums) {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n  switch (true) {\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (isString(value)) {\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n    case isTypeNonZero(type):\n      return parseBaseTypes(getArrayType(type), value);\n    case type === \"core::starknet::eth_address::EthAddress\":\n      return parseBaseTypes(type, value);\n    case (isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type) || CairoUint256.isAbiType(type)):\n      return parseCalldataValue(value, type, structs, enums);\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value,\n        type,\n        structs,\n        enums\n      );\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n\n// src/utils/calldata/responseParser.ts\nfunction parseBaseTypes2(type, it) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return new CairoUint256(low, high).toBigInt();\n    case CairoUint512.isAbiType(type):\n      const limb0 = it.next().value;\n      const limb1 = it.next().value;\n      const limb2 = it.next().value;\n      const limb3 = it.next().value;\n      return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n    case type === \"core::starknet::eth_address::EthAddress\":\n      temp = it.next().value;\n      return BigInt(temp);\n    case type === \"core::bytes_31::bytes31\":\n      temp = it.next().value;\n      return decodeShortString(temp);\n    case isTypeSecp256k1Point(type):\n      const xLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const xHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yLow = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const yHigh = removeHexPrefix(it.next().value).padStart(32, \"0\");\n      const pubK = BigInt(addHexPrefix(xHigh + xLow + yHigh + yLow));\n      return pubK;\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\nfunction parseResponseValue(responseIterator, element, structs, enums) {\n  if (element.type === \"()\") {\n    return {};\n  }\n  if (CairoUint256.isAbiType(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return new CairoUint256(low, high).toBigInt();\n  }\n  if (CairoUint512.isAbiType(element.type)) {\n    const limb0 = responseIterator.next().value;\n    const limb1 = responseIterator.next().value;\n    const limb2 = responseIterator.next().value;\n    const limb3 = responseIterator.next().value;\n    return new CairoUint512(limb0, limb1, limb2, limb3).toBigInt();\n  }\n  if (isTypeByteArray(element.type)) {\n    const parsedBytes31Arr = [];\n    const bytes31ArrLen = BigInt(responseIterator.next().value);\n    while (parsedBytes31Arr.length < bytes31ArrLen) {\n      parsedBytes31Arr.push(toHex(responseIterator.next().value));\n    }\n    const pending_word = toHex(responseIterator.next().value);\n    const pending_word_len = BigInt(responseIterator.next().value);\n    const myByteArray = {\n      data: parsedBytes31Arr,\n      pending_word,\n      pending_word_len\n    };\n    return stringFromByteArray(myByteArray);\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  if (isTypeNonZero(element.type)) {\n    const el = { name: \"\", type: getArrayType(element.type) };\n    return parseResponseValue(responseIterator, el, structs, enums);\n  }\n  if (structs && element.type in structs && structs[element.type]) {\n    if (element.type === \"core::starknet::eth_address::EthAddress\") {\n      return parseBaseTypes2(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum = Number(responseIterator.next().value);\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: \"\", type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = void 0;\n      return acc;\n    }, {});\n    if (element.type.startsWith(\"core::option::Option\")) {\n      const content = variantNum === 0 /* Some */ ? rawEnum.Some : void 0;\n      return new CairoOption(variantNum, content);\n    }\n    if (element.type.startsWith(\"core::result::Result\")) {\n      let content;\n      if (variantNum === 0 /* Ok */) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult(variantNum, content);\n    }\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {});\n  }\n  if (isTypeArray(element.type)) {\n    const parsedDataArr = [];\n    const el = { name: \"\", type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value);\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n  return parseBaseTypes2(element.type, responseIterator);\n}\nfunction responseParser(responseIterator, output, structs, enums, parsedResult) {\n  const { name, type } = output;\n  let temp;\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n    case (structs && type in structs || isTypeTuple(type)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case (enums && isTypeEnum(type, enums)):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    case isTypeArray(type):\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      const parsedDataArr = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`];\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace(\"*\", \"\") },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n    case isTypeNonZero(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n    default:\n      return parseBaseTypes2(type, responseIterator);\n  }\n}\n\n// src/utils/calldata/validate.ts\nvar validateFelt = (parameter, input) => {\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter),\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (isString(parameter) && !isHex(parameter)) return;\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\nvar validateBytes31 = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n  assert(\n    parameter.length < 32,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`\n  );\n};\nvar validateByteArray = (parameter, input) => {\n  assert(isString(parameter), `Validate: arg ${input.name} should be a string.`);\n};\nvar validateUint = (parameter, input) => {\n  if (isNumber(parameter)) {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      `Validation: Parameter is to large to be typed as Number use (BigInt or String)`\n    );\n  }\n  assert(\n    isString(parameter) || isNumber(parameter) || isBigInt(parameter) || typeof parameter === \"object\" && \"low\" in parameter && \"high\" in parameter || typeof parameter === \"object\" && [\"limb0\", \"limb1\", \"limb2\", \"limb3\"].every((key) => key in parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  let param;\n  switch (input.type) {\n    case \"core::integer::u256\" /* u256 */:\n      param = new CairoUint256(parameter).toBigInt();\n      break;\n    case \"core::integer::u512\" /* u512 */:\n      param = new CairoUint512(parameter).toBigInt();\n      break;\n    default:\n      param = toBigInt(parameter);\n  }\n  switch (input.type) {\n    case \"core::integer::u8\" /* u8 */:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n    case \"core::integer::u16\" /* u16 */:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n    case \"core::integer::u32\" /* u32 */:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n    case \"core::integer::u64\" /* u64 */:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n    case \"core::integer::u128\" /* u128 */:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n    case \"core::integer::u256\" /* u256 */:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`\n      );\n      break;\n    case \"core::integer::u512\" /* u512 */:\n      assert(CairoUint512.is(param), `Validate: arg ${input.name} is ${input.type} 0 - 2^512-1`);\n      break;\n    case \"core::starknet::class_hash::ClassHash\" /* ClassHash */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case \"core::starknet::contract_address::ContractAddress\" /* ContractAddress */:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    case \"core::starknet::secp256k1::Secp256k1Point\" /* Secp256k1Point */: {\n      assert(\n        param >= 0n && param <= 2n ** 512n - 1n,\n        `Validate: arg ${input.name} must be ${input.type} : a 512 bits number.`\n      );\n      break;\n    }\n    default:\n      break;\n  }\n};\nvar validateBool = (parameter, input) => {\n  assert(\n    isBoolean(parameter),\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\nvar validateStruct = (parameter, input, structs) => {\n  if (input.type === \"core::integer::u256\" /* u256 */ || input.type === \"core::integer::u512\" /* u512 */) {\n    validateUint(parameter, input);\n    return;\n  }\n  if (input.type === \"core::starknet::eth_address::EthAddress\") {\n    assert(\n      typeof parameter !== \"object\",\n      `EthAddress type is waiting a BigNumberish. Got ${parameter}`\n    );\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`\n  );\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\nvar validateEnum = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`\n  );\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n    return;\n  }\n  if (isTypeResult(input.type) && keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n    return;\n  }\n  if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n    return;\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`\n  );\n};\nvar validateTuple = (parameter, input) => {\n  assert(\n    typeof parameter === \"object\" && !Array.isArray(parameter),\n    `Validate: arg ${input.name} should be a tuple (defined as object)`\n  );\n};\nvar validateArray = (parameter, input, structs, enums) => {\n  const baseType = getArrayType(input.type);\n  if (isTypeFelt(baseType) && isLongText(parameter)) {\n    return;\n  }\n  assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeArray(baseType):\n      parameter.forEach(\n        (param) => validateArray(param, { name: \"\", type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach(\n        (it) => validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case (isTypeUint(baseType) || isTypeLiteral(baseType)):\n      parameter.forEach((param) => validateUint(param, { name: \"\", type: baseType }));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\nvar validateNonZero = (parameter, input) => {\n  const baseType = getArrayType(input.type);\n  assert(\n    isTypeUint(baseType) && baseType !== CairoUint512.abiSelector || isTypeFelt(baseType),\n    `Validate: ${input.name} type is not authorized for NonZero type.`\n  );\n  switch (true) {\n    case isTypeFelt(baseType):\n      validateFelt(parameter, input);\n      assert(\n        BigInt(parameter.toString(10)) > 0,\n        \"Validate: value 0 is not authorized in NonZero felt252 type.\"\n      );\n      break;\n    case isTypeUint(baseType):\n      validateUint(parameter, { name: \"\", type: baseType });\n      switch (input.type) {\n        case \"core::integer::u256\" /* u256 */:\n          assert(\n            new CairoUint256(parameter).toBigInt() > 0,\n            \"Validate: value 0 is not authorized in NonZero uint256 type.\"\n          );\n          break;\n        default:\n          assert(\n            toBigInt(parameter) > 0,\n            \"Validate: value 0 is not authorized in NonZero uint type.\"\n          );\n      }\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\nfunction validateFields(abiMethod, args, structs, enums) {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case isTypeBytes31(input.type):\n        validateBytes31(parameter, input);\n        break;\n      case (isTypeUint(input.type) || isTypeLiteral(input.type)):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeByteArray(input.type):\n        validateByteArray(parameter, input);\n        break;\n      case isTypeArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      case isTypeNonZero(input.type):\n        validateNonZero(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n    return acc + 1;\n  }, 0);\n}\n\n// src/utils/calldata/index.ts\nvar CallData = class _CallData {\n  abi;\n  parser;\n  structs;\n  enums;\n  constructor(abi) {\n    this.structs = _CallData.getAbiStruct(abi);\n    this.enums = _CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  validate(type, method, args = []) {\n    if (type !== \"DEPLOY\" /* DEPLOY */) {\n      const invocableFunctionNames = this.abi.filter((abi) => {\n        if (abi.type !== \"function\") return false;\n        const isView = abi.stateMutability === \"view\" || abi.state_mutability === \"view\";\n        return type === \"INVOKE\" /* INVOKE */ ? !isView : isView;\n      }).map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === \"INVOKE\" /* INVOKE */ ? \"invocable\" : \"viewable\"} method not found in abi`\n      );\n    }\n    const abiMethod = this.abi.find(\n      (abi) => type === \"DEPLOY\" /* DEPLOY */ ? abi.name === method && abi.type === \"constructor\" : abi.name === method && abi.type === \"function\"\n    );\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  compile(method, argsCalldata) {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method);\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n    let args;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      args = Object.values(orderedObject);\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n    const argsIterator = args[Symbol.iterator]();\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) => isLen(input.name) && !isCairo1Type(input.type) ? acc : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      []\n    );\n    Object.defineProperty(callArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callArray;\n  }\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs) {\n    const createTree = (obj) => {\n      const getEntries = (o, prefix = \".\") => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === \"entrypoint\") value = getSelectorFromName(value);\n          else if (isLongText(value)) value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === \"0\" ? \"$$len\" : k;\n          if (isBigInt(value)) return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes(\"isSome\") && keys.includes(\"isNone\")) {\n              const myOption = value;\n              const variantNb = myOption.isSome() ? 0 /* Some */ : 1 /* None */;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes(\"isOk\") && keys.includes(\"isErr\")) {\n              const myResult = value;\n              const variantNb = myResult.isOk() ? 0 /* Ok */ : 1 /* Err */;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes(\"variant\") && keys.includes(\"activeVariant\")) {\n              const myEnum = value;\n              const activeVariant = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant) => variant === activeVariant\n              );\n              if (typeof myEnum.unwrap() === \"object\" && Object.keys(myEnum.unwrap()).length === 0) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      const callTree = createTree(rawArgs);\n      callTreeArray = Object.values(callTree);\n    } else {\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n    Object.defineProperty(callTreeArray, \"__compiled__\", {\n      enumerable: false,\n      writable: false,\n      value: true\n    });\n    return callTreeArray;\n  }\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  parse(method, response) {\n    const { outputs } = this.abi.find((abi) => abi.name === method);\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {});\n    return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;\n  }\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  format(method, response, format) {\n    const parsed = this.parse(method, response);\n    return formatter(parsed, format);\n  }\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi) {\n    return abi.filter((abiEntry) => abiEntry.type === \"struct\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n  }\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi) {\n    const fullEnumList = abi.filter((abiEntry) => abiEntry.type === \"enum\").reduce(\n      (acc, abiEntry) => ({\n        ...acc,\n        [abiEntry.name]: abiEntry\n      }),\n      {}\n    );\n    delete fullEnumList[\"core::bool\"];\n    return fullEnumList;\n  }\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata = []) {\n    return _CallData.compile(rawCalldata);\n  }\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw = []) {\n    const calldata = _CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  decodeParameters(typeCairo, response) {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) => responseParser(\n        responseIterator,\n        { name: \"\", type: typeParam },\n        this.structs,\n        this.enums\n      )\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n};\n\n// src/utils/hash/index.ts\nvar hash_exports = {};\n__export(hash_exports, {\n  calculateContractAddressFromHash: () => calculateContractAddressFromHash,\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash3,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash3,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash2,\n  calculateL2MessageTxHash: () => calculateL2MessageTxHash,\n  computeCompiledClassHash: () => computeCompiledClassHash,\n  computeContractClassHash: () => computeContractClassHash,\n  computeHashOnElements: () => computeHashOnElements2,\n  computeHintedClassHash: () => computeHintedClassHash,\n  computeLegacyContractClassHash: () => computeLegacyContractClassHash,\n  computePedersenHash: () => computePedersenHash,\n  computePedersenHashOnElements: () => computePedersenHashOnElements,\n  computePoseidonHash: () => computePoseidonHash,\n  computePoseidonHashOnElements: () => computePoseidonHashOnElements,\n  computeSierraContractClassHash: () => computeSierraContractClassHash,\n  formatSpaces: () => formatSpaces,\n  getL2MessageHash: () => getL2MessageHash,\n  getSelector: () => getSelector,\n  getSelectorFromName: () => getSelectorFromName,\n  hashByteCodeSegments: () => hashByteCodeSegments,\n  keccakBn: () => keccakBn,\n  poseidon: () => _noble_curves_abstract_poseidon__WEBPACK_IMPORTED_MODULE_8__,\n  solidityUint256PackedKeccak256: () => solidityUint256PackedKeccak256,\n  starknetKeccak: () => starknetKeccak\n});\n\n\n// src/utils/hash/transactionHash/v2.ts\nvar v2_exports = {};\n__export(v2_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash,\n  calculateL2MessageTxHash: () => calculateL2MessageTxHash,\n  calculateTransactionHash: () => calculateTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon,\n  computeHashOnElements: () => computeHashOnElements\n});\n\n// src/utils/ec.ts\nvar ec_exports = {};\n__export(ec_exports, {\n  starkCurve: () => _scure_starknet__WEBPACK_IMPORTED_MODULE_6__,\n  weierstrass: () => _noble_curves_abstract_weierstrass__WEBPACK_IMPORTED_MODULE_9__\n});\n\n\n\n// src/utils/hash/transactionHash/v2.ts\nfunction computeHashOnElements(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(toBigInt(x), toBigInt(y)), 0).toString();\n}\nfunction calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData = []) {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData\n  ];\n  return computeHashOnElements(dataToHash);\n}\nfunction calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {\n  return calculateTransactionHashCommon(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...compiledClassHash ? [compiledClassHash] : []]\n  );\n}\nfunction calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n  return calculateTransactionHashCommon(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {\n  return calculateTransactionHashCommon(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\nfunction calculateL2MessageTxHash(l1FromAddress, l2ToAddress, l2Selector, l2Calldata, l2ChainId, l1Nonce) {\n  const payload = [l1FromAddress, ...l2Calldata];\n  return calculateTransactionHashCommon(\n    \"0x6c315f68616e646c6572\" /* L1_HANDLER */,\n    0,\n    l2ToAddress,\n    getSelector(l2Selector),\n    payload,\n    0,\n    l2ChainId,\n    [l1Nonce]\n  );\n}\n\n// src/utils/hash/transactionHash/v3.ts\nvar v3_exports = {};\n__export(v3_exports, {\n  calculateDeclareTransactionHash: () => calculateDeclareTransactionHash2,\n  calculateDeployAccountTransactionHash: () => calculateDeployAccountTransactionHash2,\n  calculateInvokeTransactionHash: () => calculateInvokeTransactionHash,\n  calculateTransactionHashCommon: () => calculateTransactionHashCommon2,\n  hashDAMode: () => hashDAMode,\n  hashFeeField: () => hashFeeField\n});\n\nvar AToBI = (array) => array.map((it) => BigInt(it));\nvar DATA_AVAILABILITY_MODE_BITS = 32n;\nvar MAX_AMOUNT_BITS = 64n;\nvar MAX_PRICE_PER_UNIT_BITS = 128n;\nvar RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nvar L1_GAS_NAME = BigInt(encodeShortString(\"L1_GAS\"));\nvar L2_GAS_NAME = BigInt(encodeShortString(\"L2_GAS\"));\nfunction hashDAMode(nonceDAMode, feeDAMode) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\nfunction hashFeeField(tip, bounds) {\n  const L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l1_gas.max_price_per_unit);\n  const L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) + (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) + BigInt(bounds.l2_gas.max_price_per_unit);\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)([BigInt(tip), L1Bound, L2Bound]);\n}\nfunction calculateTransactionHashCommon2(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData = []) {\n  const feeFieldHash = hashFeeField(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData)\n  ]);\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(dataToHash));\n}\nfunction calculateDeployAccountTransactionHash2(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465706c6f795f6163636f756e74\" /* DEPLOY_ACCOUNT */,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\nfunction calculateDeclareTransactionHash2(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x6465636c617265\" /* DECLARE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\nfunction calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {\n  return calculateTransactionHashCommon2(\n    \"0x696e766f6b65\" /* INVOKE */,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [(0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(accountDeploymentData)), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(AToBI(compiledCalldata))]\n  );\n}\n\n// src/utils/hash/transactionHash/index.ts\nfunction isV3InvokeTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateInvokeTransactionHash2(args) {\n  if (isV3InvokeTx(args)) {\n    return calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateTransactionHash(\n    args.senderAddress,\n    args.version,\n    args.compiledCalldata,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\nfunction isV3DeclareTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateDeclareTransactionHash3(args) {\n  if (isV3DeclareTx(args)) {\n    return calculateDeclareTransactionHash2(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeclareTransactionHash(\n    args.classHash,\n    args.senderAddress,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce,\n    args.compiledClassHash\n  );\n}\nfunction isV3DeployAccountTx(args) {\n  return [api_exports.ETransactionVersion.V3, api_exports.ETransactionVersion.F3].includes(args.version);\n}\nfunction calculateDeployAccountTransactionHash3(args) {\n  if (isV3DeployAccountTx(args)) {\n    return calculateDeployAccountTransactionHash2(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return calculateDeployAccountTransactionHash(\n    args.contractAddress,\n    args.classHash,\n    args.constructorCalldata,\n    args.salt,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n\n// src/utils/hash/classHash.ts\n\nfunction computePedersenHash(a, b) {\n  return _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(BigInt(a), BigInt(b));\n}\nfunction computePoseidonHash(a, b) {\n  return toHex(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHash(BigInt(a), BigInt(b)));\n}\nfunction computeHashOnElements2(data) {\n  return [...data, data.length].reduce((x, y) => _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(BigInt(x), BigInt(y)), 0).toString();\n}\nvar computePedersenHashOnElements = computeHashOnElements2;\nfunction computePoseidonHashOnElements(data) {\n  return toHex((0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(data.map((x) => BigInt(x))));\n}\nfunction calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements2(compiledCalldata);\n  const CONTRACT_ADDRESS_PREFIX = felt(\"0x535441524b4e45545f434f4e54524143545f41444452455353\");\n  const hash = computeHashOnElements2([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\nfunction nullSkipReplacer(key, value) {\n  if (key === \"attributes\" || key === \"accessible_scopes\") {\n    return Array.isArray(value) && value.length === 0 ? void 0 : value;\n  }\n  if (key === \"debug_info\") {\n    return null;\n  }\n  return value === null ? void 0 : value;\n}\nfunction formatSpaces(json2) {\n  let insideQuotes = false;\n  const newString = [];\n  for (const char of json2) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === \"\\\\\") === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      newString.push(char === \":\" ? \": \" : char === \",\" ? \", \" : char);\n    }\n  }\n  return newString.join(\"\");\n}\nfunction computeHintedClassHash(compiledContract) {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify2(contractClass, nullSkipReplacer));\n  return addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(serializedJson)).toString(16));\n}\nfunction computeLegacyContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  const apiVersion = toHex(API_VERSION);\n  const externalEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n  const l1HandlerEntryPointsHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n  const constructorEntryPointHash = computeHashOnElements2(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n  const builtinsHash = computeHashOnElements2(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n  const dataHash = computeHashOnElements2(compiledContract.program.data);\n  return computeHashOnElements2([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash\n  ]);\n}\nfunction hashBuiltins(builtins) {\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(\n    builtins.flatMap((it) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\nfunction hashEntryPoint(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(base);\n}\nfunction hashByteCodeSegments(casm) {\n  const byteCode = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths = casm.bytecode_segment_lengths ?? [];\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, segmentStart += len);\n    return [BigInt(len), (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(segment)];\n  });\n  return 1n + (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(hashLeaves);\n}\nfunction computeCompiledClassHash(casm) {\n  const COMPILED_CLASS_VERSION = \"COMPILED_CLASS_V1\";\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n  const bytecode = casm.bytecode_segment_lengths ? hashByteCodeSegments(casm) : (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(casm.bytecode.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode\n    ])\n  );\n}\nfunction hashEntryPointSierra(data) {\n  const base = data.flatMap((it) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(base);\n}\nfunction hashAbi(sierra) {\n  const indentString = formatSpaces(stringify2(sierra.abi, null));\n  return BigInt(addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(indentString)).toString(16)));\n}\nfunction computeSierraContractClassHash(sierra) {\n  const CONTRACT_CLASS_VERSION = \"CONTRACT_CLASS_V0.1.0\";\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n  const abiHash = hashAbi(sierra);\n  const sierraProgram = (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)(sierra.sierra_program.map((it) => BigInt(it)));\n  return toHex(\n    (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.poseidonHashMany)([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram\n    ])\n  );\n}\nfunction computeContractClassHash(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  if (\"sierra_program\" in compiledContract) {\n    return computeSierraContractClassHash(compiledContract);\n  }\n  return computeLegacyContractClassHash(compiledContract);\n}\n\n// src/utils/stark.ts\nvar stark_exports = {};\n__export(stark_exports, {\n  compressProgram: () => compressProgram,\n  decompressProgram: () => decompressProgram,\n  estimateFeeToBounds: () => estimateFeeToBounds,\n  estimatedFeeToMaxFee: () => estimatedFeeToMaxFee,\n  formatSignature: () => formatSignature,\n  intDAM: () => intDAM,\n  makeAddress: () => makeAddress,\n  randomAddress: () => randomAddress,\n  reduceV2: () => reduceV2,\n  signatureToDecimalArray: () => signatureToDecimalArray,\n  signatureToHexArray: () => signatureToHexArray,\n  toFeeVersion: () => toFeeVersion,\n  toTransactionVersion: () => toTransactionVersion,\n  v3Details: () => v3Details\n});\n\n\nfunction compressProgram(jsonProgram) {\n  const stringified = isString(jsonProgram) ? jsonProgram : stringify2(jsonProgram);\n  const compressedProgram = (0,pako__WEBPACK_IMPORTED_MODULE_10__.gzip)(stringified);\n  return btoaUniversal(compressedProgram);\n}\nfunction decompressProgram(base642) {\n  if (Array.isArray(base642)) return base642;\n  const decompressed = arrayBufferToString((0,pako__WEBPACK_IMPORTED_MODULE_10__.ungzip)(atobUniversal(base642)));\n  return parse2(decompressed);\n}\nfunction randomAddress() {\n  const randomKeyPair = _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.utils.randomPrivateKey();\n  return (0,_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.getStarkKey)(randomKeyPair);\n}\nfunction makeAddress(input) {\n  return addHexPrefix(input).toLowerCase();\n}\nfunction formatSignature(sig) {\n  if (!sig) throw Error(\"formatSignature: provided signature is undefined\");\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error(\"Signature need to be weierstrass.SignatureType or an array for custom\");\n  }\n}\nfunction signatureToDecimalArray(sig) {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\nfunction signatureToHexArray(sig) {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\nfunction estimatedFeeToMaxFee(estimatedFee, overhead = 50 /* MAX_FEE */) {\n  return addPercent(estimatedFee, overhead);\n}\nfunction estimateFeeToBounds(estimate, amountOverhead = 50 /* L1_BOUND_MAX_AMOUNT */, priceOverhead = 50 /* L1_BOUND_MAX_PRICE_PER_UNIT */) {\n  if (isBigInt(estimate)) {\n    return {\n      l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n      l1_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" }\n    };\n  }\n  if (typeof estimate.gas_consumed === \"undefined\" || typeof estimate.gas_price === \"undefined\") {\n    throw Error(\"estimateFeeToBounds: estimate is undefined\");\n  }\n  const maxUnits = estimate.data_gas_consumed !== void 0 && estimate.data_gas_price !== void 0 ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead)) : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n  return {\n    l2_gas: { max_amount: \"0x0\", max_price_per_unit: \"0x0\" },\n    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice }\n  };\n}\nfunction intDAM(dam) {\n  if (dam === api_exports.EDataAvailabilityMode.L1) return api_exports.EDAMode.L1;\n  if (dam === api_exports.EDataAvailabilityMode.L2) return api_exports.EDAMode.L2;\n  throw Error(\"EDAM conversion\");\n}\nfunction toTransactionVersion(defaultVersion, providedVersion) {\n  const providedVersion0xs = providedVersion ? toHex(providedVersion) : void 0;\n  const defaultVersion0xs = toHex(defaultVersion);\n  if (providedVersion && !Object.values(api_exports.ETransactionVersion).includes(providedVersion0xs)) {\n    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n  }\n  if (!Object.values(api_exports.ETransactionVersion).includes(defaultVersion0xs)) {\n    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n  }\n  return providedVersion ? providedVersion0xs : defaultVersion0xs;\n}\nfunction toFeeVersion(providedVersion) {\n  if (!providedVersion) return void 0;\n  const version = toHex(providedVersion);\n  if (version === api_exports.ETransactionVersion.V0) return api_exports.ETransactionVersion.F0;\n  if (version === api_exports.ETransactionVersion.V1) return api_exports.ETransactionVersion.F1;\n  if (version === api_exports.ETransactionVersion.V2) return api_exports.ETransactionVersion.F2;\n  if (version === api_exports.ETransactionVersion.V3) return api_exports.ETransactionVersion.F3;\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\nfunction v3Details(details) {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_exports.EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO)\n  };\n}\nfunction reduceV2(providedVersion) {\n  if (providedVersion === api_exports.ETransactionVersion.F2) return api_exports.ETransactionVersion.F1;\n  if (providedVersion === api_exports.ETransactionVersion.V2) return api_exports.ETransactionVersion.V1;\n  return providedVersion;\n}\n\n// src/utils/contract.ts\nfunction isSierra(contract) {\n  const compiledContract = isString(contract) ? parse2(contract) : contract;\n  return \"sierra_program\" in compiledContract;\n}\nfunction extractContractHashes(payload) {\n  const response = { ...payload };\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        \"Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash\"\n      );\n  }\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error(\"Extract classHash failed, provide (CompiledContract).json file or classHash\");\n  return response;\n}\nfunction contractClassResponseToLegacyCompiledContract(ccr) {\n  if (isSierra(ccr)) {\n    throw Error(\"ContractClassResponse need to be LegacyContractClass (cairo0 response class)\");\n  }\n  const contract = ccr;\n  return { ...contract, program: decompressProgram(contract.program) };\n}\n\n// src/utils/eth.ts\nvar eth_exports = {};\n__export(eth_exports, {\n  ethRandomPrivateKey: () => ethRandomPrivateKey,\n  validateAndParseEthAddress: () => validateAndParseEthAddress\n});\n\nfunction ethRandomPrivateKey() {\n  return sanitizeHex(buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.utils.randomPrivateKey()));\n}\nfunction validateAndParseEthAddress(address) {\n  assertInRange(address, ZERO, 2n ** 160n - 1n, \"Ethereum Address \");\n  const result = addHexPrefix(removeHexPrefix(toHex(address)).padStart(40, \"0\"));\n  assert(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), \"Invalid Ethereum Address Format\");\n  return result;\n}\n\n// src/utils/fetchPonyfill.ts\n\n\nvar fetchPonyfill_default = typeof window !== \"undefined\" && window.fetch || // use buildin fetch in browser if available\ntypeof global !== \"undefined\" && (0,fetch_cookie__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(global.fetch) || // use buildin fetch in node, react-native and service worker if available\nisomorphic_fetch__WEBPACK_IMPORTED_MODULE_13__;\n\n// src/utils/provider.ts\nvar provider_exports = {};\n__export(provider_exports, {\n  Block: () => Block,\n  createSierraContractClass: () => createSierraContractClass,\n  getDefaultNodeUrl: () => getDefaultNodeUrl,\n  isPendingBlock: () => isPendingBlock,\n  isPendingStateUpdate: () => isPendingStateUpdate,\n  isPendingTransaction: () => isPendingTransaction,\n  isV3Tx: () => isV3Tx,\n  isVersion: () => isVersion,\n  parseContract: () => parseContract,\n  validBlockTags: () => validBlockTags,\n  wait: () => wait\n});\nfunction wait(delay) {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\nfunction createSierraContractClass(contract) {\n  const result = { ...contract };\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify2(contract.abi));\n  result.sierra_program = formatSpaces(stringify2(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\nfunction parseContract(contract) {\n  const parsedContract = isString(contract) ? parse2(contract) : contract;\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...\"program\" in parsedContract && { program: compressProgram(parsedContract.program) }\n    };\n  }\n  return createSierraContractClass(parsedContract);\n}\nvar getDefaultNodeUrl = (networkName, mute = false) => {\n  if (!mute) {\n    console.warn(\"Using default public node url, please provide nodeUrl in provider options!\");\n  }\n  const nodes = RPC_NODES[networkName ?? \"SN_SEPOLIA\" /* SN_SEPOLIA */];\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\nvar validBlockTags = Object.values(BlockTag);\nvar Block = class {\n  /**\n   * @param {BlockIdentifier} hash if not null, contains the block hash\n   */\n  hash = null;\n  /**\n   * @param {BlockIdentifier} number if not null, contains the block number\n   */\n  number = null;\n  /**\n   * @param {BlockIdentifier} tag if not null, contains \"pending\" or \"latest\"\n   */\n  tag = null;\n  setIdentifier(__identifier) {\n    if (isString(__identifier)) {\n      if (isDecimalString(__identifier)) {\n        this.number = parseInt(__identifier, 10);\n      } else if (isHex(__identifier)) {\n        this.hash = __identifier;\n      } else if (validBlockTags.includes(__identifier)) {\n        this.tag = __identifier;\n      } else {\n        throw TypeError(`Block identifier unmanaged: ${__identifier}`);\n      }\n    } else if (isBigInt(__identifier)) {\n      this.hash = toHex(__identifier);\n    } else if (isNumber(__identifier)) {\n      this.number = __identifier;\n    } else {\n      this.tag = \"pending\" /* PENDING */;\n    }\n    if (isNumber(this.number) && this.number < 0) {\n      throw TypeError(`Block number (${this.number}) can't be negative`);\n    }\n  }\n  /**\n   * Create a Block instance\n   * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.\n   * decimal string and number are detected as block numbers.\n   * text string are detected as block tag.\n   * null is considered as a 'pending' block tag.\n   */\n  constructor(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as a string\n   * @example\n   * ```typescript\n   * const result = new provider.Block(123456n).queryIdentifier;\n   * // result = \"blockHash=0x1e240\"\n   * ```\n   */\n  get queryIdentifier() {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n    return `blockNumber=${this.tag}`;\n  }\n  // TODO: fix any\n  /**\n   * @returns {any} the identifier as an object\n   * @example\n   * ```typescript\n   * const result = new provider.Block(56789).identifier;\n   * // result = { block_number: 56789 }\n   * ```\n   */\n  get identifier() {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n    return this.tag;\n  }\n  /**\n   * change the identifier of an existing Block instance\n   * @example\n   * ```typescript\n   * const myBlock = new provider.Block(\"latest\");\n   * myBlock.identifier =\"0x3456789abc\";\n   * const result = myBlock.identifier;\n   * // result = { block_hash: '0x3456789abc' }\n   * ```\n   */\n  set identifier(_identifier) {\n    this.setIdentifier(_identifier);\n  }\n  valueOf = () => this.number;\n  toString = () => this.hash;\n};\nfunction isV3Tx(details) {\n  const version = details.version ? toHex(details.version) : api_exports.ETransactionVersion.V3;\n  return version === api_exports.ETransactionVersion.V3 || version === api_exports.ETransactionVersion.F3;\n}\nfunction isVersion(version, response) {\n  const [majorS, minorS] = version.split(\".\");\n  const [majorR, minorR] = response.split(\".\");\n  return majorS === majorR && minorS === minorR;\n}\nfunction isPendingBlock(response) {\n  return response.status === \"PENDING\";\n}\nfunction isPendingTransaction(response) {\n  return !(\"block_hash\" in response);\n}\nfunction isPendingStateUpdate(response) {\n  return !(\"block_hash\" in response);\n}\n\n// src/utils/transaction.ts\nvar transaction_exports = {};\n__export(transaction_exports, {\n  buildUDCCall: () => buildUDCCall,\n  fromCallsToExecuteCalldata: () => fromCallsToExecuteCalldata,\n  fromCallsToExecuteCalldataWithNonce: () => fromCallsToExecuteCalldataWithNonce,\n  fromCallsToExecuteCalldata_cairo1: () => fromCallsToExecuteCalldata_cairo1,\n  getExecuteCalldata: () => getExecuteCalldata,\n  getVersionsByType: () => getVersionsByType,\n  transformCallsToMulticallArrays: () => transformCallsToMulticallArrays,\n  transformCallsToMulticallArrays_cairo1: () => transformCallsToMulticallArrays_cairo1\n});\nvar transformCallsToMulticallArrays = (calls) => {\n  const callArray = [];\n  const calldata = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString()\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata })\n  };\n};\nvar fromCallsToExecuteCalldata = (calls) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata];\n};\nvar fromCallsToExecuteCalldataWithNonce = (calls, nonce) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()];\n};\nvar transformCallsToMulticallArrays_cairo1 = (calls) => {\n  const callArray = calls.map((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || [])\n  }));\n  return callArray;\n};\nvar fromCallsToExecuteCalldata_cairo1 = (calls) => {\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata: Array.isArray(call.calldata) && \"__compiled__\" in call.calldata ? call.calldata : CallData.compile(call.calldata)\n    // RawArgsObject | RawArgsArray type\n  }));\n  return CallData.compile({ orderCalls });\n};\nvar getExecuteCalldata = (calls, cairoVersion = \"0\") => {\n  if (cairoVersion === \"1\") {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\nfunction buildUDCCall(payload, address) {\n  const params = [].concat(payload).map((it) => {\n    const {\n      classHash,\n      salt,\n      unique = true,\n      constructorCalldata = []\n    } = it;\n    const compiledConstructorCallData = CallData.compile(constructorCalldata);\n    const deploySalt = salt ?? randomAddress();\n    return {\n      call: {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          deploySalt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      },\n      address: calculateContractAddressFromHash(\n        unique ? _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.pedersen(address, deploySalt) : deploySalt,\n        classHash,\n        compiledConstructorCallData,\n        unique ? UDC.ADDRESS : 0\n      )\n    };\n  });\n  return {\n    calls: params.map((it) => it.call),\n    addresses: params.map((it) => it.address)\n  };\n}\nfunction getVersionsByType(versionType) {\n  return versionType === \"fee\" ? {\n    v1: api_exports.ETransactionVersion.F1,\n    v2: api_exports.ETransactionVersion.F2,\n    v3: api_exports.ETransactionVersion.F3\n  } : { v1: api_exports.ETransactionVersion.V1, v2: api_exports.ETransactionVersion.V2, v3: api_exports.ETransactionVersion.V3 };\n}\n\n// src/channel/rpc_0_6.ts\nvar defaultOptions = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: \"pending\" /* PENDING */,\n  retries: 200\n};\nvar RpcChannel = class {\n  nodeUrl;\n  headers;\n  retries;\n  requestId;\n  blockIdentifier;\n  chainId;\n  specVersion;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  batchClient;\n  constructor(optionsOrProvider) {\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode, batch } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n    if (typeof batch === \"number\") {\n      this.batchClient = new BatchClient({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch\n      });\n    }\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return fetchPonyfill_default(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify2(params, null, 2)}\n\n        ${code}: ${message}: ${stringify2(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      if (this.batchClient) {\n        const { error: error2, result: result2 } = await this.batchClient.fetch(\n          method,\n          params,\n          this.requestId += 1\n        );\n        this.errorHandler(method, params, error2);\n        return result2;\n      }\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, simulateTransactionOptions = {}) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate) simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(rpcspec_0_6_exports.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5e3;\n    const errorStates = options?.errorStates ?? [\n      rpcspec_0_6_exports.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      rpcspec_0_6_exports.ETransactionExecutionStatus.SUCCEEDED,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L2,\n      rpcspec_0_6_exports.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [rpcspec_0_6_exports.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: rpcspec_0_6_exports.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: rpcspec_0_6_exports.ETransactionType.DEPLOY_ACCOUNT,\n          version: rpcspec_0_6_exports.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        // v0 v1 v3\n        type: rpcspec_0_6_exports.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/channel/rpc_0_7.ts\nvar rpc_0_7_exports = {};\n__export(rpc_0_7_exports, {\n  RpcChannel: () => RpcChannel2\n});\nvar defaultOptions2 = {\n  headers: { \"Content-Type\": \"application/json\" },\n  blockIdentifier: \"pending\" /* PENDING */,\n  retries: 200\n};\nvar RpcChannel2 = class {\n  nodeUrl;\n  headers;\n  retries;\n  requestId;\n  blockIdentifier;\n  chainId;\n  specVersion;\n  transactionRetryIntervalFallback;\n  waitMode;\n  // behave like web2 rpc and return when tx is processed\n  batchClient;\n  constructor(optionsOrProvider) {\n    const {\n      nodeUrl,\n      retries,\n      headers,\n      blockIdentifier,\n      chainId,\n      specVersion,\n      waitMode,\n      transactionRetryIntervalFallback,\n      batch\n    } = optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(void 0, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions2.retries;\n    this.headers = { ...defaultOptions2.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions2.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n    this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;\n    if (typeof batch === \"number\") {\n      this.batchClient = new BatchClient({\n        nodeUrl: this.nodeUrl,\n        headers: this.headers,\n        interval: batch\n      });\n    }\n  }\n  get transactionRetryIntervalDefault() {\n    return this.transactionRetryIntervalFallback ?? 5e3;\n  }\n  setChainId(chainId) {\n    this.chainId = chainId;\n  }\n  fetch(method, params, id = 0) {\n    const rpcRequestBody = {\n      id,\n      jsonrpc: \"2.0\",\n      method,\n      ...params && { params }\n    };\n    return fetchPonyfill_default(this.nodeUrl, {\n      method: \"POST\",\n      body: stringify2(rpcRequestBody),\n      headers: this.headers\n    });\n  }\n  errorHandler(method, params, rpcError, otherError) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify2(params, null, 2)}\n \n        ${code}: ${message}: ${stringify2(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n  async fetchEndpoint(method, params) {\n    try {\n      if (this.batchClient) {\n        const { error: error2, result: result2 } = await this.batchClient.fetch(\n          method,\n          params,\n          this.requestId += 1\n        );\n        this.errorHandler(method, params, error2);\n        return result2;\n      }\n      const rawResult = await this.fetch(method, params, this.requestId += 1);\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result;\n    } catch (error) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n  async getChainId() {\n    this.chainId ??= await this.fetchEndpoint(\"starknet_chainId\");\n    return this.chainId;\n  }\n  async getSpecVersion() {\n    this.specVersion ??= await this.fetchEndpoint(\"starknet_specVersion\");\n    return this.specVersion;\n  }\n  getNonceForAddress(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getNonce\", {\n      contract_address,\n      block_id\n    });\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  getBlockLatestAccepted() {\n    return this.fetchEndpoint(\"starknet_blockHashAndNumber\");\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  getBlockNumber() {\n    return this.fetchEndpoint(\"starknet_blockNumber\");\n  }\n  getBlockWithTxHashes(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxHashes\", { block_id });\n  }\n  getBlockWithTxs(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithTxs\", { block_id });\n  }\n  getBlockWithReceipts(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockWithReceipts\", { block_id });\n  }\n  getBlockStateUpdate(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStateUpdate\", { block_id });\n  }\n  getBlockTransactionsTraces(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_traceBlockTransactions\", { block_id });\n  }\n  getBlockTransactionCount(blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getBlockTransactionCount\", { block_id });\n  }\n  getTransactionByHash(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionByHash\", {\n      transaction_hash\n    });\n  }\n  getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getTransactionByBlockIdAndIndex\", { block_id, index });\n  }\n  getTransactionReceipt(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_getTransactionReceipt\", { transaction_hash });\n  }\n  getTransactionTrace(txHash) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint(\"starknet_traceTransaction\", { transaction_hash });\n  }\n  /**\n   * Get the status of a transaction\n   */\n  getTransactionStatus(transactionHash) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint(\"starknet_getTransactionStatus\", { transaction_hash });\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  simulateTransaction(invocations, simulateTransactionOptions = {}) {\n    const {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true\n    } = simulateTransactionOptions;\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags = [];\n    if (skipValidate) simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ESimulationFlag.SKIP_FEE_CHARGE);\n    return this.fetchEndpoint(\"starknet_simulateTransactions\", {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags\n    });\n  }\n  async waitForTransaction(txHash, options) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? this.transactionRetryIntervalDefault;\n    const errorStates = options?.errorStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionStatus.REJECTED\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates = options?.successStates ?? [\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionExecutionStatus.SUCCEEDED,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionStatus.ACCEPTED_ON_L2,\n      starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionStatus.ACCEPTED_ON_L1\n    ];\n    let txStatus;\n    while (!onchain) {\n      await wait(retryInterval);\n      try {\n        txStatus = await this.getTransactionStatus(transactionHash);\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n        if (!finalityStatus) {\n          const error = new Error(\"waiting for transaction status\");\n          throw error;\n        }\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message);\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (successStates.includes(executionStatus) || successStates.includes(finalityStatus)) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n    }\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      await wait(retryInterval);\n    }\n    return txReceipt;\n  }\n  getStorageAt(contractAddress, key, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getStorageAt\", {\n      contract_address,\n      key: parsedKey,\n      block_id\n    });\n  }\n  getClassHashAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassHashAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  getClass(classHash, blockIdentifier = this.blockIdentifier) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClass\", {\n      class_hash,\n      block_id\n    });\n  }\n  getClassAt(contractAddress, blockIdentifier = this.blockIdentifier) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_getClassAt\", {\n      block_id,\n      contract_address\n    });\n  }\n  async getEstimateFee(invocations, { blockIdentifier = this.blockIdentifier, skipValidate = true }) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion(\"0.5\", await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ESimulationFlag.SKIP_VALIDATE] : []\n      };\n    }\n    return this.fetchEndpoint(\"starknet_estimateFee\", {\n      request: invocations.map((it) => this.buildTransaction(it, \"fee\")),\n      block_id,\n      ...flags\n    });\n  }\n  async invoke(functionInvocation, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addInvokeTransaction\", {\n        invoke_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async declare({ contract, signature, senderAddress, compiledClassHash }, details) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeclareTransaction\", {\n        declare_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || \"\",\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    } else {\n      throw Error(\"declare unspotted parameters\");\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  async deployAccount({ classHash, constructorCalldata, addressSalt, signature }, details) {\n    let promise;\n    if (!isV3Tx(details)) {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce)\n        }\n      });\n    } else {\n      promise = this.fetchEndpoint(\"starknet_addDeployAccountTransaction\", {\n        deploy_account_transaction: {\n          type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.DEPLOY_ACCOUNT,\n          version: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode\n        }\n      });\n    }\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n  callContract(call, blockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_call\", {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata)\n      },\n      block_id\n    });\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  estimateMessageFee(message, blockIdentifier = this.blockIdentifier) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: validateAndParseEthAddress(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload)\n    };\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint(\"starknet_estimateMessageFee\", {\n      message: formattedMessage,\n      block_id\n    });\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  getSyncingStats() {\n    return this.fetchEndpoint(\"starknet_syncing\");\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  getEvents(eventFilter) {\n    return this.fetchEndpoint(\"starknet_getEvents\", { filter: eventFilter });\n  }\n  buildTransaction(invocation, versionType) {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n    if (!isV3Tx(invocation)) {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0)\n      };\n    } else {\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it))\n      };\n    }\n    if (invocation.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n      return {\n        // v0 v1 v3\n        type: starknet_types_07__WEBPACK_IMPORTED_MODULE_14__.ETransactionType.INVOKE,\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DECLARE\" /* DECLARE */) {\n      if (!isSierra(invocation.contract)) {\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details\n        };\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program)\n        },\n        compiled_class_hash: invocation.compiledClassHash || \"\",\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details\n      };\n    }\n    if (invocation.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n      const { account_deployment_data, ...restDetails } = details;\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...restDetails\n      };\n    }\n    throw Error(\"RPC buildTransaction received unknown TransactionType\");\n  }\n};\n\n// src/utils/responseParser/rpc.ts\nvar RPCResponseParser = class {\n  margin;\n  constructor(margin) {\n    this.margin = margin;\n  }\n  estimatedFeeToMaxFee(estimatedFee) {\n    return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n  }\n  estimateFeeToBounds(estimate) {\n    return estimateFeeToBounds(\n      estimate,\n      this.margin?.l1BoundMaxAmount,\n      this.margin?.l1BoundMaxPricePerUnit\n    );\n  }\n  parseGetBlockResponse(res) {\n    return { status: \"PENDING\", ...res };\n  }\n  parseTransactionReceipt(res) {\n    if (\"actual_fee\" in res && isString(res.actual_fee)) {\n      return {\n        ...res,\n        actual_fee: {\n          amount: res.actual_fee,\n          unit: \"FRI\"\n        }\n      };\n    }\n    return res;\n  }\n  parseFeeEstimateResponse(res) {\n    const val = res[0];\n    return {\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    };\n  }\n  parseFeeEstimateBulkResponse(res) {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n      data_gas_consumed: val.data_gas_consumed ? toBigInt(val.data_gas_consumed) : 0n,\n      data_gas_price: val.data_gas_price ? toBigInt(val.data_gas_price) : 0n\n    }));\n  }\n  parseSimulateTransactionResponse(res) {\n    return res.map((it) => {\n      return {\n        ...it,\n        suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n        resourceBounds: this.estimateFeeToBounds(it.fee_estimation)\n      };\n    });\n  }\n  parseContractClassResponse(res) {\n    return {\n      ...res,\n      abi: isString(res.abi) ? JSON.parse(res.abi) : res.abi\n    };\n  }\n  parseL1GasPriceResponse(res) {\n    return res.l1_gas_price.price_in_wei;\n  }\n};\n\n// src/utils/transactionReceipt.ts\nvar ReceiptTx = class _ReceiptTx {\n  statusReceipt;\n  value;\n  constructor(receipt) {\n    [this.statusReceipt, this.value] = _ReceiptTx.isSuccess(receipt) ? [\"success\", receipt] : _ReceiptTx.isReverted(receipt) ? [\"reverted\", receipt] : _ReceiptTx.isRejected(receipt) ? [\"rejected\", receipt] : [\"error\", new Error(\"Unknown response type\")];\n    for (const [key] of Object.entries(this)) {\n      Object.defineProperty(this, key, {\n        enumerable: false\n      });\n    }\n    for (const [key, value] of Object.entries(receipt)) {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        writable: false,\n        value\n      });\n    }\n  }\n  match(callbacks) {\n    if (this.statusReceipt in callbacks) {\n      return callbacks[this.statusReceipt](this.value);\n    }\n    return callbacks._();\n  }\n  isSuccess() {\n    return this.statusReceipt === \"success\";\n  }\n  isReverted() {\n    return this.statusReceipt === \"reverted\";\n  }\n  isRejected() {\n    return this.statusReceipt === \"rejected\";\n  }\n  isError() {\n    return this.statusReceipt === \"error\";\n  }\n  static isSuccess(transactionReceipt) {\n    return transactionReceipt.execution_status === \"SUCCEEDED\" /* SUCCEEDED */;\n  }\n  static isReverted(transactionReceipt) {\n    return transactionReceipt.execution_status === \"REVERTED\" /* REVERTED */;\n  }\n  static isRejected(transactionReceipt) {\n    return transactionReceipt.status === \"REJECTED\" /* REJECTED */;\n  }\n};\n\n// src/provider/rpc.ts\nvar RpcProvider = class {\n  responseParser;\n  channel;\n  constructor(optionsOrProvider) {\n    if (optionsOrProvider && \"channel\" in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser = \"responseParser\" in optionsOrProvider ? optionsOrProvider.responseParser : new RPCResponseParser();\n    } else {\n      this.channel = new RpcChannel2({ ...optionsOrProvider, waitMode: false });\n      this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n    }\n  }\n  fetch(method, params, id = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n  async getChainId() {\n    return this.channel.getChainId();\n  }\n  async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n  async getNonceForAddress(contractAddress, blockIdentifier) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n  async getBlock(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseGetBlockResponse);\n  }\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n  async getBlockWithTxHashes(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n  async getBlockWithTxs(blockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n  /**\n   * Pause the execution of the script until a specified block is created.\n   * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberish) or 'pending' or 'latest'.\n   * Use of 'latest\" or of a block already created will generate no pause.\n   * @param {number} [retryInterval] number of milliseconds between 2 requests to the node\n   * @example\n   * ```typescript\n   * await myProvider.waitForBlock();\n   * // wait the creation of the pending block\n   * ```\n   */\n  async waitForBlock(blockIdentifier = \"pending\", retryInterval = 5e3) {\n    if (blockIdentifier === \"latest\" /* LATEST */) return;\n    const currentBlock = await this.getBlockNumber();\n    const targetBlock = blockIdentifier === \"pending\" /* PENDING */ ? currentBlock + 1 : Number(toHex(blockIdentifier));\n    if (targetBlock <= currentBlock) return;\n    const { retries } = this.channel;\n    let retriesCount = retries;\n    let isTargetBlock = false;\n    while (!isTargetBlock) {\n      const currBlock = await this.getBlockNumber();\n      if (currBlock === targetBlock) {\n        isTargetBlock = true;\n      } else {\n        await wait(retryInterval);\n      }\n      retriesCount -= 1;\n      if (retriesCount <= 0) {\n        throw new Error(`waitForBlock() timed-out after ${retries} tries.`);\n      }\n    }\n  }\n  async getL1GasPrice(blockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier).then(this.responseParser.parseL1GasPriceResponse);\n  }\n  async getL1MessageHash(l2TxHash) {\n    const transaction = await this.channel.getTransactionByHash(l2TxHash);\n    assert(transaction.type === \"L1_HANDLER\", \"This L2 transaction is not a L1 message.\");\n    const { calldata, contract_address, entry_point_selector, nonce } = transaction;\n    const params = [\n      calldata[0],\n      contract_address,\n      nonce,\n      entry_point_selector,\n      calldata.length - 1,\n      ...calldata.slice(1)\n    ];\n    return solidityUint256PackedKeccak256(params);\n  }\n  async getBlockWithReceipts(blockIdentifier) {\n    if (this.channel instanceof rpc_0_6_exports.RpcChannel)\n      throw new LibraryError(\"Unsupported method for RPC version\");\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n  getStateUpdate = this.getBlockStateUpdate;\n  async getBlockStateUpdate(blockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n  async getBlockTransactionsTraces(blockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n  async getBlockTransactionCount(blockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */\n  async getPendingTransactions() {\n    const { transactions } = await this.getBlockWithTxHashes(\"pending\" /* PENDING */).then(\n      this.responseParser.parseGetBlockResponse\n    );\n    return Promise.all(transactions.map((it) => this.getTransactionByHash(it)));\n  }\n  async getTransaction(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByHash(txHash) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n  async getTransactionByBlockIdAndIndex(blockIdentifier, index) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n  async getTransactionReceipt(txHash) {\n    const txReceiptWoHelper = await this.channel.getTransactionReceipt(txHash);\n    const txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);\n    return new ReceiptTx(txReceiptWoHelperModified);\n  }\n  async getTransactionTrace(txHash) {\n    return this.channel.getTransactionTrace(txHash);\n  }\n  /**\n   * Get the status of a transaction\n   */\n  async getTransactionStatus(transactionHash) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n  /**\n   * @param invocations AccountInvocations\n   * @param options blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  async getSimulateTransaction(invocations, options) {\n    return this.channel.simulateTransaction(invocations, options).then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n  async waitForTransaction(txHash, options) {\n    const receiptWoHelper = await this.channel.waitForTransaction(\n      txHash,\n      options\n    );\n    return new ReceiptTx(receiptWoHelper);\n  }\n  async getStorageAt(contractAddress, key, blockIdentifier) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n  async getClassHashAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n  async getClassByHash(classHash) {\n    return this.getClass(classHash);\n  }\n  async getClass(classHash, blockIdentifier) {\n    return this.channel.getClass(classHash, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getClassAt(contractAddress, blockIdentifier) {\n    return this.channel.getClassAt(contractAddress, blockIdentifier).then(this.responseParser.parseContractClassResponse);\n  }\n  async getContractVersion(contractAddress, classHash, {\n    blockIdentifier = this.channel.blockIdentifier,\n    compiler = true\n  } = {}) {\n    let contractClass;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error(\"getContractVersion require contractAddress or classHash\");\n    }\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: \"1\", compiler: abiTest.compiler };\n      }\n      return { cairo: \"1\", compiler: void 0 };\n    }\n    return { cairo: \"0\", compiler: \"0\" };\n  }\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  async getEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n  async getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"INVOKE_FUNCTION\" /* INVOKE */,\n          ...invocation,\n          ...invocationDetails\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeclareEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"DECLARE\" /* DECLARE */,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getDeployAccountEstimateFee(invocation, details, blockIdentifier, skipValidate) {\n    return this.channel.getEstimateFee(\n      [\n        {\n          type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n          ...invocation,\n          ...details\n        }\n      ],\n      { blockIdentifier, skipValidate }\n    ).then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n  async getEstimateFeeBulk(invocations, options) {\n    return this.channel.getEstimateFee(invocations, options).then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n  async invokeFunction(functionInvocation, details) {\n    return this.channel.invoke(functionInvocation, details);\n  }\n  async declareContract(transaction, details) {\n    return this.channel.declare(transaction, details);\n  }\n  async deployAccountContract(transaction, details) {\n    return this.channel.deployAccount(\n      transaction,\n      details\n    );\n  }\n  async callContract(call, blockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  async estimateMessageFee(message, blockIdentifier) {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  async getEvents(eventFilter) {\n    return this.channel.getEvents(eventFilter);\n  }\n};\n\n// src/provider/extensions/default.ts\n\n\n// src/utils/starknetId.ts\nvar starknetId_exports = {};\n__export(starknetId_exports, {\n  StarknetIdContract: () => StarknetIdContract,\n  StarknetIdIdentityContract: () => StarknetIdIdentityContract,\n  StarknetIdMulticallContract: () => StarknetIdMulticallContract,\n  StarknetIdPfpContract: () => StarknetIdPfpContract,\n  StarknetIdPopContract: () => StarknetIdPopContract,\n  StarknetIdVerifierContract: () => StarknetIdVerifierContract,\n  dynamicCallData: () => dynamicCallData,\n  dynamicFelt: () => dynamicFelt,\n  execution: () => execution,\n  getStarknetIdContract: () => getStarknetIdContract,\n  getStarknetIdIdentityContract: () => getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract: () => getStarknetIdMulticallContract,\n  getStarknetIdPfpContract: () => getStarknetIdPfpContract,\n  getStarknetIdPopContract: () => getStarknetIdPopContract,\n  getStarknetIdVerifierContract: () => getStarknetIdVerifierContract,\n  useDecoded: () => useDecoded,\n  useEncoded: () => useEncoded\n});\nvar basicAlphabet = \"abcdefghijklmnopqrstuvwxyz0123456789-\";\nvar basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nvar bigAlphabet = \"\\u8FD9\\u6765\";\nvar basicAlphabetSize = BigInt(basicAlphabet.length);\nvar bigAlphabetSize = BigInt(bigAlphabet.length);\nvar bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\nfunction extractStars(str) {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\nfunction useDecoded(encoded) {\n  let decoded = \"\";\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO) decoded += basicAlphabet[0];\n          else decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else decoded += basicAlphabet[Number(code)];\n    }\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded = str + (k % 2 === 0 ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) + bigAlphabet[0] + basicAlphabet[1] : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += \".\";\n  });\n  if (!decoded) {\n    return decoded;\n  }\n  return decoded.concat(\"stark\");\n}\nfunction useEncoded(decoded) {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n    if (index !== -1) {\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n  return encoded;\n}\nvar StarknetIdContract = /* @__PURE__ */ ((StarknetIdContract2) => {\n  StarknetIdContract2[\"MAINNET\"] = \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\";\n  StarknetIdContract2[\"TESTNET_SEPOLIA\"] = \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\";\n  return StarknetIdContract2;\n})(StarknetIdContract || {});\nfunction getStarknetIdContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id is not yet deployed on this network\");\n  }\n}\nvar StarknetIdIdentityContract = /* @__PURE__ */ ((StarknetIdIdentityContract2) => {\n  StarknetIdIdentityContract2[\"MAINNET\"] = \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\";\n  StarknetIdIdentityContract2[\"TESTNET_SEPOLIA\"] = \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\";\n  return StarknetIdIdentityContract2;\n})(StarknetIdIdentityContract || {});\nfunction getStarknetIdIdentityContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdMulticallContract = \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\";\nfunction getStarknetIdMulticallContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return StarknetIdMulticallContract;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return StarknetIdMulticallContract;\n    default:\n      throw new Error(\"Starknet.id multicall contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdVerifierContract = /* @__PURE__ */ ((StarknetIdVerifierContract2) => {\n  StarknetIdVerifierContract2[\"MAINNET\"] = \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\";\n  StarknetIdVerifierContract2[\"TESTNET_SEPOLIA\"] = \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\";\n  return StarknetIdVerifierContract2;\n})(StarknetIdVerifierContract || {});\nfunction getStarknetIdVerifierContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\"Starknet.id verifier contract is not yet deployed on this network\");\n  }\n}\nvar StarknetIdPfpContract = /* @__PURE__ */ ((StarknetIdPfpContract2) => {\n  StarknetIdPfpContract2[\"MAINNET\"] = \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\";\n  StarknetIdPfpContract2[\"TESTNET_SEPOLIA\"] = \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\";\n  return StarknetIdPfpContract2;\n})(StarknetIdPfpContract || {});\nfunction getStarknetIdPfpContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\n        \"Starknet.id profile picture verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nvar StarknetIdPopContract = /* @__PURE__ */ ((StarknetIdPopContract2) => {\n  StarknetIdPopContract2[\"MAINNET\"] = \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\";\n  StarknetIdPopContract2[\"TESTNET_SEPOLIA\"] = \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\";\n  return StarknetIdPopContract2;\n})(StarknetIdPopContract || {});\nfunction getStarknetIdPopContract(chainId) {\n  switch (chainId) {\n    case \"0x534e5f4d41494e\" /* SN_MAIN */:\n      return \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\" /* MAINNET */;\n    case \"0x534e5f5345504f4c4941\" /* SN_SEPOLIA */:\n      return \"0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a\" /* TESTNET_SEPOLIA */;\n    default:\n      throw new Error(\n        \"Starknet.id proof of personhood verifier contract is not yet deployed on this network\"\n      );\n  }\n}\nfunction execution(staticEx, ifEqual = void 0, ifNotEqual = void 0) {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : void 0,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : void 0\n  });\n}\nfunction dynamicFelt(hardcoded, reference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0\n  });\n}\nfunction dynamicCallData(hardcoded, reference = void 0, arrayReference = void 0) {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : void 0,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : void 0\n  });\n}\n\n// src/provider/extensions/starknetId.ts\nvar StarknetId = class _StarknetId {\n  async getStarkName(address, StarknetIdContract2) {\n    return _StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2\n    );\n  }\n  async getAddressFromStarkName(name, StarknetIdContract2) {\n    return _StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      this,\n      name,\n      StarknetIdContract2\n    );\n  }\n  async getStarkProfile(address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    return _StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      this,\n      address,\n      StarknetIdContract2,\n      StarknetIdIdentityContract2,\n      StarknetIdVerifierContract2,\n      StarknetIdPfpContract2,\n      StarknetIdPopContract2,\n      StarknetIdMulticallContract2\n    );\n  }\n  static async getStarkName(provider, address, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"address_to_domain\",\n        calldata: CallData.compile({\n          address,\n          hint: []\n        })\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n      const stringDomain = useDecoded(decimalDomain);\n      if (!stringDomain) {\n        throw Error(\"Starkname not found\");\n      }\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === \"Starkname not found\") {\n        throw e;\n      }\n      throw Error(\"Could not get stark name\");\n    }\n  }\n  static async getAddressFromStarkName(provider, name, StarknetIdContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    try {\n      const encodedDomain = name.replace(\".stark\", \"\").split(\".\").map((part) => useEncoded(part).toString(10));\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: \"domain_to_address\",\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] })\n      });\n      return addressData[0];\n    } catch {\n      throw Error(\"Could not get address from stark name\");\n    }\n  }\n  static async getStarkProfile(provider, address, StarknetIdContract2, StarknetIdIdentityContract2, StarknetIdVerifierContract2, StarknetIdPfpContract2, StarknetIdPopContract2, StarknetIdMulticallContract2) {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract2 ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract2 ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract2 ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract2 ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract2 ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract2 ?? getStarknetIdMulticallContract(chainId);\n    try {\n      const calls = [\n        {\n          execution: execution({}),\n          to: dynamicCallData(contract),\n          selector: dynamicCallData(getSelectorFromName(\"address_to_domain\")),\n          calldata: [dynamicCallData(address), dynamicCallData(\"0\")]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(contract),\n          selector: dynamicFelt(getSelectorFromName(\"domain_to_id\")),\n          calldata: [dynamicCallData(void 0, void 0, [0, 0])]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"twitter\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"github\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"discord\")),\n            dynamicCallData(verifierContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"proof_of_personhood\")),\n            dynamicCallData(popContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        // PFP\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"nft_pp_contract\")),\n            dynamicCallData(pfpContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution({}),\n          to: dynamicFelt(identityContract),\n          selector: dynamicFelt(getSelectorFromName(\"get_extended_verifier_data\")),\n          calldata: [\n            dynamicCallData(void 0, [1, 0]),\n            dynamicCallData(encodeShortString(\"nft_pp_id\")),\n            dynamicCallData(\"2\"),\n            dynamicCallData(pfpContract),\n            dynamicCallData(\"0\")\n          ]\n        },\n        {\n          execution: execution(void 0, void 0, [6, 0, 0]),\n          to: dynamicFelt(void 0, [6, 0]),\n          selector: dynamicFelt(getSelectorFromName(\"tokenURI\")),\n          calldata: [dynamicCallData(void 0, [7, 1]), dynamicCallData(void 0, [7, 2])]\n        }\n      ];\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: \"aggregate\",\n        calldata: CallData.compile({\n          calls\n        })\n      });\n      if (Array.isArray(data)) {\n        const size = parseInt(data[0], 16);\n        const finalArray = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n        const twitter = finalArray[2][0] !== \"0x0\" ? BigInt(finalArray[2][0]).toString() : void 0;\n        const github = finalArray[3][0] !== \"0x0\" ? BigInt(finalArray[3][0]).toString() : void 0;\n        const discord = finalArray[4][0] !== \"0x0\" ? BigInt(finalArray[4][0]).toString() : void 0;\n        const proofOfPersonhood = finalArray[5][0] === \"0x1\";\n        const profilePictureMetadata = data[0] === \"0x9\" ? finalArray[8].slice(1).map((val) => decodeShortString(val)).join(\"\") : void 0;\n        const profilePicture = profilePictureMetadata || `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture\n        };\n      }\n      throw Error(\"Error while calling aggregate function\");\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error(\"Could not get user stark profile data from address\");\n    }\n  }\n};\n\n// src/provider/extensions/default.ts\nvar RpcProvider2 = class extends (0,ts_mixer__WEBPACK_IMPORTED_MODULE_15__.Mixin)(RpcProvider, StarknetId) {\n};\n\n// src/provider/interface.ts\nvar ProviderInterface = class {\n};\n\n// src/provider/index.ts\nvar defaultProvider = new RpcProvider({ default: true });\n\n// src/signer/interface.ts\nvar SignerInterface = class {\n};\n\n// src/utils/typedData.ts\nvar typedData_exports = {};\n__export(typedData_exports, {\n  TypedDataRevision: () => starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision,\n  encodeData: () => encodeData,\n  encodeType: () => encodeType,\n  encodeValue: () => encodeValue,\n  getDependencies: () => getDependencies,\n  getMessageHash: () => getMessageHash,\n  getStructHash: () => getStructHash,\n  getTypeHash: () => getTypeHash,\n  isMerkleTreeType: () => isMerkleTreeType,\n  prepareSelector: () => prepareSelector\n});\n\n// src/utils/merkle.ts\nvar merkle_exports = {};\n__export(merkle_exports, {\n  MerkleTree: () => MerkleTree,\n  proofMerklePath: () => proofMerklePath\n});\nvar MerkleTree = class _MerkleTree {\n  leaves;\n  branches = [];\n  root;\n  hashMethod;\n  /**\n   * Create a Merkle tree\n   *\n   * @param leafHashes hex-string array\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns created Merkle tree\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * // tree = {\n   * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],\n   * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],\n   * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',\n   * //   hashMethod: [Function computePedersenHash],\n   * // }\n   * ```\n   */\n  constructor(leafHashes, hashMethod = computePedersenHash) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n  /** @ignore */\n  build(leaves) {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(_MerkleTree.hash(leaves[i], \"0x0\", this.hashMethod));\n      } else {\n        newLeaves.push(_MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n  /**\n   * Calculate hash from ordered a and b, Pedersen hash default\n   *\n   * @param a first value\n   * @param b second value\n   * @param hashMethod hash method to use, default: Pedersen\n   * @returns result of the hash function\n   * @example\n   * ```typescript\n   * const result1 = MerkleTree.hash('0xabc', '0xdef');\n   * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'\n   *\n   * const customHashMethod = (a, b) => `custom_${a}_${b}`;\n   * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);\n   * // result2 = 'custom_2748_3567'\n   * ```\n   */\n  static hash(a, b, hashMethod = computePedersenHash) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => x >= y ? 1 : -1);\n    return hashMethod(aSorted, bSorted);\n  }\n  /**\n   * Calculates the merkle membership proof path\n   *\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns collection of merkle proof hex-string hashes\n   * @example\n   * ```typescript\n   * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];\n   * const tree = new MerkleTree(leaves);\n   * const result = tree.getProof('0x3');\n   * // result = [\n   * //   '0x4',\n   * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',\n   * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',\n   * // ]\n   * ```\n   */\n  getProof(leaf, branch = this.leaves, hashPath = []) {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error(\"leaf not found\");\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? \"0x0\";\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex = this.leaves.length === branch.length ? -1 : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      _MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n};\nfunction proofMerklePath(root, leaf, path, hashMethod = computePedersenHash) {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n\n// src/utils/typedData.ts\nvar presetTypes = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  )\n};\nvar revisionConfiguration = {\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE]: {\n    domain: \"StarknetDomain\",\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes\n  },\n  [starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY]: {\n    domain: \"StarkNetDomain\",\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {}\n  }\n};\nfunction assertRange(data, type, { min, max }) {\n  const value = BigInt(data);\n  assert(value >= min && value <= max, `${value} (${type}) is out of bounds [${min}, ${max}]`);\n}\nfunction identifyRevision({ types, domain }) {\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE].domain in types && domain.revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE;\n  if (revisionConfiguration[starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY].domain in types && (domain.revision ?? starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY)\n    return starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY;\n  return void 0;\n}\nfunction getHex(value) {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (isString(value)) {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\nfunction validateTypedData(data) {\n  const typedData = data;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\nfunction prepareSelector(selector) {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\nfunction isMerkleTreeType(type) {\n  return type.type === \"merkletree\";\n}\nfunction getDependencies(types, type, dependencies = [], contains = \"\", revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  if (type[type.length - 1] === \"*\") {\n    type = type.slice(0, -1);\n  } else if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n    if (type === \"enum\") {\n      type = contains;\n    } else if (type.match(/^\\(.*\\)$/)) {\n      type = type.slice(1, -1);\n    }\n  }\n  if (dependencies.includes(type) || !types[type]) {\n    return dependencies;\n  }\n  return [\n    type,\n    ...types[type].reduce(\n      (previous, t) => [\n        ...previous,\n        ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n          (dependency) => !previous.includes(dependency)\n        )\n      ],\n      []\n    )\n  ];\n}\nfunction getMerkleTreeType(types, ctx) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key);\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith(\"*\")) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return \"raw\";\n}\nfunction encodeType(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  const allTypes = revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE ? { ...types, ...revisionConfiguration[revision].presetTypes } : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    void 0,\n    void 0,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n  const esc = revisionConfiguration[revision].escapeTypeString;\n  return newTypes.map((dependency) => {\n    const dependencyElements = allTypes[dependency].map((t) => {\n      const targetType = t.type === \"enum\" && revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE ? t.contains : t.type;\n      const typeString = targetType.match(/^\\(.*\\)$/) ? `(${targetType.slice(1, -1).split(\",\").map((e) => e ? esc(e) : e).join(\",\")})` : esc(targetType);\n      return `${esc(t.name)}:${typeString}`;\n    });\n    return `${esc(dependency)}(${dependencyElements})`;\n  }).join(\"\");\n}\nfunction getTypeHash(types, type, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\nfunction encodeValue(types, type, data, ctx = {}, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data, revision)];\n  }\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data,\n        revision\n      )\n    ];\n  }\n  if (type.endsWith(\"*\")) {\n    const hashes = data.map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, void 0, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n  switch (type) {\n    case \"enum\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        const [variantKey, variantData] = Object.entries(data)[0];\n        const parentType = types[ctx.parent][0];\n        const enumType = types[parentType.contains];\n        const variantType = enumType.find((t) => t.name === variantKey);\n        const variantIndex = enumType.indexOf(variantType);\n        const encodedSubtypes = variantType.type.slice(1, -1).split(\",\").map((subtype, index) => {\n          if (!subtype) return subtype;\n          const subtypeData = variantData[index];\n          return encodeValue(types, subtype, subtypeData, void 0, revision)[1];\n        });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes])\n        ];\n      }\n      return [type, getHex(data)];\n    }\n    case \"merkletree\": {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes = data.map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, void 0, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes,\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return [\"felt\", root];\n    }\n    case \"selector\": {\n      return [\"felt\", prepareSelector(data)];\n    }\n    case \"string\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        const byteArray = byteArrayFromString(data);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"i128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        const value = BigInt(data);\n        assertRange(value, type, RANGE_I128);\n        return [type, getHex(value < 0n ? PRIME + value : value)];\n      }\n      return [type, getHex(data)];\n    }\n    case \"timestamp\":\n    case \"u128\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assertRange(data, type, RANGE_U128);\n      }\n      return [type, getHex(data)];\n    }\n    case \"felt\":\n    case \"shortstring\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assertRange(getHex(data), type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"ClassHash\":\n    case \"ContractAddress\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assertRange(data, type, RANGE_FELT);\n      }\n      return [type, getHex(data)];\n    }\n    case \"bool\": {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        assert(typeof data === \"boolean\", `Type mismatch for ${type} ${data}`);\n      }\n      return [type, getHex(data)];\n    }\n    default: {\n      if (revision === starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.ACTIVE) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data)];\n    }\n  }\n}\nfunction encodeData(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce(\n    ([ts, vs], field) => {\n      if (data[field.name] === void 0 || data[field.name] === null && field.type !== \"enum\") {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n      const value = data[field.name];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n      return [\n        [...ts, t],\n        [...vs, encodedValue]\n      ];\n    },\n    [[\"felt\"], [getTypeHash(types, type, revision)]]\n  );\n  return [returnTypes, values];\n}\nfunction getStructHash(types, type, data, revision = starknet_types_07__WEBPACK_IMPORTED_MODULE_2__.TypedDataRevision.LEGACY) {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\nfunction getMessageHash(typedData, account) {\n  if (!validateTypedData(typedData)) {\n    throw new Error(\"Typed data does not match JSON schema\");\n  }\n  const revision = identifyRevision(typedData);\n  const { domain, hashMethod } = revisionConfiguration[revision];\n  const message = [\n    encodeShortString(\"StarkNet Message\"),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision)\n  ];\n  return hashMethod(message);\n}\n\n// src/signer/default.ts\nvar Signer = class {\n  pk;\n  constructor(pk = _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n  async getPubKey() {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.getStarkKey(this.pk);\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signRaw(msgHash) {\n    return _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.sign(msgHash, this.pk);\n  }\n};\n\n// src/signer/ethSigner.ts\n\n\n// src/utils/uint256.ts\nvar uint256_exports = {};\n__export(uint256_exports, {\n  UINT_128_MAX: () => UINT_128_MAX,\n  UINT_256_MAX: () => UINT_256_MAX,\n  bnToUint256: () => bnToUint256,\n  isUint256: () => isUint256,\n  uint256ToBN: () => uint256ToBN\n});\nfunction uint256ToBN(uint2562) {\n  return new CairoUint256(uint2562).toBigInt();\n}\nfunction isUint256(bn) {\n  return CairoUint256.is(bn);\n}\nfunction bnToUint256(bn) {\n  return new CairoUint256(bn).toUint256HexString();\n}\n\n// src/signer/ethSigner.ts\nvar EthSigner = class {\n  pk;\n  // hex string without 0x and with an odd number of characters\n  constructor(pk = ethRandomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk).padStart(64, \"0\") : removeHexPrefix(toHex(pk)).padStart(64, \"0\");\n  }\n  /**\n   * provides the Ethereum full public key (without parity prefix)\n   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  async getPubKey() {\n    return addHexPrefix(\n      buf2hex(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.getPublicKey(this.pk, false)).padStart(130, \"0\").slice(2)\n    );\n  }\n  async signMessage(typedData, accountAddress) {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signTransaction(transactions, details) {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(api_exports.ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_11__.secp256k1.sign(\n      removeHexPrefix(sanitizeHex(msgHash)),\n      this.pk\n    );\n    return this.formatEthSignature(signature);\n  }\n  /**\n   * Serialize the signature in conformity with starknet::eth_signature::Signature\n   * @param ethSignature secp256k1 signature from Noble curves library\n   * @return an array of felts, representing a Cairo Eth Signature.\n   */\n  formatEthSignature(ethSignature) {\n    const r = bnToUint256(ethSignature.r);\n    const s = bnToUint256(ethSignature.s);\n    return [\n      toHex(r.low),\n      toHex(r.high),\n      toHex(s.low),\n      toHex(s.high),\n      toHex(ethSignature.recovery)\n    ];\n  }\n};\n\n// src/signer/ledgerSigner.ts\nvar LedgerSigner = class {\n  transporter;\n  // this is a hack to allow the '@ledgerhq/hw-transport' type to be used as a dev dependency but not exposed in the production build\n  _transporter;\n  accountID;\n  eip2645applicationName;\n  pathBuffer;\n  appVersion;\n  pubKey;\n  fullPubKey;\n  /**\n   * constructor of the LedgerSigner class.\n   * @param {Transport} transport 5 transports are available to handle USB, bluetooth, Node, Web, Mobile.\n   * See Guides for more details.\n   * @param {number} accountID ID of Ledger Nano (can handle 2**31 accounts).\n   * @param {string} [eip2645application='LedgerW'] A wallet is defined by an ERC2645 derivation path (6 items).\n   * One item is the `application`. Default value is `LedgerW`.\n   * @example\n   * ```typescript\n   * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n   * const myNodeTransport = await TransportNodeHid.create();\n   * const myLedgerSigner = new LedgerSigner(myNodeTransport, 0);\n   * ```\n   */\n  constructor(transport, accountID, eip2645application = \"LedgerW\") {\n    assert(accountID >= 0, \"Ledger account ID shall not be a negative number.\");\n    assert(accountID <= MASK_31, \"Ledger account ID shall be < 2**31.\");\n    assert(!!eip2645application, \"Ledger application name shall not be empty.\");\n    this.transporter = transport;\n    this._transporter = this.transporter;\n    this.accountID = accountID;\n    this.pubKey = \"\";\n    this.fullPubKey = \"\";\n    this.eip2645applicationName = eip2645application;\n    this.appVersion = \"\";\n    this.pathBuffer = getLedgerPathBuffer(this.accountID, this.eip2645applicationName);\n  }\n  /**\n   * provides the Starknet public key\n   * @returns an hex string : 64 characters are Point X coordinate.\n   */\n  async getPubKey() {\n    if (!this.pubKey) await this.getPublicKeys();\n    return this.pubKey;\n  }\n  /**\n   * provides the full public key (with parity prefix)\n   * @returns an hex string : 2 first characters are the parity, the 64 following characters are Point X coordinate. 64 last characters are Point Y coordinate.\n   */\n  async getFullPubKey() {\n    if (!this.fullPubKey) await this.getPublicKeys();\n    return this.fullPubKey;\n  }\n  /**\n   * Returns the version of the Starknet APP implemented in the Ledger.\n   * @returns {string} version.\n   * @example\n   * ```typescript\n   * const result = await myLedgerSigner.getAppVersion();\n   * // result= \"1.1.1\"\n   * ```\n   */\n  async getAppVersion() {\n    if (!this.appVersion) {\n      const resp = await this._transporter.send(Number(\"0x5a\"), 0, 0, 0);\n      this.appVersion = `${resp[0]}.${resp[1]}.${resp[2]}`;\n    }\n    return this.appVersion;\n  }\n  async signMessage(typedDataToHash, accountAddress) {\n    const msgHash = getMessageHash(typedDataToHash, accountAddress);\n    return this.signRaw(msgHash);\n  }\n  async signTransaction(transactions, transactionsDetail) {\n    const compiledCalldata = getExecuteCalldata(transactions, transactionsDetail.cairoVersion);\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(transactionsDetail.version)) {\n      const det = transactionsDetail;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(transactionsDetail.version)) {\n      const det = transactionsDetail;\n      msgHash = calculateInvokeTransactionHash2({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeployAccountTransaction(details) {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeployAccountTransactionHash3({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeployAccountTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signDeclareTransaction(details) {\n    let msgHash;\n    if (Object.values(ETransactionVersion2).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version\n      });\n    } else if (Object.values(api_exports.ETransactionVersion3).includes(details.version)) {\n      const det = details;\n      msgHash = calculateDeclareTransactionHash3({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode)\n      });\n    } else {\n      throw Error(\"unsupported signDeclareTransaction version\");\n    }\n    return this.signRaw(msgHash);\n  }\n  async signRaw(msgHash) {\n    addHexPrefix(\n      buf2hex(await this._transporter.send(Number(\"0x5a\"), 2, 0, 0, Buffer.from(this.pathBuffer)))\n    );\n    const shiftedHash = toHex(BigInt(msgHash) << 4n);\n    const buff2 = hexToBytes(shiftedHash);\n    const respSign2 = Uint8Array.from(\n      await this._transporter.send(Number(\"0x5a\"), 2, 1, 0, Buffer.from(buff2))\n    );\n    const r = BigInt(addHexPrefix(buf2hex(respSign2.subarray(1, 33))));\n    const s = BigInt(addHexPrefix(buf2hex(respSign2.subarray(33, 65))));\n    const v = respSign2[65];\n    const sign0 = new _scure_starknet__WEBPACK_IMPORTED_MODULE_6__.Signature(r, s);\n    const sign1 = sign0.addRecoveryBit(v);\n    return sign1;\n  }\n  async getPublicKeys() {\n    const pathBuff = this.pathBuffer;\n    const respGetPublic = Uint8Array.from(\n      await this._transporter.send(Number(\"0x5a\"), 1, 0, 0, Buffer.from(pathBuff))\n    );\n    this.pubKey = addHexPrefix(buf2hex(respGetPublic.subarray(1, 33)));\n    this.fullPubKey = addHexPrefix(buf2hex(respGetPublic.subarray(0, 65)));\n  }\n};\nfunction getLedgerPathBuffer(accountId, applicationName) {\n  const path0buff = new Uint8Array([128, 0, 10, 85]);\n  const path1buff = new Uint8Array([71, 65, 233, 201]);\n  const path2buff = applicationName === \"LedgerW\" ? new Uint8Array([43, 206, 231, 219]) : stringToSha256ToArrayBuff4(applicationName);\n  const path3buff = new Uint8Array([0, 0, 0, 0]);\n  const hex = toHex(accountId);\n  const padded = addHexPrefix(removeHexPrefix(hex).padStart(8, \"0\"));\n  const path4buff = hexToBytes(padded);\n  const path5buff = new Uint8Array([0, 0, 0, 0]);\n  const pathBuff = concatenateArrayBuffer([\n    path0buff,\n    path1buff,\n    path2buff,\n    path3buff,\n    path4buff,\n    path5buff\n  ]);\n  return pathBuff;\n}\n\n// src/utils/events/index.ts\nvar events_exports = {};\n__export(events_exports, {\n  getAbiEvents: () => getAbiEvents,\n  isAbiEvent: () => isAbiEvent,\n  isObject: () => isObject,\n  parseEvents: () => parseEvents,\n  parseUDCEvent: () => parseUDCEvent\n});\nfunction isAbiEvent(object) {\n  return object.type === \"event\";\n}\nfunction getCairo0AbiEvents(abi) {\n  return abi.filter((abiEntry) => abiEntry.type === \"event\").reduce((acc, abiEntry) => {\n    const entryName = abiEntry.name;\n    const abiEntryMod = { ...abiEntry };\n    abiEntryMod.name = entryName;\n    return {\n      ...acc,\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod\n    };\n  }, {});\n}\nfunction getCairo1AbiEvents(abi) {\n  const abiEventsStructs = abi.filter((obj) => isAbiEvent(obj) && obj.kind === \"struct\");\n  const abiEventsEnums = abi.filter((obj) => isAbiEvent(obj) && obj.kind === \"enum\");\n  const abiEventsData = abiEventsStructs.reduce((acc, event) => {\n    let nameList = [];\n    let { name } = event;\n    let flat = false;\n    const findName = (variant) => variant.type === name;\n    while (true) {\n      const eventEnum = abiEventsEnums.find((eventE) => eventE.variants.some(findName));\n      if (typeof eventEnum === \"undefined\") break;\n      const variant = eventEnum.variants.find(findName);\n      nameList.unshift(variant.name);\n      if (variant.kind === \"flat\") flat = true;\n      name = eventEnum.name;\n    }\n    if (nameList.length === 0) {\n      throw new Error(\"inconsistency in ABI events definition.\");\n    }\n    if (flat) nameList = [nameList[nameList.length - 1]];\n    const final = nameList.pop();\n    let result = {\n      [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(final)).toString(16))]: event\n    };\n    while (nameList.length > 0) {\n      result = {\n        [addHexPrefix(_scure_starknet__WEBPACK_IMPORTED_MODULE_6__.keccak(utf8ToArray(nameList.pop())).toString(16))]: result\n      };\n    }\n    result = { ...result };\n    return mergeAbiEvents(acc, result);\n  }, {});\n  return abiEventsData;\n}\nfunction getAbiEvents(abi) {\n  return isCairo1Abi(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);\n}\nfunction isObject(item) {\n  return item && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction mergeAbiEvents(target, source) {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) Object.assign(output, { [key]: source[key] });\n        else output[key] = mergeAbiEvents(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\nfunction parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {\n  const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {\n    let abiEvent = abiEvents[recEvent.keys.shift() ?? 0];\n    if (!abiEvent) {\n      return acc;\n    }\n    while (!abiEvent.name) {\n      const hashName = recEvent.keys.shift();\n      assert(!!hashName, 'Not enough data in \"key\" property of this event.');\n      abiEvent = abiEvent[hashName];\n    }\n    const parsedEvent = {};\n    parsedEvent[abiEvent.name] = {};\n    const keysIter = recEvent.keys[Symbol.iterator]();\n    const dataIter = recEvent.data[Symbol.iterator]();\n    const abiEventKeys = abiEvent.members?.filter((it) => it.kind === \"key\") || abiEvent.keys;\n    const abiEventData = abiEvent.members?.filter((it) => it.kind === \"data\") || abiEvent.data;\n    abiEventKeys.forEach((key) => {\n      parsedEvent[abiEvent.name][key.name] = responseParser(\n        keysIter,\n        key,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    abiEventData.forEach((data) => {\n      parsedEvent[abiEvent.name][data.name] = responseParser(\n        dataIter,\n        data,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    acc.push(parsedEvent);\n    return acc;\n  }, []);\n  return ret;\n}\nfunction parseUDCEvent(txReceipt) {\n  if (!txReceipt.events) {\n    throw new Error(\"UDC emitted event is empty\");\n  }\n  const event = txReceipt.events.find(\n    (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: []\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1]\n  };\n}\n\n// src/account/default.ts\nvar Account = class extends RpcProvider2 {\n  signer;\n  address;\n  cairoVersion;\n  transactionVersion;\n  constructor(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion = api_exports.ETransactionVersion.V2) {\n    super(providerOrOptions);\n    this.address = address.toLowerCase();\n    this.signer = isString(pkOrSigner) || pkOrSigner instanceof Uint8Array ? new Signer(pkOrSigner) : pkOrSigner;\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString();\n    }\n    this.transactionVersion = transactionVersion;\n  }\n  // provided version or contract based preferred transactionVersion\n  getPreferredVersion(type12, type3) {\n    if (this.transactionVersion === api_exports.ETransactionVersion.V3) return type3;\n    if (this.transactionVersion === api_exports.ETransactionVersion.V2) return type12;\n    return api_exports.ETransactionVersion.V3;\n  }\n  async getNonce(blockIdentifier) {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n  async getNonceSafe(nonce) {\n    try {\n      return toBigInt(nonce ?? await this.getNonce());\n    } catch (error) {\n      return 0n;\n    }\n  }\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  async getCairoVersion(classHash) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash ? await super.getContractVersion(void 0, classHash) : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n  async estimateFee(calls, estimateFeeDetails = {}) {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n  async estimateInvokeFee(calls, details = {}) {\n    const {\n      nonce: providedNonce,\n      blockIdentifier,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n      skipValidate\n    };\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    return super.getInvokeEstimateFee(\n      { ...invocation },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeclareFee(payload, details = {}) {\n    const {\n      blockIdentifier,\n      nonce: providedNonce,\n      version: providedVersion,\n      skipValidate = true\n    } = details;\n    const nonce = toBigInt(providedNonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.F1 : this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n    const declareContractTransaction = await this.buildDeclarePayload(payload, {\n      ...v3Details(details),\n      nonce,\n      chainId,\n      version,\n      walletAddress: this.address,\n      maxFee: ZERO,\n      cairoVersion: void 0,\n      // unused parameter\n      skipValidate\n    });\n    return super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateAccountDeployFee({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress\n  }, details = {}) {\n    const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.F1, api_exports.ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress },\n      {\n        ...v3Details(details),\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address,\n        // unused parameter\n        maxFee: ZERO,\n        cairoVersion: void 0,\n        // unused parameter,\n        skipValidate\n      }\n    );\n    return super.getDeployAccountEstimateFee(\n      { ...payload },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n  async estimateDeployFee(payload, details = {}) {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, details);\n  }\n  async estimateFeeBulk(invocations, details = {}) {\n    const { nonce, blockIdentifier, version, skipValidate } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.F1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.F2, api_exports.ETransactionVersion.F3),\n          version\n        )\n        // sierra\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate\n    });\n  }\n  async simulateTransaction(invocations, details = {}) {\n    const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        api_exports.ETransactionVersion.V1,\n        // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n          version\n        )\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate\n    });\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute\n    });\n  }\n  async execute(transactions, arg2, transactionsDetail = {}) {\n    const details = arg2 === void 0 || Array.isArray(arg2) ? transactionsDetail : arg2;\n    const calls = Array.isArray(transactions) ? transactions : [transactions];\n    const nonce = toBigInt(details.nonce ?? await this.getNonce());\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      // TODO: does this depend on cairo version ?\n      details.version\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      { type: \"INVOKE_FUNCTION\" /* INVOKE */, payload: transactions },\n      {\n        ...details,\n        version\n      }\n    );\n    const chainId = await this.getChainId();\n    const signerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      walletAddress: this.address,\n      nonce,\n      maxFee: estimate.maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion()\n    };\n    const signature = await this.signer.signTransaction(calls, signerDetails);\n    const calldata = getExecuteCalldata(calls, await this.getCairoVersion());\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        ...v3Details(details),\n        resourceBounds: estimate.resourceBounds,\n        nonce,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  async declareIfNot(payload, transactionsDetail = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: \"\",\n      class_hash: declareContractPayload.classHash\n    };\n  }\n  async declare(payload, details = {}) {\n    const declareContractPayload = extractContractHashes(payload);\n    const { nonce, version: providedVersion } = details;\n    const version = toTransactionVersion(\n      !isSierra(payload.contract) ? api_exports.ETransactionVersion.V1 : this.getPreferredVersion(api_exports.ETransactionVersion.V2, api_exports.ETransactionVersion.V3),\n      providedVersion\n    );\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: \"DECLARE\" /* DECLARE */,\n        payload: declareContractPayload\n      },\n      {\n        ...details,\n        version\n      }\n    );\n    const declareDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      nonce: toBigInt(nonce ?? await this.getNonce()),\n      version,\n      chainId: await this.getChainId(),\n      walletAddress: this.address,\n      cairoVersion: void 0\n    };\n    const declareContractTransaction = await this.buildDeclarePayload(\n      declareContractPayload,\n      declareDetails\n    );\n    return this.declareContract(declareContractTransaction, declareDetails);\n  }\n  async deploy(payload, details = {}) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls, void 0, details);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  async deployContract(payload, details = {}) {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt);\n  }\n  async declareAndDeploy(payload, details = {}) {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== \"\") {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n  deploySelf = this.deployAccount;\n  async deployAccount({\n    classHash,\n    constructorCalldata = [],\n    addressSalt = 0,\n    contractAddress: providedContractAddress\n  }, details = {}) {\n    const version = toTransactionVersion(\n      this.getPreferredVersion(api_exports.ETransactionVersion.V1, api_exports.ETransactionVersion.V3),\n      details.version\n    );\n    const nonce = ZERO;\n    const chainId = await this.getChainId();\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress\n        }\n      },\n      details\n    );\n    const signature = await this.signer.signDeployAccountTransaction({\n      ...v3Details(details),\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      version,\n      nonce\n    });\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        ...v3Details(details),\n        nonce,\n        resourceBounds: estimate.resourceBounds,\n        maxFee: estimate.maxFee,\n        version\n      }\n    );\n  }\n  async signMessage(typedData) {\n    return this.signer.signMessage(typedData, this.address);\n  }\n  async hashMessage(typedData) {\n    return getMessageHash(typedData, this.address);\n  }\n  async verifyMessageHash(hash, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n    const knownSigVerificationFName = signatureVerificationFunctionName ? [signatureVerificationFunctionName] : [\"isValidSignature\", \"is_valid_signature\"];\n    const knownSignatureResponse = signatureVerificationResponse || {\n      okResponse: [\n        // any non-nok response is true\n      ],\n      nokResponse: [\n        \"0x0\",\n        // Devnet\n        \"0x00\"\n        // OpenZeppelin 0.7.0 to 0.9.0 invalid signature\n      ],\n      error: [\n        \"argent/invalid-signature\",\n        // ArgentX 0.3.0 to 0.3.1\n        \"is invalid, with respect to the public key\",\n        // OpenZeppelin until 0.6.1, Braavos 0.0.11\n        \"INVALID_SIG\"\n        // Braavos 1.0.0\n      ]\n    };\n    let error;\n    for (const SigVerificationFName of knownSigVerificationFName) {\n      try {\n        const resp = await this.callContract({\n          contractAddress: this.address,\n          entrypoint: SigVerificationFName,\n          calldata: CallData.compile({\n            hash: toBigInt(hash).toString(),\n            signature: formatSignature(signature)\n          })\n        });\n        if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {\n          return false;\n        }\n        if (knownSignatureResponse.okResponse.length === 0 || knownSignatureResponse.okResponse.includes(resp[0].toString())) {\n          return true;\n        }\n        throw Error(\"signatureVerificationResponse Error: response is not part of known responses\");\n      } catch (err) {\n        if (knownSignatureResponse.error.some(\n          (errMessage) => err.message.includes(errMessage)\n        )) {\n          return false;\n        }\n        error = err;\n      }\n    }\n    throw Error(`Signature verification Error: ${error}`);\n  }\n  async verifyMessage(typedData, signature, signatureVerificationFunctionName, signatureVerificationResponse) {\n    const hash = await this.hashMessage(typedData);\n    return this.verifyMessageHash(\n      hash,\n      signature,\n      signatureVerificationFunctionName,\n      signatureVerificationResponse\n    );\n  }\n  /*\n   * Support methods\n   */\n  async getUniversalSuggestedFee(version, { type, payload }, details) {\n    let maxFee = 0;\n    let resourceBounds = estimateFeeToBounds(ZERO);\n    if (version === api_exports.ETransactionVersion.V3) {\n      resourceBounds = details.resourceBounds ?? (await this.getSuggestedFee({ type, payload }, details)).resourceBounds;\n    } else {\n      maxFee = details.maxFee ?? (await this.getSuggestedFee({ type, payload }, details)).suggestedMaxFee;\n    }\n    return {\n      maxFee,\n      resourceBounds\n    };\n  }\n  async getSuggestedFee({ type, payload }, details) {\n    let feeEstimate;\n    switch (type) {\n      case \"INVOKE_FUNCTION\" /* INVOKE */:\n        feeEstimate = await this.estimateInvokeFee(payload, details);\n        break;\n      case \"DECLARE\" /* DECLARE */:\n        feeEstimate = await this.estimateDeclareFee(payload, details);\n        break;\n      case \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */:\n        feeEstimate = await this.estimateAccountDeployFee(payload, details);\n        break;\n      case \"DEPLOY\" /* DEPLOY */:\n        feeEstimate = await this.estimateDeployFee(payload, details);\n        break;\n      default:\n        feeEstimate = {\n          gas_consumed: 0n,\n          gas_price: 0n,\n          overall_fee: ZERO,\n          unit: \"FRI\",\n          suggestedMaxFee: ZERO,\n          resourceBounds: estimateFeeToBounds(ZERO),\n          data_gas_consumed: 0n,\n          data_gas_price: 0n\n        };\n        break;\n    }\n    return feeEstimate;\n  }\n  async buildInvocation(call, details) {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature\n    };\n  }\n  async buildDeclarePayload(payload, details) {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n    if (typeof compiledClassHash === \"undefined\" && (details.version === api_exports.ETransactionVersion3.F3 || details.version === api_exports.ETransactionVersion3.V3)) {\n      throw Error(\"V3 Transaction work with Cairo1 Contracts and require compiledClassHash\");\n    }\n    const signature = !details.skipValidate ? await this.signer.signDeclareTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      compiledClassHash,\n      // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n      senderAddress: details.walletAddress\n    }) : [];\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash\n    };\n  }\n  async buildAccountDeployPayload({\n    classHash,\n    addressSalt = 0,\n    constructorCalldata = [],\n    contractAddress: providedContractAddress\n  }, details) {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress = providedContractAddress ?? calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n    const signature = !details.skipValidate ? await this.signer.signDeployAccountTransaction({\n      ...details,\n      ...v3Details(details),\n      classHash,\n      contractAddress,\n      addressSalt,\n      constructorCalldata: compiledCalldata\n    }) : [];\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature\n    };\n  }\n  buildUDCContractPayload(payload) {\n    const calls = [].concat(payload).map((it) => {\n      const {\n        classHash,\n        salt = \"0\",\n        unique = true,\n        constructorCalldata = []\n      } = it;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData\n        ]\n      };\n    });\n    return calls;\n  }\n  async accountInvocationsFactory(invocations, details) {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n    const tx0Payload = \"payload\" in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion = invocations[0].type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */ ? await this.getCairoVersion(tx0Payload.classHash) : await this.getCairoVersion();\n    return Promise.all(\n      [].concat(invocations).map(async (transaction, index) => {\n        const txPayload = \"payload\" in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          chainId,\n          cairoVersion,\n          version: \"\",\n          skipValidate\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: \"\"\n        };\n        if (transaction.type === \"INVOKE_FUNCTION\" /* INVOKE */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildInvocation(\n            [].concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DEPLOY\" /* DEPLOY */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            type: \"INVOKE_FUNCTION\" /* INVOKE */\n          };\n        }\n        if (transaction.type === \"DECLARE\" /* DECLARE */) {\n          const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        if (transaction.type === \"DEPLOY_ACCOUNT\" /* DEPLOY_ACCOUNT */) {\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    );\n  }\n  async getStarkName(address = this.address, StarknetIdContract2) {\n    return super.getStarkName(address, StarknetIdContract2);\n  }\n};\n\n// src/account/interface.ts\nvar AccountInterface = class extends ProviderInterface {\n};\n\n// src/wallet/connect.ts\nvar connect_exports = {};\n__export(connect_exports, {\n  addDeclareTransaction: () => addDeclareTransaction,\n  addInvokeTransaction: () => addInvokeTransaction,\n  addStarknetChain: () => addStarknetChain,\n  deploymentData: () => deploymentData,\n  getPermissions: () => getPermissions,\n  onAccountChange: () => onAccountChange,\n  onNetworkChanged: () => onNetworkChanged,\n  requestAccounts: () => requestAccounts,\n  requestChainId: () => requestChainId,\n  signMessage: () => signMessage,\n  supportedSpecs: () => supportedSpecs,\n  switchStarknetChain: () => switchStarknetChain,\n  watchAsset: () => watchAsset\n});\nfunction requestAccounts(swo, silent_mode = false) {\n  return swo.request({\n    type: \"wallet_requestAccounts\",\n    params: {\n      silent_mode\n    }\n  });\n}\nfunction getPermissions(swo) {\n  return swo.request({ type: \"wallet_getPermissions\" });\n}\nfunction watchAsset(swo, asset) {\n  return swo.request({\n    type: \"wallet_watchAsset\",\n    params: asset\n  });\n}\nfunction addStarknetChain(swo, chain) {\n  return swo.request({\n    type: \"wallet_addStarknetChain\",\n    params: chain\n  });\n}\nfunction switchStarknetChain(swo, chainId) {\n  return swo.request({\n    type: \"wallet_switchStarknetChain\",\n    params: {\n      chainId\n    }\n  });\n}\nfunction requestChainId(swo) {\n  return swo.request({ type: \"wallet_requestChainId\" });\n}\nfunction deploymentData(swo) {\n  return swo.request({ type: \"wallet_deploymentData\" });\n}\nfunction addInvokeTransaction(swo, params) {\n  return swo.request({\n    type: \"wallet_addInvokeTransaction\",\n    params\n  });\n}\nfunction addDeclareTransaction(swo, params) {\n  return swo.request({\n    type: \"wallet_addDeclareTransaction\",\n    params\n  });\n}\nfunction signMessage(swo, typedData) {\n  return swo.request({\n    type: \"wallet_signTypedData\",\n    params: typedData\n  });\n}\nfunction supportedSpecs(swo) {\n  return swo.request({ type: \"wallet_supportedSpecs\" });\n}\nfunction onAccountChange(swo, callback) {\n  swo.on(\"accountsChanged\", callback);\n}\nfunction onNetworkChanged(swo, callback) {\n  swo.on(\"networkChanged\", callback);\n}\n\n// src/wallet/account.ts\nvar WalletAccount = class extends Account {\n  address = \"\";\n  walletProvider;\n  constructor(providerOrOptions, walletProvider, cairoVersion) {\n    super(providerOrOptions, \"\", \"\", cairoVersion);\n    this.walletProvider = walletProvider;\n    this.walletProvider.on(\"accountsChanged\", (res) => {\n      if (!res) return;\n      this.address = res[0].toLowerCase();\n    });\n    this.walletProvider.on(\"networkChanged\", (res) => {\n      if (!res) return;\n      this.channel.setChainId(res);\n    });\n    walletProvider.request({\n      type: \"wallet_requestAccounts\",\n      params: {\n        silent_mode: false\n      }\n    }).then((res) => {\n      this.address = res[0].toLowerCase();\n    });\n  }\n  /**\n   * WALLET EVENTS\n   */\n  onAccountChange(callback) {\n    onAccountChange(this.walletProvider, callback);\n  }\n  onNetworkChanged(callback) {\n    onNetworkChanged(this.walletProvider, callback);\n  }\n  /**\n   * WALLET SPECIFIC METHODS\n   */\n  requestAccounts(silentMode = false) {\n    return requestAccounts(this.walletProvider, silentMode);\n  }\n  getPermissions() {\n    return getPermissions(this.walletProvider);\n  }\n  switchStarknetChain(chainId) {\n    return switchStarknetChain(this.walletProvider, chainId);\n  }\n  watchAsset(asset) {\n    return watchAsset(this.walletProvider, asset);\n  }\n  addStarknetChain(chain) {\n    return addStarknetChain(this.walletProvider, chain);\n  }\n  /**\n   * ACCOUNT METHODS\n   */\n  execute(calls) {\n    const txCalls = [].concat(calls).map((it) => {\n      const { contractAddress, entrypoint, calldata } = it;\n      return {\n        contract_address: contractAddress,\n        entry_point: entrypoint,\n        calldata\n      };\n    });\n    const params = {\n      calls: txCalls\n    };\n    return addInvokeTransaction(this.walletProvider, params);\n  }\n  declare(payload) {\n    const declareContractPayload = extractContractHashes(payload);\n    const pContract = payload.contract;\n    const cairo1Contract = {\n      ...pContract,\n      abi: stringify2(pContract.abi)\n    };\n    if (!declareContractPayload.compiledClassHash) {\n      throw Error(\"compiledClassHash is required\");\n    }\n    const params = {\n      compiled_class_hash: declareContractPayload.compiledClassHash,\n      contract_class: cairo1Contract\n    };\n    return addDeclareTransaction(this.walletProvider, params);\n  }\n  async deploy(payload) {\n    const { calls, addresses } = buildUDCCall(payload, this.address);\n    const invokeResponse = await this.execute(calls);\n    return {\n      ...invokeResponse,\n      contract_address: addresses\n    };\n  }\n  signMessage(typedData) {\n    return signMessage(this.walletProvider, typedData);\n  }\n  // TODO: MISSING ESTIMATES\n};\n\n// src/contract/default.ts\nvar splitArgsAndOptions = (args) => {\n  const options = [\n    \"blockIdentifier\",\n    \"parseRequest\",\n    \"parseResponse\",\n    \"formatResponse\",\n    \"maxFee\",\n    \"nonce\",\n    \"signature\",\n    \"addressSalt\"\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === \"object\" && options.some((x) => x in lastArg)) {\n    return { args, options: args.pop() };\n  }\n  return { args };\n};\nfunction buildCall(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options\n    });\n  };\n}\nfunction buildInvoke(contract, functionAbi) {\n  return async function(...args) {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options\n    });\n  };\n}\nfunction buildDefault(contract, functionAbi) {\n  if (functionAbi.stateMutability === \"view\" || functionAbi.state_mutability === \"view\") {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\nfunction buildPopulate(contract, functionAbi) {\n  return function(...args) {\n    return contract.populate(functionAbi.name, args);\n  };\n}\nfunction buildEstimate(contract, functionAbi) {\n  return function(...args) {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\nfunction getCalldata(args, callback) {\n  if (Array.isArray(args) && \"__compiled__\" in args) return args;\n  if (Array.isArray(args) && Array.isArray(args[0]) && \"__compiled__\" in args[0])\n    return args[0];\n  return callback();\n}\nvar Contract = class {\n  abi;\n  address;\n  providerOrAccount;\n  deployTransactionHash;\n  structs;\n  events;\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n  callData;\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(abi, address, providerOrAccount = defaultProvider) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false }\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== \"function\") return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement)\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement)\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement)\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement)\n        });\n      }\n    });\n  }\n  attach(address) {\n    this.address = address;\n  }\n  connect(providerOrAccount) {\n    this.providerOrAccount = providerOrAccount;\n  }\n  async deployed() {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = void 0;\n    }\n    return this;\n  }\n  async call(method, args = [], {\n    parseRequest = true,\n    parseResponse = true,\n    formatResponse = void 0,\n    blockIdentifier = void 0\n  } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"CALL\" /* CALL */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    return this.providerOrAccount.callContract(\n      {\n        contractAddress: this.address,\n        calldata,\n        entrypoint: method\n      },\n      blockIdentifier\n    ).then((it) => {\n      if (!parseResponse) {\n        return it;\n      }\n      if (formatResponse) {\n        return this.callData.format(method, it, formatResponse);\n      }\n      return this.callData.parse(method, it);\n    });\n  }\n  invoke(method, args = [], { parseRequest = true, maxFee, nonce, signature } = {}) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n        return this.callData.compile(method, args);\n      }\n      console.warn(\"Invoke skipped parsing but provided rawArgs, possible malfunction request\");\n      return args;\n    });\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method\n    };\n    if (\"execute\" in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, void 0, {\n        maxFee,\n        nonce\n      });\n    }\n    if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n    console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature\n      },\n      {\n        nonce\n      }\n    );\n  }\n  async estimate(method, args = []) {\n    assert(this.address !== null, \"contract is not connected to an address\");\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(\"INVOKE\" /* INVOKE */, method, args);\n    }\n    const invocation = this.populate(method, args);\n    if (\"estimateInvokeFee\" in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error(\"Contract must be connected to the account contract to estimate\");\n  }\n  populate(method, args = []) {\n    const calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata\n    };\n  }\n  parseEvents(receipt) {\n    return parseEvents(\n      receipt.events?.filter(\n        (event) => cleanHex(event.from_address) === cleanHex(this.address),\n        []\n      ) || [],\n      this.events,\n      this.structs,\n      CallData.getAbiEnum(this.abi)\n    );\n  }\n  isCairo1() {\n    return cairo_exports.isCairo1Abi(this.abi);\n  }\n  async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n  typedv2(tAbi) {\n    return this;\n  }\n};\n\n// src/contract/interface.ts\nvar ContractInterface = class {\n  functions;\n  callStatic;\n  populateTransaction;\n  estimateFee;\n};\n\n// src/contract/contractFactory.ts\nvar ContractFactory = class {\n  compiledContract;\n  account;\n  abi;\n  classHash;\n  casm;\n  compiledClassHash;\n  CallData;\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  async deploy(...args) {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(\"DEPLOY\" /* DEPLOY */, \"constructor\", param);\n        return this.CallData.compile(\"constructor\", param);\n      }\n      console.warn(\"Call skipped parsing but provided rawArgs, possible malfunction request\");\n      return param;\n    });\n    const {\n      deploy: { contract_address, transaction_hash }\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt\n    });\n    assert(Boolean(contract_address), \"Deployment of the contract failed\");\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n    return contractInstance;\n  }\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account) {\n    this.account = account;\n    return this;\n  }\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address) {\n    return new Contract(this.abi, address, this.account);\n  }\n  // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n};\n\n// src/utils/responseParser/interface.ts\nvar ResponseParser = class {\n};\n\n// src/utils/address.ts\n\nfunction addAddressPadding(address) {\n  const hex = toHex(addHexPrefix(address.toString()));\n  const padded = removeHexPrefix(hex).padStart(64, \"0\");\n  return addHexPrefix(padded);\n}\nfunction validateAndParseAddress(address) {\n  const result = addAddressPadding(address);\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error(\"Invalid Address Format\");\n  }\n  assertInRange(result, ZERO, ADDR_BOUND - 1n, \"Starknet Address\");\n  return result;\n}\nfunction getChecksumAddress(address) {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split(\"\");\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.hexToBytes)(hex.padStart(64, \"0\"));\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 15) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return addHexPrefix(chars.join(\"\"));\n}\nfunction validateChecksumAddress(address) {\n  return getChecksumAddress(address) === address;\n}\n\n// src/utils/url.ts\n\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nfunction isUrl(s) {\n  if (!s) {\n    return false;\n  }\n  if (typeof s !== \"string\") {\n    return false;\n  }\n  const match = s.match(protocolAndDomainRE);\n  if (!match) {\n    return false;\n  }\n  const everythingAfterProtocol = match[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n  if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {\n    return true;\n  }\n  return false;\n}\nfunction buildUrl(baseUrl, defaultPath, urlOrPath) {\n  return isUrl(urlOrPath) ? urlOrPath : url_join__WEBPACK_IMPORTED_MODULE_16__(baseUrl, urlOrPath ?? defaultPath);\n}\n\n// src/index.ts\nvar number = num_exports;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBUztBQUM1QixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQ0FBbUM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQjtBQUNsQjtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSSxHQUFHLFVBQVUsMkJBQTJCLElBQUksR0FBRyxXQUFXLHlCQUF5QixpQkFBaUI7QUFDbEo7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtREFBbUQsSUFBSSxHQUFHLFdBQVcsV0FBVyxJQUFJLEdBQUcsVUFBVTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVMsa0NBQWtDLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkIsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLGtDQUFrQyxNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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TztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87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UTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBMEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZCQUE2QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlDQUFpQztBQUN0RSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixvQ0FBb0M7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGVBQWU7QUFDdkIsUUFBUSx1Q0FBdUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSx1Q0FBdUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxjQUFjO0FBQ2pCLFlBQVksaUVBQWlFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBOEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWTtBQUNw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RSxlQUFlO0FBQzlGLE1BQU07QUFDTiwrREFBK0QsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Oi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdGFya25ldC9kaXN0L2luZGV4Lm1qcz83OGE1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIGNvbnN0YW50c19leHBvcnRzID0ge307XG5fX2V4cG9ydChjb25zdGFudHNfZXhwb3J0cywge1xuICBBRERSX0JPVU5EOiAoKSA9PiBBRERSX0JPVU5ELFxuICBBUElfVkVSU0lPTjogKCkgPT4gQVBJX1ZFUlNJT04sXG4gIEJhc2VVcmw6ICgpID0+IEJhc2VVcmwsXG4gIEZlZU1hcmdpblBlcmNlbnRhZ2U6ICgpID0+IEZlZU1hcmdpblBlcmNlbnRhZ2UsXG4gIElTX0JST1dTRVI6ICgpID0+IElTX0JST1dTRVIsXG4gIE1BU0tfMjUwOiAoKSA9PiBNQVNLXzI1MCxcbiAgTUFTS18zMTogKCkgPT4gTUFTS18zMSxcbiAgTUFYX1NUT1JBR0VfSVRFTV9TSVpFOiAoKSA9PiBNQVhfU1RPUkFHRV9JVEVNX1NJWkUsXG4gIE5ldHdvcmtOYW1lOiAoKSA9PiBOZXR3b3JrTmFtZSxcbiAgUFJJTUU6ICgpID0+IFBSSU1FLFxuICBSQU5HRV9GRUxUOiAoKSA9PiBSQU5HRV9GRUxULFxuICBSQU5HRV9JMTI4OiAoKSA9PiBSQU5HRV9JMTI4LFxuICBSQU5HRV9VMTI4OiAoKSA9PiBSQU5HRV9VMTI4LFxuICBSUENfREVGQVVMVF9WRVJTSU9OOiAoKSA9PiBSUENfREVGQVVMVF9WRVJTSU9OLFxuICBSUENfTk9ERVM6ICgpID0+IFJQQ19OT0RFUyxcbiAgU3RhcmtuZXRDaGFpbklkOiAoKSA9PiBTdGFya25ldENoYWluSWQsXG4gIFRFWFRfVE9fRkVMVF9NQVhfTEVOOiAoKSA9PiBURVhUX1RPX0ZFTFRfTUFYX0xFTixcbiAgVFJBTlNBQ1RJT05fVkVSU0lPTjogKCkgPT4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbixcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4OiAoKSA9PiBUcmFuc2FjdGlvbkhhc2hQcmVmaXgsXG4gIFVEQzogKCkgPT4gVURDLFxuICBaRVJPOiAoKSA9PiBaRVJPXG59KTtcblxuLy8gc3JjL3R5cGVzL2FwaS9pbmRleC50c1xudmFyIGFwaV9leHBvcnRzID0ge307XG5fX2V4cG9ydChhcGlfZXhwb3J0cywge1xuICBKUlBDOiAoKSA9PiBqc29ucnBjX2V4cG9ydHMsXG4gIFJQQ1NQRUMwNjogKCkgPT4gcnBjc3BlY18wXzZfZXhwb3J0cyxcbiAgUlBDU1BFQzA3OiAoKSA9PiBSUENTUEVDMDdcbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL2pzb25ycGMvaW5kZXgudHNcbnZhciBqc29ucnBjX2V4cG9ydHMgPSB7fTtcblxuLy8gc3JjL3R5cGVzL2FwaS9ycGNzcGVjXzBfNi9pbmRleC50c1xudmFyIHJwY3NwZWNfMF82X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJwY3NwZWNfMF82X2V4cG9ydHMsIHtcbiAgRUJsb2NrVGFnOiAoKSA9PiBFQmxvY2tUYWcsXG4gIEVEQU1vZGU6ICgpID0+IEVEQU1vZGUsXG4gIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTogKCkgPT4gRURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICBFU2ltdWxhdGlvbkZsYWc6ICgpID0+IEVTaW11bGF0aW9uRmxhZyxcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyxcbiAgRVRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBFVHJhbnNhY3Rpb25TdGF0dXMsXG4gIEVUcmFuc2FjdGlvblR5cGU6ICgpID0+IEVUcmFuc2FjdGlvblR5cGUsXG4gIEVUcmFuc2FjdGlvblZlcnNpb246ICgpID0+IEVUcmFuc2FjdGlvblZlcnNpb24sXG4gIEVUcmFuc2FjdGlvblZlcnNpb24yOiAoKSA9PiBFVHJhbnNhY3Rpb25WZXJzaW9uMixcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjM6ICgpID0+IEVUcmFuc2FjdGlvblZlcnNpb24zLFxuICBFcnJvcnM6ICgpID0+IGVycm9yc19leHBvcnRzLFxuICBTUEVDOiAoKSA9PiBjb21wb25lbnRzX2V4cG9ydHNcbn0pO1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWNfMF82L2Vycm9ycy50c1xudmFyIGVycm9yc19leHBvcnRzID0ge307XG5cbi8vIHNyYy90eXBlcy9hcGkvcnBjc3BlY18wXzYvY29tcG9uZW50cy50c1xudmFyIGNvbXBvbmVudHNfZXhwb3J0cyA9IHt9O1xuXG4vLyBzcmMvdHlwZXMvYXBpL3JwY3NwZWNfMF82L25vbnNwZWMudHNcbnZhciBFVHJhbnNhY3Rpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uVHlwZTIpID0+IHtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERUNMQVJFXCJdID0gXCJERUNMQVJFXCI7XG4gIEVUcmFuc2FjdGlvblR5cGUyW1wiREVQTE9ZXCJdID0gXCJERVBMT1lcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiREVQTE9ZX0FDQ09VTlRcIjtcbiAgRVRyYW5zYWN0aW9uVHlwZTJbXCJJTlZPS0VcIl0gPSBcIklOVk9LRVwiO1xuICBFVHJhbnNhY3Rpb25UeXBlMltcIkwxX0hBTkRMRVJcIl0gPSBcIkwxX0hBTkRMRVJcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvblR5cGUyO1xufSkoRVRyYW5zYWN0aW9uVHlwZSB8fCB7fSk7XG52YXIgRVNpbXVsYXRpb25GbGFnID0gLyogQF9fUFVSRV9fICovICgoRVNpbXVsYXRpb25GbGFnMikgPT4ge1xuICBFU2ltdWxhdGlvbkZsYWcyW1wiU0tJUF9WQUxJREFURVwiXSA9IFwiU0tJUF9WQUxJREFURVwiO1xuICBFU2ltdWxhdGlvbkZsYWcyW1wiU0tJUF9GRUVfQ0hBUkdFXCJdID0gXCJTS0lQX0ZFRV9DSEFSR0VcIjtcbiAgcmV0dXJuIEVTaW11bGF0aW9uRmxhZzI7XG59KShFU2ltdWxhdGlvbkZsYWcgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvblN0YXR1czIpID0+IHtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIlJFQ0VJVkVEXCJdID0gXCJSRUNFSVZFRFwiO1xuICBFVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIEVUcmFuc2FjdGlvblN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgRVRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uU3RhdHVzMjtcbn0pKEVUcmFuc2FjdGlvblN0YXR1cyB8fCB7fSk7XG52YXIgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChFVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czIpID0+IHtcbiAgRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIEVUcmFuc2FjdGlvbkZpbmFsaXR5U3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyO1xufSkoRVRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIpID0+IHtcbiAgRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlNVQ0NFRURFRFwiXSA9IFwiU1VDQ0VFREVEXCI7XG4gIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJSRVZFUlRFRFwiXSA9IFwiUkVWRVJURURcIjtcbiAgcmV0dXJuIEVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czI7XG59KShFVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgfHwge30pO1xudmFyIEVCbG9ja1RhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEVCbG9ja1RhZzIpID0+IHtcbiAgRUJsb2NrVGFnMltcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgRUJsb2NrVGFnMltcIkxBVEVTVFwiXSA9IFwibGF0ZXN0XCI7XG4gIHJldHVybiBFQmxvY2tUYWcyO1xufSkoRUJsb2NrVGFnIHx8IHt9KTtcbnZhciBFRGF0YUF2YWlsYWJpbGl0eU1vZGUgPSAvKiBAX19QVVJFX18gKi8gKChFRGF0YUF2YWlsYWJpbGl0eU1vZGUzKSA9PiB7XG4gIEVEYXRhQXZhaWxhYmlsaXR5TW9kZTNbXCJMMVwiXSA9IFwiTDFcIjtcbiAgRURhdGFBdmFpbGFiaWxpdHlNb2RlM1tcIkwyXCJdID0gXCJMMlwiO1xuICByZXR1cm4gRURhdGFBdmFpbGFiaWxpdHlNb2RlMztcbn0pKEVEYXRhQXZhaWxhYmlsaXR5TW9kZSB8fCB7fSk7XG52YXIgRURBTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVEQU1vZGU0KSA9PiB7XG4gIEVEQU1vZGU0W0VEQU1vZGU0W1wiTDFcIl0gPSAwXSA9IFwiTDFcIjtcbiAgRURBTW9kZTRbRURBTW9kZTRbXCJMMlwiXSA9IDFdID0gXCJMMlwiO1xuICByZXR1cm4gRURBTW9kZTQ7XG59KShFREFNb2RlIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25WZXJzaW9uID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uVmVyc2lvbjEwKSA9PiB7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIlYwXCJdID0gXCIweDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiVjFcIl0gPSBcIjB4MVwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJWMlwiXSA9IFwiMHgyXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIlYzXCJdID0gXCIweDNcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiRjBcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24xMFtcIkYxXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMTBbXCJGMlwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjEwW1wiRjNcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25WZXJzaW9uMTA7XG59KShFVHJhbnNhY3Rpb25WZXJzaW9uIHx8IHt9KTtcbnZhciBFVHJhbnNhY3Rpb25WZXJzaW9uMiA9IC8qIEBfX1BVUkVfXyAqLyAoKEVUcmFuc2FjdGlvblZlcnNpb24yNSkgPT4ge1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJWMFwiXSA9IFwiMHgwXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIlYxXCJdID0gXCIweDFcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiVjJcIl0gPSBcIjB4MlwiO1xuICBFVHJhbnNhY3Rpb25WZXJzaW9uMjVbXCJGMFwiXSA9IFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjI1W1wiRjFcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCI7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24yNVtcIkYyXCJdID0gXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMlwiO1xuICByZXR1cm4gRVRyYW5zYWN0aW9uVmVyc2lvbjI1O1xufSkoRVRyYW5zYWN0aW9uVmVyc2lvbjIgfHwge30pO1xudmFyIEVUcmFuc2FjdGlvblZlcnNpb24zID0gLyogQF9fUFVSRV9fICovICgoRVRyYW5zYWN0aW9uVmVyc2lvbjM3KSA9PiB7XG4gIEVUcmFuc2FjdGlvblZlcnNpb24zN1tcIlYzXCJdID0gXCIweDNcIjtcbiAgRVRyYW5zYWN0aW9uVmVyc2lvbjM3W1wiRjNcIl0gPSBcIjB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzXCI7XG4gIHJldHVybiBFVHJhbnNhY3Rpb25WZXJzaW9uMzc7XG59KShFVHJhbnNhY3Rpb25WZXJzaW9uMyB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9hcGkvaW5kZXgudHNcbl9fcmVFeHBvcnQoYXBpX2V4cG9ydHMsIHN0YXJrbmV0X3R5cGVzXzA3X3N0YXIpO1xuaW1wb3J0ICogYXMgUlBDU1BFQzA3IGZyb20gXCJzdGFya25ldC10eXBlcy0wN1wiO1xuaW1wb3J0ICogYXMgc3RhcmtuZXRfdHlwZXNfMDdfc3RhciBmcm9tIFwic3RhcmtuZXQtdHlwZXMtMDdcIjtcblxuLy8gc3JjL3V0aWxzL2VuY29kZS50c1xudmFyIGVuY29kZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChlbmNvZGVfZXhwb3J0cywge1xuICBJU19CUk9XU0VSOiAoKSA9PiBJU19CUk9XU0VSLFxuICBhZGRIZXhQcmVmaXg6ICgpID0+IGFkZEhleFByZWZpeCxcbiAgYXJyYXlCdWZmZXJUb1N0cmluZzogKCkgPT4gYXJyYXlCdWZmZXJUb1N0cmluZyxcbiAgYXRvYlVuaXZlcnNhbDogKCkgPT4gYXRvYlVuaXZlcnNhbCxcbiAgYnRvYVVuaXZlcnNhbDogKCkgPT4gYnRvYVVuaXZlcnNhbCxcbiAgYnVmMmhleDogKCkgPT4gYnVmMmhleCxcbiAgY2FsY0J5dGVMZW5ndGg6ICgpID0+IGNhbGNCeXRlTGVuZ3RoLFxuICBjb25jYXRlbmF0ZUFycmF5QnVmZmVyOiAoKSA9PiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyLFxuICBwYWRMZWZ0OiAoKSA9PiBwYWRMZWZ0LFxuICBwYXNjYWxUb1NuYWtlOiAoKSA9PiBwYXNjYWxUb1NuYWtlLFxuICByZW1vdmVIZXhQcmVmaXg6ICgpID0+IHJlbW92ZUhleFByZWZpeCxcbiAgc2FuaXRpemVCeXRlczogKCkgPT4gc2FuaXRpemVCeXRlcyxcbiAgc2FuaXRpemVIZXg6ICgpID0+IHNhbml0aXplSGV4LFxuICBzdHJpbmdUb0FycmF5QnVmZmVyOiAoKSA9PiBzdHJpbmdUb0FycmF5QnVmZmVyLFxuICB1dGY4VG9BcnJheTogKCkgPT4gdXRmOFRvQXJyYXlcbn0pO1xuaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgU1RSSU5HX1pFUk8gPSBcIjBcIjtcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9TdHJpbmcoYXJyYXkpIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5KS5yZWR1Y2UoKGRhdGEsIGJ5dGUpID0+IGRhdGEgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0FycmF5KHN0cikge1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5QnVmZmVyKHN0cikge1xuICByZXR1cm4gdXRmOFRvQXJyYXkoc3RyKTtcbn1cbmZ1bmN0aW9uIGF0b2JVbml2ZXJzYWwoYSkge1xuICByZXR1cm4gYmFzZTY0LmRlY29kZShhKTtcbn1cbmZ1bmN0aW9uIGJ0b2FVbml2ZXJzYWwoYikge1xuICByZXR1cm4gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShiKSk7XG59XG5mdW5jdGlvbiBidWYyaGV4KGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnJlZHVjZSgociwgeCkgPT4gciArIHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiByZW1vdmVIZXhQcmVmaXgoaGV4KSB7XG4gIHJldHVybiBoZXgucmVwbGFjZSgvXjB4L2ksIFwiXCIpO1xufVxuZnVuY3Rpb24gYWRkSGV4UHJlZml4KGhleCkge1xuICByZXR1cm4gYDB4JHtyZW1vdmVIZXhQcmVmaXgoaGV4KX1gO1xufVxuZnVuY3Rpb24gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCBsZWZ0LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgY29uc3QgZGlmZiA9IGxlbmd0aCAtIHN0ci5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSBzdHI7XG4gIGlmIChkaWZmID4gMCkge1xuICAgIGNvbnN0IHBhZCA9IHBhZGRpbmcucmVwZWF0KGRpZmYpO1xuICAgIHJlc3VsdCA9IGxlZnQgPyBwYWQgKyBzdHIgOiBzdHIgKyBwYWQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhZExlZnQoc3RyLCBsZW5ndGgsIHBhZGRpbmcgPSBTVFJJTkdfWkVSTykge1xuICByZXR1cm4gcGFkU3RyaW5nKHN0ciwgbGVuZ3RoLCB0cnVlLCBwYWRkaW5nKTtcbn1cbmZ1bmN0aW9uIGNhbGNCeXRlTGVuZ3RoKHN0ciwgYnl0ZVNpemUgPSA4KSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBzdHI7XG4gIGNvbnN0IHJlbWFpbmRlciA9IGxlbmd0aCAlIGJ5dGVTaXplO1xuICByZXR1cm4gcmVtYWluZGVyID8gKGxlbmd0aCAtIHJlbWFpbmRlcikgLyBieXRlU2l6ZSAqIGJ5dGVTaXplICsgYnl0ZVNpemUgOiBsZW5ndGg7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUJ5dGVzKHN0ciwgYnl0ZVNpemUgPSA4LCBwYWRkaW5nID0gU1RSSU5HX1pFUk8pIHtcbiAgcmV0dXJuIHBhZExlZnQoc3RyLCBjYWxjQnl0ZUxlbmd0aChzdHIsIGJ5dGVTaXplKSwgcGFkZGluZyk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUhleChoZXgpIHtcbiAgaGV4ID0gcmVtb3ZlSGV4UHJlZml4KGhleCk7XG4gIGhleCA9IHNhbml0aXplQnl0ZXMoaGV4LCAyKTtcbiAgaWYgKGhleCkge1xuICAgIGhleCA9IGFkZEhleFByZWZpeChoZXgpO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG52YXIgcGFzY2FsVG9TbmFrZSA9ICh0ZXh0KSA9PiAvW2Etel0vLnRlc3QodGV4dCkgPyB0ZXh0LnNwbGl0KC8oPz1bQS1aXSkvKS5qb2luKFwiX1wiKS50b1VwcGVyQ2FzZSgpIDogdGV4dDtcbmZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIodWludDhhcnJheXMpIHtcbiAgY29uc3QgdG90YWxMZW5ndGggPSB1aW50OGFycmF5cy5yZWR1Y2UoKHRvdGFsLCB1aW50OGFycmF5KSA9PiB0b3RhbCArIHVpbnQ4YXJyYXkuYnl0ZUxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIHVpbnQ4YXJyYXlzLmZvckVhY2goKHVpbnQ4YXJyYXkpID0+IHtcbiAgICByZXN1bHQuc2V0KHVpbnQ4YXJyYXksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHVpbnQ4YXJyYXkuYnl0ZUxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBURVhUX1RPX0ZFTFRfTUFYX0xFTiA9IDMxO1xudmFyIFpFUk8gPSAwbjtcbnZhciBNQVNLXzI1MCA9IDJuICoqIDI1MG4gLSAxbjtcbnZhciBNQVNLXzMxID0gMm4gKiogMzFuIC0gMW47XG52YXIgQVBJX1ZFUlNJT04gPSBaRVJPO1xudmFyIFBSSU1FID0gMm4gKiogMjUxbiArIDE3biAqIDJuICoqIDE5Mm4gKyAxbjtcbnZhciBNQVhfU1RPUkFHRV9JVEVNX1NJWkUgPSAyNTZuO1xudmFyIEFERFJfQk9VTkQgPSAybiAqKiAyNTFuIC0gTUFYX1NUT1JBR0VfSVRFTV9TSVpFO1xudmFyIHJhbmdlID0gKG1pbiwgbWF4KSA9PiAoeyBtaW4sIG1heCB9KTtcbnZhciBSQU5HRV9GRUxUID0gcmFuZ2UoWkVSTywgUFJJTUUgLSAxbik7XG52YXIgUkFOR0VfSTEyOCA9IHJhbmdlKC0oMm4gKiogMTI3biksIDJuICoqIDEyN24gLSAxbik7XG52YXIgUkFOR0VfVTEyOCA9IHJhbmdlKFpFUk8sIDJuICoqIDEyOG4gLSAxbik7XG52YXIgQmFzZVVybCA9IC8qIEBfX1BVUkVfXyAqLyAoKEJhc2VVcmwyKSA9PiB7XG4gIEJhc2VVcmwyW1wiU05fTUFJTlwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1tYWlubmV0LnN0YXJrbmV0LmlvXCI7XG4gIEJhc2VVcmwyW1wiU05fU0VQT0xJQVwiXSA9IFwiaHR0cHM6Ly9hbHBoYS1zZXBvbGlhLnN0YXJrbmV0LmlvXCI7XG4gIHJldHVybiBCYXNlVXJsMjtcbn0pKEJhc2VVcmwgfHwge30pO1xudmFyIE5ldHdvcmtOYW1lID0gLyogQF9fUFVSRV9fICovICgoTmV0d29ya05hbWUyKSA9PiB7XG4gIE5ldHdvcmtOYW1lMltcIlNOX01BSU5cIl0gPSBcIlNOX01BSU5cIjtcbiAgTmV0d29ya05hbWUyW1wiU05fU0VQT0xJQVwiXSA9IFwiU05fU0VQT0xJQVwiO1xuICByZXR1cm4gTmV0d29ya05hbWUyO1xufSkoTmV0d29ya05hbWUgfHwge30pO1xudmFyIFN0YXJrbmV0Q2hhaW5JZCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0Q2hhaW5JZDYpID0+IHtcbiAgU3RhcmtuZXRDaGFpbklkNltcIlNOX01BSU5cIl0gPSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIjtcbiAgU3RhcmtuZXRDaGFpbklkNltcIlNOX1NFUE9MSUFcIl0gPSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIjtcbiAgcmV0dXJuIFN0YXJrbmV0Q2hhaW5JZDY7XG59KShTdGFya25ldENoYWluSWQgfHwge30pO1xudmFyIFRyYW5zYWN0aW9uSGFzaFByZWZpeCA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uSGFzaFByZWZpeDIpID0+IHtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFQ0xBUkVcIl0gPSBcIjB4NjQ2NTYzNmM2MTcyNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWVwiXSA9IFwiMHg2NDY1NzA2YzZmNzlcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkRFUExPWV9BQ0NPVU5UXCJdID0gXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIklOVk9LRVwiXSA9IFwiMHg2OTZlNzY2ZjZiNjVcIjtcbiAgVHJhbnNhY3Rpb25IYXNoUHJlZml4MltcIkwxX0hBTkRMRVJcIl0gPSBcIjB4NmMzMTVmNjg2MTZlNjQ2YzY1NzJcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uSGFzaFByZWZpeDI7XG59KShUcmFuc2FjdGlvbkhhc2hQcmVmaXggfHwge30pO1xudmFyIEZlZU1hcmdpblBlcmNlbnRhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChGZWVNYXJnaW5QZXJjZW50YWdlMikgPT4ge1xuICBGZWVNYXJnaW5QZXJjZW50YWdlMltGZWVNYXJnaW5QZXJjZW50YWdlMltcIkwxX0JPVU5EX01BWF9BTU9VTlRcIl0gPSA1MF0gPSBcIkwxX0JPVU5EX01BWF9BTU9VTlRcIjtcbiAgRmVlTWFyZ2luUGVyY2VudGFnZTJbRmVlTWFyZ2luUGVyY2VudGFnZTJbXCJMMV9CT1VORF9NQVhfUFJJQ0VfUEVSX1VOSVRcIl0gPSA1MF0gPSBcIkwxX0JPVU5EX01BWF9QUklDRV9QRVJfVU5JVFwiO1xuICBGZWVNYXJnaW5QZXJjZW50YWdlMltGZWVNYXJnaW5QZXJjZW50YWdlMltcIk1BWF9GRUVcIl0gPSA1MF0gPSBcIk1BWF9GRUVcIjtcbiAgcmV0dXJuIEZlZU1hcmdpblBlcmNlbnRhZ2UyO1xufSkoRmVlTWFyZ2luUGVyY2VudGFnZSB8fCB7fSk7XG52YXIgVURDID0ge1xuICBBRERSRVNTOiBcIjB4MDQxYTc4ZTc0MWU1YWYyZmVjMzRiNjk1Njc5YmM2ODkxNzQyNDM5ZjdhZmI4NDg0ZWNkNzc2NjY2MWFkMDJiZlwiLFxuICBFTlRSWVBPSU5UOiBcImRlcGxveUNvbnRyYWN0XCJcbn07XG52YXIgUlBDX0RFRkFVTFRfVkVSU0lPTiA9IFwidjBfN1wiO1xudmFyIFJQQ19OT0RFUyA9IHtcbiAgU05fTUFJTjogW1xuICAgIGBodHRwczovL3N0YXJrbmV0LW1haW5uZXQucHVibGljLmJsYXN0YXBpLmlvL3JwYy8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YCxcbiAgICBgaHR0cHM6Ly9mcmVlLXJwYy5uZXRoZXJtaW5kLmlvL21haW5uZXQtanVuby8ke1JQQ19ERUZBVUxUX1ZFUlNJT059YFxuICBdLFxuICBTTl9TRVBPTElBOiBbXG4gICAgYGh0dHBzOi8vc3RhcmtuZXQtc2Vwb2xpYS5wdWJsaWMuYmxhc3RhcGkuaW8vcnBjLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gLFxuICAgIGBodHRwczovL2ZyZWUtcnBjLm5ldGhlcm1pbmQuaW8vc2Vwb2xpYS1qdW5vLyR7UlBDX0RFRkFVTFRfVkVSU0lPTn1gXG4gIF1cbn07XG5cbi8vIHNyYy9jaGFubmVsL3JwY18wXzYudHNcbnZhciBycGNfMF82X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJwY18wXzZfZXhwb3J0cywge1xuICBScGNDaGFubmVsOiAoKSA9PiBScGNDaGFubmVsXG59KTtcblxuLy8gc3JjL3Byb3ZpZGVyL2Vycm9ycy50c1xuZnVuY3Rpb24gZml4U3RhY2sodGFyZ2V0LCBmbiA9IHRhcmdldC5jb25zdHJ1Y3Rvcikge1xuICBjb25zdCB7IGNhcHR1cmVTdGFja1RyYWNlIH0gPSBFcnJvcjtcbiAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7XG59XG5mdW5jdGlvbiBmaXhQcm90byh0YXJnZXQsIHByb3RvdHlwZSkge1xuICBjb25zdCB7IHNldFByb3RvdHlwZU9mIH0gPSBPYmplY3Q7XG4gIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogdGFyZ2V0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbn1cbnZhciBDdXN0b21FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICB2YWx1ZTogbmV3LnRhcmdldC5uYW1lLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBmaXhQcm90byh0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgZml4U3RhY2sodGhpcyk7XG4gIH1cbn07XG52YXIgTGlicmFyeUVycm9yID0gY2xhc3MgZXh0ZW5kcyBDdXN0b21FcnJvciB7XG59O1xudmFyIEdhdGV3YXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgTGlicmFyeUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvckNvZGUgPSBlcnJvckNvZGU7XG4gIH1cbn07XG52YXIgSHR0cEVycm9yID0gY2xhc3MgZXh0ZW5kcyBMaWJyYXJ5RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvckNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL2luZGV4LnRzXG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBCbG9ja1N0YXR1czogKCkgPT4gQmxvY2tTdGF0dXMsXG4gIEJsb2NrVGFnOiAoKSA9PiBCbG9ja1RhZyxcbiAgRW50cnlQb2ludFR5cGU6ICgpID0+IEVudHJ5UG9pbnRUeXBlLFxuICBMaXRlcmFsOiAoKSA9PiBMaXRlcmFsLFxuICBSUEM6ICgpID0+IGFwaV9leHBvcnRzLFxuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czogKCkgPT4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXM6ICgpID0+IFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzOiAoKSA9PiBUcmFuc2FjdGlvblN0YXR1cyxcbiAgVHJhbnNhY3Rpb25UeXBlOiAoKSA9PiBUcmFuc2FjdGlvblR5cGUsXG4gIFR5cGVkRGF0YVJldmlzaW9uOiAoKSA9PiBUeXBlZERhdGFSZXZpc2lvbixcbiAgVWludDogKCkgPT4gVWludCxcbiAgVmFsaWRhdGVUeXBlOiAoKSA9PiBWYWxpZGF0ZVR5cGVcbn0pO1xuXG4vLyBzcmMvdHlwZXMvY2FsbGRhdGEudHNcbnZhciBWYWxpZGF0ZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChWYWxpZGF0ZVR5cGUyKSA9PiB7XG4gIFZhbGlkYXRlVHlwZTJbXCJERVBMT1lcIl0gPSBcIkRFUExPWVwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiQ0FMTFwiXSA9IFwiQ0FMTFwiO1xuICBWYWxpZGF0ZVR5cGUyW1wiSU5WT0tFXCJdID0gXCJJTlZPS0VcIjtcbiAgcmV0dXJuIFZhbGlkYXRlVHlwZTI7XG59KShWYWxpZGF0ZVR5cGUgfHwge30pO1xudmFyIFVpbnQgPSAvKiBAX19QVVJFX18gKi8gKChVaW50MikgPT4ge1xuICBVaW50MltcInU4XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1OFwiO1xuICBVaW50MltcInUxNlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTE2XCI7XG4gIFVpbnQyW1widTMyXCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MzJcIjtcbiAgVWludDJbXCJ1NjRcIl0gPSBcImNvcmU6OmludGVnZXI6OnU2NFwiO1xuICBVaW50MltcInUxMjhcIl0gPSBcImNvcmU6OmludGVnZXI6OnUxMjhcIjtcbiAgVWludDJbXCJ1MjU2XCJdID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIFVpbnQyW1widTUxMlwiXSA9IFwiY29yZTo6aW50ZWdlcjo6dTUxMlwiO1xuICByZXR1cm4gVWludDI7XG59KShVaW50IHx8IHt9KTtcbnZhciBMaXRlcmFsID0gLyogQF9fUFVSRV9fICovICgoTGl0ZXJhbDIpID0+IHtcbiAgTGl0ZXJhbDJbXCJDbGFzc0hhc2hcIl0gPSBcImNvcmU6OnN0YXJrbmV0OjpjbGFzc19oYXNoOjpDbGFzc0hhc2hcIjtcbiAgTGl0ZXJhbDJbXCJDb250cmFjdEFkZHJlc3NcIl0gPSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIjtcbiAgTGl0ZXJhbDJbXCJTZWNwMjU2azFQb2ludFwiXSA9IFwiY29yZTo6c3RhcmtuZXQ6OnNlY3AyNTZrMTo6U2VjcDI1NmsxUG9pbnRcIjtcbiAgcmV0dXJuIExpdGVyYWwyO1xufSkoTGl0ZXJhbCB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy9saWIvY29udHJhY3QvaW5kZXgudHNcbnZhciBFbnRyeVBvaW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEVudHJ5UG9pbnRUeXBlMikgPT4ge1xuICBFbnRyeVBvaW50VHlwZTJbXCJFWFRFUk5BTFwiXSA9IFwiRVhURVJOQUxcIjtcbiAgRW50cnlQb2ludFR5cGUyW1wiTDFfSEFORExFUlwiXSA9IFwiTDFfSEFORExFUlwiO1xuICBFbnRyeVBvaW50VHlwZTJbXCJDT05TVFJVQ1RPUlwiXSA9IFwiQ09OU1RSVUNUT1JcIjtcbiAgcmV0dXJuIEVudHJ5UG9pbnRUeXBlMjtcbn0pKEVudHJ5UG9pbnRUeXBlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL2xpYi9pbmRleC50c1xudmFyIFRyYW5zYWN0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uVHlwZTIpID0+IHtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFQ0xBUkVcIl0gPSBcIkRFQ0xBUkVcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIkRFUExPWVwiXSA9IFwiREVQTE9ZXCI7XG4gIFRyYW5zYWN0aW9uVHlwZTJbXCJERVBMT1lfQUNDT1VOVFwiXSA9IFwiREVQTE9ZX0FDQ09VTlRcIjtcbiAgVHJhbnNhY3Rpb25UeXBlMltcIklOVk9LRVwiXSA9IFwiSU5WT0tFX0ZVTkNUSU9OXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblR5cGUyO1xufSkoVHJhbnNhY3Rpb25UeXBlIHx8IHt9KTtcbnZhciBUcmFuc2FjdGlvblN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uU3RhdHVzMikgPT4ge1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJOT1RfUkVDRUlWRURcIl0gPSBcIk5PVF9SRUNFSVZFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiQUNDRVBURURfT05fTDJcIl0gPSBcIkFDQ0VQVEVEX09OX0wyXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wxXCJdID0gXCJBQ0NFUFRFRF9PTl9MMVwiO1xuICBUcmFuc2FjdGlvblN0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXMyW1wiUkVWRVJURURcIl0gPSBcIlJFVkVSVEVEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1czI7XG59KShUcmFuc2FjdGlvblN0YXR1cyB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyKSA9PiB7XG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyW1wiTk9UX1JFQ0VJVkVEXCJdID0gXCJOT1RfUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJSRUNFSVZFRFwiXSA9IFwiUkVDRUlWRURcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMlwiXSA9IFwiQUNDRVBURURfT05fTDJcIjtcbiAgVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1czJbXCJBQ0NFUFRFRF9PTl9MMVwiXSA9IFwiQUNDRVBURURfT05fTDFcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25GaW5hbGl0eVN0YXR1cyB8fCB7fSk7XG52YXIgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czIpID0+IHtcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyW1wiUkVKRUNURURcIl0gPSBcIlJFSkVDVEVEXCI7XG4gIFRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzMltcIlJFVkVSVEVEXCJdID0gXCJSRVZFUlRFRFwiO1xuICBUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1czJbXCJTVUNDRUVERURcIl0gPSBcIlNVQ0NFRURFRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMyO1xufSkoVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMgfHwge30pO1xudmFyIEJsb2NrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoQmxvY2tTdGF0dXMyKSA9PiB7XG4gIEJsb2NrU3RhdHVzMltcIlBFTkRJTkdcIl0gPSBcIlBFTkRJTkdcIjtcbiAgQmxvY2tTdGF0dXMyW1wiQUNDRVBURURfT05fTDFcIl0gPSBcIkFDQ0VQVEVEX09OX0wxXCI7XG4gIEJsb2NrU3RhdHVzMltcIkFDQ0VQVEVEX09OX0wyXCJdID0gXCJBQ0NFUFRFRF9PTl9MMlwiO1xuICBCbG9ja1N0YXR1czJbXCJSRUpFQ1RFRFwiXSA9IFwiUkVKRUNURURcIjtcbiAgcmV0dXJuIEJsb2NrU3RhdHVzMjtcbn0pKEJsb2NrU3RhdHVzIHx8IHt9KTtcbnZhciBCbG9ja1RhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEJsb2NrVGFnMikgPT4ge1xuICBCbG9ja1RhZzJbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XG4gIEJsb2NrVGFnMltcIkxBVEVTVFwiXSA9IFwibGF0ZXN0XCI7XG4gIHJldHVybiBCbG9ja1RhZzI7XG59KShCbG9ja1RhZyB8fCB7fSk7XG5cbi8vIHNyYy90eXBlcy90eXBlZERhdGEudHNcbmltcG9ydCB7XG4gIFR5cGVkRGF0YVJldmlzaW9uXG59IGZyb20gXCJzdGFya25ldC10eXBlcy0wN1wiO1xuXG4vLyBzcmMvdXRpbHMvanNvbi50c1xudmFyIGpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoanNvbl9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZTIsXG4gIHBhcnNlQWx3YXlzQXNCaWc6ICgpID0+IHBhcnNlQWx3YXlzQXNCaWcsXG4gIHN0cmluZ2lmeTogKCkgPT4gc3RyaW5naWZ5MixcbiAgc3RyaW5naWZ5QWx3YXlzQXNCaWc6ICgpID0+IHN0cmluZ2lmeUFsd2F5c0FzQmlnXG59KTtcbmltcG9ydCAqIGFzIGpzb24gZnJvbSBcImxvc3NsZXNzLWpzb25cIjtcbnZhciBwYXJzZUludEFzTnVtYmVyT3JCaWdJbnQgPSAoc3RyKSA9PiB7XG4gIGlmICghanNvbi5pc0ludGVnZXIoc3RyKSkgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgY29uc3QgbnVtID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gIHJldHVybiBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pID8gbnVtIDogQmlnSW50KHN0cik7XG59O1xudmFyIHBhcnNlMiA9IChzdHIpID0+IGpzb24ucGFyc2UoU3RyaW5nKHN0ciksIHZvaWQgMCwgcGFyc2VJbnRBc051bWJlck9yQmlnSW50KTtcbnZhciBwYXJzZUFsd2F5c0FzQmlnID0gKHN0cikgPT4ganNvbi5wYXJzZShTdHJpbmcoc3RyKSwgdm9pZCAwLCBqc29uLnBhcnNlTnVtYmVyQW5kQmlnSW50KTtcbnZhciBzdHJpbmdpZnkyID0gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UsIG51bWJlclN0cmluZ2lmaWVycykgPT4ganNvbi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgbnVtYmVyU3RyaW5naWZpZXJzKTtcbnZhciBzdHJpbmdpZnlBbHdheXNBc0JpZyA9IHN0cmluZ2lmeTI7XG5cbi8vIHNyYy91dGlscy9iYXRjaC9pbmRleC50c1xudmFyIEJhdGNoQ2xpZW50ID0gY2xhc3Mge1xuICBub2RlVXJsO1xuICBoZWFkZXJzO1xuICBpbnRlcnZhbDtcbiAgcmVxdWVzdElkID0gMDtcbiAgcGVuZGluZ1JlcXVlc3RzID0ge307XG4gIGJhdGNoUHJvbWlzZXMgPSB7fTtcbiAgZGVsYXlUaW1lcjtcbiAgZGVsYXlQcm9taXNlO1xuICBkZWxheVByb21pc2VSZXNvbHZlO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5ub2RlVXJsID0gb3B0aW9ucy5ub2RlVXJsO1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgICB0aGlzLmludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbDtcbiAgfVxuICBhc3luYyB3YWl0KCkge1xuICAgIGlmICghdGhpcy5kZWxheVByb21pc2UgfHwgIXRoaXMuZGVsYXlQcm9taXNlUmVzb2x2ZSkge1xuICAgICAgdGhpcy5kZWxheVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzLmRlbGF5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGF5VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZXIpO1xuICAgICAgdGhpcy5kZWxheVRpbWVyID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLmRlbGF5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlbGF5UHJvbWlzZVJlc29sdmUpIHtcbiAgICAgICAgdGhpcy5kZWxheVByb21pc2VSZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuZGVsYXlQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmRlbGF5UHJvbWlzZVJlc29sdmUgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pbnRlcnZhbCk7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXlQcm9taXNlO1xuICB9XG4gIGFkZFBlbmRpbmdSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBpZCkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBpZDogaWQgPz8gYGJhdGNoZWRfJHt0aGlzLnJlcXVlc3RJZCArPSAxfWAsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgcGFyYW1zOiBwYXJhbXMgPz8gdm9pZCAwXG4gICAgfTtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSA9IHJlcXVlc3Q7XG4gICAgcmV0dXJuIHJlcXVlc3QuaWQ7XG4gIH1cbiAgYXN5bmMgc2VuZEJhdGNoKHJlcXVlc3RzKSB7XG4gICAgY29uc3QgcmF3ID0gYXdhaXQgZmV0Y2godGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihyZXF1ZXN0cyksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gcmF3Lmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogQXV0b21hdGljYWxseSBiYXRjaGVzIGFuZCBmZXRjaGVzIEpTT04tUlBDIGNhbGxzIGluIGEgc2luZ2xlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBtZXRob2QgTWV0aG9kIHRvIGNhbGxcbiAgICogQHBhcmFtIHBhcmFtcyBNZXRob2QgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gaWQgSlNPTi1SUEMgUmVxdWVzdCBJRFxuICAgKiBAcmV0dXJucyBKU09OLVJQQyBSZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkKSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5hZGRQZW5kaW5nUmVxdWVzdChtZXRob2QsIHBhcmFtcywgaWQpO1xuICAgIGF3YWl0IHRoaXMud2FpdCgpO1xuICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSB7fTtcbiAgICBpZiAoIXRoaXMuYmF0Y2hQcm9taXNlc1tyZXF1ZXN0SWRdKSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5zZW5kQmF0Y2goT2JqZWN0LnZhbHVlcyhyZXF1ZXN0cykpO1xuICAgICAgT2JqZWN0LmtleXMocmVxdWVzdHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICB0aGlzLmJhdGNoUHJvbWlzZXNba2V5XSA9IHByb21pc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuYmF0Y2hQcm9taXNlc1tyZXF1ZXN0SWRdO1xuICAgIGRlbGV0ZSB0aGlzLmJhdGNoUHJvbWlzZXNbcmVxdWVzdElkXTtcbiAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzLmZpbmQoKHJlcykgPT4gcmVzLmlkID09PSByZXF1ZXN0SWQpO1xuICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgdGhlIHJlc3VsdCBmb3IgdGhlIHJlcXVlc3QuIE1ldGhvZDogJHttZXRob2R9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiQXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL251bS50c1xudmFyIG51bV9leHBvcnRzID0ge307XG5fX2V4cG9ydChudW1fZXhwb3J0cywge1xuICBhZGRQZXJjZW50OiAoKSA9PiBhZGRQZXJjZW50LFxuICBhc3NlcnRJblJhbmdlOiAoKSA9PiBhc3NlcnRJblJhbmdlLFxuICBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5OiAoKSA9PiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5LFxuICBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheTogKCkgPT4gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXksXG4gIGNsZWFuSGV4OiAoKSA9PiBjbGVhbkhleCxcbiAgZ2V0RGVjaW1hbFN0cmluZzogKCkgPT4gZ2V0RGVjaW1hbFN0cmluZyxcbiAgZ2V0SGV4U3RyaW5nOiAoKSA9PiBnZXRIZXhTdHJpbmcsXG4gIGdldEhleFN0cmluZ0FycmF5OiAoKSA9PiBnZXRIZXhTdHJpbmdBcnJheSxcbiAgaGV4VG9CeXRlczogKCkgPT4gaGV4VG9CeXRlcyxcbiAgaGV4VG9EZWNpbWFsU3RyaW5nOiAoKSA9PiBoZXhUb0RlY2ltYWxTdHJpbmcsXG4gIGlzQmlnSW50OiAoKSA9PiBpc0JpZ0ludCxcbiAgaXNCb29sZWFuOiAoKSA9PiBpc0Jvb2xlYW4sXG4gIGlzSGV4OiAoKSA9PiBpc0hleCxcbiAgaXNOdW1iZXI6ICgpID0+IGlzTnVtYmVyLFxuICBpc1N0cmluZ1dob2xlTnVtYmVyOiAoKSA9PiBpc1N0cmluZ1dob2xlTnVtYmVyLFxuICBzdHJpbmdUb1NoYTI1NlRvQXJyYXlCdWZmNDogKCkgPT4gc3RyaW5nVG9TaGEyNTZUb0FycmF5QnVmZjQsXG4gIHRvQmlnSW50OiAoKSA9PiB0b0JpZ0ludCxcbiAgdG9DYWlyb0Jvb2w6ICgpID0+IHRvQ2Fpcm9Cb29sLFxuICB0b0hleDogKCkgPT4gdG9IZXgsXG4gIHRvSGV4U3RyaW5nOiAoKSA9PiB0b0hleFN0cmluZyxcbiAgdG9TdG9yYWdlS2V5OiAoKSA9PiB0b1N0b3JhZ2VLZXlcbn0pO1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzTm9ibGUgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5mdW5jdGlvbiBpc0hleChoZXgpIHtcbiAgcmV0dXJuIC9eMHhbMC05YS1mXSokL2kudGVzdChoZXgpO1xufVxuZnVuY3Rpb24gdG9CaWdJbnQodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xufVxuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludCh2YWx1ZSkudG9TdHJpbmcoMTYpKTtcbn1cbnZhciB0b0hleFN0cmluZyA9IHRvSGV4O1xuZnVuY3Rpb24gdG9TdG9yYWdlS2V5KG51bWJlcjIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeCh0b0JpZ0ludChudW1iZXIyKS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG59XG5mdW5jdGlvbiBoZXhUb0RlY2ltYWxTdHJpbmcoaGV4KSB7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KGhleCkpLnRvU3RyaW5nKDEwKTtcbn1cbmZ1bmN0aW9uIGNsZWFuSGV4KGhleCkge1xuICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXigweCkwKy8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRJblJhbmdlKGlucHV0LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBpbnB1dE5hbWUgPSBcIlwiKSB7XG4gIGNvbnN0IG1lc3NhZ2VTdWZmaXggPSBpbnB1dE5hbWUgPT09IFwiXCIgPyBcImludmFsaWQgbGVuZ3RoXCIgOiBgaW52YWxpZCAke2lucHV0TmFtZX0gbGVuZ3RoYDtcbiAgY29uc3QgaW5wdXRCaWdJbnQgPSBCaWdJbnQoaW5wdXQpO1xuICBjb25zdCBsb3dlckJvdW5kQmlnSW50ID0gQmlnSW50KGxvd2VyQm91bmQpO1xuICBjb25zdCB1cHBlckJvdW5kQmlnSW50ID0gQmlnSW50KHVwcGVyQm91bmQpO1xuICBhc3NlcnQoXG4gICAgaW5wdXRCaWdJbnQgPj0gbG93ZXJCb3VuZEJpZ0ludCAmJiBpbnB1dEJpZ0ludCA8PSB1cHBlckJvdW5kQmlnSW50LFxuICAgIGBNZXNzYWdlIG5vdCBzaWduYWJsZSwgJHttZXNzYWdlU3VmZml4fS5gXG4gICk7XG59XG5mdW5jdGlvbiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEubWFwKCh4KSA9PiB0b0JpZ0ludCh4KS50b1N0cmluZygxMCkpO1xufVxuZnVuY3Rpb24gYmlnTnVtYmVyaXNoQXJyYXlUb0hleGFkZWNpbWFsU3RyaW5nQXJyYXkoZGF0YSkge1xuICByZXR1cm4gZGF0YS5tYXAoKHgpID0+IHRvSGV4KHgpKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSB7XG4gIHJldHVybiAvXlxcZCskLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBnZXREZWNpbWFsU3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBoZXhUb0RlY2ltYWxTdHJpbmcoc3RyKTtcbiAgfVxuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBuZWVkcyB0byBiZSBhIGhleC1zdHJpbmcgb3Igd2hvbGUtbnVtYmVyLXN0cmluZ2ApO1xufVxuZnVuY3Rpb24gZ2V0SGV4U3RyaW5nKHN0cikge1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKGlzU3RyaW5nV2hvbGVOdW1iZXIoc3RyKSkge1xuICAgIHJldHVybiB0b0hleFN0cmluZyhzdHIpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IG5lZWRzIHRvIGJlIGEgaGV4LXN0cmluZyBvciB3aG9sZS1udW1iZXItc3RyaW5nYCk7XG59XG5mdW5jdGlvbiBnZXRIZXhTdHJpbmdBcnJheShhcnJheSkge1xuICByZXR1cm4gYXJyYXkubWFwKGdldEhleFN0cmluZyk7XG59XG5mdW5jdGlvbiB0b0NhaXJvQm9vbCh2YWx1ZSkge1xuICByZXR1cm4gKCt2YWx1ZSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoc3RyKSB7XG4gIGlmICghaXNIZXgoc3RyKSkgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gbmVlZHMgdG8gYmUgYSBoZXgtc3RyaW5nYCk7XG4gIGxldCBhZGFwdGVkVmFsdWUgPSByZW1vdmVIZXhQcmVmaXgoc3RyKTtcbiAgaWYgKGFkYXB0ZWRWYWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgYWRhcHRlZFZhbHVlID0gYDAke2FkYXB0ZWRWYWx1ZX1gO1xuICB9XG4gIHJldHVybiBoZXhUb0J5dGVzTm9ibGUoYWRhcHRlZFZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFkZFBlcmNlbnQobnVtYmVyMiwgcGVyY2VudCkge1xuICBjb25zdCBiaWdJbnROdW0gPSBCaWdJbnQobnVtYmVyMik7XG4gIHJldHVybiBiaWdJbnROdW0gKyBiaWdJbnROdW0gKiBCaWdJbnQocGVyY2VudCkgLyAxMDBuO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvU2hhMjU2VG9BcnJheUJ1ZmY0KHN0cikge1xuICBjb25zdCBpbnQzMSA9IChuKSA9PiBOdW1iZXIobiAmIE1BU0tfMzEpO1xuICBjb25zdCByZXN1bHQgPSBpbnQzMShCaWdJbnQoYWRkSGV4UHJlZml4KGJ1ZjJoZXgoc2hhMjU2KHN0cikpKSkpO1xuICByZXR1cm4gaGV4VG9CeXRlcyh0b0hleChyZXN1bHQpKTtcbn1cblxuLy8gc3JjL3V0aWxzL2hhc2gvc2VsZWN0b3IudHNcbnZhciBzZWxlY3Rvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChzZWxlY3Rvcl9leHBvcnRzLCB7XG4gIGdldEwyTWVzc2FnZUhhc2g6ICgpID0+IGdldEwyTWVzc2FnZUhhc2gsXG4gIGdldFNlbGVjdG9yOiAoKSA9PiBnZXRTZWxlY3RvcixcbiAgZ2V0U2VsZWN0b3JGcm9tTmFtZTogKCkgPT4gZ2V0U2VsZWN0b3JGcm9tTmFtZSxcbiAga2VjY2FrQm46ICgpID0+IGtlY2Nha0JuLFxuICBzb2xpZGl0eVVpbnQyNTZQYWNrZWRLZWNjYWsyNTY6ICgpID0+IHNvbGlkaXR5VWludDI1NlBhY2tlZEtlY2NhazI1NixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbmltcG9ydCB7IGtlY2NhayB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEzXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHNcIjtcbmZ1bmN0aW9uIGtlY2Nha0JuKHZhbHVlKSB7XG4gIGNvbnN0IGhleFdpdGhvdXRQcmVmaXggPSByZW1vdmVIZXhQcmVmaXgodG9IZXgoQmlnSW50KHZhbHVlKSkpO1xuICBjb25zdCBldmVuSGV4ID0gaGV4V2l0aG91dFByZWZpeC5sZW5ndGggJSAyID09PSAwID8gaGV4V2l0aG91dFByZWZpeCA6IGAwJHtoZXhXaXRob3V0UHJlZml4fWA7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoa2VjY2FrKGhleFRvQnl0ZXMoYWRkSGV4UHJlZml4KGV2ZW5IZXgpKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIGtlY2Nha0hleChzdHIpIHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChrZWNjYWsodXRmOFRvQXJyYXkoc3RyKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIHN0YXJrbmV0S2VjY2FrKHN0cikge1xuICBjb25zdCBoYXNoID0gQmlnSW50KGtlY2Nha0hleChzdHIpKTtcbiAgcmV0dXJuIGhhc2ggJiBNQVNLXzI1MDtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbU5hbWUoZnVuY05hbWUpIHtcbiAgcmV0dXJuIHRvSGV4KHN0YXJrbmV0S2VjY2FrKGZ1bmNOYW1lKSk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rvcih2YWx1ZSkge1xuICBpZiAoaXNOdW1iZXIodmFsdWUpIHx8IGlzQmlnSW50KHZhbHVlKSkgcmV0dXJuIHRvSGV4KHZhbHVlKTtcbiAgaWYgKGlzSGV4KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcih2YWx1ZSkpIHJldHVybiB0b0hleCh2YWx1ZSk7XG4gIHJldHVybiBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNvbGlkaXR5VWludDI1NlBhY2tlZEtlY2NhazI1NihwYXJhbXMpIHtcbiAgY29uc3QgbXlFbmNvZGUgPSBhZGRIZXhQcmVmaXgoXG4gICAgcGFyYW1zLnJlZHVjZShcbiAgICAgIChyZXMsIHBhcikgPT4gcmVzICsgcmVtb3ZlSGV4UHJlZml4KHRvSGV4KHBhcikpLnBhZFN0YXJ0KDY0LCBcIjBcIiksXG4gICAgICBcIlwiXG4gICAgKVxuICApO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGJ5dGVzVG9IZXgoa2VjY2FrXzI1NihoZXhUb0J5dGVzKG15RW5jb2RlKSkpKTtcbn1cbmZ1bmN0aW9uIGdldEwyTWVzc2FnZUhhc2gobDFGcm9tQWRkcmVzcywgbDJUb0FkZHJlc3MsIGwyU2VsZWN0b3IsIGwyQ2FsbGRhdGEsIGwxTm9uY2UpIHtcbiAgcmV0dXJuIHNvbGlkaXR5VWludDI1NlBhY2tlZEtlY2NhazI1NihbXG4gICAgbDFGcm9tQWRkcmVzcyxcbiAgICBsMlRvQWRkcmVzcyxcbiAgICBsMU5vbmNlLFxuICAgIGwyU2VsZWN0b3IsXG4gICAgbDJDYWxsZGF0YS5sZW5ndGgsXG4gICAgLi4ubDJDYWxsZGF0YVxuICBdKTtcbn1cblxuLy8gc3JjL3V0aWxzL3Nob3J0U3RyaW5nLnRzXG52YXIgc2hvcnRTdHJpbmdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2hvcnRTdHJpbmdfZXhwb3J0cywge1xuICBkZWNvZGVTaG9ydFN0cmluZzogKCkgPT4gZGVjb2RlU2hvcnRTdHJpbmcsXG4gIGVuY29kZVNob3J0U3RyaW5nOiAoKSA9PiBlbmNvZGVTaG9ydFN0cmluZyxcbiAgaXNBU0NJSTogKCkgPT4gaXNBU0NJSSxcbiAgaXNEZWNpbWFsU3RyaW5nOiAoKSA9PiBpc0RlY2ltYWxTdHJpbmcsXG4gIGlzTG9uZ1RleHQ6ICgpID0+IGlzTG9uZ1RleHQsXG4gIGlzU2hvcnRTdHJpbmc6ICgpID0+IGlzU2hvcnRTdHJpbmcsXG4gIGlzU2hvcnRUZXh0OiAoKSA9PiBpc1Nob3J0VGV4dCxcbiAgaXNTdHJpbmc6ICgpID0+IGlzU3RyaW5nLFxuICBpc1RleHQ6ICgpID0+IGlzVGV4dCxcbiAgc3BsaXRMb25nU3RyaW5nOiAoKSA9PiBzcGxpdExvbmdTdHJpbmdcbn0pO1xuZnVuY3Rpb24gaXNBU0NJSShzdHIpIHtcbiAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBpc1Nob3J0U3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLmxlbmd0aCA8PSBURVhUX1RPX0ZFTFRfTUFYX0xFTjtcbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOV0qJC9pLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc1RleHQodmFsKSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpICYmICFpc0hleCh2YWwpICYmICFpc1N0cmluZ1dob2xlTnVtYmVyKHZhbCk7XG59XG52YXIgaXNTaG9ydFRleHQgPSAodmFsKSA9PiBpc1RleHQodmFsKSAmJiBpc1Nob3J0U3RyaW5nKHZhbCk7XG52YXIgaXNMb25nVGV4dCA9ICh2YWwpID0+IGlzVGV4dCh2YWwpICYmICFpc1Nob3J0U3RyaW5nKHZhbCk7XG5mdW5jdGlvbiBzcGxpdExvbmdTdHJpbmcobG9uZ1N0cikge1xuICBjb25zdCByZWdleCA9IFJlZ0V4cChgW15dezEsJHtURVhUX1RPX0ZFTFRfTUFYX0xFTn19YCwgXCJnXCIpO1xuICByZXR1cm4gbG9uZ1N0ci5tYXRjaChyZWdleCkgfHwgW107XG59XG5mdW5jdGlvbiBlbmNvZGVTaG9ydFN0cmluZyhzdHIpIHtcbiAgaWYgKCFpc0FTQ0lJKHN0cikpIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIG5vdCBhbiBBU0NJSSBzdHJpbmdgKTtcbiAgaWYgKCFpc1Nob3J0U3RyaW5nKHN0cikpIHRocm93IG5ldyBFcnJvcihgJHtzdHJ9IGlzIHRvbyBsb25nYCk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoc3RyLnJlcGxhY2UoLy4vZywgKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVNob3J0U3RyaW5nKHN0cikge1xuICBpZiAoIWlzQVNDSUkoc3RyKSkgdGhyb3cgbmV3IEVycm9yKGAke3N0cn0gaXMgbm90IGFuIEFTQ0lJIHN0cmluZ2ApO1xuICBpZiAoaXNIZXgoc3RyKSkge1xuICAgIHJldHVybiByZW1vdmVIZXhQcmVmaXgoc3RyKS5yZXBsYWNlKC8uezJ9L2csIChoZXgpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpKTtcbiAgfVxuICBpZiAoaXNEZWNpbWFsU3RyaW5nKHN0cikpIHtcbiAgICByZXR1cm4gZGVjb2RlU2hvcnRTdHJpbmcoXCIwWFwiLmNvbmNhdChCaWdJbnQoc3RyKS50b1N0cmluZygxNikpKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYCR7c3RyfSBpcyBub3QgSGV4IG9yIGRlY2ltYWxgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2J5dGVBcnJheS50c1xudmFyIGJ5dGVBcnJheV9leHBvcnRzID0ge307XG5fX2V4cG9ydChieXRlQXJyYXlfZXhwb3J0cywge1xuICBieXRlQXJyYXlGcm9tU3RyaW5nOiAoKSA9PiBieXRlQXJyYXlGcm9tU3RyaW5nLFxuICBzdHJpbmdGcm9tQnl0ZUFycmF5OiAoKSA9PiBzdHJpbmdGcm9tQnl0ZUFycmF5XG59KTtcbmZ1bmN0aW9uIHN0cmluZ0Zyb21CeXRlQXJyYXkobXlCeXRlQXJyYXkpIHtcbiAgY29uc3QgcGVuZGluZ193b3JkID0gQmlnSW50KG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZCkgPT09IDBuID8gXCJcIiA6IGRlY29kZVNob3J0U3RyaW5nKHRvSGV4KG15Qnl0ZUFycmF5LnBlbmRpbmdfd29yZCkpO1xuICByZXR1cm4gbXlCeXRlQXJyYXkuZGF0YS5yZWR1Y2UoKGN1bXVsZWRTdHJpbmcsIGVuY29kZWRTdHJpbmcpID0+IHtcbiAgICBjb25zdCBhZGQgPSBCaWdJbnQoZW5jb2RlZFN0cmluZykgPT09IDBuID8gXCJcIiA6IGRlY29kZVNob3J0U3RyaW5nKHRvSGV4KGVuY29kZWRTdHJpbmcpKTtcbiAgICByZXR1cm4gY3VtdWxlZFN0cmluZyArIGFkZDtcbiAgfSwgXCJcIikgKyBwZW5kaW5nX3dvcmQ7XG59XG5mdW5jdGlvbiBieXRlQXJyYXlGcm9tU3RyaW5nKHRhcmdldFN0cmluZykge1xuICBjb25zdCBzaG9ydFN0cmluZ3MgPSBzcGxpdExvbmdTdHJpbmcodGFyZ2V0U3RyaW5nKTtcbiAgY29uc3QgcmVtYWluZGVyID0gc2hvcnRTdHJpbmdzW3Nob3J0U3RyaW5ncy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgc2hvcnRTdHJpbmdzRW5jb2RlZCA9IHNob3J0U3RyaW5ncy5tYXAoZW5jb2RlU2hvcnRTdHJpbmcpO1xuICBjb25zdCBbcGVuZGluZ1dvcmQsIHBlbmRpbmdXb3JkTGVuZ3RoXSA9IHJlbWFpbmRlciA9PT0gdm9pZCAwIHx8IHJlbWFpbmRlci5sZW5ndGggPT09IDMxID8gW1wiMHgwMFwiLCAwXSA6IFtzaG9ydFN0cmluZ3NFbmNvZGVkLnBvcCgpLCByZW1haW5kZXIubGVuZ3RoXTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBzaG9ydFN0cmluZ3NFbmNvZGVkLmxlbmd0aCA9PT0gMCA/IFtdIDogc2hvcnRTdHJpbmdzRW5jb2RlZCxcbiAgICBwZW5kaW5nX3dvcmQ6IHBlbmRpbmdXb3JkLFxuICAgIHBlbmRpbmdfd29yZF9sZW46IHBlbmRpbmdXb3JkTGVuZ3RoXG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9jYWlyby50c1xudmFyIGNhaXJvX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNhaXJvX2V4cG9ydHMsIHtcbiAgZmVsdDogKCkgPT4gZmVsdCxcbiAgZ2V0QWJpQ29udHJhY3RWZXJzaW9uOiAoKSA9PiBnZXRBYmlDb250cmFjdFZlcnNpb24sXG4gIGdldEFycmF5VHlwZTogKCkgPT4gZ2V0QXJyYXlUeXBlLFxuICBpc0NhaXJvMUFiaTogKCkgPT4gaXNDYWlybzFBYmksXG4gIGlzQ2Fpcm8xVHlwZTogKCkgPT4gaXNDYWlybzFUeXBlLFxuICBpc0xlbjogKCkgPT4gaXNMZW4sXG4gIGlzVHlwZUFycmF5OiAoKSA9PiBpc1R5cGVBcnJheSxcbiAgaXNUeXBlQm9vbDogKCkgPT4gaXNUeXBlQm9vbCxcbiAgaXNUeXBlQnl0ZUFycmF5OiAoKSA9PiBpc1R5cGVCeXRlQXJyYXksXG4gIGlzVHlwZUJ5dGVzMzE6ICgpID0+IGlzVHlwZUJ5dGVzMzEsXG4gIGlzVHlwZUNvbnRyYWN0QWRkcmVzczogKCkgPT4gaXNUeXBlQ29udHJhY3RBZGRyZXNzLFxuICBpc1R5cGVFbnVtOiAoKSA9PiBpc1R5cGVFbnVtLFxuICBpc1R5cGVFdGhBZGRyZXNzOiAoKSA9PiBpc1R5cGVFdGhBZGRyZXNzLFxuICBpc1R5cGVGZWx0OiAoKSA9PiBpc1R5cGVGZWx0LFxuICBpc1R5cGVMaXRlcmFsOiAoKSA9PiBpc1R5cGVMaXRlcmFsLFxuICBpc1R5cGVOYW1lZFR1cGxlOiAoKSA9PiBpc1R5cGVOYW1lZFR1cGxlLFxuICBpc1R5cGVOb25aZXJvOiAoKSA9PiBpc1R5cGVOb25aZXJvLFxuICBpc1R5cGVPcHRpb246ICgpID0+IGlzVHlwZU9wdGlvbixcbiAgaXNUeXBlUmVzdWx0OiAoKSA9PiBpc1R5cGVSZXN1bHQsXG4gIGlzVHlwZVNlY3AyNTZrMVBvaW50OiAoKSA9PiBpc1R5cGVTZWNwMjU2azFQb2ludCxcbiAgaXNUeXBlU3RydWN0OiAoKSA9PiBpc1R5cGVTdHJ1Y3QsXG4gIGlzVHlwZVR1cGxlOiAoKSA9PiBpc1R5cGVUdXBsZSxcbiAgaXNUeXBlVWludDogKCkgPT4gaXNUeXBlVWludCxcbiAgaXNUeXBlVWludDI1NjogKCkgPT4gaXNUeXBlVWludDI1NixcbiAgdHVwbGU6ICgpID0+IHR1cGxlLFxuICB1aW50MjU2OiAoKSA9PiB1aW50MjU2LFxuICB1aW50NTEyOiAoKSA9PiB1aW50NTEyXG59KTtcblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL2ZlbHQudHNcbmZ1bmN0aW9uIENhaXJvRmVsdChpdCkge1xuICBpZiAoaXNCaWdJbnQoaXQpIHx8IE51bWJlci5pc0ludGVnZXIoaXQpKSB7XG4gICAgcmV0dXJuIGl0LnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKGlzU3RyaW5nKGl0KSkge1xuICAgIGlmIChpc0hleChpdCkpIHtcbiAgICAgIHJldHVybiBCaWdJbnQoaXQpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc1RleHQoaXQpKSB7XG4gICAgICBpZiAoIWlzU2hvcnRTdHJpbmcoaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtpdH0gaXMgYSBsb25nIHN0cmluZyA+IDMxIGNoYXJzLiBQbGVhc2Ugc3BsaXQgaXQgaW50byBhbiBhcnJheSBvZiBzaG9ydCBzdHJpbmdzLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoaXQpKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmdXaG9sZU51bWJlcihpdCkpIHtcbiAgICAgIHJldHVybiBpdDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQm9vbGVhbihpdCkpIHtcbiAgICByZXR1cm4gYCR7K2l0fWA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGAke2l0fSBjYW4ndCBiZSBjb21wdXRlZCBieSBmZWx0KClgKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhaXJvRGF0YVR5cGVzL3VpbnQyNTYudHNcbnZhciBVSU5UXzEyOF9NQVggPSAoMW4gPDwgMTI4bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NQVggPSAoMW4gPDwgMjU2bikgLSAxbjtcbnZhciBVSU5UXzI1Nl9NSU4gPSAwbjtcbnZhciBVSU5UXzI1Nl9MT1dfTUFYID0gMzQwMjgyMzY2OTIwOTM4NDYzNDYzMzc0NjA3NDMxNzY4MjExNDU1bjtcbnZhciBVSU5UXzI1Nl9ISUdIX01BWCA9IDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NW47XG52YXIgVUlOVF8yNTZfTE9XX01JTiA9IDBuO1xudmFyIFVJTlRfMjU2X0hJR0hfTUlOID0gMG47XG52YXIgQ2Fpcm9VaW50MjU2ID0gY2xhc3MgX0NhaXJvVWludDI1NiB7XG4gIGxvdztcbiAgaGlnaDtcbiAgc3RhdGljIGFiaVNlbGVjdG9yID0gXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCI7XG4gIGNvbnN0cnVjdG9yKC4uLmFycikge1xuICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSBcIm9iamVjdFwiICYmIGFyci5sZW5ndGggPT09IDEgJiYgXCJsb3dcIiBpbiBhcnJbMF0gJiYgXCJoaWdoXCIgaW4gYXJyWzBdKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQyNTYudmFsaWRhdGVQcm9wcyhhcnJbMF0ubG93LCBhcnJbMF0uaGlnaCk7XG4gICAgICB0aGlzLmxvdyA9IHByb3BzLmxvdztcbiAgICAgIHRoaXMuaGlnaCA9IHByb3BzLmhpZ2g7XG4gICAgfSBlbHNlIGlmIChhcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBiaWdJbnQgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlKGFyclswXSk7XG4gICAgICB0aGlzLmxvdyA9IGJpZ0ludCAmIFVJTlRfMTI4X01BWDtcbiAgICAgIHRoaXMuaGlnaCA9IGJpZ0ludCA+PiAxMjhuO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50MjU2LnZhbGlkYXRlUHJvcHMoYXJyWzBdLCBhcnJbMV0pO1xuICAgICAgdGhpcy5sb3cgPSBwcm9wcy5sb3c7XG4gICAgICB0aGlzLmhpZ2ggPSBwcm9wcy5oaWdoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkluY29ycmVjdCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUoYmlnTnVtYmVyaXNoKSB7XG4gICAgY29uc3QgYmlnSW50ID0gQmlnSW50KGJpZ051bWJlcmlzaCk7XG4gICAgaWYgKGJpZ0ludCA8IFVJTlRfMjU2X01JTikgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgc21hbGxlciB0aGFuIFVJTlRfMjU2X01JTlwiKTtcbiAgICBpZiAoYmlnSW50ID4gVUlOVF8yNTZfTUFYKSB0aHJvdyBuZXcgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgYmlnZ2VyIHRoYW4gVUlOVF8yNTZfTUFYXCIpO1xuICAgIHJldHVybiBiaWdJbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGlmIGxvdyBhbmQgaGlnaCBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVW5pdDI1NlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlUHJvcHMobG93LCBoaWdoKSB7XG4gICAgY29uc3QgYmlnSW50TG93ID0gQmlnSW50KGxvdyk7XG4gICAgY29uc3QgYmlnSW50SGlnaCA9IEJpZ0ludChoaWdoKTtcbiAgICBpZiAoYmlnSW50TG93IDwgVUlOVF8yNTZfTE9XX01JTiB8fCBiaWdJbnRMb3cgPiBVSU5UXzI1Nl9MT1dfTUFYKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb3cgaXMgb3V0IG9mIHJhbmdlIFVJTlRfMjU2X0xPV19NSU4gLSBVSU5UXzI1Nl9MT1dfTUFYXCIpO1xuICAgIH1cbiAgICBpZiAoYmlnSW50SGlnaCA8IFVJTlRfMjU2X0hJR0hfTUlOIHx8IGJpZ0ludEhpZ2ggPiBVSU5UXzI1Nl9ISUdIX01BWCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGlnaCBpcyBvdXQgb2YgcmFuZ2UgVUlOVF8yNTZfSElHSF9NSU4gLSBVSU5UXzI1Nl9ISUdIX01BWFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbG93OiBiaWdJbnRMb3csIGhpZ2g6IGJpZ0ludEhpZ2ggfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVbml0MjU2XG4gICAqL1xuICBzdGF0aWMgaXMoYmlnTnVtYmVyaXNoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF9DYWlyb1VpbnQyNTYudmFsaWRhdGUoYmlnTnVtYmVyaXNoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcHJvdmlkZWQgYWJpIHR5cGUgaXMgdGhpcyBkYXRhIHR5cGVcbiAgICovXG4gIHN0YXRpYyBpc0FiaVR5cGUoYWJpVHlwZSkge1xuICAgIHJldHVybiBhYmlUeXBlID09PSBfQ2Fpcm9VaW50MjU2LmFiaVNlbGVjdG9yO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYmlnaW50IHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICB0b0JpZ0ludCgpIHtcbiAgICByZXR1cm4gKHRoaXMuaGlnaCA8PCAxMjhuKSArIHRoaXMubG93O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDI1NiBzdHJ1Y3R1cmUgd2l0aCBIZXhTdHJpbmcgcHJvcHNcbiAgICoge2xvdzogSGV4U3RyaW5nLCBoaWdoOiBIZXhTdHJpbmd9XG4gICAqL1xuICB0b1VpbnQyNTZIZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvdzogYWRkSGV4UHJlZml4KHRoaXMubG93LnRvU3RyaW5nKDE2KSksXG4gICAgICBoaWdoOiBhZGRIZXhQcmVmaXgodGhpcy5oaWdoLnRvU3RyaW5nKDE2KSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDI1NiBzdHJ1Y3R1cmUgd2l0aCBEZWNpbWFsU3RyaW5nIHByb3BzXG4gICAqIHtsb3c6IERlY1N0cmluZywgaGlnaDogRGVjU3RyaW5nfVxuICAgKi9cbiAgdG9VaW50MjU2RGVjaW1hbFN0cmluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG93OiB0aGlzLmxvdy50b1N0cmluZygxMCksXG4gICAgICBoaWdoOiB0aGlzLmhpZ2gudG9TdHJpbmcoMTApXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFwaSByZXF1ZXN0cyByZXByZXNlbnRhdGlvbiB3aXRjaCBpcyBmZWx0IGFycmF5XG4gICAqL1xuICB0b0FwaVJlcXVlc3QoKSB7XG4gICAgcmV0dXJuIFtDYWlyb0ZlbHQodGhpcy5sb3cpLCBDYWlyb0ZlbHQodGhpcy5oaWdoKV07XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWlyb0RhdGFUeXBlcy91aW50NTEyLnRzXG52YXIgVUlOVF81MTJfTUFYID0gKDFuIDw8IDUxMm4pIC0gMW47XG52YXIgVUlOVF81MTJfTUlOID0gMG47XG52YXIgVUlOVF8xMjhfTUlOID0gMG47XG52YXIgQ2Fpcm9VaW50NTEyID0gY2xhc3MgX0NhaXJvVWludDUxMiB7XG4gIGxpbWIwO1xuICBsaW1iMTtcbiAgbGltYjI7XG4gIGxpbWIzO1xuICBzdGF0aWMgYWJpU2VsZWN0b3IgPSBcImNvcmU6OmludGVnZXI6OnU1MTJcIjtcbiAgY29uc3RydWN0b3IoLi4uYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwib2JqZWN0XCIgJiYgYXJyLmxlbmd0aCA9PT0gMSAmJiBcImxpbWIwXCIgaW4gYXJyWzBdICYmIFwibGltYjFcIiBpbiBhcnJbMF0gJiYgXCJsaW1iMlwiIGluIGFyclswXSAmJiBcImxpbWIzXCIgaW4gYXJyWzBdKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IF9DYWlyb1VpbnQ1MTIudmFsaWRhdGVQcm9wcyhcbiAgICAgICAgYXJyWzBdLmxpbWIwLFxuICAgICAgICBhcnJbMF0ubGltYjEsXG4gICAgICAgIGFyclswXS5saW1iMixcbiAgICAgICAgYXJyWzBdLmxpbWIzXG4gICAgICApO1xuICAgICAgdGhpcy5saW1iMCA9IHByb3BzLmxpbWIwO1xuICAgICAgdGhpcy5saW1iMSA9IHByb3BzLmxpbWIxO1xuICAgICAgdGhpcy5saW1iMiA9IHByb3BzLmxpbWIyO1xuICAgICAgdGhpcy5saW1iMyA9IHByb3BzLmxpbWIzO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgYmlnSW50ID0gX0NhaXJvVWludDUxMi52YWxpZGF0ZShhcnJbMF0pO1xuICAgICAgdGhpcy5saW1iMCA9IGJpZ0ludCAmIFVJTlRfMTI4X01BWDtcbiAgICAgIHRoaXMubGltYjEgPSAoYmlnSW50ICYgVUlOVF8xMjhfTUFYIDw8IDEyOG4pID4+IDEyOG47XG4gICAgICB0aGlzLmxpbWIyID0gKGJpZ0ludCAmIFVJTlRfMTI4X01BWCA8PCAyNTZuKSA+PiAyNTZuO1xuICAgICAgdGhpcy5saW1iMyA9IGJpZ0ludCA+PiAzODRuO1xuICAgIH0gZWxzZSBpZiAoYXJyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3QgcHJvcHMgPSBfQ2Fpcm9VaW50NTEyLnZhbGlkYXRlUHJvcHMoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSwgYXJyWzNdKTtcbiAgICAgIHRoaXMubGltYjAgPSBwcm9wcy5saW1iMDtcbiAgICAgIHRoaXMubGltYjEgPSBwcm9wcy5saW1iMTtcbiAgICAgIHRoaXMubGltYjIgPSBwcm9wcy5saW1iMjtcbiAgICAgIHRoaXMubGltYjMgPSBwcm9wcy5saW1iMztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbmNvcnJlY3QgVWludDUxMiBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgaWYgQmlnTnVtYmVyaXNoIGNhbiBiZSByZXByZXNlbnRlZCBhcyBVaW50NTEyXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGUoYmlnTnVtYmVyaXNoKSB7XG4gICAgY29uc3QgYmlnSW50ID0gQmlnSW50KGJpZ051bWJlcmlzaCk7XG4gICAgaWYgKGJpZ0ludCA8IFVJTlRfNTEyX01JTikgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgc21hbGxlciB0aGFuIFVJTlRfNTEyX01JTi5cIik7XG4gICAgaWYgKGJpZ0ludCA+IFVJTlRfNTEyX01BWCkgdGhyb3cgRXJyb3IoXCJiaWdOdW1iZXJpc2ggaXMgYmlnZ2VyIHRoYW4gVUlOVF81MTJfTUFYLlwiKTtcbiAgICByZXR1cm4gYmlnSW50O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiBsaW1icyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgVWludDUxMlxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlUHJvcHMobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpIHtcbiAgICBjb25zdCBsMCA9IEJpZ0ludChsaW1iMCk7XG4gICAgY29uc3QgbDEgPSBCaWdJbnQobGltYjEpO1xuICAgIGNvbnN0IGwyID0gQmlnSW50KGxpbWIyKTtcbiAgICBjb25zdCBsMyA9IEJpZ0ludChsaW1iMyk7XG4gICAgW2wwLCBsMSwgbDIsIGwzXS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA8IFVJTlRfMTI4X01JTiB8fCB2YWx1ZSA+IFVJTlRfMTI4X01BWCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgbGltYiR7aW5kZXh9IGlzIG5vdCBpbiB0aGUgcmFuZ2Ugb2YgYSB1MTI4IG51bWJlcmApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IGxpbWIwOiBsMCwgbGltYjE6IGwxLCBsaW1iMjogbDIsIGxpbWIzOiBsMyB9O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBCaWdOdW1iZXJpc2ggY2FuIGJlIHJlcHJlc2VudGVkIGFzIFVpbnQ1MTJcbiAgICovXG4gIHN0YXRpYyBpcyhiaWdOdW1iZXJpc2gpIHtcbiAgICB0cnkge1xuICAgICAgX0NhaXJvVWludDUxMi52YWxpZGF0ZShiaWdOdW1iZXJpc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwcm92aWRlZCBhYmkgdHlwZSBpcyB0aGlzIGRhdGEgdHlwZVxuICAgKi9cbiAgc3RhdGljIGlzQWJpVHlwZShhYmlUeXBlKSB7XG4gICAgcmV0dXJuIGFiaVR5cGUgPT09IF9DYWlyb1VpbnQ1MTIuYWJpU2VsZWN0b3I7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBiaWdpbnQgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIHRvQmlnSW50KCkge1xuICAgIHJldHVybiAodGhpcy5saW1iMyA8PCAzODRuKSArICh0aGlzLmxpbWIyIDw8IDI1Nm4pICsgKHRoaXMubGltYjEgPDwgMTI4bikgKyB0aGlzLmxpbWIwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVWludDUxMiBzdHJ1Y3R1cmUgd2l0aCBIZXhTdHJpbmcgcHJvcHNcbiAgICogbGltYng6IEhleFN0cmluZ1xuICAgKi9cbiAgdG9VaW50NTEySGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1iMDogYWRkSGV4UHJlZml4KHRoaXMubGltYjAudG9TdHJpbmcoMTYpKSxcbiAgICAgIGxpbWIxOiBhZGRIZXhQcmVmaXgodGhpcy5saW1iMS50b1N0cmluZygxNikpLFxuICAgICAgbGltYjI6IGFkZEhleFByZWZpeCh0aGlzLmxpbWIyLnRvU3RyaW5nKDE2KSksXG4gICAgICBsaW1iMzogYWRkSGV4UHJlZml4KHRoaXMubGltYjMudG9TdHJpbmcoMTYpKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBVaW50NTEyIHN0cnVjdHVyZSB3aXRoIERlY2ltYWxTdHJpbmcgcHJvcHNcbiAgICogbGltYnggRGVjU3RyaW5nXG4gICAqL1xuICB0b1VpbnQ1MTJEZWNpbWFsU3RyaW5nKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW1iMDogdGhpcy5saW1iMC50b1N0cmluZygxMCksXG4gICAgICBsaW1iMTogdGhpcy5saW1iMS50b1N0cmluZygxMCksXG4gICAgICBsaW1iMjogdGhpcy5saW1iMi50b1N0cmluZygxMCksXG4gICAgICBsaW1iMzogdGhpcy5saW1iMy50b1N0cmluZygxMClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXBpIHJlcXVlc3RzIHJlcHJlc2VudGF0aW9uIHdpdGNoIGlzIGZlbHQgYXJyYXlcbiAgICovXG4gIHRvQXBpUmVxdWVzdCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjApLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjEpLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjIpLFxuICAgICAgQ2Fpcm9GZWx0KHRoaXMubGltYjMpXG4gICAgXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2NhaXJvLnRzXG52YXIgaXNMZW4gPSAobmFtZSkgPT4gL19sZW4kLy50ZXN0KG5hbWUpO1xudmFyIGlzVHlwZUZlbHQgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJmZWx0XCIgfHwgdHlwZSA9PT0gXCJjb3JlOjpmZWx0MjUyXCI7XG52YXIgaXNUeXBlQXJyYXkgPSAodHlwZSkgPT4gL1xcKi8udGVzdCh0eXBlKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6QXJyYXk6OlwiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjphcnJheTo6U3Bhbjo6XCIpO1xudmFyIGlzVHlwZVR1cGxlID0gKHR5cGUpID0+IC9eXFwoLipcXCkkL2kudGVzdCh0eXBlKTtcbnZhciBpc1R5cGVOYW1lZFR1cGxlID0gKHR5cGUpID0+IC9cXCguKlxcKS9pLnRlc3QodHlwZSkgJiYgdHlwZS5pbmNsdWRlcyhcIjpcIik7XG52YXIgaXNUeXBlU3RydWN0ID0gKHR5cGUsIHN0cnVjdHMpID0+IHR5cGUgaW4gc3RydWN0cztcbnZhciBpc1R5cGVFbnVtID0gKHR5cGUsIGVudW1zKSA9PiB0eXBlIGluIGVudW1zO1xudmFyIGlzVHlwZU9wdGlvbiA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpvcHRpb246Ok9wdGlvbjo6XCIpO1xudmFyIGlzVHlwZVJlc3VsdCA9ICh0eXBlKSA9PiB0eXBlLnN0YXJ0c1dpdGgoXCJjb3JlOjpyZXN1bHQ6OlJlc3VsdDo6XCIpO1xudmFyIGlzVHlwZVVpbnQgPSAodHlwZSkgPT4gT2JqZWN0LnZhbHVlcyhVaW50KS5pbmNsdWRlcyh0eXBlKTtcbnZhciBpc1R5cGVVaW50MjU2ID0gKHR5cGUpID0+IENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk7XG52YXIgaXNUeXBlTGl0ZXJhbCA9ICh0eXBlKSA9PiBPYmplY3QudmFsdWVzKExpdGVyYWwpLmluY2x1ZGVzKHR5cGUpO1xudmFyIGlzVHlwZUJvb2wgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpib29sXCI7XG52YXIgaXNUeXBlQ29udHJhY3RBZGRyZXNzID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmNvbnRyYWN0X2FkZHJlc3M6OkNvbnRyYWN0QWRkcmVzc1wiO1xudmFyIGlzVHlwZUV0aEFkZHJlc3MgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpzdGFya25ldDo6ZXRoX2FkZHJlc3M6OkV0aEFkZHJlc3NcIjtcbnZhciBpc1R5cGVCeXRlczMxID0gKHR5cGUpID0+IHR5cGUgPT09IFwiY29yZTo6Ynl0ZXNfMzE6OmJ5dGVzMzFcIjtcbnZhciBpc1R5cGVCeXRlQXJyYXkgPSAodHlwZSkgPT4gdHlwZSA9PT0gXCJjb3JlOjpieXRlX2FycmF5OjpCeXRlQXJyYXlcIjtcbnZhciBpc1R5cGVTZWNwMjU2azFQb2ludCA9ICh0eXBlKSA9PiB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpzZWNwMjU2azE6OlNlY3AyNTZrMVBvaW50XCI7XG52YXIgaXNDYWlybzFUeXBlID0gKHR5cGUpID0+IHR5cGUuaW5jbHVkZXMoXCI6OlwiKTtcbnZhciBnZXRBcnJheVR5cGUgPSAodHlwZSkgPT4ge1xuICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHR5cGUuc3Vic3RyaW5nKHR5cGUuaW5kZXhPZihcIjxcIikgKyAxLCB0eXBlLmxhc3RJbmRleE9mKFwiPlwiKSk7XG4gIH1cbiAgcmV0dXJuIHR5cGUucmVwbGFjZShcIipcIiwgXCJcIik7XG59O1xuZnVuY3Rpb24gaXNDYWlybzFBYmkoYWJpKSB7XG4gIGNvbnN0IHsgY2Fpcm8gfSA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihhYmkpO1xuICBpZiAoY2Fpcm8gPT09IHZvaWQgMCkge1xuICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGRldGVybWluZSBDYWlybyB2ZXJzaW9uXCIpO1xuICB9XG4gIHJldHVybiBjYWlybyA9PT0gXCIxXCI7XG59XG5mdW5jdGlvbiBpc1R5cGVOb25aZXJvKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuc3RhcnRzV2l0aChcImNvcmU6Onplcm9hYmxlOjpOb25aZXJvOjpcIik7XG59XG5mdW5jdGlvbiBnZXRBYmlDb250cmFjdFZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKSB7XG4gICAgcmV0dXJuIHsgY2Fpcm86IFwiMVwiLCBjb21waWxlcjogXCIyXCIgfTtcbiAgfVxuICBjb25zdCB0ZXN0RnVuY3Rpb24gPSBhYmkuZmluZChcbiAgICAoaXQpID0+IGl0LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiAoaXQuaW5wdXRzLmxlbmd0aCB8fCBpdC5vdXRwdXRzLmxlbmd0aClcbiAgKTtcbiAgaWYgKCF0ZXN0RnVuY3Rpb24pIHtcbiAgICByZXR1cm4geyBjYWlybzogdm9pZCAwLCBjb21waWxlcjogdm9pZCAwIH07XG4gIH1cbiAgY29uc3QgaW8gPSB0ZXN0RnVuY3Rpb24uaW5wdXRzLmxlbmd0aCA/IHRlc3RGdW5jdGlvbi5pbnB1dHMgOiB0ZXN0RnVuY3Rpb24ub3V0cHV0cztcbiAgaWYgKGlzQ2Fpcm8xVHlwZShpb1swXS50eXBlKSkge1xuICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IFwiMVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgY2Fpcm86IFwiMFwiLCBjb21waWxlcjogXCIwXCIgfTtcbn1cbnZhciB1aW50MjU2ID0gKGl0KSA9PiB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGl0KS50b1VpbnQyNTZEZWNpbWFsU3RyaW5nKCk7XG59O1xudmFyIHVpbnQ1MTIgPSAoaXQpID0+IHtcbiAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIoaXQpLnRvVWludDUxMkRlY2ltYWxTdHJpbmcoKTtcbn07XG52YXIgdHVwbGUgPSAoLi4uYXJncykgPT4gKHsgLi4uYXJncyB9KTtcbmZ1bmN0aW9uIGZlbHQoaXQpIHtcbiAgcmV0dXJuIENhaXJvRmVsdChpdCk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9lbnVtL0NhaXJvQ3VzdG9tRW51bS50c1xudmFyIENhaXJvQ3VzdG9tRW51bSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIGRpcmVjdCByZWFkb25seSBhY2Nlc3MgdG8gdmFyaWFudHMgb2YgdGhlIENhaXJvIEN1c3RvbSBFbnVtLlxuICAgKiBAcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgYW55XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgc3VjY2Vzc1ZhbHVlID0gbXlDYWlyb0VudW0udmFyaWFudC5TdWNjZXNzO1xuICAgKi9cbiAgdmFyaWFudDtcbiAgLyoqXG4gICAqIEBwYXJhbSBlbnVtQ29udGVudCBhbiBvYmplY3Qgd2l0aCB0aGUgdmFyaWFudHMgYXMga2V5cyBhbmQgdGhlIGNvbnRlbnQgYXMgdmFsdWUuIE9ubHkgb25lIGNvbnRlbnQgc2hhbGwgYmUgZGVmaW5lZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudW1Db250ZW50KSB7XG4gICAgY29uc3QgdmFyaWFudHNMaXN0ID0gT2JqZWN0LnZhbHVlcyhlbnVtQ29udGVudCk7XG4gICAgaWYgKHZhcmlhbnRzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRW51bSBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBuYkFjdGl2ZVZhcmlhbnRzID0gdmFyaWFudHNMaXN0LmZpbHRlcihcbiAgICAgIChjb250ZW50KSA9PiB0eXBlb2YgY29udGVudCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICkubGVuZ3RoO1xuICAgIGlmIChuYkFjdGl2ZVZhcmlhbnRzICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIEVudW0gbXVzdCBoYXZlIGV4YWN0bHkgb25lIGFjdGl2ZSB2YXJpYW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhbnQgPSBlbnVtQ29udGVudDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZhbGlkIHZhcmlhbnQgb2YgYSBDYWlybyBjdXN0b20gRW51bS5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVWYXJpYW50WzFdO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIGN1c3RvbSBFbnVtLlxuICAgKi9cbiAgYWN0aXZlVmFyaWFudCgpIHtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFudCk7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IHR5cGVvZiBpdGVtWzFdICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZVZhcmlhbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlVmFyaWFudFswXTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9PcHRpb24udHNcbnZhciBDYWlyb09wdGlvblZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb09wdGlvblZhcmlhbnQyKSA9PiB7XG4gIENhaXJvT3B0aW9uVmFyaWFudDJbQ2Fpcm9PcHRpb25WYXJpYW50MltcIlNvbWVcIl0gPSAwXSA9IFwiU29tZVwiO1xuICBDYWlyb09wdGlvblZhcmlhbnQyW0NhaXJvT3B0aW9uVmFyaWFudDJbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgcmV0dXJuIENhaXJvT3B0aW9uVmFyaWFudDI7XG59KShDYWlyb09wdGlvblZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvT3B0aW9uID0gY2xhc3Mge1xuICBTb21lO1xuICBOb25lO1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCBzb21lQ29udGVudCkge1xuICAgIGlmICghKHZhcmlhbnQgaW4gQ2Fpcm9PcHRpb25WYXJpYW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdmFyaWFudCA6IHNob3VsZCBiZSBDYWlyb09wdGlvblZhcmlhbnQuU29tZSBvciAuTm9uZS5cIik7XG4gICAgfVxuICAgIGlmICh2YXJpYW50ID09PSAwIC8qIFNvbWUgKi8pIHtcbiAgICAgIGlmICh0eXBlb2Ygc29tZUNvbnRlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgY3JlYXRpb24gb2YgYSBDYWlybyBPcHRpb24gd2l0aCBcIlNvbWVcIiB2YXJpYW50IG5lZWRzIGEgY29udGVudCBhcyBpbnB1dC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLlNvbWUgPSBzb21lQ29udGVudDtcbiAgICAgIHRoaXMuTm9uZSA9IHZvaWQgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5Tb21lID0gdm9pZCAwO1xuICAgICAgdGhpcy5Ob25lID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSB2YWxpZCB2YXJpYW50IG9mIGEgQ2Fpcm8gY3VzdG9tIEVudW0uXG4gICAqICBJZiBOb25lLCByZXR1cm5zICd1bmRlZmluZWQnLlxuICAgKi9cbiAgdW53cmFwKCkge1xuICAgIGlmICh0aGlzLk5vbmUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLlNvbWU7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzU29tZScuXG4gICAqL1xuICBpc1NvbWUoKSB7XG4gICAgcmV0dXJuICEodHlwZW9mIHRoaXMuU29tZSA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzTm9uZScuXG4gICAqL1xuICBpc05vbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuTm9uZSA9PT0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2VudW0vQ2Fpcm9SZXN1bHQudHNcbnZhciBDYWlyb1Jlc3VsdFZhcmlhbnQgPSAvKiBAX19QVVJFX18gKi8gKChDYWlyb1Jlc3VsdFZhcmlhbnQyKSA9PiB7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIk9rXCJdID0gMF0gPSBcIk9rXCI7XG4gIENhaXJvUmVzdWx0VmFyaWFudDJbQ2Fpcm9SZXN1bHRWYXJpYW50MltcIkVyclwiXSA9IDFdID0gXCJFcnJcIjtcbiAgcmV0dXJuIENhaXJvUmVzdWx0VmFyaWFudDI7XG59KShDYWlyb1Jlc3VsdFZhcmlhbnQgfHwge30pO1xudmFyIENhaXJvUmVzdWx0ID0gY2xhc3Mge1xuICBPaztcbiAgRXJyO1xuICBjb25zdHJ1Y3Rvcih2YXJpYW50LCByZXN1bHRDb250ZW50KSB7XG4gICAgaWYgKCEodmFyaWFudCBpbiBDYWlyb1Jlc3VsdFZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB2YXJpYW50IDogc2hvdWxkIGJlIENhaXJvUmVzdWx0VmFyaWFudC5PayBvciAuRXJyLlwiKTtcbiAgICB9XG4gICAgaWYgKHZhcmlhbnQgPT09IDAgLyogT2sgKi8pIHtcbiAgICAgIHRoaXMuT2sgPSByZXN1bHRDb250ZW50O1xuICAgICAgdGhpcy5FcnIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT2sgPSB2b2lkIDA7XG4gICAgICB0aGlzLkVyciA9IHJlc3VsdENvbnRlbnQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgdmFsaWQgdmFyaWFudCBvZiBhIENhaXJvIFJlc3VsdC5cbiAgICovXG4gIHVud3JhcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuT2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLk9rO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuRXJyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5FcnI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggUmVzdWx0Lk9rIGFuZCAuRXJyIGFyZSB1bmRlZmluZWQuIE5vdCBhdXRob3JpemVkLlwiKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsaWQgdmFyaWFudCBpcyAnT2snLlxuICAgKi9cbiAgaXNPaygpIHtcbiAgICByZXR1cm4gISh0eXBlb2YgdGhpcy5PayA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZhbGlkIHZhcmlhbnQgaXMgJ2lzRXJyJy5cbiAgICovXG4gIGlzRXJyKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB0aGlzLkVyciA9PT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9mb3JtYXR0ZXIudHNcbnZhciBndWFyZCA9IHtcbiAgaXNCTjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIGlmICghaXNCaWdJbnQoZGF0YVtrZXldKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYERhdGEgYW5kIGZvcm1hdHRlciBtaXNtYXRjaCBvbiAke2tleX06JHt0eXBlW2tleV19LCBleHBlY3RlZCByZXNwb25zZSBkYXRhICR7a2V5fToke2RhdGFba2V5XX0gdG8gYmUgQk4gaW5zdGVhZCBpdCBpcyAke3R5cGVvZiBkYXRhW2tleV19YFxuICAgICAgKTtcbiAgfSxcbiAgdW5rbm93bjogKGRhdGEsIHR5cGUsIGtleSkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGZvcm1hdHRlciB0eXBlIG9uICR7a2V5fToke3R5cGVba2V5XX0gZm9yIGRhdGEgJHtrZXl9OiR7ZGF0YVtrZXldfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZm9ybWF0dGVyKGRhdGEsIHR5cGUsIHNhbWVUeXBlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoXG4gICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjb25zdCBlbFR5cGUgPSBzYW1lVHlwZSA/PyB0eXBlW2tleV07XG4gICAgICBpZiAoIShrZXkgaW4gdHlwZSkgJiYgIXNhbWVUeXBlKSB7XG4gICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBpZiAoZWxUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkpIHtcbiAgICAgICAgICBjb25zdCBhcnJheVN0ciA9IGZvcm1hdHRlcihcbiAgICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICAgIGRhdGFba2V5XS5tYXAoKF8pID0+IGVsVHlwZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGFjY1trZXldID0gT2JqZWN0LnZhbHVlcyhhcnJheVN0cikuam9pbihcIlwiKTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgICAgYWNjW2tleV0gPSBkZWNvZGVTaG9ydFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBpZiAoZWxUeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGd1YXJkLmlzQk4oZGF0YSwgdHlwZSwga2V5KTtcbiAgICAgICAgYWNjW2tleV0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBhY2Nba2V5XSA9IGVsVHlwZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5T2JqID0gZm9ybWF0dGVyKGRhdGFba2V5XSwgZWxUeXBlLCBlbFR5cGVbMF0pO1xuICAgICAgICBhY2Nba2V5XSA9IE9iamVjdC52YWx1ZXMoYXJyYXlPYmopO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgYWNjW2tleV0gPSBmb3JtYXR0ZXIoZGF0YVtrZXldLCBlbFR5cGUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgZ3VhcmQudW5rbm93bihkYXRhLCB0eXBlLCBrZXkpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvcGFyc2VyLTAtMS4xLjAudHNcbnZhciBBYmlQYXJzZXIxID0gY2xhc3Mge1xuICBhYmk7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICB9XG4gIC8qKlxuICAgKiBhYmkgbWV0aG9kIGlucHV0cyBsZW5ndGggd2l0aG91dCAnX2xlbicgaW5wdXRzXG4gICAqIGNhaXJvIDAgcmVkdWNlclxuICAgKiBAcGFyYW0gYWJpTWV0aG9kIEZ1bmN0aW9uQWJpXG4gICAqIEByZXR1cm5zIG51bWJlclxuICAgKi9cbiAgbWV0aG9kSW5wdXRzTGVuZ3RoKGFiaU1ldGhvZCkge1xuICAgIHJldHVybiBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4gIWlzTGVuKGlucHV0Lm5hbWUpID8gYWNjICsgMSA6IGFjYywgMCk7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGFiaVxuICAgKiBAcGFyYW0gbmFtZSBzdHJpbmdcbiAgICogQHJldHVybnMgRnVuY3Rpb25BYmkgfCB1bmRlZmluZWRcbiAgICovXG4gIGdldE1ldGhvZChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJpLmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3BhcnNlci9wYXJzZXItMi4wLjAudHNcbnZhciBBYmlQYXJzZXIyID0gY2xhc3Mge1xuICBhYmk7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuYWJpID0gYWJpO1xuICB9XG4gIC8qKlxuICAgKiBhYmkgbWV0aG9kIGlucHV0cyBsZW5ndGhcbiAgICogQHBhcmFtIGFiaU1ldGhvZCBGdW5jdGlvbkFiaVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIG1ldGhvZElucHV0c0xlbmd0aChhYmlNZXRob2QpIHtcbiAgICByZXR1cm4gYWJpTWV0aG9kLmlucHV0cy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBtZXRob2QgZGVmaW5pdGlvbiBmcm9tIGFiaVxuICAgKiBAcGFyYW0gbmFtZSBzdHJpbmdcbiAgICogQHJldHVybnMgRnVuY3Rpb25BYmkgfCB1bmRlZmluZWRcbiAgICovXG4gIGdldE1ldGhvZChuYW1lKSB7XG4gICAgY29uc3QgaW50ZiA9IHRoaXMuYWJpLmZpbmQoXG4gICAgICAoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCJcbiAgICApO1xuICAgIHJldHVybiBpbnRmLml0ZW1zLmZpbmQoKGl0KSA9PiBpdC5uYW1lID09PSBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IEFiaSBpbiBsZWdhY3kgZm9ybWF0XG4gICAqIEByZXR1cm5zIEFiaVxuICAgKi9cbiAgZ2V0TGVnYWN5Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmFiaS5mbGF0TWFwKChlKSA9PiB7XG4gICAgICBpZiAoZS50eXBlID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgIHJldHVybiBlLml0ZW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wYXJzZXIvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZUFiaVBhcnNlcihhYmkpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGdldEFiaVZlcnNpb24oYWJpKTtcbiAgaWYgKHZlcnNpb24gPT09IDAgfHwgdmVyc2lvbiA9PT0gMSkge1xuICAgIHJldHVybiBuZXcgQWJpUGFyc2VyMShhYmkpO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAyKSB7XG4gICAgcmV0dXJuIG5ldyBBYmlQYXJzZXIyKGFiaSk7XG4gIH1cbiAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIEFCSSB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbn1cbmZ1bmN0aW9uIGdldEFiaVZlcnNpb24oYWJpKSB7XG4gIGlmIChhYmkuZmluZCgoaXQpID0+IGl0LnR5cGUgPT09IFwiaW50ZXJmYWNlXCIpKSByZXR1cm4gMjtcbiAgaWYgKGlzQ2Fpcm8xQWJpKGFiaSkpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJnc0NhbGxkYXRhLCBhYmlNZXRob2QpIHtcbiAgcmV0dXJuIG1ldGhvZCA9PT0gXCJjb25zdHJ1Y3RvclwiICYmICFhYmlNZXRob2QgJiYgIWFyZ3NDYWxsZGF0YS5sZW5ndGg7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS90dXBsZS50c1xuZnVuY3Rpb24gcGFyc2VOYW1lZFR1cGxlKG5hbWVkVHVwbGUpIHtcbiAgY29uc3QgbmFtZSA9IG5hbWVkVHVwbGUuc3Vic3RyaW5nKDAsIG5hbWVkVHVwbGUuaW5kZXhPZihcIjpcIikpO1xuICBjb25zdCB0eXBlID0gbmFtZWRUdXBsZS5zdWJzdHJpbmcobmFtZS5sZW5ndGggKyBcIjpcIi5sZW5ndGgpO1xuICByZXR1cm4geyBuYW1lLCB0eXBlIH07XG59XG5mdW5jdGlvbiBwYXJzZVN1YlR1cGxlKHMpIHtcbiAgaWYgKCFzLmluY2x1ZGVzKFwiKFwiKSkgcmV0dXJuIHsgc3ViVHVwbGU6IFtdLCByZXN1bHQ6IHMgfTtcbiAgY29uc3Qgc3ViVHVwbGUgPSBbXTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBzLmxlbmd0aCkge1xuICAgIGlmIChzW2ldID09PSBcIihcIikge1xuICAgICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgICAgY29uc3QgbEJyYWNrZXQgPSBpO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGNvdW50ZXIpIHtcbiAgICAgICAgaWYgKHNbaV0gPT09IFwiKVwiKSBjb3VudGVyLS07XG4gICAgICAgIGlmIChzW2ldID09PSBcIihcIikgY291bnRlcisrO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBzdWJUdXBsZS5wdXNoKHMuc3Vic3RyaW5nKGxCcmFja2V0LCBpKSk7XG4gICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICBpLS07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSBzW2ldO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdWJUdXBsZSxcbiAgICByZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDYWlybzBUdXBsZSh0eXBlKSB7XG4gIGNvbnN0IGNsZWFuVHlwZSA9IHR5cGUucmVwbGFjZSgvXFxzL2csIFwiXCIpLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgeyBzdWJUdXBsZSwgcmVzdWx0IH0gPSBwYXJzZVN1YlR1cGxlKGNsZWFuVHlwZSk7XG4gIGxldCByZWNvbXBvc2VkID0gcmVzdWx0LnNwbGl0KFwiLFwiKS5tYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIHN1YlR1cGxlLmxlbmd0aCA/IGl0LnJlcGxhY2UoXCIgXCIsIHN1YlR1cGxlLnNoaWZ0KCkpIDogaXQ7XG4gIH0pO1xuICBpZiAoaXNUeXBlTmFtZWRUdXBsZSh0eXBlKSkge1xuICAgIHJlY29tcG9zZWQgPSByZWNvbXBvc2VkLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQocGFyc2VOYW1lZFR1cGxlKGl0KSk7XG4gICAgfSwgW10pO1xuICB9XG4gIHJldHVybiByZWNvbXBvc2VkO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc3VyZU9mZnNldChpbnB1dCwgb3BlbiwgY2xvc2UpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGNvdW50ZXIgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaW5wdXRbaV0gPT09IG9wZW4pIHtcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9IGVsc2UgaWYgKGlucHV0W2ldID09PSBjbG9zZSAmJiAtLWNvdW50ZXIgPT09IDApIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xufVxuZnVuY3Rpb24gZXh0cmFjdENhaXJvMVR1cGxlKHR5cGUpIHtcbiAgY29uc3QgaW5wdXQgPSB0eXBlLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICBsZXQgbGltaXRJbmRleDtcbiAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IGlucHV0Lmxlbmd0aCkge1xuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBpbnB1dFtjdXJyZW50SW5kZXhdID09PSBcIihcIjoge1xuICAgICAgICBsaW1pdEluZGV4ID0gY3VycmVudEluZGV4ICsgZ2V0Q2xvc3VyZU9mZnNldChpbnB1dC5zbGljZShjdXJyZW50SW5kZXgpLCBcIihcIiwgXCIpXCIpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIChpbnB1dC5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHQ6OjxcIiwgY3VycmVudEluZGV4KSB8fCBpbnB1dC5zdGFydHNXaXRoKFwiY29yZTo6YXJyYXk6OkFycmF5Ojo8XCIsIGN1cnJlbnRJbmRleCkgfHwgaW5wdXQuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uOjo8XCIsIGN1cnJlbnRJbmRleCkpOiB7XG4gICAgICAgIGxpbWl0SW5kZXggPSBjdXJyZW50SW5kZXggKyBnZXRDbG9zdXJlT2Zmc2V0KGlucHV0LnNsaWNlKGN1cnJlbnRJbmRleCksIFwiPFwiLCBcIj5cIikgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgY29tbWFJbmRleCA9IGlucHV0LmluZGV4T2YoXCIsXCIsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgIGxpbWl0SW5kZXggPSBjb21tYUluZGV4ICE9PSAtMSA/IGNvbW1hSW5kZXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGlucHV0LnNsaWNlKGN1cnJlbnRJbmRleCwgbGltaXRJbmRleCkpO1xuICAgIGN1cnJlbnRJbmRleCA9IGxpbWl0SW5kZXggKyAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyh0eXBlKSB7XG4gIGlmIChpc0NhaXJvMVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gZXh0cmFjdENhaXJvMVR1cGxlKHR5cGUpO1xuICB9XG4gIHJldHVybiBleHRyYWN0Q2Fpcm8wVHVwbGUodHlwZSk7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9wcm9wZXJ0eU9yZGVyLnRzXG5mdW5jdGlvbiBlcnJvclUyNTYoa2V5KSB7XG4gIHJldHVybiBFcnJvcihcbiAgICBgWW91ciBvYmplY3QgaW5jbHVkZXMgdGhlIHByb3BlcnR5IDogJHtrZXl9LCBjb250YWluaW5nIGFuIFVpbnQyNTYgb2JqZWN0IHdpdGhvdXQgdGhlICdsb3cnIGFuZCAnaGlnaCcga2V5cy5gXG4gICk7XG59XG5mdW5jdGlvbiBlcnJvclU1MTIoa2V5KSB7XG4gIHJldHVybiBFcnJvcihcbiAgICBgWW91ciBvYmplY3QgaW5jbHVkZXMgdGhlIHByb3BlcnR5IDogJHtrZXl9LCBjb250YWluaW5nIGFuIFVpbnQ1MTIgb2JqZWN0IHdpdGhvdXQgdGhlICdsaW1iMCcgdG8gJ2xpbWIzJyBrZXlzLmBcbiAgKTtcbn1cbmZ1bmN0aW9uIG9yZGVyUHJvcHNCeUFiaSh1bm9yZGVyZWRPYmplY3QsIGFiaU9mT2JqZWN0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCBvcmRlcklucHV0ID0gKHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpID0+IHtcbiAgICBpZiAoaXNUeXBlQXJyYXkoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlckFycmF5KHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRW51bShhYmlUeXBlLCBlbnVtcykpIHtcbiAgICAgIGNvbnN0IGFiaU9iaiA9IGVudW1zW2FiaVR5cGVdO1xuICAgICAgcmV0dXJuIG9yZGVyRW51bSh1bm9yZGVyZWRJdGVtLCBhYmlPYmopO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlVHVwbGUoYWJpVHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlclR1cGxlKHVub3JkZXJlZEl0ZW0sIGFiaVR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNUeXBlRXRoQWRkcmVzcyhhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChpc1R5cGVOb25aZXJvKGFiaVR5cGUpKSB7XG4gICAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZUJ5dGVBcnJheShhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChpc1R5cGVTZWNwMjU2azFQb2ludChhYmlUeXBlKSkge1xuICAgICAgcmV0dXJuIHVub3JkZXJlZEl0ZW07XG4gICAgfVxuICAgIGlmIChDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKGFiaVR5cGUpKSB7XG4gICAgICBjb25zdCB1MjU2ID0gdW5vcmRlcmVkSXRlbTtcbiAgICAgIGlmICh0eXBlb2YgdTI1NiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gdTI1NjtcbiAgICAgIH1cbiAgICAgIGlmICghKFwibG93XCIgaW4gdTI1NiAmJiBcImhpZ2hcIiBpbiB1MjU2KSkge1xuICAgICAgICB0aHJvdyBlcnJvclUyNTYoYWJpVHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsb3c6IHUyNTYubG93LCBoaWdoOiB1MjU2LmhpZ2ggfTtcbiAgICB9XG4gICAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUoYWJpVHlwZSkpIHtcbiAgICAgIGNvbnN0IHU1MTIgPSB1bm9yZGVyZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiB1NTEyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiB1NTEyO1xuICAgICAgfVxuICAgICAgaWYgKCFbXCJsaW1iMFwiLCBcImxpbWIxXCIsIFwibGltYjJcIiwgXCJsaW1iM1wiXS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gdTUxMikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JVNTEyKGFiaVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbGltYjA6IHU1MTIubGltYjAsIGxpbWIxOiB1NTEyLmxpbWIxLCBsaW1iMjogdTUxMi5saW1iMiwgbGltYjM6IHU1MTIubGltYjMgfTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVN0cnVjdChhYmlUeXBlLCBzdHJ1Y3RzKSkge1xuICAgICAgY29uc3QgYWJpT2ZTdHJ1Y3QgPSBzdHJ1Y3RzW2FiaVR5cGVdLm1lbWJlcnM7XG4gICAgICByZXR1cm4gb3JkZXJTdHJ1Y3QodW5vcmRlcmVkSXRlbSwgYWJpT2ZTdHJ1Y3QpO1xuICAgIH1cbiAgICByZXR1cm4gdW5vcmRlcmVkSXRlbTtcbiAgfTtcbiAgY29uc3Qgb3JkZXJTdHJ1Y3QgPSAodW5vcmRlcmVkT2JqZWN0MiwgYWJpT2JqZWN0KSA9PiB7XG4gICAgY29uc3Qgb3JkZXJlZE9iamVjdDIgPSBhYmlPYmplY3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbSkgPT4ge1xuICAgICAgY29uc3Qgc2V0UHJvcGVydHkgPSAodmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbS5uYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdXG4gICAgICB9KTtcbiAgICAgIGlmICh1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmIChpc0NhaXJvMVR5cGUoYWJpUGFyYW0udHlwZSkgfHwgIWlzTGVuKGFiaVBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYFlvdXIgb2JqZWN0IG5lZWRzIGEgcHJvcGVydHkgd2l0aCBrZXkgOiAke2FiaVBhcmFtLm5hbWV9IC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UHJvcGVydHkob3JkZXJJbnB1dCh1bm9yZGVyZWRPYmplY3QyW2FiaVBhcmFtLm5hbWVdLCBhYmlQYXJhbS50eXBlKSk7XG4gICAgICByZXR1cm4gb3JkZXJlZE9iamVjdDtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIG9yZGVyZWRPYmplY3QyO1xuICB9O1xuICBmdW5jdGlvbiBvcmRlckFycmF5KG15QXJyYXksIGFiaVBhcmFtKSB7XG4gICAgY29uc3QgdHlwZUluQXJyYXkgPSBnZXRBcnJheVR5cGUoYWJpUGFyYW0pO1xuICAgIGlmIChpc1N0cmluZyhteUFycmF5KSkge1xuICAgICAgcmV0dXJuIG15QXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBteUFycmF5Lm1hcCgobXlFbGVtKSA9PiBvcmRlcklucHV0KG15RWxlbSwgdHlwZUluQXJyYXkpKTtcbiAgfVxuICBmdW5jdGlvbiBvcmRlclR1cGxlKHVub3JkZXJlZE9iamVjdDIsIGFiaVBhcmFtKSB7XG4gICAgY29uc3QgdHlwZUxpc3QgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyhhYmlQYXJhbSk7XG4gICAgY29uc3Qgb3JkZXJlZE9iamVjdDIgPSB0eXBlTGlzdC5yZWR1Y2UoKG9yZGVyZWRPYmplY3QsIGFiaVR5cGVDYWlyb1gsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBteU9iaktleXMgPSBPYmplY3Qua2V5cyh1bm9yZGVyZWRPYmplY3QyKTtcbiAgICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgaW5kZXgudG9TdHJpbmcoKSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUgPz8gdW5vcmRlcmVkT2JqZWN0MltteU9iaktleXNbaW5kZXhdXVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhYmlUeXBlID0gYWJpVHlwZUNhaXJvWD8udHlwZSA/IGFiaVR5cGVDYWlyb1gudHlwZSA6IGFiaVR5cGVDYWlyb1g7XG4gICAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdDJbbXlPYmpLZXlzW2luZGV4XV0sIGFiaVR5cGUpKTtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gb3JkZXJlZE9iamVjdDI7XG4gIH1cbiAgY29uc3Qgb3JkZXJFbnVtID0gKHVub3JkZXJlZE9iamVjdDIsIGFiaU9iamVjdCkgPT4ge1xuICAgIGlmIChpc1R5cGVSZXN1bHQoYWJpT2JqZWN0Lm5hbWUpKSB7XG4gICAgICBjb25zdCB1bm9yZGVyZWRSZXN1bHQgPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgICAgY29uc3QgcmVzdWx0T2tUeXBlID0gYWJpT2JqZWN0Lm5hbWUuc3Vic3RyaW5nKFxuICAgICAgICBhYmlPYmplY3QubmFtZS5pbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmxhc3RJbmRleE9mKFwiLFwiKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3VsdEVyclR5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCIsXCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHVub3JkZXJlZFJlc3VsdC5pc09rKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdChcbiAgICAgICAgICAwIC8qIE9rICovLFxuICAgICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0Mi51bndyYXAoKSwgcmVzdWx0T2tUeXBlKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1Jlc3VsdChcbiAgICAgICAgMSAvKiBFcnIgKi8sXG4gICAgICAgIG9yZGVySW5wdXQodW5vcmRlcmVkT2JqZWN0Mi51bndyYXAoKSwgcmVzdWx0RXJyVHlwZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc1R5cGVPcHRpb24oYWJpT2JqZWN0Lm5hbWUpKSB7XG4gICAgICBjb25zdCB1bm9yZGVyZWRPcHRpb24gPSB1bm9yZGVyZWRPYmplY3QyO1xuICAgICAgY29uc3QgcmVzdWx0U29tZVR5cGUgPSBhYmlPYmplY3QubmFtZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC5uYW1lLmluZGV4T2YoXCI8XCIpICsgMSxcbiAgICAgICAgYWJpT2JqZWN0Lm5hbWUubGFzdEluZGV4T2YoXCI+XCIpXG4gICAgICApO1xuICAgICAgaWYgKHVub3JkZXJlZE9wdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKFxuICAgICAgICAgIDAgLyogU29tZSAqLyxcbiAgICAgICAgICBvcmRlcklucHV0KHVub3JkZXJlZE9wdGlvbi51bndyYXAoKSwgcmVzdWx0U29tZVR5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvT3B0aW9uKDEgLyogTm9uZSAqLywge30pO1xuICAgIH1cbiAgICBjb25zdCB1bm9yZGVyZWRDdXN0b21FbnVtID0gdW5vcmRlcmVkT2JqZWN0MjtcbiAgICBjb25zdCB2YXJpYW50cyA9IE9iamVjdC5lbnRyaWVzKHVub3JkZXJlZEN1c3RvbUVudW0udmFyaWFudCk7XG4gICAgY29uc3QgbmV3RW50cmllcyA9IHZhcmlhbnRzLm1hcCgodmFyaWFudCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YXJpYW50WzFdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudFR5cGUgPSBhYmlPYmplY3QudHlwZS5zdWJzdHJpbmcoXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPFwiKSArIDEsXG4gICAgICAgIGFiaU9iamVjdC50eXBlLmxhc3RJbmRleE9mKFwiPlwiKVxuICAgICAgKTtcbiAgICAgIGlmICh2YXJpYW50VHlwZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt2YXJpYW50WzBdLCBvcmRlcklucHV0KHVub3JkZXJlZEN1c3RvbUVudW0udW53cmFwKCksIHZhcmlhbnRUeXBlKV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBDYWlyb0N1c3RvbUVudW0oT2JqZWN0LmZyb21FbnRyaWVzKG5ld0VudHJpZXMpKTtcbiAgfTtcbiAgY29uc3QgZmluYWxPcmRlcmVkT2JqZWN0ID0gYWJpT2ZPYmplY3QucmVkdWNlKChvcmRlcmVkT2JqZWN0LCBhYmlQYXJhbSkgPT4ge1xuICAgIGNvbnN0IHNldFByb3BlcnR5ID0gKHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJlZE9iamVjdCwgYWJpUGFyYW0ubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgaWYgKGlzTGVuKGFiaVBhcmFtLm5hbWUpICYmICFpc0NhaXJvMVR5cGUoYWJpUGFyYW0udHlwZSkpIHtcbiAgICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICAgIH1cbiAgICBzZXRQcm9wZXJ0eShvcmRlcklucHV0KHVub3JkZXJlZE9iamVjdFthYmlQYXJhbS5uYW1lXSwgYWJpUGFyYW0udHlwZSkpO1xuICAgIHJldHVybiBvcmRlcmVkT2JqZWN0O1xuICB9LCB7fSk7XG4gIHJldHVybiBmaW5hbE9yZGVyZWRPYmplY3Q7XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXF1ZXN0UGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZUJhc2VUeXBlcyh0eXBlLCB2YWwpIHtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpOlxuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYodmFsKS50b0FwaVJlcXVlc3QoKTtcbiAgICBjYXNlIENhaXJvVWludDUxMi5pc0FiaVR5cGUodHlwZSk6XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMih2YWwpLnRvQXBpUmVxdWVzdCgpO1xuICAgIGNhc2UgaXNUeXBlQnl0ZXMzMSh0eXBlKTpcbiAgICAgIHJldHVybiBlbmNvZGVTaG9ydFN0cmluZyh2YWwudG9TdHJpbmcoKSk7XG4gICAgY2FzZSBpc1R5cGVTZWNwMjU2azFQb2ludCh0eXBlKToge1xuICAgICAgY29uc3QgcHViS2V5RVRIID0gcmVtb3ZlSGV4UHJlZml4KHRvSGV4KHZhbCkpLnBhZFN0YXJ0KDEyOCwgXCIwXCIpO1xuICAgICAgY29uc3QgcHViS2V5RVRIeSA9IHVpbnQyNTYoYWRkSGV4UHJlZml4KHB1YktleUVUSC5zbGljZSgtNjQpKSk7XG4gICAgICBjb25zdCBwdWJLZXlFVEh4ID0gdWludDI1NihhZGRIZXhQcmVmaXgocHViS2V5RVRILnNsaWNlKDAsIC02NCkpKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGZlbHQocHViS2V5RVRIeC5sb3cpLFxuICAgICAgICBmZWx0KHB1YktleUVUSHguaGlnaCksXG4gICAgICAgIGZlbHQocHViS2V5RVRIeS5sb3cpLFxuICAgICAgICBmZWx0KHB1YktleUVUSHkuaGlnaClcbiAgICAgIF07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmVsdCh2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVR1cGxlKGVsZW1lbnQsIHR5cGVTdHIpIHtcbiAgY29uc3QgbWVtYmVyVHlwZXMgPSBleHRyYWN0VHVwbGVNZW1iZXJUeXBlcyh0eXBlU3RyKTtcbiAgY29uc3QgZWxlbWVudHMgPSBPYmplY3QudmFsdWVzKGVsZW1lbnQpO1xuICBpZiAoZWxlbWVudHMubGVuZ3RoICE9PSBtZW1iZXJUeXBlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBQYXJzZVR1cGxlOiBwcm92aWRlZCBhbmQgZXhwZWN0ZWQgYWJpIHR1cGxlIHNpemUgZG8gbm90IG1hdGNoLlxuICAgICAgcHJvdmlkZWQ6ICR7ZWxlbWVudHN9IFxuICAgICAgZXhwZWN0ZWQ6ICR7bWVtYmVyVHlwZXN9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1lbWJlclR5cGVzLm1hcCgoaXQsIGR4KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnRzW2R4XSxcbiAgICAgIHR5cGU6IGl0LnR5cGUgPz8gaXRcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQnl0ZUFycmF5KGVsZW1lbnQpIHtcbiAgY29uc3QgbXlCeXRlQXJyYXkgPSBieXRlQXJyYXlGcm9tU3RyaW5nKGVsZW1lbnQpO1xuICByZXR1cm4gW1xuICAgIG15Qnl0ZUFycmF5LmRhdGEubGVuZ3RoLnRvU3RyaW5nKCksXG4gICAgLi4ubXlCeXRlQXJyYXkuZGF0YS5tYXAoKGJuKSA9PiBibi50b1N0cmluZygpKSxcbiAgICBteUJ5dGVBcnJheS5wZW5kaW5nX3dvcmQudG9TdHJpbmcoKSxcbiAgICBteUJ5dGVBcnJheS5wZW5kaW5nX3dvcmRfbGVuLnRvU3RyaW5nKClcbiAgXTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFWYWx1ZShlbGVtZW50LCB0eXBlLCBzdHJ1Y3RzLCBlbnVtcykge1xuICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoYE1pc3NpbmcgcGFyYW1ldGVyIGZvciB0eXBlICR7dHlwZX1gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5wdXNoKGZlbHQoZWxlbWVudC5sZW5ndGgpKTtcbiAgICBjb25zdCBhcnJheVR5cGUgPSBnZXRBcnJheVR5cGUodHlwZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoaXQsIGFycmF5VHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCByZXN1bHQpO1xuICB9XG4gIGlmIChzdHJ1Y3RzW3R5cGVdICYmIHN0cnVjdHNbdHlwZV0ubWVtYmVycy5sZW5ndGgpIHtcbiAgICBpZiAoQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYoZWxlbWVudCkudG9BcGlSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGlmIChDYWlyb1VpbnQ1MTIuaXNBYmlUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gbmV3IENhaXJvVWludDUxMihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpXG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgZWxlbWVudCk7XG4gICAgaWYgKHR5cGUgPT09IFwiY29yZTo6Ynl0ZV9hcnJheTo6Qnl0ZUFycmF5XCIpIHJldHVybiBwYXJzZUJ5dGVBcnJheShlbGVtZW50KTtcbiAgICBjb25zdCB7IG1lbWJlcnMgfSA9IHN0cnVjdHNbdHlwZV07XG4gICAgY29uc3Qgc3ViRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKChhY2MsIGl0KSA9PiB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZUNhbGxkYXRhVmFsdWUoc3ViRWxlbWVudFtpdC5uYW1lXSwgaXQudHlwZSwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKGlzVHlwZVR1cGxlKHR5cGUpKSB7XG4gICAgY29uc3QgdHVwbGVkID0gcGFyc2VUdXBsZShlbGVtZW50LCB0eXBlKTtcbiAgICByZXR1cm4gdHVwbGVkLnJlZHVjZSgoYWNjLCBpdCkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShpdC5lbGVtZW50LCBpdC50eXBlLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChwYXJzZWREYXRhKTtcbiAgICB9LCBbXSk7XG4gIH1cbiAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSkpIHtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDI1NihlbGVtZW50KS50b0FwaVJlcXVlc3QoKTtcbiAgfVxuICBpZiAoQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKSkge1xuICAgIHJldHVybiBuZXcgQ2Fpcm9VaW50NTEyKGVsZW1lbnQpLnRvQXBpUmVxdWVzdCgpO1xuICB9XG4gIGlmIChpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSkge1xuICAgIGNvbnN0IHsgdmFyaWFudHMgfSA9IGVudW1zW3R5cGVdO1xuICAgIGlmIChpc1R5cGVPcHRpb24odHlwZSkpIHtcbiAgICAgIGNvbnN0IG15T3B0aW9uID0gZWxlbWVudDtcbiAgICAgIGlmIChteU9wdGlvbi5pc1NvbWUoKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQyID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIlNvbWVcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdFR5cGVWYXJpYW50MiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBpbiBhYmkgOiBPcHRpb24gaGFzIG5vICdTb21lJyB2YXJpYW50LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGVWYXJpYW50U29tZSA9IGxpc3RUeXBlVmFyaWFudDIudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50U29tZSA9PT0gXCIoKVwiKSB7XG4gICAgICAgICAgcmV0dXJuIDAgLyogU29tZSAqLy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlcjIgPSBwYXJzZUNhbGxkYXRhVmFsdWUoXG4gICAgICAgICAgbXlPcHRpb24udW53cmFwKCksXG4gICAgICAgICAgdHlwZVZhcmlhbnRTb21lLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWzAgLyogU29tZSAqLy50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC8qIE5vbmUgKi8udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzVHlwZVJlc3VsdCh0eXBlKSkge1xuICAgICAgY29uc3QgbXlSZXN1bHQgPSBlbGVtZW50O1xuICAgICAgaWYgKG15UmVzdWx0LmlzT2soKSkge1xuICAgICAgICBjb25zdCBsaXN0VHlwZVZhcmlhbnQzID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBcIk9rXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXJyb3IgaW4gYWJpIDogUmVzdWx0IGhhcyBubyAnT2snIHZhcmlhbnQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZVZhcmlhbnRPayA9IGxpc3RUeXBlVmFyaWFudDMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVWYXJpYW50T2sgPT09IFwiKClcIikge1xuICAgICAgICAgIHJldHVybiAwIC8qIE9rICovLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkUGFyYW1ldGVyMyA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgICBteVJlc3VsdC51bndyYXAoKSxcbiAgICAgICAgICB0eXBlVmFyaWFudE9rLFxuICAgICAgICAgIHN0cnVjdHMsXG4gICAgICAgICAgZW51bXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMykpIHtcbiAgICAgICAgICByZXR1cm4gWzAgLyogT2sgKi8udG9TdHJpbmcoKSwgLi4ucGFyc2VkUGFyYW1ldGVyM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswIC8qIE9rICovLnRvU3RyaW5nKCksIHBhcnNlZFBhcmFtZXRlcjNdO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdFR5cGVWYXJpYW50MiA9IHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gXCJFcnJcIik7XG4gICAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudDIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9yIGluIGFiaSA6IFJlc3VsdCBoYXMgbm8gJ0VycicgdmFyaWFudC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGVWYXJpYW50RXJyID0gbGlzdFR5cGVWYXJpYW50Mi50eXBlO1xuICAgICAgaWYgKHR5cGVWYXJpYW50RXJyID09PSBcIigpXCIpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogRXJyICovLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWRQYXJhbWV0ZXIyID0gcGFyc2VDYWxsZGF0YVZhbHVlKG15UmVzdWx0LnVud3JhcCgpLCB0eXBlVmFyaWFudEVyciwgc3RydWN0cywgZW51bXMpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyMikpIHtcbiAgICAgICAgcmV0dXJuIFsxIC8qIEVyciAqLy50b1N0cmluZygpLCAuLi5wYXJzZWRQYXJhbWV0ZXIyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbMSAvKiBFcnIgKi8udG9TdHJpbmcoKSwgcGFyc2VkUGFyYW1ldGVyMl07XG4gICAgfVxuICAgIGNvbnN0IG15RW51bSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgY29uc3QgbGlzdFR5cGVWYXJpYW50ID0gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5uYW1lID09PSBhY3RpdmVWYXJpYW50KTtcbiAgICBpZiAodHlwZW9mIGxpc3RUeXBlVmFyaWFudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgRXJyb3IoYE5vdCBmaW5kIGluIGFiaSA6IEVudW0gaGFzIG5vICcke2FjdGl2ZVZhcmlhbnR9JyB2YXJpYW50LmApO1xuICAgIH1cbiAgICBjb25zdCB0eXBlQWN0aXZlVmFyaWFudCA9IGxpc3RUeXBlVmFyaWFudC50eXBlO1xuICAgIGNvbnN0IG51bUFjdGl2ZVZhcmlhbnQgPSB2YXJpYW50cy5maW5kSW5kZXgoKHZhcmlhbnQpID0+IHZhcmlhbnQubmFtZSA9PT0gYWN0aXZlVmFyaWFudCk7XG4gICAgaWYgKHR5cGVBY3RpdmVWYXJpYW50ID09PSBcIigpXCIpIHtcbiAgICAgIHJldHVybiBudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFBhcmFtZXRlciA9IHBhcnNlQ2FsbGRhdGFWYWx1ZShteUVudW0udW53cmFwKCksIHR5cGVBY3RpdmVWYXJpYW50LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkUGFyYW1ldGVyKSkge1xuICAgICAgcmV0dXJuIFtudW1BY3RpdmVWYXJpYW50LnRvU3RyaW5nKCksIC4uLnBhcnNlZFBhcmFtZXRlcl07XG4gICAgfVxuICAgIHJldHVybiBbbnVtQWN0aXZlVmFyaWFudC50b1N0cmluZygpLCBwYXJzZWRQYXJhbWV0ZXJdO1xuICB9XG4gIGlmIChpc1R5cGVOb25aZXJvKHR5cGUpKSB7XG4gICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKGdldEFycmF5VHlwZSh0eXBlKSwgZWxlbWVudCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgRXJyb3IoYFBhcmFtZXRlciAke2VsZW1lbnR9IGRvIG5vdCBhbGlnbiB3aXRoIGFiaSBwYXJhbWV0ZXIgJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBwYXJzZUJhc2VUeXBlcyh0eXBlLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGlucHV0O1xuICBsZXQgeyB2YWx1ZSB9ID0gYXJnc0l0ZXJhdG9yLm5leHQoKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVBcnJheSh0eXBlKTpcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIWlzVGV4dCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEFCSSBleHBlY3RlZCBwYXJhbWV0ZXIgJHtuYW1lfSB0byBiZSBhcnJheSBvciBsb25nIHN0cmluZywgZ290ICR7dmFsdWV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gc3BsaXRMb25nU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIGlucHV0LnR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZU5vblplcm8odHlwZSk6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXMoZ2V0QXJyYXlUeXBlKHR5cGUpLCB2YWx1ZSk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzKHR5cGUsIHZhbHVlKTtcbiAgICBjYXNlIChpc1R5cGVTdHJ1Y3QodHlwZSwgc3RydWN0cykgfHwgaXNUeXBlVHVwbGUodHlwZSkgfHwgQ2Fpcm9VaW50MjU2LmlzQWJpVHlwZSh0eXBlKSB8fCBDYWlyb1VpbnQyNTYuaXNBYmlUeXBlKHR5cGUpKTpcbiAgICAgIHJldHVybiBwYXJzZUNhbGxkYXRhVmFsdWUodmFsdWUsIHR5cGUsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIGlzVHlwZUVudW0odHlwZSwgZW51bXMpOlxuICAgICAgcmV0dXJuIHBhcnNlQ2FsbGRhdGFWYWx1ZShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0cnVjdHMsXG4gICAgICAgIGVudW1zXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcGFyc2VCYXNlVHlwZXModHlwZSwgdmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy91dGlscy9jYWxsZGF0YS9yZXNwb25zZVBhcnNlci50c1xuZnVuY3Rpb24gcGFyc2VCYXNlVHlwZXMyKHR5cGUsIGl0KSB7XG4gIGxldCB0ZW1wO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIGlzVHlwZUJvb2wodHlwZSk6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oQmlnSW50KHRlbXApKTtcbiAgICBjYXNlIENhaXJvVWludDI1Ni5pc0FiaVR5cGUodHlwZSk6XG4gICAgICBjb25zdCBsb3cgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBoaWdoID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQyNTYobG93LCBoaWdoKS50b0JpZ0ludCgpO1xuICAgIGNhc2UgQ2Fpcm9VaW50NTEyLmlzQWJpVHlwZSh0eXBlKTpcbiAgICAgIGNvbnN0IGxpbWIwID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgY29uc3QgbGltYjEgPSBpdC5uZXh0KCkudmFsdWU7XG4gICAgICBjb25zdCBsaW1iMiA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIGNvbnN0IGxpbWIzID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpLnRvQmlnSW50KCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OnN0YXJrbmV0OjpldGhfYWRkcmVzczo6RXRoQWRkcmVzc1wiOlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSB0eXBlID09PSBcImNvcmU6OmJ5dGVzXzMxOjpieXRlczMxXCI6XG4gICAgICB0ZW1wID0gaXQubmV4dCgpLnZhbHVlO1xuICAgICAgcmV0dXJuIGRlY29kZVNob3J0U3RyaW5nKHRlbXApO1xuICAgIGNhc2UgaXNUeXBlU2VjcDI1NmsxUG9pbnQodHlwZSk6XG4gICAgICBjb25zdCB4TG93ID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHhIaWdoID0gcmVtb3ZlSGV4UHJlZml4KGl0Lm5leHQoKS52YWx1ZSkucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICAgIGNvbnN0IHlMb3cgPSByZW1vdmVIZXhQcmVmaXgoaXQubmV4dCgpLnZhbHVlKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICAgICAgY29uc3QgeUhpZ2ggPSByZW1vdmVIZXhQcmVmaXgoaXQubmV4dCgpLnZhbHVlKS5wYWRTdGFydCgzMiwgXCIwXCIpO1xuICAgICAgY29uc3QgcHViSyA9IEJpZ0ludChhZGRIZXhQcmVmaXgoeEhpZ2ggKyB4TG93ICsgeUhpZ2ggKyB5TG93KSk7XG4gICAgICByZXR1cm4gcHViSztcbiAgICBkZWZhdWx0OlxuICAgICAgdGVtcCA9IGl0Lm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbGVtZW50LCBzdHJ1Y3RzLCBlbnVtcykge1xuICBpZiAoZWxlbWVudC50eXBlID09PSBcIigpXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgaWYgKENhaXJvVWludDI1Ni5pc0FiaVR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IGxvdyA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGhpZ2ggPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICByZXR1cm4gbmV3IENhaXJvVWludDI1Nihsb3csIGhpZ2gpLnRvQmlnSW50KCk7XG4gIH1cbiAgaWYgKENhaXJvVWludDUxMi5pc0FiaVR5cGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IGxpbWIwID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgY29uc3QgbGltYjEgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICBjb25zdCBsaW1iMiA9IHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIGNvbnN0IGxpbWIzID0gcmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgcmV0dXJuIG5ldyBDYWlyb1VpbnQ1MTIobGltYjAsIGxpbWIxLCBsaW1iMiwgbGltYjMpLnRvQmlnSW50KCk7XG4gIH1cbiAgaWYgKGlzVHlwZUJ5dGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkQnl0ZXMzMUFyciA9IFtdO1xuICAgIGNvbnN0IGJ5dGVzMzFBcnJMZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWRCeXRlczMxQXJyLmxlbmd0aCA8IGJ5dGVzMzFBcnJMZW4pIHtcbiAgICAgIHBhcnNlZEJ5dGVzMzFBcnIucHVzaCh0b0hleChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSkpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nX3dvcmQgPSB0b0hleChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgY29uc3QgcGVuZGluZ193b3JkX2xlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgY29uc3QgbXlCeXRlQXJyYXkgPSB7XG4gICAgICBkYXRhOiBwYXJzZWRCeXRlczMxQXJyLFxuICAgICAgcGVuZGluZ193b3JkLFxuICAgICAgcGVuZGluZ193b3JkX2xlblxuICAgIH07XG4gICAgcmV0dXJuIHN0cmluZ0Zyb21CeXRlQXJyYXkobXlCeXRlQXJyYXkpO1xuICB9XG4gIGlmIChpc1R5cGVBcnJheShlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgcGFyc2VkRGF0YUFyciA9IFtdO1xuICAgIGNvbnN0IGVsID0geyBuYW1lOiBcIlwiLCB0eXBlOiBnZXRBcnJheVR5cGUoZWxlbWVudC50eXBlKSB9O1xuICAgIGNvbnN0IGxlbiA9IEJpZ0ludChyZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgd2hpbGUgKHBhcnNlZERhdGFBcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICBwYXJzZWREYXRhQXJyLnB1c2gocGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcykpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkRGF0YUFycjtcbiAgfVxuICBpZiAoaXNUeXBlTm9uWmVybyhlbGVtZW50LnR5cGUpKSB7XG4gICAgY29uc3QgZWwgPSB7IG5hbWU6IFwiXCIsIHR5cGU6IGdldEFycmF5VHlwZShlbGVtZW50LnR5cGUpIH07XG4gICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpO1xuICB9XG4gIGlmIChzdHJ1Y3RzICYmIGVsZW1lbnQudHlwZSBpbiBzdHJ1Y3RzICYmIHN0cnVjdHNbZWxlbWVudC50eXBlXSkge1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpIHtcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIoZWxlbWVudC50eXBlLCByZXNwb25zZUl0ZXJhdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHNbZWxlbWVudC50eXBlXS5tZW1iZXJzLnJlZHVjZSgoYWNjLCBlbCkgPT4ge1xuICAgICAgYWNjW2VsLm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoZW51bXMgJiYgZWxlbWVudC50eXBlIGluIGVudW1zICYmIGVudW1zW2VsZW1lbnQudHlwZV0pIHtcbiAgICBjb25zdCB2YXJpYW50TnVtID0gTnVtYmVyKHJlc3BvbnNlSXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICBjb25zdCByYXdFbnVtID0gZW51bXNbZWxlbWVudC50eXBlXS52YXJpYW50cy5yZWR1Y2UoKGFjYywgdmFyaWFudCwgbnVtKSA9PiB7XG4gICAgICBpZiAobnVtID09PSB2YXJpYW50TnVtKSB7XG4gICAgICAgIGFjY1t2YXJpYW50Lm5hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKFxuICAgICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgICAgeyBuYW1lOiBcIlwiLCB0eXBlOiB2YXJpYW50LnR5cGUgfSxcbiAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgIGVudW1zXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9XG4gICAgICBhY2NbdmFyaWFudC5uYW1lXSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aChcImNvcmU6Om9wdGlvbjo6T3B0aW9uXCIpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdmFyaWFudE51bSA9PT0gMCAvKiBTb21lICovID8gcmF3RW51bS5Tb21lIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBDYWlyb09wdGlvbih2YXJpYW50TnVtLCBjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKFwiY29yZTo6cmVzdWx0OjpSZXN1bHRcIikpIHtcbiAgICAgIGxldCBjb250ZW50O1xuICAgICAgaWYgKHZhcmlhbnROdW0gPT09IDAgLyogT2sgKi8pIHtcbiAgICAgICAgY29udGVudCA9IHJhd0VudW0uT2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gcmF3RW51bS5FcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENhaXJvUmVzdWx0KHZhcmlhbnROdW0sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjdXN0b21FbnVtID0gbmV3IENhaXJvQ3VzdG9tRW51bShyYXdFbnVtKTtcbiAgICByZXR1cm4gY3VzdG9tRW51bTtcbiAgfVxuICBpZiAoaXNUeXBlVHVwbGUoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IG1lbWJlclR5cGVzID0gZXh0cmFjdFR1cGxlTWVtYmVyVHlwZXMoZWxlbWVudC50eXBlKTtcbiAgICByZXR1cm4gbWVtYmVyVHlwZXMucmVkdWNlKChhY2MsIGl0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpdD8ubmFtZSA/IGl0Lm5hbWUgOiBpZHg7XG4gICAgICBjb25zdCB0eXBlID0gaXQ/LnR5cGUgPyBpdC50eXBlIDogaXQ7XG4gICAgICBjb25zdCBlbCA9IHsgbmFtZSwgdHlwZSB9O1xuICAgICAgYWNjW25hbWVdID0gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIGVsLCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBpZiAoaXNUeXBlQXJyYXkoZWxlbWVudC50eXBlKSkge1xuICAgIGNvbnN0IHBhcnNlZERhdGFBcnIgPSBbXTtcbiAgICBjb25zdCBlbCA9IHsgbmFtZTogXCJcIiwgdHlwZTogZ2V0QXJyYXlUeXBlKGVsZW1lbnQudHlwZSkgfTtcbiAgICBjb25zdCBsZW4gPSBCaWdJbnQocmVzcG9uc2VJdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGxlbikge1xuICAgICAgcGFyc2VkRGF0YUFyci5wdXNoKHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBlbCwgc3RydWN0cywgZW51bXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZERhdGFBcnI7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQmFzZVR5cGVzMihlbGVtZW50LnR5cGUsIHJlc3BvbnNlSXRlcmF0b3IpO1xufVxuZnVuY3Rpb24gcmVzcG9uc2VQYXJzZXIocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcywgcGFyc2VkUmVzdWx0KSB7XG4gIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gb3V0cHV0O1xuICBsZXQgdGVtcDtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc0xlbihuYW1lKTpcbiAgICAgIHRlbXAgPSByZXNwb25zZUl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBCaWdJbnQodGVtcCk7XG4gICAgY2FzZSAoc3RydWN0cyAmJiB0eXBlIGluIHN0cnVjdHMgfHwgaXNUeXBlVHVwbGUodHlwZSkpOlxuICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2VWYWx1ZShyZXNwb25zZUl0ZXJhdG9yLCBvdXRwdXQsIHN0cnVjdHMsIGVudW1zKTtcbiAgICBjYXNlIChlbnVtcyAmJiBpc1R5cGVFbnVtKHR5cGUsIGVudW1zKSk6XG4gICAgICByZXR1cm4gcGFyc2VSZXNwb25zZVZhbHVlKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgIGNhc2UgaXNUeXBlQXJyYXkodHlwZSk6XG4gICAgICBpZiAoaXNDYWlybzFUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWREYXRhQXJyID0gW107XG4gICAgICBpZiAocGFyc2VkUmVzdWx0ICYmIHBhcnNlZFJlc3VsdFtgJHtuYW1lfV9sZW5gXSkge1xuICAgICAgICBjb25zdCBhcnJMZW4gPSBwYXJzZWRSZXN1bHRbYCR7bmFtZX1fbGVuYF07XG4gICAgICAgIHdoaWxlIChwYXJzZWREYXRhQXJyLmxlbmd0aCA8IGFyckxlbikge1xuICAgICAgICAgIHBhcnNlZERhdGFBcnIucHVzaChcbiAgICAgICAgICAgIHBhcnNlUmVzcG9uc2VWYWx1ZShcbiAgICAgICAgICAgICAgcmVzcG9uc2VJdGVyYXRvcixcbiAgICAgICAgICAgICAgeyBuYW1lLCB0eXBlOiBvdXRwdXQudHlwZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSB9LFxuICAgICAgICAgICAgICBzdHJ1Y3RzLFxuICAgICAgICAgICAgICBlbnVtc1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWREYXRhQXJyO1xuICAgIGNhc2UgaXNUeXBlTm9uWmVybyh0eXBlKTpcbiAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlVmFsdWUocmVzcG9uc2VJdGVyYXRvciwgb3V0cHV0LCBzdHJ1Y3RzLCBlbnVtcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZUJhc2VUeXBlczIodHlwZSwgcmVzcG9uc2VJdGVyYXRvcik7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL3ZhbGlkYXRlLnRzXG52YXIgdmFsaWRhdGVGZWx0ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIGlzU3RyaW5nKHBhcmFtZXRlcikgfHwgaXNOdW1iZXIocGFyYW1ldGVyKSB8fCBpc0JpZ0ludChwYXJhbWV0ZXIpLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgZmVsdCB0eXBlZCBhcyAoU3RyaW5nLCBOdW1iZXIgb3IgQmlnSW50KWBcbiAgKTtcbiAgaWYgKGlzU3RyaW5nKHBhcmFtZXRlcikgJiYgIWlzSGV4KHBhcmFtZXRlcikpIHJldHVybjtcbiAgY29uc3QgcGFyYW0gPSBCaWdJbnQocGFyYW1ldGVyLnRvU3RyaW5nKDEwKSk7XG4gIGFzc2VydChcbiAgICAvLyBmcm9tIDogaHR0cHM6Ly9naXRodWIuY29tL3N0YXJrd2FyZS1saWJzL3N0YXJrbmV0LXNwZWNzL2Jsb2IvMjliYWI2NTBiZTZiMTg0N2M5MmQ0NDYxZDRjMzMwMDhiNWU1MGIxYS9hcGkvc3RhcmtuZXRfYXBpX29wZW5ycGMuanNvbiNMMTI2NlxuICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswLCAyXjI1Mi0xXWBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVCeXRlczMxID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KGlzU3RyaW5nKHBhcmFtZXRlciksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGEgc3RyaW5nLmApO1xuICBhc3NlcnQoXG4gICAgcGFyYW1ldGVyLmxlbmd0aCA8IDMyLFxuICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgYSBzdHJpbmcgb2YgbGVzcyB0aGFuIDMyIGNoYXJhY3RlcnMuYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUJ5dGVBcnJheSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChpc1N0cmluZyhwYXJhbWV0ZXIpLCBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBiZSBhIHN0cmluZy5gKTtcbn07XG52YXIgdmFsaWRhdGVVaW50ID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgaWYgKGlzTnVtYmVyKHBhcmFtZXRlcikpIHtcbiAgICBhc3NlcnQoXG4gICAgICBwYXJhbWV0ZXIgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBgVmFsaWRhdGlvbjogUGFyYW1ldGVyIGlzIHRvIGxhcmdlIHRvIGJlIHR5cGVkIGFzIE51bWJlciB1c2UgKEJpZ0ludCBvciBTdHJpbmcpYFxuICAgICk7XG4gIH1cbiAgYXNzZXJ0KFxuICAgIGlzU3RyaW5nKHBhcmFtZXRlcikgfHwgaXNOdW1iZXIocGFyYW1ldGVyKSB8fCBpc0JpZ0ludChwYXJhbWV0ZXIpIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgXCJsb3dcIiBpbiBwYXJhbWV0ZXIgJiYgXCJoaWdoXCIgaW4gcGFyYW1ldGVyIHx8IHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgW1wibGltYjBcIiwgXCJsaW1iMVwiLCBcImxpbWIyXCIsIFwibGltYjNcIl0uZXZlcnkoKGtleSkgPT4ga2V5IGluIHBhcmFtZXRlciksXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBvZiBjYWlybyB0eXBlICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIHR5cGUgKFN0cmluZywgTnVtYmVyIG9yIEJpZ0ludCksIGJ1dCBpcyAke3R5cGVvZiBwYXJhbWV0ZXJ9ICR7cGFyYW1ldGVyfS5gXG4gICk7XG4gIGxldCBwYXJhbTtcbiAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUyNTZcIiAvKiB1MjU2ICovOlxuICAgICAgcGFyYW0gPSBuZXcgQ2Fpcm9VaW50MjU2KHBhcmFtZXRlcikudG9CaWdJbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1NTEyXCIgLyogdTUxMiAqLzpcbiAgICAgIHBhcmFtID0gbmV3IENhaXJvVWludDUxMihwYXJhbWV0ZXIpLnRvQmlnSW50KCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcGFyYW0gPSB0b0JpZ0ludChwYXJhbWV0ZXIpO1xuICB9XG4gIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1OFwiIC8qIHU4ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAyNTVuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGNhaXJvIHR5cGVkICR7aW5wdXQudHlwZX0gc2hvdWxkIGJlIGluIHJhbmdlIFswIC0gMjU1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTE2XCIgLyogdTE2ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA2NTUzNW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDY1NTM1XWBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29yZTo6aW50ZWdlcjo6dTMyXCIgLyogdTMyICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSA0Mjk0OTY3Mjk1bixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgNDI5NDk2NzI5NV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU2NFwiIC8qIHU2NCAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogNjRuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeNjQtMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnUxMjhcIiAvKiB1MTI4ICovOlxuICAgICAgYXNzZXJ0KFxuICAgICAgICBwYXJhbSA+PSAwbiAmJiBwYXJhbSA8PSAybiAqKiAxMjhuIC0gMW4sXG4gICAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMTI4LTFdYFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLzpcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogMjU2biAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzICR7aW5wdXQudHlwZX0gMCAtIDJeMjU2LTFgXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OmludGVnZXI6OnU1MTJcIiAvKiB1NTEyICovOlxuICAgICAgYXNzZXJ0KENhaXJvVWludDUxMi5pcyhwYXJhbSksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gaXMgJHtpbnB1dC50eXBlfSAwIC0gMl41MTItMWApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OnN0YXJrbmV0OjpjbGFzc19oYXNoOjpDbGFzc0hhc2hcIiAvKiBDbGFzc0hhc2ggKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxNjcwXG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OnN0YXJrbmV0Ojpjb250cmFjdF9hZGRyZXNzOjpDb250cmFjdEFkZHJlc3NcIiAvKiBDb250cmFjdEFkZHJlc3MgKi86XG4gICAgICBhc3NlcnQoXG4gICAgICAgIC8vIGZyb20gOiBodHRwczovL2dpdGh1Yi5jb20vc3Rhcmt3YXJlLWxpYnMvc3RhcmtuZXQtc3BlY3MvYmxvYi8yOWJhYjY1MGJlNmIxODQ3YzkyZDQ0NjFkNGMzMzAwOGI1ZTUwYjFhL2FwaS9zdGFya25ldF9hcGlfb3BlbnJwYy5qc29uI0wxMjQ1XG4gICAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDI1Mm4gLSAxbixcbiAgICAgICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBjYWlybyB0eXBlZCAke2lucHV0LnR5cGV9IHNob3VsZCBiZSBpbiByYW5nZSBbMCwgMl4yNTItMV1gXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvcmU6OnN0YXJrbmV0OjpzZWNwMjU2azE6OlNlY3AyNTZrMVBvaW50XCIgLyogU2VjcDI1NmsxUG9pbnQgKi86IHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgcGFyYW0gPj0gMG4gJiYgcGFyYW0gPD0gMm4gKiogNTEybiAtIDFuLFxuICAgICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG11c3QgYmUgJHtpbnB1dC50eXBlfSA6IGEgNTEyIGJpdHMgbnVtYmVyLmBcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59O1xudmFyIHZhbGlkYXRlQm9vbCA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICBpc0Jvb2xlYW4ocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IG9mIGNhaXJvIHR5cGUgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgdHlwZSAoQm9vbGVhbilgXG4gICk7XG59O1xudmFyIHZhbGlkYXRlU3RydWN0ID0gKHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMpID0+IHtcbiAgaWYgKGlucHV0LnR5cGUgPT09IFwiY29yZTo6aW50ZWdlcjo6dTI1NlwiIC8qIHUyNTYgKi8gfHwgaW5wdXQudHlwZSA9PT0gXCJjb3JlOjppbnRlZ2VyOjp1NTEyXCIgLyogdTUxMiAqLykge1xuICAgIHZhbGlkYXRlVWludChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlucHV0LnR5cGUgPT09IFwiY29yZTo6c3RhcmtuZXQ6OmV0aF9hZGRyZXNzOjpFdGhBZGRyZXNzXCIpIHtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2YgcGFyYW1ldGVyICE9PSBcIm9iamVjdFwiLFxuICAgICAgYEV0aEFkZHJlc3MgdHlwZSBpcyB3YWl0aW5nIGEgQmlnTnVtYmVyaXNoLiBHb3QgJHtwYXJhbWV0ZXJ9YFxuICAgICk7XG4gICAgY29uc3QgcGFyYW0gPSBCaWdJbnQocGFyYW1ldGVyLnRvU3RyaW5nKDEwKSk7XG4gICAgYXNzZXJ0KFxuICAgICAgLy8gZnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdGFya3dhcmUtbGlicy9zdGFya25ldC1zcGVjcy9ibG9iLzI5YmFiNjUwYmU2YjE4NDdjOTJkNDQ2MWQ0YzMzMDA4YjVlNTBiMWEvYXBpL3N0YXJrbmV0X2FwaV9vcGVucnBjLmpzb24jTDEyNTlcbiAgICAgIHBhcmFtID49IDBuICYmIHBhcmFtIDw9IDJuICoqIDE2MG4gLSAxbixcbiAgICAgIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gY2Fpcm8gdHlwZWQgJHtpbnB1dC50eXBlfSBzaG91bGQgYmUgaW4gcmFuZ2UgWzAsIDJeMTYwLTFdYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHBhcmFtZXRlciksXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBpcyBjYWlybyB0eXBlIHN0cnVjdCAoJHtpbnB1dC50eXBlfSksIGFuZCBzaG91bGQgYmUgZGVmaW5lZCBhcyBqcyBvYmplY3QgKG5vdCBhcnJheSlgXG4gICk7XG4gIHN0cnVjdHNbaW5wdXQudHlwZV0ubWVtYmVycy5mb3JFYWNoKCh7IG5hbWUgfSkgPT4ge1xuICAgIGFzc2VydChcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtZXRlcikuaW5jbHVkZXMobmFtZSksXG4gICAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IHNob3VsZCBoYXZlIGEgcHJvcGVydHkgJHtuYW1lfWBcbiAgICApO1xuICB9KTtcbn07XG52YXIgdmFsaWRhdGVFbnVtID0gKHBhcmFtZXRlciwgaW5wdXQpID0+IHtcbiAgYXNzZXJ0KFxuICAgIHR5cGVvZiBwYXJhbWV0ZXIgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1ldGVyKSxcbiAgICBgVmFsaWRhdGU6IGFyZyAke2lucHV0Lm5hbWV9IGlzIGNhaXJvIHR5cGUgRW51bSAoJHtpbnB1dC50eXBlfSksIGFuZCBzaG91bGQgYmUgZGVmaW5lZCBhcyBqcyBvYmplY3QgKG5vdCBhcnJheSlgXG4gICk7XG4gIGNvbnN0IG1ldGhvZHNLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmFtZXRlcikpO1xuICBjb25zdCBrZXlzID0gWy4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmFtZXRlciksIC4uLm1ldGhvZHNLZXlzXTtcbiAgaWYgKGlzVHlwZU9wdGlvbihpbnB1dC50eXBlKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNTb21lXCIpICYmIGtleXMuaW5jbHVkZXMoXCJpc05vbmVcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzVHlwZVJlc3VsdChpbnB1dC50eXBlKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNPa1wiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNFcnJcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGtleXMuaW5jbHVkZXMoXCJ2YXJpYW50XCIpICYmIGtleXMuaW5jbHVkZXMoXCJhY3RpdmVWYXJpYW50XCIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgVmFsaWRhdGUgRW51bTogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSByZWNlaXZlZCAke3BhcmFtZXRlcn0sIGlzIG5vdCBhbiBFbnVtLmBcbiAgKTtcbn07XG52YXIgdmFsaWRhdGVUdXBsZSA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGFzc2VydChcbiAgICB0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHBhcmFtZXRlciksXG4gICAgYFZhbGlkYXRlOiBhcmcgJHtpbnB1dC5uYW1lfSBzaG91bGQgYmUgYSB0dXBsZSAoZGVmaW5lZCBhcyBvYmplY3QpYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUFycmF5ID0gKHBhcmFtZXRlciwgaW5wdXQsIHN0cnVjdHMsIGVudW1zKSA9PiB7XG4gIGNvbnN0IGJhc2VUeXBlID0gZ2V0QXJyYXlUeXBlKGlucHV0LnR5cGUpO1xuICBpZiAoaXNUeXBlRmVsdChiYXNlVHlwZSkgJiYgaXNMb25nVGV4dChwYXJhbWV0ZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhcmFtZXRlciksIGBWYWxpZGF0ZTogYXJnICR7aW5wdXQubmFtZX0gc2hvdWxkIGJlIGFuIEFycmF5YCk7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgaXNUeXBlRmVsdChiYXNlVHlwZSk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaCgocGFyYW0pID0+IHZhbGlkYXRlRmVsdChwYXJhbSwgaW5wdXQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlVHVwbGUoYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKGl0KSA9PiB2YWxpZGF0ZVR1cGxlKGl0LCB7IG5hbWU6IGlucHV0Lm5hbWUsIHR5cGU6IGJhc2VUeXBlIH0pKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlQXJyYXkoYmFzZVR5cGUpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goXG4gICAgICAgIChwYXJhbSkgPT4gdmFsaWRhdGVBcnJheShwYXJhbSwgeyBuYW1lOiBcIlwiLCB0eXBlOiBiYXNlVHlwZSB9LCBzdHJ1Y3RzLCBlbnVtcylcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlzVHlwZVN0cnVjdChiYXNlVHlwZSwgc3RydWN0cyk6XG4gICAgICBwYXJhbWV0ZXIuZm9yRWFjaChcbiAgICAgICAgKGl0KSA9PiB2YWxpZGF0ZVN0cnVjdChpdCwgeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBiYXNlVHlwZSB9LCBzdHJ1Y3RzKVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlRW51bShiYXNlVHlwZSwgZW51bXMpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKGl0KSA9PiB2YWxpZGF0ZUVudW0oaXQsIHsgbmFtZTogaW5wdXQubmFtZSwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAoaXNUeXBlVWludChiYXNlVHlwZSkgfHwgaXNUeXBlTGl0ZXJhbChiYXNlVHlwZSkpOlxuICAgICAgcGFyYW1ldGVyLmZvckVhY2goKHBhcmFtKSA9PiB2YWxpZGF0ZVVpbnQocGFyYW0sIHsgbmFtZTogXCJcIiwgdHlwZTogYmFzZVR5cGUgfSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpc1R5cGVCb29sKGJhc2VUeXBlKTpcbiAgICAgIHBhcmFtZXRlci5mb3JFYWNoKChwYXJhbSkgPT4gdmFsaWRhdGVCb29sKHBhcmFtLCBpbnB1dCkpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFZhbGlkYXRlIFVuaGFuZGxlZDogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSAke3BhcmFtZXRlcn1gXG4gICAgICApO1xuICB9XG59O1xudmFyIHZhbGlkYXRlTm9uWmVybyA9IChwYXJhbWV0ZXIsIGlucHV0KSA9PiB7XG4gIGNvbnN0IGJhc2VUeXBlID0gZ2V0QXJyYXlUeXBlKGlucHV0LnR5cGUpO1xuICBhc3NlcnQoXG4gICAgaXNUeXBlVWludChiYXNlVHlwZSkgJiYgYmFzZVR5cGUgIT09IENhaXJvVWludDUxMi5hYmlTZWxlY3RvciB8fCBpc1R5cGVGZWx0KGJhc2VUeXBlKSxcbiAgICBgVmFsaWRhdGU6ICR7aW5wdXQubmFtZX0gdHlwZSBpcyBub3QgYXV0aG9yaXplZCBmb3IgTm9uWmVybyB0eXBlLmBcbiAgKTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBpc1R5cGVGZWx0KGJhc2VUeXBlKTpcbiAgICAgIHZhbGlkYXRlRmVsdChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgIGFzc2VydChcbiAgICAgICAgQmlnSW50KHBhcmFtZXRlci50b1N0cmluZygxMCkpID4gMCxcbiAgICAgICAgXCJWYWxpZGF0ZTogdmFsdWUgMCBpcyBub3QgYXV0aG9yaXplZCBpbiBOb25aZXJvIGZlbHQyNTIgdHlwZS5cIlxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaXNUeXBlVWludChiYXNlVHlwZSk6XG4gICAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCB7IG5hbWU6IFwiXCIsIHR5cGU6IGJhc2VUeXBlIH0pO1xuICAgICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjb3JlOjppbnRlZ2VyOjp1MjU2XCIgLyogdTI1NiAqLzpcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICBuZXcgQ2Fpcm9VaW50MjU2KHBhcmFtZXRlcikudG9CaWdJbnQoKSA+IDAsXG4gICAgICAgICAgICBcIlZhbGlkYXRlOiB2YWx1ZSAwIGlzIG5vdCBhdXRob3JpemVkIGluIE5vblplcm8gdWludDI1NiB0eXBlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgICB0b0JpZ0ludChwYXJhbWV0ZXIpID4gMCxcbiAgICAgICAgICAgIFwiVmFsaWRhdGU6IHZhbHVlIDAgaXMgbm90IGF1dGhvcml6ZWQgaW4gTm9uWmVybyB1aW50IHR5cGUuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFZhbGlkYXRlIFVuaGFuZGxlZDogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSAke3BhcmFtZXRlcn1gXG4gICAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZHMoYWJpTWV0aG9kLCBhcmdzLCBzdHJ1Y3RzLCBlbnVtcykge1xuICBhYmlNZXRob2QuaW5wdXRzLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IGFyZ3NbYWNjXTtcbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgaXNMZW4oaW5wdXQubmFtZSk6XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICBjYXNlIGlzVHlwZUZlbHQoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlRmVsdChwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUJ5dGVzMzEoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQnl0ZXMzMShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIChpc1R5cGVVaW50KGlucHV0LnR5cGUpIHx8IGlzVHlwZUxpdGVyYWwoaW5wdXQudHlwZSkpOlxuICAgICAgICB2YWxpZGF0ZVVpbnQocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCb29sKGlucHV0LnR5cGUpOlxuICAgICAgICB2YWxpZGF0ZUJvb2wocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVCeXRlQXJyYXkoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQnl0ZUFycmF5KHBhcmFtZXRlciwgaW5wdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlQXJyYXkoaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlQXJyYXkocGFyYW1ldGVyLCBpbnB1dCwgc3RydWN0cywgZW51bXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaXNUeXBlU3RydWN0KGlucHV0LnR5cGUsIHN0cnVjdHMpOlxuICAgICAgICB2YWxpZGF0ZVN0cnVjdChwYXJhbWV0ZXIsIGlucHV0LCBzdHJ1Y3RzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZUVudW0oaW5wdXQudHlwZSwgZW51bXMpOlxuICAgICAgICB2YWxpZGF0ZUVudW0ocGFyYW1ldGVyLCBpbnB1dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpc1R5cGVUdXBsZShpbnB1dC50eXBlKTpcbiAgICAgICAgdmFsaWRhdGVUdXBsZShwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlzVHlwZU5vblplcm8oaW5wdXQudHlwZSk6XG4gICAgICAgIHZhbGlkYXRlTm9uWmVybyhwYXJhbWV0ZXIsIGlucHV0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFZhbGlkYXRlIFVuaGFuZGxlZDogYXJndW1lbnQgJHtpbnB1dC5uYW1lfSwgdHlwZSAke2lucHV0LnR5cGV9LCB2YWx1ZSAke3BhcmFtZXRlcn1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhY2MgKyAxO1xuICB9LCAwKTtcbn1cblxuLy8gc3JjL3V0aWxzL2NhbGxkYXRhL2luZGV4LnRzXG52YXIgQ2FsbERhdGEgPSBjbGFzcyBfQ2FsbERhdGEge1xuICBhYmk7XG4gIHBhcnNlcjtcbiAgc3RydWN0cztcbiAgZW51bXM7XG4gIGNvbnN0cnVjdG9yKGFiaSkge1xuICAgIHRoaXMuc3RydWN0cyA9IF9DYWxsRGF0YS5nZXRBYmlTdHJ1Y3QoYWJpKTtcbiAgICB0aGlzLmVudW1zID0gX0NhbGxEYXRhLmdldEFiaUVudW0oYWJpKTtcbiAgICB0aGlzLnBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gdGhpcy5wYXJzZXIuZ2V0TGVnYWN5Rm9ybWF0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBhcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBvbmVzIGluIHRoZSBhYmlcbiAgICogQHBhcmFtIHR5cGUgVmFsaWRhdGVUeXBlIC0gdHlwZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbmFtZSBvZiB0aGUgbWV0aG9kXG4gICAqIEBwYXJhbSBhcmdzIEFyZ3NPckNhbGxkYXRhIC0gYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXG4gICAqL1xuICB2YWxpZGF0ZSh0eXBlLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGlmICh0eXBlICE9PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgY29uc3QgaW52b2NhYmxlRnVuY3Rpb25OYW1lcyA9IHRoaXMuYWJpLmZpbHRlcigoYWJpKSA9PiB7XG4gICAgICAgIGlmIChhYmkudHlwZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlzVmlldyA9IGFiaS5zdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IGFiaS5zdGF0ZV9tdXRhYmlsaXR5ID09PSBcInZpZXdcIjtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiSU5WT0tFXCIgLyogSU5WT0tFICovID8gIWlzVmlldyA6IGlzVmlldztcbiAgICAgIH0pLm1hcCgoYWJpKSA9PiBhYmkubmFtZSk7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIGludm9jYWJsZUZ1bmN0aW9uTmFtZXMuaW5jbHVkZXMobWV0aG9kKSxcbiAgICAgICAgYCR7dHlwZSA9PT0gXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8gPyBcImludm9jYWJsZVwiIDogXCJ2aWV3YWJsZVwifSBtZXRob2Qgbm90IGZvdW5kIGluIGFiaWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGFiaU1ldGhvZCA9IHRoaXMuYWJpLmZpbmQoXG4gICAgICAoYWJpKSA9PiB0eXBlID09PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLyA/IGFiaS5uYW1lID09PSBtZXRob2QgJiYgYWJpLnR5cGUgPT09IFwiY29uc3RydWN0b3JcIiA6IGFiaS5uYW1lID09PSBtZXRob2QgJiYgYWJpLnR5cGUgPT09IFwiZnVuY3Rpb25cIlxuICAgICk7XG4gICAgaWYgKGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJncywgYWJpTWV0aG9kKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dHNMZW5ndGggPSB0aGlzLnBhcnNlci5tZXRob2RJbnB1dHNMZW5ndGgoYWJpTWV0aG9kKTtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IGlucHV0c0xlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMsIGV4cGVjdGVkICR7aW5wdXRzTGVuZ3RofSBhcmd1bWVudHMsIGJ1dCBnb3QgJHthcmdzLmxlbmd0aH1gXG4gICAgICApO1xuICAgIH1cbiAgICB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBpbGUgY29udHJhY3QgY2FsbERhdGEgd2l0aCBhYmlcbiAgICogUGFyc2UgdGhlIGNhbGxkYXRhIGJ5IHVzaW5nIGlucHV0IGZpZWxkcyBmcm9tIHRoZSBhYmkgZm9yIHRoYXQgbWV0aG9kXG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIGFyZ3NDYWxsZGF0YSBSYXdBcmdzIC0gYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBDYW4gYmUgYW4gYXJyYXkgb2YgYXJndW1lbnRzIChpbiB0aGUgb3JkZXIgb2YgYWJpIGRlZmluaXRpb24pLCBvciBhbiBvYmplY3QgY29uc3RydWN0ZWQgaW4gY29uZm9ybWl0eSB3aXRoIGFiaSAoaW4gdGhpcyBjYXNlLCB0aGUgcGFyYW1ldGVyIGNhbiBiZSBpbiBhIHdyb25nIG9yZGVyKS5cbiAgICogQHJldHVybiBDYWxsZGF0YSAtIHBhcnNlZCBhcmd1bWVudHMgaW4gZm9ybWF0IHRoYXQgY29udHJhY3QgaXMgZXhwZWN0aW5nXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgY2FsbGRhdGEgPSBteUNhbGxEYXRhLmNvbXBpbGUoXCJjb25zdHJ1Y3RvclwiLCBbXCIweDM0YVwiLCBbMSwgM25dXSk7XG4gICAqIGBgYFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGNhbGxkYXRhMiA9IG15Q2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHtsaXN0OlsxLCAzbl0sIGJhbGFuY2U6XCIweDM0XCJ9KTsgLy8gd3Jvbmcgb3JkZXIgaXMgdmFsaWRcbiAgICogYGBgXG4gICAqL1xuICBjb21waWxlKG1ldGhvZCwgYXJnc0NhbGxkYXRhKSB7XG4gICAgY29uc3QgYWJpTWV0aG9kID0gdGhpcy5hYmkuZmluZCgoYWJpRnVuY3Rpb24pID0+IGFiaUZ1bmN0aW9uLm5hbWUgPT09IG1ldGhvZCk7XG4gICAgaWYgKGlzTm9Db25zdHJ1Y3RvclZhbGlkKG1ldGhvZCwgYXJnc0NhbGxkYXRhLCBhYmlNZXRob2QpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBhcmdzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NDYWxsZGF0YSkpIHtcbiAgICAgIGFyZ3MgPSBhcmdzQ2FsbGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yZGVyZWRPYmplY3QgPSBvcmRlclByb3BzQnlBYmkoXG4gICAgICAgIGFyZ3NDYWxsZGF0YSxcbiAgICAgICAgYWJpTWV0aG9kLmlucHV0cyxcbiAgICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgICB0aGlzLmVudW1zXG4gICAgICApO1xuICAgICAgYXJncyA9IE9iamVjdC52YWx1ZXMob3JkZXJlZE9iamVjdCk7XG4gICAgICB2YWxpZGF0ZUZpZWxkcyhhYmlNZXRob2QsIGFyZ3MsIHRoaXMuc3RydWN0cywgdGhpcy5lbnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3NJdGVyYXRvciA9IGFyZ3NbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGNhbGxBcnJheSA9IGFiaU1ldGhvZC5pbnB1dHMucmVkdWNlKFxuICAgICAgKGFjYywgaW5wdXQpID0+IGlzTGVuKGlucHV0Lm5hbWUpICYmICFpc0NhaXJvMVR5cGUoaW5wdXQudHlwZSkgPyBhY2MgOiBhY2MuY29uY2F0KHBhcnNlQ2FsbGRhdGFGaWVsZChhcmdzSXRlcmF0b3IsIGlucHV0LCB0aGlzLnN0cnVjdHMsIHRoaXMuZW51bXMpKSxcbiAgICAgIFtdXG4gICAgKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FsbEFycmF5LCBcIl9fY29tcGlsZWRfX1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxBcnJheTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBjb250cmFjdCBjYWxsRGF0YSB3aXRob3V0IGFiaVxuICAgKiBAcGFyYW0gcmF3QXJncyBSYXdBcmdzIHJlcHJlc2VudGluZyBjYWlybyBtZXRob2QgYXJndW1lbnRzIG9yIHN0cmluZyBhcnJheSBvZiBjb21waWxlZCBkYXRhXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgY29tcGlsZShyYXdBcmdzKSB7XG4gICAgY29uc3QgY3JlYXRlVHJlZSA9IChvYmopID0+IHtcbiAgICAgIGNvbnN0IGdldEVudHJpZXMgPSAobywgcHJlZml4ID0gXCIuXCIpID0+IHtcbiAgICAgICAgY29uc3Qgb2UgPSBBcnJheS5pc0FycmF5KG8pID8gW28ubGVuZ3RoLnRvU3RyaW5nKCksIC4uLm9dIDogbztcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9lKS5mbGF0TWFwKChbaywgdl0pID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB2O1xuICAgICAgICAgIGlmIChrID09PSBcImVudHJ5cG9pbnRcIikgdmFsdWUgPSBnZXRTZWxlY3RvckZyb21OYW1lKHZhbHVlKTtcbiAgICAgICAgICBlbHNlIGlmIChpc0xvbmdUZXh0KHZhbHVlKSkgdmFsdWUgPSBieXRlQXJyYXlGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBrayA9IEFycmF5LmlzQXJyYXkob2UpICYmIGsgPT09IFwiMFwiID8gXCIkJGxlblwiIDogaztcbiAgICAgICAgICBpZiAoaXNCaWdJbnQodmFsdWUpKSByZXR1cm4gW1tgJHtwcmVmaXh9JHtra31gLCBmZWx0KHZhbHVlKV1dO1xuICAgICAgICAgIGlmIChPYmplY3QodmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kc0tleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLCAuLi5tZXRob2RzS2V5c107XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcImlzU29tZVwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiaXNOb25lXCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15T3B0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnROYiA9IG15T3B0aW9uLmlzU29tZSgpID8gMCAvKiBTb21lICovIDogMSAvKiBOb25lICovO1xuICAgICAgICAgICAgICBpZiAobXlPcHRpb24uaXNTb21lKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiB2YXJpYW50TmIsIDE6IG15T3B0aW9uLnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YXJpYW50TmIpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhcImlzT2tcIikgJiYga2V5cy5pbmNsdWRlcyhcImlzRXJyXCIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG15UmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnROYiA9IG15UmVzdWx0LmlzT2soKSA/IDAgLyogT2sgKi8gOiAxIC8qIEVyciAqLztcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXMoeyAwOiB2YXJpYW50TmIsIDE6IG15UmVzdWx0LnVud3JhcCgpIH0sIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKFwidmFyaWFudFwiKSAmJiBrZXlzLmluY2x1ZGVzKFwiYWN0aXZlVmFyaWFudFwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBteUVudW0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFudCA9IG15RW51bS5hY3RpdmVWYXJpYW50KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGxpc3RWYXJpYW50cyA9IE9iamVjdC5rZXlzKG15RW51bS52YXJpYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlVmFyaWFudE5iID0gbGlzdFZhcmlhbnRzLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAodmFyaWFudCkgPT4gdmFyaWFudCA9PT0gYWN0aXZlVmFyaWFudFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG15RW51bS51bndyYXAoKSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhteUVudW0udW53cmFwKCkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbW2Ake3ByZWZpeH0ke2trfWAsIGZlbHQoYWN0aXZlVmFyaWFudE5iKV1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFbnRyaWVzKHsgMDogYWN0aXZlVmFyaWFudE5iLCAxOiBteUVudW0udW53cmFwKCkgfSwgYCR7cHJlZml4fSR7a2t9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEVudHJpZXModmFsdWUsIGAke3ByZWZpeH0ke2trfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtbYCR7cHJlZml4fSR7a2t9YCwgZmVsdCh2YWx1ZSldXTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldEVudHJpZXMob2JqKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgbGV0IGNhbGxUcmVlQXJyYXk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJhd0FyZ3MpKSB7XG4gICAgICBjb25zdCBjYWxsVHJlZSA9IGNyZWF0ZVRyZWUocmF3QXJncyk7XG4gICAgICBjYWxsVHJlZUFycmF5ID0gT2JqZWN0LnZhbHVlcyhjYWxsVHJlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNhbGxPYmogPSB7IC4uLnJhd0FyZ3MgfTtcbiAgICAgIGNvbnN0IGNhbGxUcmVlID0gY3JlYXRlVHJlZShjYWxsT2JqKTtcbiAgICAgIGNhbGxUcmVlQXJyYXkgPSBPYmplY3QudmFsdWVzKGNhbGxUcmVlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbGxUcmVlQXJyYXksIFwiX19jb21waWxlZF9fXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbFRyZWVBcnJheTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgZWxlbWVudHMgb2YgdGhlIHJlc3BvbnNlIGFycmF5IGFuZCBzdHJ1Y3R1cmluZyB0aGVtIGludG8gcmVzcG9uc2Ugb2JqZWN0XG4gICAqIEBwYXJhbSBtZXRob2Qgc3RyaW5nIC0gbWV0aG9kIG5hbWVcbiAgICogQHBhcmFtIHJlc3BvbnNlIHN0cmluZ1tdIC0gcmVzcG9uc2UgZnJvbSB0aGUgbWV0aG9kXG4gICAqIEByZXR1cm4gUmVzdWx0IC0gcGFyc2VkIHJlc3BvbnNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFiaVxuICAgKi9cbiAgcGFyc2UobWV0aG9kLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHsgb3V0cHV0cyB9ID0gdGhpcy5hYmkuZmluZCgoYWJpKSA9PiBhYmkubmFtZSA9PT0gbWV0aG9kKTtcbiAgICBjb25zdCByZXNwb25zZUl0ZXJhdG9yID0gcmVzcG9uc2UuZmxhdCgpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBjb25zdCBwYXJzZWQgPSBvdXRwdXRzLmZsYXQoKS5yZWR1Y2UoKGFjYywgb3V0cHV0LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BOYW1lID0gb3V0cHV0Lm5hbWUgPz8gaWR4O1xuICAgICAgYWNjW3Byb3BOYW1lXSA9IHJlc3BvbnNlUGFyc2VyKHJlc3BvbnNlSXRlcmF0b3IsIG91dHB1dCwgdGhpcy5zdHJ1Y3RzLCB0aGlzLmVudW1zLCBhY2MpO1xuICAgICAgaWYgKGFjY1twcm9wTmFtZV0gJiYgYWNjW2Ake3Byb3BOYW1lfV9sZW5gXSkge1xuICAgICAgICBkZWxldGUgYWNjW2Ake3Byb3BOYW1lfV9sZW5gXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJzZWQpLmxlbmd0aCA9PT0gMSAmJiAwIGluIHBhcnNlZCA/IHBhcnNlZFswXSA6IHBhcnNlZDtcbiAgfVxuICAvKipcbiAgICogRm9ybWF0IGNhaXJvIG1ldGhvZCByZXNwb25zZSBkYXRhIHRvIG5hdGl2ZSBqcyB2YWx1ZXMgYmFzZWQgb24gcHJvdmlkZWQgZm9ybWF0IHNjaGVtYVxuICAgKiBAcGFyYW0gbWV0aG9kIHN0cmluZyAtIGNhaXJvIG1ldGhvZCBuYW1lXG4gICAqIEBwYXJhbSByZXNwb25zZSBzdHJpbmdbXSAtIGNhaXJvIG1ldGhvZCByZXNwb25zZVxuICAgKiBAcGFyYW0gZm9ybWF0IG9iamVjdCAtIGZvcm1hdHRlciBvYmplY3Qgc2NoZW1hXG4gICAqIEByZXR1cm5zIFJlc3VsdCAtIHBhcnNlZCBhbmQgZm9ybWF0dGVkIHJlc3BvbnNlIG9iamVjdFxuICAgKi9cbiAgZm9ybWF0KG1ldGhvZCwgcmVzcG9uc2UsIGZvcm1hdCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2UobWV0aG9kLCByZXNwb25zZSk7XG4gICAgcmV0dXJuIGZvcm1hdHRlcihwYXJzZWQsIGZvcm1hdCk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IHN0cnVjdHMgZnJvbSBhYmlcbiAgICogQHBhcmFtIGFiaSBBYmlcbiAgICogQHJldHVybnMgQWJpU3RydWN0cyAtIHN0cnVjdHMgZnJvbSBhYmlcbiAgICovXG4gIHN0YXRpYyBnZXRBYmlTdHJ1Y3QoYWJpKSB7XG4gICAgcmV0dXJuIGFiaS5maWx0ZXIoKGFiaUVudHJ5KSA9PiBhYmlFbnRyeS50eXBlID09PSBcInN0cnVjdFwiKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBhYmlFbnRyeSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbYWJpRW50cnkubmFtZV06IGFiaUVudHJ5XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIHRvIGV4dHJhY3QgZW51bXMgZnJvbSBhYmlcbiAgICogQHBhcmFtIGFiaSBBYmlcbiAgICogQHJldHVybnMgQWJpRW51bXMgLSBlbnVtcyBmcm9tIGFiaVxuICAgKi9cbiAgc3RhdGljIGdldEFiaUVudW0oYWJpKSB7XG4gICAgY29uc3QgZnVsbEVudW1MaXN0ID0gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwiZW51bVwiKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBhYmlFbnRyeSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBbYWJpRW50cnkubmFtZV06IGFiaUVudHJ5XG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBkZWxldGUgZnVsbEVudW1MaXN0W1wiY29yZTo6Ym9vbFwiXTtcbiAgICByZXR1cm4gZnVsbEVudW1MaXN0O1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXI6IENvbXBpbGUgSGV4Q2FsbGRhdGEgfCBSYXdDYWxsZGF0YSB8IFJhd0FyZ3NcbiAgICogQHBhcmFtIHJhd0NhbGxkYXRhIEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEByZXR1cm5zIENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgdG9DYWxsZGF0YShyYXdDYWxsZGF0YSA9IFtdKSB7XG4gICAgcmV0dXJuIF9DYWxsRGF0YS5jb21waWxlKHJhd0NhbGxkYXRhKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyOiBDb252ZXJ0IHJhdyB0byBIZXhDYWxsZGF0YVxuICAgKiBAcGFyYW0gcmF3IEhleENhbGxkYXRhIHwgUmF3Q2FsbGRhdGEgfCBSYXdBcmdzXG4gICAqIEByZXR1cm5zIEhleENhbGxkYXRhXG4gICAqL1xuICBzdGF0aWMgdG9IZXgocmF3ID0gW10pIHtcbiAgICBjb25zdCBjYWxsZGF0YSA9IF9DYWxsRGF0YS5jb21waWxlKHJhdyk7XG4gICAgcmV0dXJuIGNhbGxkYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIGNvbnRyYWN0IHJlc3BvbnNlIGFuZCBzdHJ1Y3R1cmUgdGhlbSBpbnRvIG9uZSBvciBzZXZlcmFsIFJlc3VsdC5cbiAgICogSW4gQ2Fpcm8gMCwgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgKiBAcGFyYW0gdHlwZUNhaXJvIHN0cmluZyBvciBzdHJpbmdbXSAtIENhaXJvIHR5cGUgbmFtZSwgZXggOiBcImhlbGxvOjpoZWxsbzo6VXNlckRhdGFcIlxuICAgKiBAcGFyYW0gcmVzcG9uc2Ugc3RyaW5nW10gLSBzZXJpYWxpemVkIGRhdGEgY29ycmVzcG9uZGluZyB0byB0eXBlQ2Fpcm8uXG4gICAqIEByZXR1cm4gUmVzdWx0IG9yIFJlc3VsdFtdIC0gcGFyc2VkIHJlc3BvbnNlIGNvcnJlc3BvbmRpbmcgdG8gdHlwZURhdGEuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlczI9aGVsbG9DYWxsRGF0YS5kZWNvZGVQYXJhbWV0ZXJzKFwiaGVsbG86OmhlbGxvOjpVc2VyRGF0YVwiLFtcIjB4MTIzNDU2XCIsXCIweDFcIl0pO1xuICAgKiByZXN1bHQgPSB7IGFkZHJlc3M6IDExOTMwNDZuLCBpc19jbGFpbWVkOiB0cnVlIH1cbiAgICovXG4gIGRlY29kZVBhcmFtZXRlcnModHlwZUNhaXJvLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHR5cGVDYWlyb0FycmF5ID0gQXJyYXkuaXNBcnJheSh0eXBlQ2Fpcm8pID8gdHlwZUNhaXJvIDogW3R5cGVDYWlyb107XG4gICAgY29uc3QgcmVzcG9uc2VJdGVyYXRvciA9IHJlc3BvbnNlLmZsYXQoKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgZGVjb2RlZEFycmF5ID0gdHlwZUNhaXJvQXJyYXkubWFwKFxuICAgICAgKHR5cGVQYXJhbSkgPT4gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIHJlc3BvbnNlSXRlcmF0b3IsXG4gICAgICAgIHsgbmFtZTogXCJcIiwgdHlwZTogdHlwZVBhcmFtIH0sXG4gICAgICAgIHRoaXMuc3RydWN0cyxcbiAgICAgICAgdGhpcy5lbnVtc1xuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuIGRlY29kZWRBcnJheS5sZW5ndGggPT09IDEgPyBkZWNvZGVkQXJyYXlbMF0gOiBkZWNvZGVkQXJyYXk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9oYXNoL2luZGV4LnRzXG52YXIgaGFzaF9leHBvcnRzID0ge307XG5fX2V4cG9ydChoYXNoX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2g6ICgpID0+IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoLFxuICBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoOiAoKSA9PiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyxcbiAgY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMsXG4gIGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMixcbiAgY2FsY3VsYXRlTDJNZXNzYWdlVHhIYXNoOiAoKSA9PiBjYWxjdWxhdGVMMk1lc3NhZ2VUeEhhc2gsXG4gIGNvbXB1dGVDb21waWxlZENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlQ29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHMyLFxuICBjb21wdXRlSGludGVkQ2xhc3NIYXNoOiAoKSA9PiBjb21wdXRlSGludGVkQ2xhc3NIYXNoLFxuICBjb21wdXRlTGVnYWN5Q29udHJhY3RDbGFzc0hhc2g6ICgpID0+IGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaDogKCkgPT4gY29tcHV0ZVBlZGVyc2VuSGFzaCxcbiAgY29tcHV0ZVBlZGVyc2VuSGFzaE9uRWxlbWVudHM6ICgpID0+IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICBjb21wdXRlUG9zZWlkb25IYXNoOiAoKSA9PiBjb21wdXRlUG9zZWlkb25IYXNoLFxuICBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50czogKCkgPT4gY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gIGNvbXB1dGVTaWVycmFDb250cmFjdENsYXNzSGFzaDogKCkgPT4gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoLFxuICBmb3JtYXRTcGFjZXM6ICgpID0+IGZvcm1hdFNwYWNlcyxcbiAgZ2V0TDJNZXNzYWdlSGFzaDogKCkgPT4gZ2V0TDJNZXNzYWdlSGFzaCxcbiAgZ2V0U2VsZWN0b3I6ICgpID0+IGdldFNlbGVjdG9yLFxuICBnZXRTZWxlY3RvckZyb21OYW1lOiAoKSA9PiBnZXRTZWxlY3RvckZyb21OYW1lLFxuICBoYXNoQnl0ZUNvZGVTZWdtZW50czogKCkgPT4gaGFzaEJ5dGVDb2RlU2VnbWVudHMsXG4gIGtlY2Nha0JuOiAoKSA9PiBrZWNjYWtCbixcbiAgcG9zZWlkb246ICgpID0+IHBvc2VpZG9uLFxuICBzb2xpZGl0eVVpbnQyNTZQYWNrZWRLZWNjYWsyNTY6ICgpID0+IHNvbGlkaXR5VWludDI1NlBhY2tlZEtlY2NhazI1NixcbiAgc3RhcmtuZXRLZWNjYWs6ICgpID0+IHN0YXJrbmV0S2VjY2FrXG59KTtcbmltcG9ydCAqIGFzIHBvc2VpZG9uIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3Bvc2VpZG9uXCI7XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92Mi50c1xudmFyIHYyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHYyX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlTDJNZXNzYWdlVHhIYXNoOiAoKSA9PiBjYWxjdWxhdGVMMk1lc3NhZ2VUeEhhc2gsXG4gIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoLFxuICBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb246ICgpID0+IGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbixcbiAgY29tcHV0ZUhhc2hPbkVsZW1lbnRzOiAoKSA9PiBjb21wdXRlSGFzaE9uRWxlbWVudHNcbn0pO1xuXG4vLyBzcmMvdXRpbHMvZWMudHNcbnZhciBlY19leHBvcnRzID0ge307XG5fX2V4cG9ydChlY19leHBvcnRzLCB7XG4gIHN0YXJrQ3VydmU6ICgpID0+IHN0YXJrQ3VydmUsXG4gIHdlaWVyc3RyYXNzOiAoKSA9PiB3ZWllcnN0cmFzc1xufSk7XG5pbXBvcnQgKiBhcyBzdGFya0N1cnZlIGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmltcG9ydCAqIGFzIHdlaWVyc3RyYXNzIGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3dlaWVyc3RyYXNzXCI7XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92Mi50c1xuZnVuY3Rpb24gY29tcHV0ZUhhc2hPbkVsZW1lbnRzKGRhdGEpIHtcbiAgcmV0dXJuIFsuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBzdGFya0N1cnZlLnBlZGVyc2VuKHRvQmlnSW50KHgpLCB0b0JpZ0ludCh5KSksIDApLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24odHhIYXNoUHJlZml4LCB2ZXJzaW9uLCBjb250cmFjdEFkZHJlc3MsIGVudHJ5UG9pbnRTZWxlY3RvciwgY2FsbGRhdGEsIG1heEZlZSwgY2hhaW5JZCwgYWRkaXRpb25hbERhdGEgPSBbXSkge1xuICBjb25zdCBjYWxsZGF0YUhhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMoY2FsbGRhdGEpO1xuICBjb25zdCBkYXRhVG9IYXNoID0gW1xuICAgIHR4SGFzaFByZWZpeCxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICBlbnRyeVBvaW50U2VsZWN0b3IsXG4gICAgY2FsbGRhdGFIYXNoLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIC4uLmFkZGl0aW9uYWxEYXRhXG4gIF07XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMoZGF0YVRvSGFzaCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoKGNsYXNzSGFzaCwgc2VuZGVyQWRkcmVzcywgdmVyc2lvbiwgbWF4RmVlLCBjaGFpbklkLCBub25jZSwgY29tcGlsZWRDbGFzc0hhc2gpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICAwLFxuICAgIFtjbGFzc0hhc2hdLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZSwgLi4uY29tcGlsZWRDbGFzc0hhc2ggPyBbY29tcGlsZWRDbGFzc0hhc2hdIDogW11dXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKGNvbnRyYWN0QWRkcmVzcywgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBzYWx0LCB2ZXJzaW9uLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIGNvbnN0IGNhbGxkYXRhID0gW2NsYXNzSGFzaCwgc2FsdCwgLi4uY29uc3RydWN0b3JDYWxsZGF0YV07XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY0NjU3MDZjNmY3OTVmNjE2MzYzNmY3NTZlNzRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChjb250cmFjdEFkZHJlc3MsIHZlcnNpb24sIGNhbGxkYXRhLCBtYXhGZWUsIGNoYWluSWQsIG5vbmNlKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDY5NmU3NjZmNmI2NVwiIC8qIElOVk9LRSAqLyxcbiAgICB2ZXJzaW9uLFxuICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAwLFxuICAgIGNhbGxkYXRhLFxuICAgIG1heEZlZSxcbiAgICBjaGFpbklkLFxuICAgIFtub25jZV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUwyTWVzc2FnZVR4SGFzaChsMUZyb21BZGRyZXNzLCBsMlRvQWRkcmVzcywgbDJTZWxlY3RvciwgbDJDYWxsZGF0YSwgbDJDaGFpbklkLCBsMU5vbmNlKSB7XG4gIGNvbnN0IHBheWxvYWQgPSBbbDFGcm9tQWRkcmVzcywgLi4ubDJDYWxsZGF0YV07XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24oXG4gICAgXCIweDZjMzE1ZjY4NjE2ZTY0NmM2NTcyXCIgLyogTDFfSEFORExFUiAqLyxcbiAgICAwLFxuICAgIGwyVG9BZGRyZXNzLFxuICAgIGdldFNlbGVjdG9yKGwyU2VsZWN0b3IpLFxuICAgIHBheWxvYWQsXG4gICAgMCxcbiAgICBsMkNoYWluSWQsXG4gICAgW2wxTm9uY2VdXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC92My50c1xudmFyIHYzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHYzX2V4cG9ydHMsIHtcbiAgY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDogKCkgPT4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIsXG4gIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyLFxuICBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2g6ICgpID0+IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaCxcbiAgY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uOiAoKSA9PiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yLFxuICBoYXNoREFNb2RlOiAoKSA9PiBoYXNoREFNb2RlLFxuICBoYXNoRmVlRmllbGQ6ICgpID0+IGhhc2hGZWVGaWVsZFxufSk7XG5pbXBvcnQgeyBwb3NlaWRvbkhhc2hNYW55IH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xudmFyIEFUb0JJID0gKGFycmF5KSA9PiBhcnJheS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKTtcbnZhciBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMgPSAzMm47XG52YXIgTUFYX0FNT1VOVF9CSVRTID0gNjRuO1xudmFyIE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTID0gMTI4bjtcbnZhciBSRVNPVVJDRV9WQUxVRV9PRkZTRVQgPSBNQVhfQU1PVU5UX0JJVFMgKyBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUztcbnZhciBMMV9HQVNfTkFNRSA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhcIkwxX0dBU1wiKSk7XG52YXIgTDJfR0FTX05BTUUgPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoXCJMMl9HQVNcIikpO1xuZnVuY3Rpb24gaGFzaERBTW9kZShub25jZURBTW9kZSwgZmVlREFNb2RlKSB7XG4gIHJldHVybiAoQmlnSW50KG5vbmNlREFNb2RlKSA8PCBEQVRBX0FWQUlMQUJJTElUWV9NT0RFX0JJVFMpICsgQmlnSW50KGZlZURBTW9kZSk7XG59XG5mdW5jdGlvbiBoYXNoRmVlRmllbGQodGlwLCBib3VuZHMpIHtcbiAgY29uc3QgTDFCb3VuZCA9IChMMV9HQVNfTkFNRSA8PCBSRVNPVVJDRV9WQUxVRV9PRkZTRVQpICsgKEJpZ0ludChib3VuZHMubDFfZ2FzLm1heF9hbW91bnQpIDw8IE1BWF9QUklDRV9QRVJfVU5JVF9CSVRTKSArIEJpZ0ludChib3VuZHMubDFfZ2FzLm1heF9wcmljZV9wZXJfdW5pdCk7XG4gIGNvbnN0IEwyQm91bmQgPSAoTDJfR0FTX05BTUUgPDwgUkVTT1VSQ0VfVkFMVUVfT0ZGU0VUKSArIChCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfYW1vdW50KSA8PCBNQVhfUFJJQ0VfUEVSX1VOSVRfQklUUykgKyBCaWdJbnQoYm91bmRzLmwyX2dhcy5tYXhfcHJpY2VfcGVyX3VuaXQpO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueShbQmlnSW50KHRpcCksIEwxQm91bmQsIEwyQm91bmRdKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaENvbW1vbjIodHhIYXNoUHJlZml4LCB2ZXJzaW9uLCBzZW5kZXJBZGRyZXNzLCBjaGFpbklkLCBub25jZSwgdGlwLCBwYXltYXN0ZXJEYXRhLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIGFkZGl0aW9uYWxEYXRhID0gW10pIHtcbiAgY29uc3QgZmVlRmllbGRIYXNoID0gaGFzaEZlZUZpZWxkKHRpcCwgcmVzb3VyY2VCb3VuZHMpO1xuICBjb25zdCBkQU1vZGVIYXNoID0gaGFzaERBTW9kZShub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSk7XG4gIGNvbnN0IGRhdGFUb0hhc2ggPSBBVG9CSShbXG4gICAgdHhIYXNoUHJlZml4LFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBmZWVGaWVsZEhhc2gsXG4gICAgcG9zZWlkb25IYXNoTWFueShBVG9CSShwYXltYXN0ZXJEYXRhKSksXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICBkQU1vZGVIYXNoLFxuICAgIC4uLkFUb0JJKGFkZGl0aW9uYWxEYXRhKVxuICBdKTtcbiAgcmV0dXJuIHRvSGV4KHBvc2VpZG9uSGFzaE1hbnkoZGF0YVRvSGFzaCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDIoY29udHJhY3RBZGRyZXNzLCBjbGFzc0hhc2gsIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSwgc2FsdCwgdmVyc2lvbiwgY2hhaW5JZCwgbm9uY2UsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2NDY1NzA2YzZmNzk1ZjYxNjM2MzZmNzU2ZTc0XCIgLyogREVQTE9ZX0FDQ09VTlQgKi8sXG4gICAgdmVyc2lvbixcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICB0aXAsXG4gICAgcGF5bWFzdGVyRGF0YSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSkpLCBjbGFzc0hhc2gsIHNhbHRdXG4gICk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMihjbGFzc0hhc2gsIGNvbXBpbGVkQ2xhc3NIYXNoLCBzZW5kZXJBZGRyZXNzLCB2ZXJzaW9uLCBjaGFpbklkLCBub25jZSwgYWNjb3VudERlcGxveW1lbnREYXRhLCBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLCBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSwgcmVzb3VyY2VCb3VuZHMsIHRpcCwgcGF5bWFzdGVyRGF0YSkge1xuICByZXR1cm4gY2FsY3VsYXRlVHJhbnNhY3Rpb25IYXNoQ29tbW9uMihcbiAgICBcIjB4NjQ2NTYzNmM2MTcyNjVcIiAvKiBERUNMQVJFICovLFxuICAgIHZlcnNpb24sXG4gICAgc2VuZGVyQWRkcmVzcyxcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIHRpcCxcbiAgICBBVG9CSShwYXltYXN0ZXJEYXRhKSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgIHJlc291cmNlQm91bmRzLFxuICAgIFtwb3NlaWRvbkhhc2hNYW55KEFUb0JJKGFjY291bnREZXBsb3ltZW50RGF0YSkpLCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2xhc3NIYXNoXVxuICApO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoKHNlbmRlckFkZHJlc3MsIHZlcnNpb24sIGNvbXBpbGVkQ2FsbGRhdGEsIGNoYWluSWQsIG5vbmNlLCBhY2NvdW50RGVwbG95bWVudERhdGEsIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLCByZXNvdXJjZUJvdW5kcywgdGlwLCBwYXltYXN0ZXJEYXRhKSB7XG4gIHJldHVybiBjYWxjdWxhdGVUcmFuc2FjdGlvbkhhc2hDb21tb24yKFxuICAgIFwiMHg2OTZlNzY2ZjZiNjVcIiAvKiBJTlZPS0UgKi8sXG4gICAgdmVyc2lvbixcbiAgICBzZW5kZXJBZGRyZXNzLFxuICAgIGNoYWluSWQsXG4gICAgbm9uY2UsXG4gICAgdGlwLFxuICAgIHBheW1hc3RlckRhdGEsXG4gICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICByZXNvdXJjZUJvdW5kcyxcbiAgICBbcG9zZWlkb25IYXNoTWFueShBVG9CSShhY2NvdW50RGVwbG95bWVudERhdGEpKSwgcG9zZWlkb25IYXNoTWFueShBVG9CSShjb21waWxlZENhbGxkYXRhKSldXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL3RyYW5zYWN0aW9uSGFzaC9pbmRleC50c1xuZnVuY3Rpb24gaXNWM0ludm9rZVR4KGFyZ3MpIHtcbiAgcmV0dXJuIFthcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXS5pbmNsdWRlcyhhcmdzLnZlcnNpb24pO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMihhcmdzKSB7XG4gIGlmIChpc1YzSW52b2tlVHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoKFxuICAgICAgYXJncy5zZW5kZXJBZGRyZXNzLFxuICAgICAgYXJncy52ZXJzaW9uLFxuICAgICAgYXJncy5jb21waWxlZENhbGxkYXRhLFxuICAgICAgYXJncy5jaGFpbklkLFxuICAgICAgYXJncy5ub25jZSxcbiAgICAgIGFyZ3MuYWNjb3VudERlcGxveW1lbnREYXRhLFxuICAgICAgYXJncy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MucmVzb3VyY2VCb3VuZHMsXG4gICAgICBhcmdzLnRpcCxcbiAgICAgIGFyZ3MucGF5bWFzdGVyRGF0YVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZVRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MuY29tcGlsZWRDYWxsZGF0YSxcbiAgICBhcmdzLm1heEZlZSxcbiAgICBhcmdzLmNoYWluSWQsXG4gICAgYXJncy5ub25jZVxuICApO1xufVxuZnVuY3Rpb24gaXNWM0RlY2xhcmVUeChhcmdzKSB7XG4gIHJldHVybiBbYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMywgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GM10uaW5jbHVkZXMoYXJncy52ZXJzaW9uKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZURlY2xhcmVUcmFuc2FjdGlvbkhhc2gzKGFyZ3MpIHtcbiAgaWYgKGlzVjNEZWNsYXJlVHgoYXJncykpIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDIoXG4gICAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2gsXG4gICAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgICBhcmdzLnZlcnNpb24sXG4gICAgICBhcmdzLmNoYWluSWQsXG4gICAgICBhcmdzLm5vbmNlLFxuICAgICAgYXJncy5hY2NvdW50RGVwbG95bWVudERhdGEsXG4gICAgICBhcmdzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgYXJncy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgIGFyZ3MudGlwLFxuICAgICAgYXJncy5wYXltYXN0ZXJEYXRhXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaChcbiAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICBhcmdzLnNlbmRlckFkZHJlc3MsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlLFxuICAgIGFyZ3MuY29tcGlsZWRDbGFzc0hhc2hcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVjNEZXBsb3lBY2NvdW50VHgoYXJncykge1xuICByZXR1cm4gW2FwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjNdLmluY2x1ZGVzKGFyZ3MudmVyc2lvbik7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyhhcmdzKSB7XG4gIGlmIChpc1YzRGVwbG95QWNjb3VudFR4KGFyZ3MpKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZURlcGxveUFjY291bnRUcmFuc2FjdGlvbkhhc2gyKFxuICAgICAgYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgICBhcmdzLmNsYXNzSGFzaCxcbiAgICAgIGFyZ3MuY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgYXJncy5zYWx0LFxuICAgICAgYXJncy52ZXJzaW9uLFxuICAgICAgYXJncy5jaGFpbklkLFxuICAgICAgYXJncy5ub25jZSxcbiAgICAgIGFyZ3Mubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgIGFyZ3MuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICBhcmdzLnJlc291cmNlQm91bmRzLFxuICAgICAgYXJncy50aXAsXG4gICAgICBhcmdzLnBheW1hc3RlckRhdGFcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoKFxuICAgIGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgIGFyZ3MuY2xhc3NIYXNoLFxuICAgIGFyZ3MuY29uc3RydWN0b3JDYWxsZGF0YSxcbiAgICBhcmdzLnNhbHQsXG4gICAgYXJncy52ZXJzaW9uLFxuICAgIGFyZ3MubWF4RmVlLFxuICAgIGFyZ3MuY2hhaW5JZCxcbiAgICBhcmdzLm5vbmNlXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9oYXNoL2NsYXNzSGFzaC50c1xuaW1wb3J0IHsgcG9zZWlkb25IYXNoTWFueSBhcyBwb3NlaWRvbkhhc2hNYW55MiB9IGZyb20gXCJAc2N1cmUvc3RhcmtuZXRcIjtcbmZ1bmN0aW9uIGNvbXB1dGVQZWRlcnNlbkhhc2goYSwgYikge1xuICByZXR1cm4gc3RhcmtDdXJ2ZS5wZWRlcnNlbihCaWdJbnQoYSksIEJpZ0ludChiKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlUG9zZWlkb25IYXNoKGEsIGIpIHtcbiAgcmV0dXJuIHRvSGV4KHN0YXJrQ3VydmUucG9zZWlkb25IYXNoKEJpZ0ludChhKSwgQmlnSW50KGIpKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlSGFzaE9uRWxlbWVudHMyKGRhdGEpIHtcbiAgcmV0dXJuIFsuLi5kYXRhLCBkYXRhLmxlbmd0aF0ucmVkdWNlKCh4LCB5KSA9PiBzdGFya0N1cnZlLnBlZGVyc2VuKEJpZ0ludCh4KSwgQmlnSW50KHkpKSwgMCkudG9TdHJpbmcoKTtcbn1cbnZhciBjb21wdXRlUGVkZXJzZW5IYXNoT25FbGVtZW50cyA9IGNvbXB1dGVIYXNoT25FbGVtZW50czI7XG5mdW5jdGlvbiBjb21wdXRlUG9zZWlkb25IYXNoT25FbGVtZW50cyhkYXRhKSB7XG4gIHJldHVybiB0b0hleChwb3NlaWRvbkhhc2hNYW55MihkYXRhLm1hcCgoeCkgPT4gQmlnSW50KHgpKSkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goc2FsdCwgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBkZXBsb3llckFkZHJlc3MpIHtcbiAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoY29uc3RydWN0b3JDYWxsZGF0YSk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihjb21waWxlZENhbGxkYXRhKTtcbiAgY29uc3QgQ09OVFJBQ1RfQUREUkVTU19QUkVGSVggPSBmZWx0KFwiMHg1MzU0NDE1MjRiNGU0NTU0NWY0MzRmNGU1NDUyNDE0MzU0NWY0MTQ0NDQ1MjQ1NTM1M1wiKTtcbiAgY29uc3QgaGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoW1xuICAgIENPTlRSQUNUX0FERFJFU1NfUFJFRklYLFxuICAgIGRlcGxveWVyQWRkcmVzcyxcbiAgICBzYWx0LFxuICAgIGNsYXNzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckNhbGxkYXRhSGFzaFxuICBdKTtcbiAgcmV0dXJuIHRvSGV4KEJpZ0ludChoYXNoKSAlIEFERFJfQk9VTkQpO1xufVxuZnVuY3Rpb24gbnVsbFNraXBSZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT09IFwiYXR0cmlidXRlc1wiIHx8IGtleSA9PT0gXCJhY2Nlc3NpYmxlX3Njb3Blc1wiKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IHZhbHVlO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZGVidWdfaW5mb1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gdm9pZCAwIDogdmFsdWU7XG59XG5mdW5jdGlvbiBmb3JtYXRTcGFjZXMoanNvbjIpIHtcbiAgbGV0IGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICBjb25zdCBuZXdTdHJpbmcgPSBbXTtcbiAgZm9yIChjb25zdCBjaGFyIG9mIGpzb24yKSB7XG4gICAgaWYgKGNoYXIgPT09ICdcIicgJiYgKG5ld1N0cmluZy5sZW5ndGggPiAwICYmIG5ld1N0cmluZy5zbGljZSgtMSlbMF0gPT09IFwiXFxcXFwiKSA9PT0gZmFsc2UpIHtcbiAgICAgIGluc2lkZVF1b3RlcyA9ICFpbnNpZGVRdW90ZXM7XG4gICAgfVxuICAgIGlmIChpbnNpZGVRdW90ZXMpIHtcbiAgICAgIG5ld1N0cmluZy5wdXNoKGNoYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHJpbmcucHVzaChjaGFyID09PSBcIjpcIiA/IFwiOiBcIiA6IGNoYXIgPT09IFwiLFwiID8gXCIsIFwiIDogY2hhcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdTdHJpbmcuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIaW50ZWRDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCkge1xuICBjb25zdCB7IGFiaSwgcHJvZ3JhbSB9ID0gY29tcGlsZWRDb250cmFjdDtcbiAgY29uc3QgY29udHJhY3RDbGFzcyA9IHsgYWJpLCBwcm9ncmFtIH07XG4gIGNvbnN0IHNlcmlhbGl6ZWRKc29uID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3RDbGFzcywgbnVsbFNraXBSZXBsYWNlcikpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KHNlcmlhbGl6ZWRKc29uKSkudG9TdHJpbmcoMTYpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaChjb250cmFjdCkge1xuICBjb25zdCBjb21waWxlZENvbnRyYWN0ID0gaXNTdHJpbmcoY29udHJhY3QpID8gcGFyc2UyKGNvbnRyYWN0KSA6IGNvbnRyYWN0O1xuICBjb25zdCBhcGlWZXJzaW9uID0gdG9IZXgoQVBJX1ZFUlNJT04pO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTC5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBsMUhhbmRsZXJFbnRyeVBvaW50c0hhc2ggPSBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFxuICAgIGNvbXBpbGVkQ29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUi5mbGF0TWFwKChlKSA9PiBbZS5zZWxlY3RvciwgZS5vZmZzZXRdKVxuICApO1xuICBjb25zdCBjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihcbiAgICBjb21waWxlZENvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SLmZsYXRNYXAoKGUpID0+IFtlLnNlbGVjdG9yLCBlLm9mZnNldF0pXG4gICk7XG4gIGNvbnN0IGJ1aWx0aW5zSGFzaCA9IGNvbXB1dGVIYXNoT25FbGVtZW50czIoXG4gICAgY29tcGlsZWRDb250cmFjdC5wcm9ncmFtLmJ1aWx0aW5zLm1hcCgocykgPT4gZW5jb2RlU2hvcnRTdHJpbmcocykpXG4gICk7XG4gIGNvbnN0IGhpbnRlZENsYXNzSGFzaCA9IGNvbXB1dGVIaW50ZWRDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIGNvbnN0IGRhdGFIYXNoID0gY29tcHV0ZUhhc2hPbkVsZW1lbnRzMihjb21waWxlZENvbnRyYWN0LnByb2dyYW0uZGF0YSk7XG4gIHJldHVybiBjb21wdXRlSGFzaE9uRWxlbWVudHMyKFtcbiAgICBhcGlWZXJzaW9uLFxuICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgIGwxSGFuZGxlckVudHJ5UG9pbnRzSGFzaCxcbiAgICBjb25zdHJ1Y3RvckVudHJ5UG9pbnRIYXNoLFxuICAgIGJ1aWx0aW5zSGFzaCxcbiAgICBoaW50ZWRDbGFzc0hhc2gsXG4gICAgZGF0YUhhc2hcbiAgXSk7XG59XG5mdW5jdGlvbiBoYXNoQnVpbHRpbnMoYnVpbHRpbnMpIHtcbiAgcmV0dXJuIHBvc2VpZG9uSGFzaE1hbnkyKFxuICAgIGJ1aWx0aW5zLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgICByZXR1cm4gQmlnSW50KGVuY29kZVNob3J0U3RyaW5nKGl0KSk7XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhc2hFbnRyeVBvaW50KGRhdGEpIHtcbiAgY29uc3QgYmFzZSA9IGRhdGEuZmxhdE1hcCgoaXQpID0+IHtcbiAgICByZXR1cm4gW0JpZ0ludChpdC5zZWxlY3RvciksIEJpZ0ludChpdC5vZmZzZXQpLCBoYXNoQnVpbHRpbnMoaXQuYnVpbHRpbnMpXTtcbiAgfSk7XG4gIHJldHVybiBwb3NlaWRvbkhhc2hNYW55MihiYXNlKTtcbn1cbmZ1bmN0aW9uIGhhc2hCeXRlQ29kZVNlZ21lbnRzKGNhc20pIHtcbiAgY29uc3QgYnl0ZUNvZGUgPSBjYXNtLmJ5dGVjb2RlLm1hcCgobikgPT4gQmlnSW50KG4pKTtcbiAgY29uc3QgYnl0ZWNvZGVTZWdtZW50TGVuZ3RocyA9IGNhc20uYnl0ZWNvZGVfc2VnbWVudF9sZW5ndGhzID8/IFtdO1xuICBsZXQgc2VnbWVudFN0YXJ0ID0gMDtcbiAgY29uc3QgaGFzaExlYXZlcyA9IGJ5dGVjb2RlU2VnbWVudExlbmd0aHMuZmxhdE1hcCgobGVuKSA9PiB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGJ5dGVDb2RlLnNsaWNlKHNlZ21lbnRTdGFydCwgc2VnbWVudFN0YXJ0ICs9IGxlbik7XG4gICAgcmV0dXJuIFtCaWdJbnQobGVuKSwgcG9zZWlkb25IYXNoTWFueTIoc2VnbWVudCldO1xuICB9KTtcbiAgcmV0dXJuIDFuICsgcG9zZWlkb25IYXNoTWFueTIoaGFzaExlYXZlcyk7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29tcGlsZWRDbGFzc0hhc2goY2FzbSkge1xuICBjb25zdCBDT01QSUxFRF9DTEFTU19WRVJTSU9OID0gXCJDT01QSUxFRF9DTEFTU19WMVwiO1xuICBjb25zdCBjb21waWxlZENsYXNzVmVyc2lvbiA9IEJpZ0ludChlbmNvZGVTaG9ydFN0cmluZyhDT01QSUxFRF9DTEFTU19WRVJTSU9OKSk7XG4gIGNvbnN0IGV4dGVybmFsRW50cnlQb2ludHNIYXNoID0gaGFzaEVudHJ5UG9pbnQoY2FzbS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludChjYXNtLmVudHJ5X3BvaW50c19ieV90eXBlLkwxX0hBTkRMRVIpO1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGhhc2hFbnRyeVBvaW50KGNhc20uZW50cnlfcG9pbnRzX2J5X3R5cGUuQ09OU1RSVUNUT1IpO1xuICBjb25zdCBieXRlY29kZSA9IGNhc20uYnl0ZWNvZGVfc2VnbWVudF9sZW5ndGhzID8gaGFzaEJ5dGVDb2RlU2VnbWVudHMoY2FzbSkgOiBwb3NlaWRvbkhhc2hNYW55MihjYXNtLmJ5dGVjb2RlLm1hcCgoaXQpID0+IEJpZ0ludChpdCkpKTtcbiAgcmV0dXJuIHRvSGV4KFxuICAgIHBvc2VpZG9uSGFzaE1hbnkyKFtcbiAgICAgIGNvbXBpbGVkQ2xhc3NWZXJzaW9uLFxuICAgICAgZXh0ZXJuYWxFbnRyeVBvaW50c0hhc2gsXG4gICAgICBsMUhhbmRsZXJzLFxuICAgICAgY29uc3RydWN0b3IsXG4gICAgICBieXRlY29kZVxuICAgIF0pXG4gICk7XG59XG5mdW5jdGlvbiBoYXNoRW50cnlQb2ludFNpZXJyYShkYXRhKSB7XG4gIGNvbnN0IGJhc2UgPSBkYXRhLmZsYXRNYXAoKGl0KSA9PiB7XG4gICAgcmV0dXJuIFtCaWdJbnQoaXQuc2VsZWN0b3IpLCBCaWdJbnQoaXQuZnVuY3Rpb25faWR4KV07XG4gIH0pO1xuICByZXR1cm4gcG9zZWlkb25IYXNoTWFueTIoYmFzZSk7XG59XG5mdW5jdGlvbiBoYXNoQWJpKHNpZXJyYSkge1xuICBjb25zdCBpbmRlbnRTdHJpbmcgPSBmb3JtYXRTcGFjZXMoc3RyaW5naWZ5MihzaWVycmEuYWJpLCBudWxsKSk7XG4gIHJldHVybiBCaWdJbnQoYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGluZGVudFN0cmluZykpLnRvU3RyaW5nKDE2KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNpZXJyYUNvbnRyYWN0Q2xhc3NIYXNoKHNpZXJyYSkge1xuICBjb25zdCBDT05UUkFDVF9DTEFTU19WRVJTSU9OID0gXCJDT05UUkFDVF9DTEFTU19WMC4xLjBcIjtcbiAgY29uc3QgY29tcGlsZWRDbGFzc1ZlcnNpb24gPSBCaWdJbnQoZW5jb2RlU2hvcnRTdHJpbmcoQ09OVFJBQ1RfQ0xBU1NfVkVSU0lPTikpO1xuICBjb25zdCBleHRlcm5hbEVudHJ5UG9pbnRzSGFzaCA9IGhhc2hFbnRyeVBvaW50U2llcnJhKHNpZXJyYS5lbnRyeV9wb2ludHNfYnlfdHlwZS5FWFRFUk5BTCk7XG4gIGNvbnN0IGwxSGFuZGxlcnMgPSBoYXNoRW50cnlQb2ludFNpZXJyYShzaWVycmEuZW50cnlfcG9pbnRzX2J5X3R5cGUuTDFfSEFORExFUik7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gaGFzaEVudHJ5UG9pbnRTaWVycmEoc2llcnJhLmVudHJ5X3BvaW50c19ieV90eXBlLkNPTlNUUlVDVE9SKTtcbiAgY29uc3QgYWJpSGFzaCA9IGhhc2hBYmkoc2llcnJhKTtcbiAgY29uc3Qgc2llcnJhUHJvZ3JhbSA9IHBvc2VpZG9uSGFzaE1hbnkyKHNpZXJyYS5zaWVycmFfcHJvZ3JhbS5tYXAoKGl0KSA9PiBCaWdJbnQoaXQpKSk7XG4gIHJldHVybiB0b0hleChcbiAgICBwb3NlaWRvbkhhc2hNYW55MihbXG4gICAgICBjb21waWxlZENsYXNzVmVyc2lvbixcbiAgICAgIGV4dGVybmFsRW50cnlQb2ludHNIYXNoLFxuICAgICAgbDFIYW5kbGVycyxcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYWJpSGFzaCxcbiAgICAgIHNpZXJyYVByb2dyYW1cbiAgICBdKVxuICApO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbnRyYWN0Q2xhc3NIYXNoKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIGlmIChcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdCkge1xuICAgIHJldHVybiBjb21wdXRlU2llcnJhQ29udHJhY3RDbGFzc0hhc2goY29tcGlsZWRDb250cmFjdCk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMZWdhY3lDb250cmFjdENsYXNzSGFzaChjb21waWxlZENvbnRyYWN0KTtcbn1cblxuLy8gc3JjL3V0aWxzL3N0YXJrLnRzXG52YXIgc3RhcmtfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3RhcmtfZXhwb3J0cywge1xuICBjb21wcmVzc1Byb2dyYW06ICgpID0+IGNvbXByZXNzUHJvZ3JhbSxcbiAgZGVjb21wcmVzc1Byb2dyYW06ICgpID0+IGRlY29tcHJlc3NQcm9ncmFtLFxuICBlc3RpbWF0ZUZlZVRvQm91bmRzOiAoKSA9PiBlc3RpbWF0ZUZlZVRvQm91bmRzLFxuICBlc3RpbWF0ZWRGZWVUb01heEZlZTogKCkgPT4gZXN0aW1hdGVkRmVlVG9NYXhGZWUsXG4gIGZvcm1hdFNpZ25hdHVyZTogKCkgPT4gZm9ybWF0U2lnbmF0dXJlLFxuICBpbnREQU06ICgpID0+IGludERBTSxcbiAgbWFrZUFkZHJlc3M6ICgpID0+IG1ha2VBZGRyZXNzLFxuICByYW5kb21BZGRyZXNzOiAoKSA9PiByYW5kb21BZGRyZXNzLFxuICByZWR1Y2VWMjogKCkgPT4gcmVkdWNlVjIsXG4gIHNpZ25hdHVyZVRvRGVjaW1hbEFycmF5OiAoKSA9PiBzaWduYXR1cmVUb0RlY2ltYWxBcnJheSxcbiAgc2lnbmF0dXJlVG9IZXhBcnJheTogKCkgPT4gc2lnbmF0dXJlVG9IZXhBcnJheSxcbiAgdG9GZWVWZXJzaW9uOiAoKSA9PiB0b0ZlZVZlcnNpb24sXG4gIHRvVHJhbnNhY3Rpb25WZXJzaW9uOiAoKSA9PiB0b1RyYW5zYWN0aW9uVmVyc2lvbixcbiAgdjNEZXRhaWxzOiAoKSA9PiB2M0RldGFpbHNcbn0pO1xuaW1wb3J0IHsgZ2V0U3RhcmtLZXksIHV0aWxzIH0gZnJvbSBcIkBzY3VyZS9zdGFya25ldFwiO1xuaW1wb3J0IHsgZ3ppcCwgdW5nemlwIH0gZnJvbSBcInBha29cIjtcbmZ1bmN0aW9uIGNvbXByZXNzUHJvZ3JhbShqc29uUHJvZ3JhbSkge1xuICBjb25zdCBzdHJpbmdpZmllZCA9IGlzU3RyaW5nKGpzb25Qcm9ncmFtKSA/IGpzb25Qcm9ncmFtIDogc3RyaW5naWZ5Mihqc29uUHJvZ3JhbSk7XG4gIGNvbnN0IGNvbXByZXNzZWRQcm9ncmFtID0gZ3ppcChzdHJpbmdpZmllZCk7XG4gIHJldHVybiBidG9hVW5pdmVyc2FsKGNvbXByZXNzZWRQcm9ncmFtKTtcbn1cbmZ1bmN0aW9uIGRlY29tcHJlc3NQcm9ncmFtKGJhc2U2NDIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZTY0MikpIHJldHVybiBiYXNlNjQyO1xuICBjb25zdCBkZWNvbXByZXNzZWQgPSBhcnJheUJ1ZmZlclRvU3RyaW5nKHVuZ3ppcChhdG9iVW5pdmVyc2FsKGJhc2U2NDIpKSk7XG4gIHJldHVybiBwYXJzZTIoZGVjb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIHJhbmRvbUFkZHJlc3MoKSB7XG4gIGNvbnN0IHJhbmRvbUtleVBhaXIgPSB1dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIHJldHVybiBnZXRTdGFya0tleShyYW5kb21LZXlQYWlyKTtcbn1cbmZ1bmN0aW9uIG1ha2VBZGRyZXNzKGlucHV0KSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoaW5wdXQpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBmb3JtYXRTaWduYXR1cmUoc2lnKSB7XG4gIGlmICghc2lnKSB0aHJvdyBFcnJvcihcImZvcm1hdFNpZ25hdHVyZTogcHJvdmlkZWQgc2lnbmF0dXJlIGlzIHVuZGVmaW5lZFwiKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHJldHVybiBzaWcubWFwKChpdCkgPT4gdG9IZXgoaXQpKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIHJldHVybiBbdG9IZXgociksIHRvSGV4KHMpXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25hdHVyZSBuZWVkIHRvIGJlIHdlaWVyc3RyYXNzLlNpZ25hdHVyZVR5cGUgb3IgYW4gYXJyYXkgZm9yIGN1c3RvbVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gc2lnbmF0dXJlVG9EZWNpbWFsQXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvRGVjaW1hbFN0cmluZ0FycmF5KGZvcm1hdFNpZ25hdHVyZShzaWcpKTtcbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnKSB7XG4gIHJldHVybiBiaWdOdW1iZXJpc2hBcnJheVRvSGV4YWRlY2ltYWxTdHJpbmdBcnJheShmb3JtYXRTaWduYXR1cmUoc2lnKSk7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkID0gNTAgLyogTUFYX0ZFRSAqLykge1xuICByZXR1cm4gYWRkUGVyY2VudChlc3RpbWF0ZWRGZWUsIG92ZXJoZWFkKTtcbn1cbmZ1bmN0aW9uIGVzdGltYXRlRmVlVG9Cb3VuZHMoZXN0aW1hdGUsIGFtb3VudE92ZXJoZWFkID0gNTAgLyogTDFfQk9VTkRfTUFYX0FNT1VOVCAqLywgcHJpY2VPdmVyaGVhZCA9IDUwIC8qIEwxX0JPVU5EX01BWF9QUklDRV9QRVJfVU5JVCAqLykge1xuICBpZiAoaXNCaWdJbnQoZXN0aW1hdGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGwyX2dhczogeyBtYXhfYW1vdW50OiBcIjB4MFwiLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHgwXCIgfSxcbiAgICAgIGwxX2dhczogeyBtYXhfYW1vdW50OiBcIjB4MFwiLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IFwiMHgwXCIgfVxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBlc3RpbWF0ZS5nYXNfY29uc3VtZWQgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVzdGltYXRlLmdhc19wcmljZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IEVycm9yKFwiZXN0aW1hdGVGZWVUb0JvdW5kczogZXN0aW1hdGUgaXMgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGNvbnN0IG1heFVuaXRzID0gZXN0aW1hdGUuZGF0YV9nYXNfY29uc3VtZWQgIT09IHZvaWQgMCAmJiBlc3RpbWF0ZS5kYXRhX2dhc19wcmljZSAhPT0gdm9pZCAwID8gdG9IZXgoYWRkUGVyY2VudChCaWdJbnQoZXN0aW1hdGUub3ZlcmFsbF9mZWUpIC8gQmlnSW50KGVzdGltYXRlLmdhc19wcmljZSksIGFtb3VudE92ZXJoZWFkKSkgOiB0b0hleChhZGRQZXJjZW50KGVzdGltYXRlLmdhc19jb25zdW1lZCwgYW1vdW50T3ZlcmhlYWQpKTtcbiAgY29uc3QgbWF4VW5pdFByaWNlID0gdG9IZXgoYWRkUGVyY2VudChlc3RpbWF0ZS5nYXNfcHJpY2UsIHByaWNlT3ZlcmhlYWQpKTtcbiAgcmV0dXJuIHtcbiAgICBsMl9nYXM6IHsgbWF4X2Ftb3VudDogXCIweDBcIiwgbWF4X3ByaWNlX3Blcl91bml0OiBcIjB4MFwiIH0sXG4gICAgbDFfZ2FzOiB7IG1heF9hbW91bnQ6IG1heFVuaXRzLCBtYXhfcHJpY2VfcGVyX3VuaXQ6IG1heFVuaXRQcmljZSB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnREQU0oZGFtKSB7XG4gIGlmIChkYW0gPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSkgcmV0dXJuIGFwaV9leHBvcnRzLkVEQU1vZGUuTDE7XG4gIGlmIChkYW0gPT09IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMikgcmV0dXJuIGFwaV9leHBvcnRzLkVEQU1vZGUuTDI7XG4gIHRocm93IEVycm9yKFwiRURBTSBjb252ZXJzaW9uXCIpO1xufVxuZnVuY3Rpb24gdG9UcmFuc2FjdGlvblZlcnNpb24oZGVmYXVsdFZlcnNpb24sIHByb3ZpZGVkVmVyc2lvbikge1xuICBjb25zdCBwcm92aWRlZFZlcnNpb24weHMgPSBwcm92aWRlZFZlcnNpb24gPyB0b0hleChwcm92aWRlZFZlcnNpb24pIDogdm9pZCAwO1xuICBjb25zdCBkZWZhdWx0VmVyc2lvbjB4cyA9IHRvSGV4KGRlZmF1bHRWZXJzaW9uKTtcbiAgaWYgKHByb3ZpZGVkVmVyc2lvbiAmJiAhT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uKS5pbmNsdWRlcyhwcm92aWRlZFZlcnNpb24weHMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYHByb3ZpZGVkVmVyc2lvbiAke3Byb3ZpZGVkVmVyc2lvbn0gaXMgbm90IEVUcmFuc2FjdGlvblZlcnNpb25gKTtcbiAgfVxuICBpZiAoIU9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbikuaW5jbHVkZXMoZGVmYXVsdFZlcnNpb24weHMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGRlZmF1bHRWZXJzaW9uICR7ZGVmYXVsdFZlcnNpb259IGlzIG5vdCBFVHJhbnNhY3Rpb25WZXJzaW9uYCk7XG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVkVmVyc2lvbiA/IHByb3ZpZGVkVmVyc2lvbjB4cyA6IGRlZmF1bHRWZXJzaW9uMHhzO1xufVxuZnVuY3Rpb24gdG9GZWVWZXJzaW9uKHByb3ZpZGVkVmVyc2lvbikge1xuICBpZiAoIXByb3ZpZGVkVmVyc2lvbikgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdmVyc2lvbiA9IHRvSGV4KHByb3ZpZGVkVmVyc2lvbik7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYwKSByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMDtcbiAgaWYgKHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEpIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxO1xuICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMikgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjI7XG4gIGlmICh2ZXJzaW9uID09PSBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSByZXR1cm4gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMztcbiAgdGhyb3cgRXJyb3IoYHRvRmVlVmVyc2lvbjogJHt2ZXJzaW9ufSBpcyBub3Qgc3VwcG9ydGVkYCk7XG59XG5mdW5jdGlvbiB2M0RldGFpbHMoZGV0YWlscykge1xuICByZXR1cm4ge1xuICAgIHRpcDogZGV0YWlscy50aXAgfHwgMCxcbiAgICBwYXltYXN0ZXJEYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEgfHwgW10sXG4gICAgYWNjb3VudERlcGxveW1lbnREYXRhOiBkZXRhaWxzLmFjY291bnREZXBsb3ltZW50RGF0YSB8fCBbXSxcbiAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUgfHwgYXBpX2V4cG9ydHMuRURhdGFBdmFpbGFiaWxpdHlNb2RlLkwxLFxuICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlIHx8IGFwaV9leHBvcnRzLkVEYXRhQXZhaWxhYmlsaXR5TW9kZS5MMSxcbiAgICByZXNvdXJjZUJvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyA/PyBlc3RpbWF0ZUZlZVRvQm91bmRzKFpFUk8pXG4gIH07XG59XG5mdW5jdGlvbiByZWR1Y2VWMihwcm92aWRlZFZlcnNpb24pIHtcbiAgaWYgKHByb3ZpZGVkVmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMikgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjE7XG4gIGlmIChwcm92aWRlZFZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIpIHJldHVybiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxO1xuICByZXR1cm4gcHJvdmlkZWRWZXJzaW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvY29udHJhY3QudHNcbmZ1bmN0aW9uIGlzU2llcnJhKGNvbnRyYWN0KSB7XG4gIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBpc1N0cmluZyhjb250cmFjdCkgPyBwYXJzZTIoY29udHJhY3QpIDogY29udHJhY3Q7XG4gIHJldHVybiBcInNpZXJyYV9wcm9ncmFtXCIgaW4gY29tcGlsZWRDb250cmFjdDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0geyAuLi5wYXlsb2FkIH07XG4gIGlmIChpc1NpZXJyYShwYXlsb2FkLmNvbnRyYWN0KSkge1xuICAgIGlmICghcGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCAmJiBwYXlsb2FkLmNhc20pIHtcbiAgICAgIHJlc3BvbnNlLmNvbXBpbGVkQ2xhc3NIYXNoID0gY29tcHV0ZUNvbXBpbGVkQ2xhc3NIYXNoKHBheWxvYWQuY2FzbSk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuY29tcGlsZWRDbGFzc0hhc2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXh0cmFjdCBjb21waWxlZENsYXNzSGFzaCBmYWlsZWQsIHByb3ZpZGUgKENhaXJvQXNzZW1ibHkpLmNhc20gZmlsZSBvciBjb21waWxlZENsYXNzSGFzaFwiXG4gICAgICApO1xuICB9XG4gIHJlc3BvbnNlLmNsYXNzSGFzaCA9IHBheWxvYWQuY2xhc3NIYXNoID8/IGNvbXB1dGVDb250cmFjdENsYXNzSGFzaChwYXlsb2FkLmNvbnRyYWN0KTtcbiAgaWYgKCFyZXNwb25zZS5jbGFzc0hhc2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0cmFjdCBjbGFzc0hhc2ggZmFpbGVkLCBwcm92aWRlIChDb21waWxlZENvbnRyYWN0KS5qc29uIGZpbGUgb3IgY2xhc3NIYXNoXCIpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBjb250cmFjdENsYXNzUmVzcG9uc2VUb0xlZ2FjeUNvbXBpbGVkQ29udHJhY3QoY2NyKSB7XG4gIGlmIChpc1NpZXJyYShjY3IpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdENsYXNzUmVzcG9uc2UgbmVlZCB0byBiZSBMZWdhY3lDb250cmFjdENsYXNzIChjYWlybzAgcmVzcG9uc2UgY2xhc3MpXCIpO1xuICB9XG4gIGNvbnN0IGNvbnRyYWN0ID0gY2NyO1xuICByZXR1cm4geyAuLi5jb250cmFjdCwgcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3QucHJvZ3JhbSkgfTtcbn1cblxuLy8gc3JjL3V0aWxzL2V0aC50c1xudmFyIGV0aF9leHBvcnRzID0ge307XG5fX2V4cG9ydChldGhfZXhwb3J0cywge1xuICBldGhSYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBldGhSYW5kb21Qcml2YXRlS2V5LFxuICB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzczogKCkgPT4gdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3Ncbn0pO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5mdW5jdGlvbiBldGhSYW5kb21Qcml2YXRlS2V5KCkge1xuICByZXR1cm4gc2FuaXRpemVIZXgoYnVmMmhleChzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFBhcnNlRXRoQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGFzc2VydEluUmFuZ2UoYWRkcmVzcywgWkVSTywgMm4gKiogMTYwbiAtIDFuLCBcIkV0aGVyZXVtIEFkZHJlc3MgXCIpO1xuICBjb25zdCByZXN1bHQgPSBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KHRvSGV4KGFkZHJlc3MpKS5wYWRTdGFydCg0MCwgXCIwXCIpKTtcbiAgYXNzZXJ0KEJvb2xlYW4ocmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mXXs0MH0kLykpLCBcIkludmFsaWQgRXRoZXJldW0gQWRkcmVzcyBGb3JtYXRcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlscy9mZXRjaFBvbnlmaWxsLnRzXG5pbXBvcnQgbWFrZUZldGNoQ29va2llIGZyb20gXCJmZXRjaC1jb29raWVcIjtcbmltcG9ydCBpc29tb3JwaGljRmV0Y2ggZnJvbSBcImlzb21vcnBoaWMtZmV0Y2hcIjtcbnZhciBmZXRjaFBvbnlmaWxsX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mZXRjaCB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBicm93c2VyIGlmIGF2YWlsYWJsZVxudHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtYWtlRmV0Y2hDb29raWUoZ2xvYmFsLmZldGNoKSB8fCAvLyB1c2UgYnVpbGRpbiBmZXRjaCBpbiBub2RlLCByZWFjdC1uYXRpdmUgYW5kIHNlcnZpY2Ugd29ya2VyIGlmIGF2YWlsYWJsZVxuaXNvbW9ycGhpY0ZldGNoO1xuXG4vLyBzcmMvdXRpbHMvcHJvdmlkZXIudHNcbnZhciBwcm92aWRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm92aWRlcl9leHBvcnRzLCB7XG4gIEJsb2NrOiAoKSA9PiBCbG9jayxcbiAgY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzczogKCkgPT4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyxcbiAgZ2V0RGVmYXVsdE5vZGVVcmw6ICgpID0+IGdldERlZmF1bHROb2RlVXJsLFxuICBpc1BlbmRpbmdCbG9jazogKCkgPT4gaXNQZW5kaW5nQmxvY2ssXG4gIGlzUGVuZGluZ1N0YXRlVXBkYXRlOiAoKSA9PiBpc1BlbmRpbmdTdGF0ZVVwZGF0ZSxcbiAgaXNQZW5kaW5nVHJhbnNhY3Rpb246ICgpID0+IGlzUGVuZGluZ1RyYW5zYWN0aW9uLFxuICBpc1YzVHg6ICgpID0+IGlzVjNUeCxcbiAgaXNWZXJzaW9uOiAoKSA9PiBpc1ZlcnNpb24sXG4gIHBhcnNlQ29udHJhY3Q6ICgpID0+IHBhcnNlQ29udHJhY3QsXG4gIHZhbGlkQmxvY2tUYWdzOiAoKSA9PiB2YWxpZEJsb2NrVGFncyxcbiAgd2FpdDogKCkgPT4gd2FpdFxufSk7XG5mdW5jdGlvbiB3YWl0KGRlbGF5KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXMsIGRlbGF5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaWVycmFDb250cmFjdENsYXNzKGNvbnRyYWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uY29udHJhY3QgfTtcbiAgZGVsZXRlIHJlc3VsdC5zaWVycmFfcHJvZ3JhbV9kZWJ1Z19pbmZvO1xuICByZXN1bHQuYWJpID0gZm9ybWF0U3BhY2VzKHN0cmluZ2lmeTIoY29udHJhY3QuYWJpKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGZvcm1hdFNwYWNlcyhzdHJpbmdpZnkyKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSk7XG4gIHJlc3VsdC5zaWVycmFfcHJvZ3JhbSA9IGNvbXByZXNzUHJvZ3JhbShyZXN1bHQuc2llcnJhX3Byb2dyYW0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VDb250cmFjdChjb250cmFjdCkge1xuICBjb25zdCBwYXJzZWRDb250cmFjdCA9IGlzU3RyaW5nKGNvbnRyYWN0KSA/IHBhcnNlMihjb250cmFjdCkgOiBjb250cmFjdDtcbiAgaWYgKCFpc1NpZXJyYShjb250cmFjdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFyc2VkQ29udHJhY3QsXG4gICAgICAuLi5cInByb2dyYW1cIiBpbiBwYXJzZWRDb250cmFjdCAmJiB7IHByb2dyYW06IGNvbXByZXNzUHJvZ3JhbShwYXJzZWRDb250cmFjdC5wcm9ncmFtKSB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlU2llcnJhQ29udHJhY3RDbGFzcyhwYXJzZWRDb250cmFjdCk7XG59XG52YXIgZ2V0RGVmYXVsdE5vZGVVcmwgPSAobmV0d29ya05hbWUsIG11dGUgPSBmYWxzZSkgPT4ge1xuICBpZiAoIW11dGUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJVc2luZyBkZWZhdWx0IHB1YmxpYyBub2RlIHVybCwgcGxlYXNlIHByb3ZpZGUgbm9kZVVybCBpbiBwcm92aWRlciBvcHRpb25zIVwiKTtcbiAgfVxuICBjb25zdCBub2RlcyA9IFJQQ19OT0RFU1tuZXR3b3JrTmFtZSA/PyBcIlNOX1NFUE9MSUFcIiAvKiBTTl9TRVBPTElBICovXTtcbiAgY29uc3QgcmFuZElkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCk7XG4gIHJldHVybiBub2Rlc1tyYW5kSWR4XTtcbn07XG52YXIgdmFsaWRCbG9ja1RhZ3MgPSBPYmplY3QudmFsdWVzKEJsb2NrVGFnKTtcbnZhciBCbG9jayA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSBoYXNoIGlmIG5vdCBudWxsLCBjb250YWlucyB0aGUgYmxvY2sgaGFzaFxuICAgKi9cbiAgaGFzaCA9IG51bGw7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jsb2NrSWRlbnRpZmllcn0gbnVtYmVyIGlmIG5vdCBudWxsLCBjb250YWlucyB0aGUgYmxvY2sgbnVtYmVyXG4gICAqL1xuICBudW1iZXIgPSBudWxsO1xuICAvKipcbiAgICogQHBhcmFtIHtCbG9ja0lkZW50aWZpZXJ9IHRhZyBpZiBub3QgbnVsbCwgY29udGFpbnMgXCJwZW5kaW5nXCIgb3IgXCJsYXRlc3RcIlxuICAgKi9cbiAgdGFnID0gbnVsbDtcbiAgc2V0SWRlbnRpZmllcihfX2lkZW50aWZpZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoX19pZGVudGlmaWVyKSkge1xuICAgICAgaWYgKGlzRGVjaW1hbFN0cmluZyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMubnVtYmVyID0gcGFyc2VJbnQoX19pZGVudGlmaWVyLCAxMCk7XG4gICAgICB9IGVsc2UgaWYgKGlzSGV4KF9faWRlbnRpZmllcikpIHtcbiAgICAgICAgdGhpcy5oYXNoID0gX19pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmICh2YWxpZEJsb2NrVGFncy5pbmNsdWRlcyhfX2lkZW50aWZpZXIpKSB7XG4gICAgICAgIHRoaXMudGFnID0gX19pZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGBCbG9jayBpZGVudGlmaWVyIHVubWFuYWdlZDogJHtfX2lkZW50aWZpZXJ9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0JpZ0ludChfX2lkZW50aWZpZXIpKSB7XG4gICAgICB0aGlzLmhhc2ggPSB0b0hleChfX2lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoX19pZGVudGlmaWVyKSkge1xuICAgICAgdGhpcy5udW1iZXIgPSBfX2lkZW50aWZpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnID0gXCJwZW5kaW5nXCIgLyogUEVORElORyAqLztcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKHRoaXMubnVtYmVyKSAmJiB0aGlzLm51bWJlciA8IDApIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihgQmxvY2sgbnVtYmVyICgke3RoaXMubnVtYmVyfSkgY2FuJ3QgYmUgbmVnYXRpdmVgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJsb2NrIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSBfaWRlbnRpZmllciAgaGV4IHN0cmluZyBhbmQgQmlnSW50IGFyZSBkZXRlY3RlZCBhcyBibG9jayBoYXNoZXMuXG4gICAqIGRlY2ltYWwgc3RyaW5nIGFuZCBudW1iZXIgYXJlIGRldGVjdGVkIGFzIGJsb2NrIG51bWJlcnMuXG4gICAqIHRleHQgc3RyaW5nIGFyZSBkZXRlY3RlZCBhcyBibG9jayB0YWcuXG4gICAqIG51bGwgaXMgY29uc2lkZXJlZCBhcyBhICdwZW5kaW5nJyBibG9jayB0YWcuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfaWRlbnRpZmllcikge1xuICAgIHRoaXMuc2V0SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gIH1cbiAgLy8gVE9ETzogZml4IGFueVxuICAvKipcbiAgICogQHJldHVybnMge2FueX0gdGhlIGlkZW50aWZpZXIgYXMgYSBzdHJpbmdcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBuZXcgcHJvdmlkZXIuQmxvY2soMTIzNDU2bikucXVlcnlJZGVudGlmaWVyO1xuICAgKiAvLyByZXN1bHQgPSBcImJsb2NrSGFzaD0weDFlMjQwXCJcbiAgICogYGBgXG4gICAqL1xuICBnZXQgcXVlcnlJZGVudGlmaWVyKCkge1xuICAgIGlmICh0aGlzLm51bWJlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGBibG9ja051bWJlcj0ke3RoaXMubnVtYmVyfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgYmxvY2tIYXNoPSR7dGhpcy5oYXNofWA7XG4gICAgfVxuICAgIHJldHVybiBgYmxvY2tOdW1iZXI9JHt0aGlzLnRhZ31gO1xuICB9XG4gIC8vIFRPRE86IGZpeCBhbnlcbiAgLyoqXG4gICAqIEByZXR1cm5zIHthbnl9IHRoZSBpZGVudGlmaWVyIGFzIGFuIG9iamVjdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdCA9IG5ldyBwcm92aWRlci5CbG9jayg1Njc4OSkuaWRlbnRpZmllcjtcbiAgICogLy8gcmVzdWx0ID0geyBibG9ja19udW1iZXI6IDU2Nzg5IH1cbiAgICogYGBgXG4gICAqL1xuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICBpZiAodGhpcy5udW1iZXIgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGJsb2NrX251bWJlcjogdGhpcy5udW1iZXIgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgYmxvY2tfaGFzaDogdGhpcy5oYXNoIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZztcbiAgfVxuICAvKipcbiAgICogY2hhbmdlIHRoZSBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIEJsb2NrIGluc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbXlCbG9jayA9IG5ldyBwcm92aWRlci5CbG9jayhcImxhdGVzdFwiKTtcbiAgICogbXlCbG9jay5pZGVudGlmaWVyID1cIjB4MzQ1Njc4OWFiY1wiO1xuICAgKiBjb25zdCByZXN1bHQgPSBteUJsb2NrLmlkZW50aWZpZXI7XG4gICAqIC8vIHJlc3VsdCA9IHsgYmxvY2tfaGFzaDogJzB4MzQ1Njc4OWFiYycgfVxuICAgKiBgYGBcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKF9pZGVudGlmaWVyKSB7XG4gICAgdGhpcy5zZXRJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgfVxuICB2YWx1ZU9mID0gKCkgPT4gdGhpcy5udW1iZXI7XG4gIHRvU3RyaW5nID0gKCkgPT4gdGhpcy5oYXNoO1xufTtcbmZ1bmN0aW9uIGlzVjNUeChkZXRhaWxzKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBkZXRhaWxzLnZlcnNpb24gPyB0b0hleChkZXRhaWxzLnZlcnNpb24pIDogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMztcbiAgcmV0dXJuIHZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMgfHwgdmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMztcbn1cbmZ1bmN0aW9uIGlzVmVyc2lvbih2ZXJzaW9uLCByZXNwb25zZSkge1xuICBjb25zdCBbbWFqb3JTLCBtaW5vclNdID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG4gIGNvbnN0IFttYWpvclIsIG1pbm9yUl0gPSByZXNwb25zZS5zcGxpdChcIi5cIik7XG4gIHJldHVybiBtYWpvclMgPT09IG1ham9yUiAmJiBtaW5vclMgPT09IG1pbm9yUjtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZ0Jsb2NrKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZS5zdGF0dXMgPT09IFwiUEVORElOR1wiO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nVHJhbnNhY3Rpb24ocmVzcG9uc2UpIHtcbiAgcmV0dXJuICEoXCJibG9ja19oYXNoXCIgaW4gcmVzcG9uc2UpO1xufVxuZnVuY3Rpb24gaXNQZW5kaW5nU3RhdGVVcGRhdGUocmVzcG9uc2UpIHtcbiAgcmV0dXJuICEoXCJibG9ja19oYXNoXCIgaW4gcmVzcG9uc2UpO1xufVxuXG4vLyBzcmMvdXRpbHMvdHJhbnNhY3Rpb24udHNcbnZhciB0cmFuc2FjdGlvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydCh0cmFuc2FjdGlvbl9leHBvcnRzLCB7XG4gIGJ1aWxkVURDQ2FsbDogKCkgPT4gYnVpbGRVRENDYWxsLFxuICBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEsXG4gIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YVdpdGhOb25jZSxcbiAgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xOiAoKSA9PiBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YV9jYWlybzEsXG4gIGdldEV4ZWN1dGVDYWxsZGF0YTogKCkgPT4gZ2V0RXhlY3V0ZUNhbGxkYXRhLFxuICBnZXRWZXJzaW9uc0J5VHlwZTogKCkgPT4gZ2V0VmVyc2lvbnNCeVR5cGUsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXM6ICgpID0+IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMsXG4gIHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXNfY2Fpcm8xOiAoKSA9PiB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMVxufSk7XG52YXIgdHJhbnNmb3JtQ2FsbHNUb011bHRpY2FsbEFycmF5cyA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBbXTtcbiAgY29uc3QgY2FsbGRhdGEgPSBbXTtcbiAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pO1xuICAgIGNhbGxBcnJheS5wdXNoKHtcbiAgICAgIHRvOiB0b0JpZ0ludChjYWxsLmNvbnRyYWN0QWRkcmVzcykudG9TdHJpbmcoMTApLFxuICAgICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgICAgZGF0YV9vZmZzZXQ6IGNhbGxkYXRhLmxlbmd0aC50b1N0cmluZygpLFxuICAgICAgZGF0YV9sZW46IGRhdGEubGVuZ3RoLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICBjYWxsZGF0YS5wdXNoKC4uLmRhdGEpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxsQXJyYXksXG4gICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoeyBjYWxsZGF0YSB9KVxuICB9O1xufTtcbnZhciBmcm9tQ2FsbHNUb0V4ZWN1dGVDYWxsZGF0YSA9IChjYWxscykgPT4ge1xuICBjb25zdCB7IGNhbGxBcnJheSwgY2FsbGRhdGEgfSA9IHRyYW5zZm9ybUNhbGxzVG9NdWx0aWNhbGxBcnJheXMoY2FsbHMpO1xuICBjb25zdCBjb21waWxlZENhbGxzID0gQ2FsbERhdGEuY29tcGlsZSh7IGNhbGxBcnJheSB9KTtcbiAgcmV0dXJuIFsuLi5jb21waWxlZENhbGxzLCAuLi5jYWxsZGF0YV07XG59O1xudmFyIGZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhV2l0aE5vbmNlID0gKGNhbGxzLCBub25jZSkgPT4ge1xuICByZXR1cm4gWy4uLmZyb21DYWxsc1RvRXhlY3V0ZUNhbGxkYXRhKGNhbGxzKSwgdG9CaWdJbnQobm9uY2UpLnRvU3RyaW5nKCldO1xufTtcbnZhciB0cmFuc2Zvcm1DYWxsc1RvTXVsdGljYWxsQXJyYXlzX2NhaXJvMSA9IChjYWxscykgPT4ge1xuICBjb25zdCBjYWxsQXJyYXkgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgdG86IHRvQmlnSW50KGNhbGwuY29udHJhY3RBZGRyZXNzKS50b1N0cmluZygxMCksXG4gICAgc2VsZWN0b3I6IHRvQmlnSW50KGdldFNlbGVjdG9yRnJvbU5hbWUoY2FsbC5lbnRyeXBvaW50KSkudG9TdHJpbmcoMTApLFxuICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKGNhbGwuY2FsbGRhdGEgfHwgW10pXG4gIH0pKTtcbiAgcmV0dXJuIGNhbGxBcnJheTtcbn07XG52YXIgZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xID0gKGNhbGxzKSA9PiB7XG4gIGNvbnN0IG9yZGVyQ2FsbHMgPSBjYWxscy5tYXAoKGNhbGwpID0+ICh7XG4gICAgY29udHJhY3RBZGRyZXNzOiBjYWxsLmNvbnRyYWN0QWRkcmVzcyxcbiAgICBlbnRyeXBvaW50OiBjYWxsLmVudHJ5cG9pbnQsXG4gICAgY2FsbGRhdGE6IEFycmF5LmlzQXJyYXkoY2FsbC5jYWxsZGF0YSkgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBjYWxsLmNhbGxkYXRhID8gY2FsbC5jYWxsZGF0YSA6IENhbGxEYXRhLmNvbXBpbGUoY2FsbC5jYWxsZGF0YSlcbiAgICAvLyBSYXdBcmdzT2JqZWN0IHwgUmF3QXJnc0FycmF5IHR5cGVcbiAgfSkpO1xuICByZXR1cm4gQ2FsbERhdGEuY29tcGlsZSh7IG9yZGVyQ2FsbHMgfSk7XG59O1xudmFyIGdldEV4ZWN1dGVDYWxsZGF0YSA9IChjYWxscywgY2Fpcm9WZXJzaW9uID0gXCIwXCIpID0+IHtcbiAgaWYgKGNhaXJvVmVyc2lvbiA9PT0gXCIxXCIpIHtcbiAgICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGFfY2Fpcm8xKGNhbGxzKTtcbiAgfVxuICByZXR1cm4gZnJvbUNhbGxzVG9FeGVjdXRlQ2FsbGRhdGEoY2FsbHMpO1xufTtcbmZ1bmN0aW9uIGJ1aWxkVURDQ2FsbChwYXlsb2FkLCBhZGRyZXNzKSB7XG4gIGNvbnN0IHBhcmFtcyA9IFtdLmNvbmNhdChwYXlsb2FkKS5tYXAoKGl0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NIYXNoLFxuICAgICAgc2FsdCxcbiAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhID0gW11cbiAgICB9ID0gaXQ7XG4gICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBkZXBsb3lTYWx0ID0gc2FsdCA/PyByYW5kb21BZGRyZXNzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGw6IHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBVREMuQUREUkVTUyxcbiAgICAgICAgZW50cnlwb2ludDogVURDLkVOVFJZUE9JTlQsXG4gICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGRlcGxveVNhbHQsXG4gICAgICAgICAgdG9DYWlyb0Jvb2wodW5pcXVlKSxcbiAgICAgICAgICBjb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGEubGVuZ3RoLFxuICAgICAgICAgIC4uLmNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgYWRkcmVzczogY2FsY3VsYXRlQ29udHJhY3RBZGRyZXNzRnJvbUhhc2goXG4gICAgICAgIHVuaXF1ZSA/IHN0YXJrQ3VydmUucGVkZXJzZW4oYWRkcmVzcywgZGVwbG95U2FsdCkgOiBkZXBsb3lTYWx0LFxuICAgICAgICBjbGFzc0hhc2gsXG4gICAgICAgIGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsRGF0YSxcbiAgICAgICAgdW5pcXVlID8gVURDLkFERFJFU1MgOiAwXG4gICAgICApXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY2FsbHM6IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5jYWxsKSxcbiAgICBhZGRyZXNzZXM6IHBhcmFtcy5tYXAoKGl0KSA9PiBpdC5hZGRyZXNzKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpIHtcbiAgcmV0dXJuIHZlcnNpb25UeXBlID09PSBcImZlZVwiID8ge1xuICAgIHYxOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYxLFxuICAgIHYyOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyLFxuICAgIHYzOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzXG4gIH0gOiB7IHYxOiBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLCB2MjogYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMiwgdjM6IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMgfTtcbn1cblxuLy8gc3JjL2NoYW5uZWwvcnBjXzBfNi50c1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gIGJsb2NrSWRlbnRpZmllcjogXCJwZW5kaW5nXCIgLyogUEVORElORyAqLyxcbiAgcmV0cmllczogMjAwXG59O1xudmFyIFJwY0NoYW5uZWwgPSBjbGFzcyB7XG4gIG5vZGVVcmw7XG4gIGhlYWRlcnM7XG4gIHJldHJpZXM7XG4gIHJlcXVlc3RJZDtcbiAgYmxvY2tJZGVudGlmaWVyO1xuICBjaGFpbklkO1xuICBzcGVjVmVyc2lvbjtcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgYmF0Y2hDbGllbnQ7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgY29uc3QgeyBub2RlVXJsLCByZXRyaWVzLCBoZWFkZXJzLCBibG9ja0lkZW50aWZpZXIsIGNoYWluSWQsIHNwZWNWZXJzaW9uLCB3YWl0TW9kZSwgYmF0Y2ggfSA9IG9wdGlvbnNPclByb3ZpZGVyIHx8IHt9O1xuICAgIGlmIChPYmplY3QudmFsdWVzKE5ldHdvcmtOYW1lKS5pbmNsdWRlcyhub2RlVXJsKSkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwobm9kZVVybCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH0gZWxzZSBpZiAobm9kZVVybCkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gbm9kZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwodm9pZCAwLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXMgfHwgZGVmYXVsdE9wdGlvbnMucmV0cmllcztcbiAgICB0aGlzLmhlYWRlcnMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLmhlYWRlcnMsIC4uLmhlYWRlcnMgfTtcbiAgICB0aGlzLmJsb2NrSWRlbnRpZmllciA9IGJsb2NrSWRlbnRpZmllciB8fCBkZWZhdWx0T3B0aW9ucy5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLnNwZWNWZXJzaW9uID0gc3BlY1ZlcnNpb247XG4gICAgdGhpcy53YWl0TW9kZSA9IHdhaXRNb2RlIHx8IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdElkID0gMDtcbiAgICBpZiAodHlwZW9mIGJhdGNoID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLmJhdGNoQ2xpZW50ID0gbmV3IEJhdGNoQ2xpZW50KHtcbiAgICAgICAgbm9kZVVybDogdGhpcy5ub2RlVXJsLFxuICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgIGludGVydmFsOiBiYXRjaFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNldENoYWluSWQoY2hhaW5JZCkge1xuICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cbiAgZmV0Y2gobWV0aG9kLCBwYXJhbXMsIGlkID0gMCkge1xuICAgIGNvbnN0IHJwY1JlcXVlc3RCb2R5ID0ge1xuICAgICAgaWQsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgLi4ucGFyYW1zICYmIHsgcGFyYW1zIH1cbiAgICB9O1xuICAgIHJldHVybiBmZXRjaFBvbnlmaWxsX2RlZmF1bHQodGhpcy5ub2RlVXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5MihycGNSZXF1ZXN0Qm9keSksXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBlcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIHJwY0Vycm9yLCBvdGhlckVycm9yKSB7XG4gICAgaWYgKHJwY0Vycm9yKSB7XG4gICAgICBjb25zdCB7IGNvZGUsIG1lc3NhZ2UsIGRhdGEgfSA9IHJwY0Vycm9yO1xuICAgICAgdGhyb3cgbmV3IExpYnJhcnlFcnJvcihcbiAgICAgICAgYFJQQzogJHttZXRob2R9IHdpdGggcGFyYW1zICR7c3RyaW5naWZ5MihwYXJhbXMsIG51bGwsIDIpfVxuXG4gICAgICAgICR7Y29kZX06ICR7bWVzc2FnZX06ICR7c3RyaW5naWZ5MihkYXRhKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvciBpbnN0YW5jZW9mIExpYnJhcnlFcnJvcikge1xuICAgICAgdGhyb3cgb3RoZXJFcnJvcjtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IpIHtcbiAgICAgIHRocm93IEVycm9yKG90aGVyRXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZldGNoRW5kcG9pbnQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuYmF0Y2hDbGllbnQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogZXJyb3IyLCByZXN1bHQ6IHJlc3VsdDIgfSA9IGF3YWl0IHRoaXMuYmF0Y2hDbGllbnQuZmV0Y2goXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICB0aGlzLnJlcXVlc3RJZCArPSAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcjIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHRoaXMuZmV0Y2gobWV0aG9kLCBwYXJhbXMsIHRoaXMucmVxdWVzdElkICs9IDEpO1xuICAgICAgY29uc3QgeyBlcnJvciwgcmVzdWx0IH0gPSBhd2FpdCByYXdSZXN1bHQuanNvbigpO1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcj8ucmVzcG9uc2U/LmRhdGEsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHRoaXMuY2hhaW5JZCA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2hhaW5JZFwiKTtcbiAgICByZXR1cm4gdGhpcy5jaGFpbklkO1xuICB9XG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHRoaXMuc3BlY1ZlcnNpb24gPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NwZWNWZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLnNwZWNWZXJzaW9uO1xuICB9XG4gIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXROb25jZVwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZUJsb2NrVHJhbnNhY3Rpb25zXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlID0gdHJ1ZSxcbiAgICAgIHNraXBGZWVDaGFyZ2UgPSB0cnVlXG4gICAgfSA9IHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCBzaW11bGF0aW9uRmxhZ3MgPSBbXTtcbiAgICBpZiAoc2tpcFZhbGlkYXRlKSBzaW11bGF0aW9uRmxhZ3MucHVzaChycGNzcGVjXzBfNl9leHBvcnRzLkVTaW11bGF0aW9uRmxhZy5TS0lQX1ZBTElEQVRFKTtcbiAgICBpZiAoc2tpcEZlZUNoYXJnZSkgc2ltdWxhdGlvbkZsYWdzLnB1c2gocnBjc3BlY18wXzZfZXhwb3J0cy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9GRUVfQ0hBUkdFKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc2ltdWxhdGVUcmFuc2FjdGlvbnNcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICB0cmFuc2FjdGlvbnM6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCkpLFxuICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2ltdWxhdGlvbkZsYWdzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgbGV0IHsgcmV0cmllcyB9ID0gdGhpcztcbiAgICBsZXQgb25jaGFpbiA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yU3RhdGUgPSBmYWxzZTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gb3B0aW9ucz8ucmV0cnlJbnRlcnZhbCA/PyA1ZTM7XG4gICAgY29uc3QgZXJyb3JTdGF0ZXMgPSBvcHRpb25zPy5lcnJvclN0YXRlcyA/PyBbXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5SRUpFQ1RFRFxuICAgICAgLy8gVE9ETzogY29tbWVudGVkIG91dCB0byBwcmVzZXJ2ZSB0aGUgbG9uZy1zdGFuZGluZyBiZWhhdmlvciBvZiBcInJldmVydGVkXCIgbm90IGJlaW5nIHRyZWF0ZWQgYXMgYW4gZXJyb3IgYnkgZGVmYXVsdFxuICAgICAgLy8gc2hvdWxkIGRlY2lkZSB3aGljaCBiZWhhdmlvciB0byBrZWVwIGluIHRoZSBmdXR1cmVcbiAgICAgIC8vIFJQQy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuUkVWRVJURUQsXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvbkV4ZWN1dGlvblN0YXR1cy5TVUNDRUVERUQsXG4gICAgICBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblN0YXR1cy5BQ0NFUFRFRF9PTl9MMixcbiAgICAgIHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uU3RhdHVzLkFDQ0VQVEVEX09OX0wxXG4gICAgXTtcbiAgICBsZXQgdHhTdGF0dXM7XG4gICAgd2hpbGUgKCFvbmNoYWluKSB7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhTdGF0dXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblN0YXR1cyA9IHR4U3RhdHVzLmV4ZWN1dGlvbl9zdGF0dXM7XG4gICAgICAgIGNvbnN0IGZpbmFsaXR5U3RhdHVzID0gdHhTdGF0dXMuZmluYWxpdHlfc3RhdHVzO1xuICAgICAgICBpZiAoIWZpbmFsaXR5U3RhdHVzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJ3YWl0aW5nIGZvciB0cmFuc2FjdGlvbiBzdGF0dXNcIik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke2V4ZWN1dGlvblN0YXR1c306ICR7ZmluYWxpdHlTdGF0dXN9YDtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHR4U3RhdHVzO1xuICAgICAgICAgIGlzRXJyb3JTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgb25jaGFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGlzRXJyb3JTdGF0ZSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgfVxuICAgIGxldCB0eFJlY2VpcHQgPSBudWxsO1xuICAgIHdoaWxlICh0eFJlY2VpcHQgPT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9TdG9yYWdlS2V5KGtleSk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdG9yYWdlQXRcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0hhc2hBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2xhc3NfaGFzaCA9IHRvSGV4KGNsYXNzSGFzaCk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc1wiLCB7XG4gICAgICBjbGFzc19oYXNoLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbnMsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IHRydWUgfSkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBsZXQgZmxhZ3MgPSB7fTtcbiAgICBpZiAoIWlzVmVyc2lvbihcIjAuNVwiLCBhd2FpdCB0aGlzLmdldFNwZWNWZXJzaW9uKCkpKSB7XG4gICAgICBmbGFncyA9IHtcbiAgICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2tpcFZhbGlkYXRlID8gW3JwY3NwZWNfMF82X2V4cG9ydHMuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEVdIDogW11cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9lc3RpbWF0ZUZlZVwiLCB7XG4gICAgICByZXF1ZXN0OiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQsIFwiZmVlXCIpKSxcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgLi4uZmxhZ3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnZva2UoZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKCFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBmdW5jdGlvbkludm9jYXRpb24uY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChmdW5jdGlvbkludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGZ1bmN0aW9uSW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZWNsYXJlKHsgY29udHJhY3QsIHNpZ25hdHVyZSwgc2VuZGVyQWRkcmVzcywgY29tcGlsZWRDbGFzc0hhc2ggfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNTaWVycmEoY29udHJhY3QpICYmICFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2llcnJhKGNvbnRyYWN0KSAmJiAhaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oY29udHJhY3Quc2llcnJhX3Byb2dyYW0pLFxuICAgICAgICAgICAgY29udHJhY3RfY2xhc3NfdmVyc2lvbjogY29udHJhY3QuY29udHJhY3RfY2xhc3NfdmVyc2lvbixcbiAgICAgICAgICAgIGVudHJ5X3BvaW50c19ieV90eXBlOiBjb250cmFjdC5lbnRyeV9wb2ludHNfYnlfdHlwZSxcbiAgICAgICAgICAgIGFiaTogY29udHJhY3QuYWJpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21waWxlZF9jbGFzc19oYXNoOiBjb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICAgIHZlcnNpb246IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMixcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERUNMQVJFLFxuICAgICAgICAgIHNlbmRlcl9hZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGNvbXBpbGVkQ2xhc3NIYXNoIHx8IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzb3VyY2VfYm91bmRzOiBkZXRhaWxzLnJlc291cmNlQm91bmRzLFxuICAgICAgICAgIHRpcDogdG9IZXgoZGV0YWlscy50aXApLFxuICAgICAgICAgIHBheW1hc3Rlcl9kYXRhOiBkZXRhaWxzLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBhY2NvdW50X2RlcGxveW1lbnRfZGF0YTogZGV0YWlscy5hY2NvdW50RGVwbG95bWVudERhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgICBub25jZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUsXG4gICAgICAgICAgZmVlX2RhdGFfYXZhaWxhYmlsaXR5X21vZGU6IGRldGFpbHMuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZGVjbGFyZSB1bnNwb3R0ZWQgcGFyYW1ldGVyc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2FpdE1vZGUgPyB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbigoYXdhaXQgcHJvbWlzZSkudHJhbnNhY3Rpb25faGFzaCkgOiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnQoeyBjbGFzc0hhc2gsIGNvbnN0cnVjdG9yQ2FsbGRhdGEsIGFkZHJlc3NTYWx0LCBzaWduYXR1cmUgfSwgZGV0YWlscykge1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcl9jYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgICAgY2xhc3NfaGFzaDogdG9IZXgoY2xhc3NIYXNoKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIHR5cGU6IHJwY3NwZWNfMF82X2V4cG9ydHMuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVwbG95X2FjY291bnRfdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuREVQTE9ZX0FDQ09VTlQsXG4gICAgICAgICAgdmVyc2lvbjogcnBjc3BlY18wXzZfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IHRvSGV4KHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlTWVzc2FnZUZlZVwiLCB7XG4gICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3luY2luZ1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0RXZlbnRzXCIsIHsgZmlsdGVyOiBldmVudEZpbHRlciB9KTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGlmICghaXNWM1R4KGludm9jYXRpb24pKSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIHJlc291cmNlX2JvdW5kczogaW52b2NhdGlvbi5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgdGlwOiB0b0hleChpbnZvY2F0aW9uLnRpcCksXG4gICAgICAgIHBheW1hc3Rlcl9kYXRhOiBpbnZvY2F0aW9uLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGludm9jYXRpb24uYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB2MCB2MSB2M1xuICAgICAgICB0eXBlOiBycGNzcGVjXzBfNl9leHBvcnRzLkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8pIHtcbiAgICAgIGlmICghaXNTaWVycmEoaW52b2NhdGlvbi5jb250cmFjdCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IGludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYxKSxcbiAgICAgICAgICAuLi5kZXRhaWxzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBDYWlybyAxIC0gdjIgdjNcbiAgICAgICAgdHlwZTogaW52b2NhdGlvbi50eXBlLFxuICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgIC4uLmludm9jYXRpb24uY29udHJhY3QsXG4gICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGludm9jYXRpb24uY29udHJhY3Quc2llcnJhX3Byb2dyYW0pXG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBpbGVkX2NsYXNzX2hhc2g6IGludm9jYXRpb24uY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGludm9jYXRpb24uc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLmRldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLykge1xuICAgICAgY29uc3QgeyBhY2NvdW50X2RlcGxveW1lbnRfZGF0YSwgLi4ucmVzdERldGFpbHMgfSA9IGRldGFpbHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChpbnZvY2F0aW9uLmNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICBjbGFzc19oYXNoOiB0b0hleChpbnZvY2F0aW9uLmNsYXNzSGFzaCksXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3Nfc2FsdDogdG9IZXgoaW52b2NhdGlvbi5hZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgdmVyc2lvbjogdG9IZXgoaW52b2NhdGlvbi52ZXJzaW9uIHx8IGRlZmF1bHRWZXJzaW9ucy52MyksXG4gICAgICAgIC4uLnJlc3REZXRhaWxzXG4gICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBFcnJvcihcIlJQQyBidWlsZFRyYW5zYWN0aW9uIHJlY2VpdmVkIHVua25vd24gVHJhbnNhY3Rpb25UeXBlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvY2hhbm5lbC9ycGNfMF83LnRzXG52YXIgcnBjXzBfN19leHBvcnRzID0ge307XG5fX2V4cG9ydChycGNfMF83X2V4cG9ydHMsIHtcbiAgUnBjQ2hhbm5lbDogKCkgPT4gUnBjQ2hhbm5lbDJcbn0pO1xudmFyIGRlZmF1bHRPcHRpb25zMiA9IHtcbiAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICBibG9ja0lkZW50aWZpZXI6IFwicGVuZGluZ1wiIC8qIFBFTkRJTkcgKi8sXG4gIHJldHJpZXM6IDIwMFxufTtcbnZhciBScGNDaGFubmVsMiA9IGNsYXNzIHtcbiAgbm9kZVVybDtcbiAgaGVhZGVycztcbiAgcmV0cmllcztcbiAgcmVxdWVzdElkO1xuICBibG9ja0lkZW50aWZpZXI7XG4gIGNoYWluSWQ7XG4gIHNwZWNWZXJzaW9uO1xuICB0cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjaztcbiAgd2FpdE1vZGU7XG4gIC8vIGJlaGF2ZSBsaWtlIHdlYjIgcnBjIGFuZCByZXR1cm4gd2hlbiB0eCBpcyBwcm9jZXNzZWRcbiAgYmF0Y2hDbGllbnQ7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnNPclByb3ZpZGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZVVybCxcbiAgICAgIHJldHJpZXMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHNwZWNWZXJzaW9uLFxuICAgICAgd2FpdE1vZGUsXG4gICAgICB0cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjayxcbiAgICAgIGJhdGNoXG4gICAgfSA9IG9wdGlvbnNPclByb3ZpZGVyIHx8IHt9O1xuICAgIGlmIChPYmplY3QudmFsdWVzKE5ldHdvcmtOYW1lKS5pbmNsdWRlcyhub2RlVXJsKSkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwobm9kZVVybCwgb3B0aW9uc09yUHJvdmlkZXI/LmRlZmF1bHQpO1xuICAgIH0gZWxzZSBpZiAobm9kZVVybCkge1xuICAgICAgdGhpcy5ub2RlVXJsID0gbm9kZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlVXJsID0gZ2V0RGVmYXVsdE5vZGVVcmwodm9pZCAwLCBvcHRpb25zT3JQcm92aWRlcj8uZGVmYXVsdCk7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXMgfHwgZGVmYXVsdE9wdGlvbnMyLnJldHJpZXM7XG4gICAgdGhpcy5oZWFkZXJzID0geyAuLi5kZWZhdWx0T3B0aW9uczIuaGVhZGVycywgLi4uaGVhZGVycyB9O1xuICAgIHRoaXMuYmxvY2tJZGVudGlmaWVyID0gYmxvY2tJZGVudGlmaWVyIHx8IGRlZmF1bHRPcHRpb25zMi5ibG9ja0lkZW50aWZpZXI7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgICB0aGlzLnNwZWNWZXJzaW9uID0gc3BlY1ZlcnNpb247XG4gICAgdGhpcy53YWl0TW9kZSA9IHdhaXRNb2RlIHx8IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdElkID0gMDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uUmV0cnlJbnRlcnZhbEZhbGxiYWNrID0gdHJhbnNhY3Rpb25SZXRyeUludGVydmFsRmFsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBiYXRjaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdGhpcy5iYXRjaENsaWVudCA9IG5ldyBCYXRjaENsaWVudCh7XG4gICAgICAgIG5vZGVVcmw6IHRoaXMubm9kZVVybCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICBpbnRlcnZhbDogYmF0Y2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgdHJhbnNhY3Rpb25SZXRyeUludGVydmFsRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxGYWxsYmFjayA/PyA1ZTM7XG4gIH1cbiAgc2V0Q2hhaW5JZChjaGFpbklkKSB7XG4gICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZDtcbiAgfVxuICBmZXRjaChtZXRob2QsIHBhcmFtcywgaWQgPSAwKSB7XG4gICAgY29uc3QgcnBjUmVxdWVzdEJvZHkgPSB7XG4gICAgICBpZCxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICAuLi5wYXJhbXMgJiYgeyBwYXJhbXMgfVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoUG9ueWZpbGxfZGVmYXVsdCh0aGlzLm5vZGVVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBzdHJpbmdpZnkyKHJwY1JlcXVlc3RCb2R5KSxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVyc1xuICAgIH0pO1xuICB9XG4gIGVycm9ySGFuZGxlcihtZXRob2QsIHBhcmFtcywgcnBjRXJyb3IsIG90aGVyRXJyb3IpIHtcbiAgICBpZiAocnBjRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gcnBjRXJyb3I7XG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFxuICAgICAgICBgUlBDOiAke21ldGhvZH0gd2l0aCBwYXJhbXMgJHtzdHJpbmdpZnkyKHBhcmFtcywgbnVsbCwgMil9XG4gXG4gICAgICAgICR7Y29kZX06ICR7bWVzc2FnZX06ICR7c3RyaW5naWZ5MihkYXRhKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3RoZXJFcnJvciBpbnN0YW5jZW9mIExpYnJhcnlFcnJvcikge1xuICAgICAgdGhyb3cgb3RoZXJFcnJvcjtcbiAgICB9XG4gICAgaWYgKG90aGVyRXJyb3IpIHtcbiAgICAgIHRocm93IEVycm9yKG90aGVyRXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZldGNoRW5kcG9pbnQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuYmF0Y2hDbGllbnQpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcjogZXJyb3IyLCByZXN1bHQ6IHJlc3VsdDIgfSA9IGF3YWl0IHRoaXMuYmF0Y2hDbGllbnQuZmV0Y2goXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICB0aGlzLnJlcXVlc3RJZCArPSAxXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcjIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhd1Jlc3VsdCA9IGF3YWl0IHRoaXMuZmV0Y2gobWV0aG9kLCBwYXJhbXMsIHRoaXMucmVxdWVzdElkICs9IDEpO1xuICAgICAgY29uc3QgeyBlcnJvciwgcmVzdWx0IH0gPSBhd2FpdCByYXdSZXN1bHQuanNvbigpO1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXIobWV0aG9kLCBwYXJhbXMsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKG1ldGhvZCwgcGFyYW1zLCBlcnJvcj8ucmVzcG9uc2U/LmRhdGEsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgIHRoaXMuY2hhaW5JZCA/Pz0gYXdhaXQgdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfY2hhaW5JZFwiKTtcbiAgICByZXR1cm4gdGhpcy5jaGFpbklkO1xuICB9XG4gIGFzeW5jIGdldFNwZWNWZXJzaW9uKCkge1xuICAgIHRoaXMuc3BlY1ZlcnNpb24gPz89IGF3YWl0IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NwZWNWZXJzaW9uXCIpO1xuICAgIHJldHVybiB0aGlzLnNwZWNWZXJzaW9uO1xuICB9XG4gIGdldE5vbmNlRm9yQWRkcmVzcyhjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXROb25jZVwiLCB7XG4gICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2Jsb2NrSGFzaEFuZE51bWJlclwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBudW1iZXJcbiAgICogcmVkdW5kYW50IHVzZSBnZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gICAqIEByZXR1cm5zIE51bWJlciBvZiB0aGUgbGF0ZXN0IGJsb2NrXG4gICAqL1xuICBnZXRCbG9ja051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYmxvY2tOdW1iZXJcIik7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldEJsb2NrV2l0aFR4SGFzaGVzXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tXaXRoVHhzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1dpdGhUeHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1dpdGhSZWNlaXB0cyhibG9ja0lkZW50aWZpZXIgPSB0aGlzLmJsb2NrSWRlbnRpZmllcikge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0QmxvY2tXaXRoUmVjZWlwdHNcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdGF0ZVVwZGF0ZVwiLCB7IGJsb2NrX2lkIH0pO1xuICB9XG4gIGdldEJsb2NrVHJhbnNhY3Rpb25zVHJhY2VzKGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF90cmFjZUJsb2NrVHJhbnNhY3Rpb25zXCIsIHsgYmxvY2tfaWQgfSk7XG4gIH1cbiAgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50KGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRcIiwgeyBibG9ja19pZCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwge1xuICAgICAgdHJhbnNhY3Rpb25faGFzaFxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQnlCbG9ja0lkQW5kSW5kZXgoYmxvY2tJZGVudGlmaWVyLCBpbmRleCkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleFwiLCB7IGJsb2NrX2lkLCBpbmRleCB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25faGFzaCA9IHRvSGV4KHR4SGFzaCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl9oYXNoID0gdG9IZXgodHhIYXNoKTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfdHJhY2VUcmFuc2FjdGlvblwiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uX2hhc2ggPSB0b0hleCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRUcmFuc2FjdGlvblN0YXR1c1wiLCB7IHRyYW5zYWN0aW9uX2hhc2ggfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnZvY2F0aW9ucyBBY2NvdW50SW52b2NhdGlvbnNcbiAgICogQHBhcmFtIHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgc2ltdWxhdGVUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlID0gdHJ1ZSxcbiAgICAgIHNraXBGZWVDaGFyZ2UgPSB0cnVlXG4gICAgfSA9IHNpbXVsYXRlVHJhbnNhY3Rpb25PcHRpb25zO1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBjb25zdCBzaW11bGF0aW9uRmxhZ3MgPSBbXTtcbiAgICBpZiAoc2tpcFZhbGlkYXRlKSBzaW11bGF0aW9uRmxhZ3MucHVzaChSUENTUEVDMDcuRVNpbXVsYXRpb25GbGFnLlNLSVBfVkFMSURBVEUpO1xuICAgIGlmIChza2lwRmVlQ2hhcmdlKSBzaW11bGF0aW9uRmxhZ3MucHVzaChSUENTUEVDMDcuRVNpbXVsYXRpb25GbGFnLlNLSVBfRkVFX0NIQVJHRSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X3NpbXVsYXRlVHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgIGJsb2NrX2lkLFxuICAgICAgdHJhbnNhY3Rpb25zOiBpbnZvY2F0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmJ1aWxkVHJhbnNhY3Rpb24oaXQpKSxcbiAgICAgIHNpbXVsYXRpb25fZmxhZ3M6IHNpbXVsYXRpb25GbGFnc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvbih0eEhhc2gsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB0b0hleCh0eEhhc2gpO1xuICAgIGxldCB7IHJldHJpZXMgfSA9IHRoaXM7XG4gICAgbGV0IG9uY2hhaW4gPSBmYWxzZTtcbiAgICBsZXQgaXNFcnJvclN0YXRlID0gZmFsc2U7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IG9wdGlvbnM/LnJldHJ5SW50ZXJ2YWwgPz8gdGhpcy50cmFuc2FjdGlvblJldHJ5SW50ZXJ2YWxEZWZhdWx0O1xuICAgIGNvbnN0IGVycm9yU3RhdGVzID0gb3B0aW9ucz8uZXJyb3JTdGF0ZXMgPz8gW1xuICAgICAgUlBDU1BFQzA3LkVUcmFuc2FjdGlvblN0YXR1cy5SRUpFQ1RFRFxuICAgICAgLy8gVE9ETzogY29tbWVudGVkIG91dCB0byBwcmVzZXJ2ZSB0aGUgbG9uZy1zdGFuZGluZyBiZWhhdmlvciBvZiBcInJldmVydGVkXCIgbm90IGJlaW5nIHRyZWF0ZWQgYXMgYW4gZXJyb3IgYnkgZGVmYXVsdFxuICAgICAgLy8gc2hvdWxkIGRlY2lkZSB3aGljaCBiZWhhdmlvciB0byBrZWVwIGluIHRoZSBmdXR1cmVcbiAgICAgIC8vIFJQQy5FVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMuUkVWRVJURUQsXG4gICAgXTtcbiAgICBjb25zdCBzdWNjZXNzU3RhdGVzID0gb3B0aW9ucz8uc3VjY2Vzc1N0YXRlcyA/PyBbXG4gICAgICBSUENTUEVDMDcuRVRyYW5zYWN0aW9uRXhlY3V0aW9uU3RhdHVzLlNVQ0NFRURFRCxcbiAgICAgIFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25TdGF0dXMuQUNDRVBURURfT05fTDIsXG4gICAgICBSUENTUEVDMDcuRVRyYW5zYWN0aW9uU3RhdHVzLkFDQ0VQVEVEX09OX0wxXG4gICAgXTtcbiAgICBsZXQgdHhTdGF0dXM7XG4gICAgd2hpbGUgKCFvbmNoYWluKSB7XG4gICAgICBhd2FpdCB3YWl0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhTdGF0dXMgPSBhd2FpdCB0aGlzLmdldFRyYW5zYWN0aW9uU3RhdHVzKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblN0YXR1cyA9IHR4U3RhdHVzLmV4ZWN1dGlvbl9zdGF0dXM7XG4gICAgICAgIGNvbnN0IGZpbmFsaXR5U3RhdHVzID0gdHhTdGF0dXMuZmluYWxpdHlfc3RhdHVzO1xuICAgICAgICBpZiAoIWZpbmFsaXR5U3RhdHVzKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJ3YWl0aW5nIGZvciB0cmFuc2FjdGlvbiBzdGF0dXNcIik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yU3RhdGVzLmluY2x1ZGVzKGV4ZWN1dGlvblN0YXR1cykgfHwgZXJyb3JTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke2V4ZWN1dGlvblN0YXR1c306ICR7ZmluYWxpdHlTdGF0dXN9YDtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHR4U3RhdHVzO1xuICAgICAgICAgIGlzRXJyb3JTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VjY2Vzc1N0YXRlcy5pbmNsdWRlcyhleGVjdXRpb25TdGF0dXMpIHx8IHN1Y2Nlc3NTdGF0ZXMuaW5jbHVkZXMoZmluYWxpdHlTdGF0dXMpKSB7XG4gICAgICAgICAgb25jaGFpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGlzRXJyb3JTdGF0ZSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXRyaWVzIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhaXRGb3JUcmFuc2FjdGlvbiB0aW1lZC1vdXQgd2l0aCByZXRyaWVzICR7dGhpcy5yZXRyaWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXRyaWVzIC09IDE7XG4gICAgfVxuICAgIGxldCB0eFJlY2VpcHQgPSBudWxsO1xuICAgIHdoaWxlICh0eFJlY2VpcHQgPT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocmV0cmllcyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3YWl0Rm9yVHJhbnNhY3Rpb24gdGltZWQtb3V0IHdpdGggcmV0cmllcyAke3RoaXMucmV0cmllc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0cmllcyAtPSAxO1xuICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4UmVjZWlwdDtcbiAgfVxuICBnZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgcGFyc2VkS2V5ID0gdG9TdG9yYWdlS2V5KGtleSk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRTdG9yYWdlQXRcIiwge1xuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIGtleTogcGFyc2VkS2V5LFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0hhc2hBdChjb250cmFjdEFkZHJlc3MsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IHRvSGV4KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc0hhc2hBdFwiLCB7XG4gICAgICBibG9ja19pZCxcbiAgICAgIGNvbnRyYWN0X2FkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgY2xhc3NfaGFzaCA9IHRvSGV4KGNsYXNzSGFzaCk7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9nZXRDbGFzc1wiLCB7XG4gICAgICBjbGFzc19oYXNoLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCBjb250cmFjdF9hZGRyZXNzID0gdG9IZXgoY29udHJhY3RBZGRyZXNzKTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2dldENsYXNzQXRcIiwge1xuICAgICAgYmxvY2tfaWQsXG4gICAgICBjb250cmFjdF9hZGRyZXNzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbnMsIHsgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSA9IHRydWUgfSkge1xuICAgIGNvbnN0IGJsb2NrX2lkID0gbmV3IEJsb2NrKGJsb2NrSWRlbnRpZmllcikuaWRlbnRpZmllcjtcbiAgICBsZXQgZmxhZ3MgPSB7fTtcbiAgICBpZiAoIWlzVmVyc2lvbihcIjAuNVwiLCBhd2FpdCB0aGlzLmdldFNwZWNWZXJzaW9uKCkpKSB7XG4gICAgICBmbGFncyA9IHtcbiAgICAgICAgc2ltdWxhdGlvbl9mbGFnczogc2tpcFZhbGlkYXRlID8gW1JQQ1NQRUMwNy5FU2ltdWxhdGlvbkZsYWcuU0tJUF9WQUxJREFURV0gOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlRmVlXCIsIHtcbiAgICAgIHJlcXVlc3Q6IGludm9jYXRpb25zLm1hcCgoaXQpID0+IHRoaXMuYnVpbGRUcmFuc2FjdGlvbihpdCwgXCJmZWVcIikpLFxuICAgICAgYmxvY2tfaWQsXG4gICAgICAuLi5mbGFnc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGludm9rZShmdW5jdGlvbkludm9jYXRpb24sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZEludm9rZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgaW52b2tlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IGZ1bmN0aW9uSW52b2NhdGlvbi5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGZ1bmN0aW9uSW52b2NhdGlvbi5jYWxsZGF0YSksXG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuSU5WT0tFLFxuICAgICAgICAgIG1heF9mZWU6IHRvSGV4KGRldGFpbHMubWF4RmVlIHx8IDApLFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShmdW5jdGlvbkludm9jYXRpb24uc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGRJbnZva2VUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGludm9rZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLklOVk9LRSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogZnVuY3Rpb25JbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEudG9IZXgoZnVuY3Rpb25JbnZvY2F0aW9uLmNhbGxkYXRhKSxcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoZnVuY3Rpb25JbnZvY2F0aW9uLnNpZ25hdHVyZSksXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZSh7IGNvbnRyYWN0LCBzaWduYXR1cmUsIHNlbmRlckFkZHJlc3MsIGNvbXBpbGVkQ2xhc3NIYXNoIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzU2llcnJhKGNvbnRyYWN0KSAmJiAhaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHByb2dyYW06IGNvbnRyYWN0LnByb2dyYW0sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVyc2lvbjogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblZlcnNpb24uVjEsXG4gICAgICAgICAgbWF4X2ZlZTogdG9IZXgoZGV0YWlscy5tYXhGZWUgfHwgMCksXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVUb0hleEFycmF5KHNpZ25hdHVyZSksXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgbm9uY2U6IHRvSGV4KGRldGFpbHMubm9uY2UpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNTaWVycmEoY29udHJhY3QpICYmICFpc1YzVHgoZGV0YWlscykpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZWNsYXJlX3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgdHlwZTogUlBDU1BFQzA3LkVUcmFuc2FjdGlvblR5cGUuREVDTEFSRSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczoge1xuICAgICAgICAgICAgc2llcnJhX3Byb2dyYW06IGRlY29tcHJlc3NQcm9ncmFtKGNvbnRyYWN0LnNpZXJyYV9wcm9ncmFtKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2NsYXNzX3ZlcnNpb246IGNvbnRyYWN0LmNvbnRyYWN0X2NsYXNzX3ZlcnNpb24sXG4gICAgICAgICAgICBlbnRyeV9wb2ludHNfYnlfdHlwZTogY29udHJhY3QuZW50cnlfcG9pbnRzX2J5X3R5cGUsXG4gICAgICAgICAgICBhYmk6IGNvbnRyYWN0LmFiaVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMixcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1NpZXJyYShjb250cmFjdCkgJiYgaXNWM1R4KGRldGFpbHMpKSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfYWRkRGVjbGFyZVRyYW5zYWN0aW9uXCIsIHtcbiAgICAgICAgZGVjbGFyZV90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFQ0xBUkUsXG4gICAgICAgICAgc2VuZGVyX2FkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogY29tcGlsZWRDbGFzc0hhc2ggfHwgXCJcIixcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMyxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSksXG4gICAgICAgICAgY29udHJhY3RfY2xhc3M6IHtcbiAgICAgICAgICAgIHNpZXJyYV9wcm9ncmFtOiBkZWNvbXByZXNzUHJvZ3JhbShjb250cmFjdC5zaWVycmFfcHJvZ3JhbSksXG4gICAgICAgICAgICBjb250cmFjdF9jbGFzc192ZXJzaW9uOiBjb250cmFjdC5jb250cmFjdF9jbGFzc192ZXJzaW9uLFxuICAgICAgICAgICAgZW50cnlfcG9pbnRzX2J5X3R5cGU6IGNvbnRyYWN0LmVudHJ5X3BvaW50c19ieV90eXBlLFxuICAgICAgICAgICAgYWJpOiBjb250cmFjdC5hYmlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGRldGFpbHMuYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcImRlY2xhcmUgdW5zcG90dGVkIHBhcmFtZXRlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndhaXRNb2RlID8gdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oKGF3YWl0IHByb21pc2UpLnRyYW5zYWN0aW9uX2hhc2gpIDogcHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXBsb3lBY2NvdW50KHsgY2xhc3NIYXNoLCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBhZGRyZXNzU2FsdCwgc2lnbmF0dXJlIH0sIGRldGFpbHMpIHtcbiAgICBsZXQgcHJvbWlzZTtcbiAgICBpZiAoIWlzVjNUeChkZXRhaWxzKSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2FkZERlcGxveUFjY291bnRUcmFuc2FjdGlvblwiLCB7XG4gICAgICAgIGRlcGxveV9hY2NvdW50X3RyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGNvbnN0cnVjdG9yQ2FsbGRhdGEgfHwgW10pLFxuICAgICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGNsYXNzSGFzaCksXG4gICAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChhZGRyZXNzU2FsdCB8fCAwKSxcbiAgICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5ERVBMT1lfQUNDT1VOVCxcbiAgICAgICAgICBtYXhfZmVlOiB0b0hleChkZXRhaWxzLm1heEZlZSB8fCAwKSxcbiAgICAgICAgICB2ZXJzaW9uOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoc2lnbmF0dXJlKSxcbiAgICAgICAgICBub25jZTogdG9IZXgoZGV0YWlscy5ub25jZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9hZGREZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25cIiwge1xuICAgICAgICBkZXBsb3lfYWNjb3VudF90cmFuc2FjdGlvbjoge1xuICAgICAgICAgIHR5cGU6IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25UeXBlLkRFUExPWV9BQ0NPVU5ULFxuICAgICAgICAgIHZlcnNpb246IFJQQ1NQRUMwNy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlVG9IZXhBcnJheShzaWduYXR1cmUpLFxuICAgICAgICAgIG5vbmNlOiB0b0hleChkZXRhaWxzLm5vbmNlKSxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzX3NhbHQ6IHRvSGV4KGFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICAgIGNvbnN0cnVjdG9yX2NhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjb25zdHJ1Y3RvckNhbGxkYXRhIHx8IFtdKSxcbiAgICAgICAgICBjbGFzc19oYXNoOiB0b0hleChjbGFzc0hhc2gpLFxuICAgICAgICAgIHJlc291cmNlX2JvdW5kczogZGV0YWlscy5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgICB0aXA6IHRvSGV4KGRldGFpbHMudGlwKSxcbiAgICAgICAgICBwYXltYXN0ZXJfZGF0YTogZGV0YWlscy5wYXltYXN0ZXJEYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSksXG4gICAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogZGV0YWlscy5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICAgIGZlZV9kYXRhX2F2YWlsYWJpbGl0eV9tb2RlOiBkZXRhaWxzLmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53YWl0TW9kZSA/IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKChhd2FpdCBwcm9taXNlKS50cmFuc2FjdGlvbl9oYXNoKSA6IHByb21pc2U7XG4gIH1cbiAgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgY29uc3QgYmxvY2tfaWQgPSBuZXcgQmxvY2soYmxvY2tJZGVudGlmaWVyKS5pZGVudGlmaWVyO1xuICAgIHJldHVybiB0aGlzLmZldGNoRW5kcG9pbnQoXCJzdGFya25ldF9jYWxsXCIsIHtcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgY29udHJhY3RfYWRkcmVzczogY2FsbC5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgIGVudHJ5X3BvaW50X3NlbGVjdG9yOiBnZXRTZWxlY3RvckZyb21OYW1lKGNhbGwuZW50cnlwb2ludCksXG4gICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS50b0hleChjYWxsLmNhbGxkYXRhKVxuICAgICAgfSxcbiAgICAgIGJsb2NrX2lkXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyID0gdGhpcy5ibG9ja0lkZW50aWZpZXIpIHtcbiAgICBjb25zdCB7IGZyb21fYWRkcmVzcywgdG9fYWRkcmVzcywgZW50cnlfcG9pbnRfc2VsZWN0b3IsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3QgZm9ybWF0dGVkTWVzc2FnZSA9IHtcbiAgICAgIGZyb21fYWRkcmVzczogdmFsaWRhdGVBbmRQYXJzZUV0aEFkZHJlc3MoZnJvbV9hZGRyZXNzKSxcbiAgICAgIHRvX2FkZHJlc3M6IHRvSGV4KHRvX2FkZHJlc3MpLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3I6IGdldFNlbGVjdG9yKGVudHJ5X3BvaW50X3NlbGVjdG9yKSxcbiAgICAgIHBheWxvYWQ6IGdldEhleFN0cmluZ0FycmF5KHBheWxvYWQpXG4gICAgfTtcbiAgICBjb25zdCBibG9ja19pZCA9IG5ldyBCbG9jayhibG9ja0lkZW50aWZpZXIpLmlkZW50aWZpZXI7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hFbmRwb2ludChcInN0YXJrbmV0X2VzdGltYXRlTWVzc2FnZUZlZVwiLCB7XG4gICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgYmxvY2tfaWRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfc3luY2luZ1wiKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGFuZCB0aGUgcGFnaW5hdGlvbiBvZiB0aGUgZXZlbnRzXG4gICAqL1xuICBnZXRFdmVudHMoZXZlbnRGaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaEVuZHBvaW50KFwic3RhcmtuZXRfZ2V0RXZlbnRzXCIsIHsgZmlsdGVyOiBldmVudEZpbHRlciB9KTtcbiAgfVxuICBidWlsZFRyYW5zYWN0aW9uKGludm9jYXRpb24sIHZlcnNpb25UeXBlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb25zID0gZ2V0VmVyc2lvbnNCeVR5cGUodmVyc2lvblR5cGUpO1xuICAgIGxldCBkZXRhaWxzO1xuICAgIGlmICghaXNWM1R4KGludm9jYXRpb24pKSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIG1heF9mZWU6IHRvSGV4KGludm9jYXRpb24ubWF4RmVlIHx8IDApXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVRvSGV4QXJyYXkoaW52b2NhdGlvbi5zaWduYXR1cmUpLFxuICAgICAgICBub25jZTogdG9IZXgoaW52b2NhdGlvbi5ub25jZSksXG4gICAgICAgIHJlc291cmNlX2JvdW5kczogaW52b2NhdGlvbi5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgdGlwOiB0b0hleChpbnZvY2F0aW9uLnRpcCksXG4gICAgICAgIHBheW1hc3Rlcl9kYXRhOiBpbnZvY2F0aW9uLnBheW1hc3RlckRhdGEubWFwKChpdCkgPT4gdG9IZXgoaXQpKSxcbiAgICAgICAgbm9uY2VfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlLFxuICAgICAgICBmZWVfZGF0YV9hdmFpbGFiaWxpdHlfbW9kZTogaW52b2NhdGlvbi5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSxcbiAgICAgICAgYWNjb3VudF9kZXBsb3ltZW50X2RhdGE6IGludm9jYXRpb24uYWNjb3VudERlcGxveW1lbnREYXRhLm1hcCgoaXQpID0+IHRvSGV4KGl0KSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnZvY2F0aW9uLnR5cGUgPT09IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB2MCB2MSB2M1xuICAgICAgICB0eXBlOiBSUENTUEVDMDcuRVRyYW5zYWN0aW9uVHlwZS5JTlZPS0UsXG4gICAgICAgIHNlbmRlcl9hZGRyZXNzOiBpbnZvY2F0aW9uLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY2FsbGRhdGEpLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgaWYgKCFpc1NpZXJyYShpbnZvY2F0aW9uLmNvbnRyYWN0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgICBjb250cmFjdF9jbGFzczogaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICAgIHZlcnNpb246IHRvSGV4KGludm9jYXRpb24udmVyc2lvbiB8fCBkZWZhdWx0VmVyc2lvbnMudjEpLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIENhaXJvIDEgLSB2MiB2M1xuICAgICAgICB0eXBlOiBpbnZvY2F0aW9uLnR5cGUsXG4gICAgICAgIGNvbnRyYWN0X2NsYXNzOiB7XG4gICAgICAgICAgLi4uaW52b2NhdGlvbi5jb250cmFjdCxcbiAgICAgICAgICBzaWVycmFfcHJvZ3JhbTogZGVjb21wcmVzc1Byb2dyYW0oaW52b2NhdGlvbi5jb250cmFjdC5zaWVycmFfcHJvZ3JhbSlcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogaW52b2NhdGlvbi5jb21waWxlZENsYXNzSGFzaCB8fCBcIlwiLFxuICAgICAgICBzZW5kZXJfYWRkcmVzczogaW52b2NhdGlvbi5zZW5kZXJBZGRyZXNzLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludm9jYXRpb24udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovKSB7XG4gICAgICBjb25zdCB7IGFjY291bnRfZGVwbG95bWVudF9kYXRhLCAuLi5yZXN0RGV0YWlscyB9ID0gZGV0YWlscztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGludm9jYXRpb24udHlwZSxcbiAgICAgICAgY29uc3RydWN0b3JfY2FsbGRhdGE6IENhbGxEYXRhLnRvSGV4KGludm9jYXRpb24uY29uc3RydWN0b3JDYWxsZGF0YSB8fCBbXSksXG4gICAgICAgIGNsYXNzX2hhc2g6IHRvSGV4KGludm9jYXRpb24uY2xhc3NIYXNoKSxcbiAgICAgICAgY29udHJhY3RfYWRkcmVzc19zYWx0OiB0b0hleChpbnZvY2F0aW9uLmFkZHJlc3NTYWx0IHx8IDApLFxuICAgICAgICB2ZXJzaW9uOiB0b0hleChpbnZvY2F0aW9uLnZlcnNpb24gfHwgZGVmYXVsdFZlcnNpb25zLnYzKSxcbiAgICAgICAgLi4ucmVzdERldGFpbHNcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiUlBDIGJ1aWxkVHJhbnNhY3Rpb24gcmVjZWl2ZWQgdW5rbm93biBUcmFuc2FjdGlvblR5cGVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9yZXNwb25zZVBhcnNlci9ycGMudHNcbnZhciBSUENSZXNwb25zZVBhcnNlciA9IGNsYXNzIHtcbiAgbWFyZ2luO1xuICBjb25zdHJ1Y3RvcihtYXJnaW4pIHtcbiAgICB0aGlzLm1hcmdpbiA9IG1hcmdpbjtcbiAgfVxuICBlc3RpbWF0ZWRGZWVUb01heEZlZShlc3RpbWF0ZWRGZWUpIHtcbiAgICByZXR1cm4gZXN0aW1hdGVkRmVlVG9NYXhGZWUoZXN0aW1hdGVkRmVlLCB0aGlzLm1hcmdpbj8ubWF4RmVlKTtcbiAgfVxuICBlc3RpbWF0ZUZlZVRvQm91bmRzKGVzdGltYXRlKSB7XG4gICAgcmV0dXJuIGVzdGltYXRlRmVlVG9Cb3VuZHMoXG4gICAgICBlc3RpbWF0ZSxcbiAgICAgIHRoaXMubWFyZ2luPy5sMUJvdW5kTWF4QW1vdW50LFxuICAgICAgdGhpcy5tYXJnaW4/LmwxQm91bmRNYXhQcmljZVBlclVuaXRcbiAgICApO1xuICB9XG4gIHBhcnNlR2V0QmxvY2tSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwiUEVORElOR1wiLCAuLi5yZXMgfTtcbiAgfVxuICBwYXJzZVRyYW5zYWN0aW9uUmVjZWlwdChyZXMpIHtcbiAgICBpZiAoXCJhY3R1YWxfZmVlXCIgaW4gcmVzICYmIGlzU3RyaW5nKHJlcy5hY3R1YWxfZmVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzLFxuICAgICAgICBhY3R1YWxfZmVlOiB7XG4gICAgICAgICAgYW1vdW50OiByZXMuYWN0dWFsX2ZlZSxcbiAgICAgICAgICB1bml0OiBcIkZSSVwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZVJlc3BvbnNlKHJlcykge1xuICAgIGNvbnN0IHZhbCA9IHJlc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHZhbC5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludCh2YWwuZ2FzX3ByaWNlKSxcbiAgICAgIHVuaXQ6IHZhbC51bml0LFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlOiB0aGlzLmVzdGltYXRlZEZlZVRvTWF4RmVlKHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICByZXNvdXJjZUJvdW5kczogdGhpcy5lc3RpbWF0ZUZlZVRvQm91bmRzKHZhbCksXG4gICAgICBkYXRhX2dhc19jb25zdW1lZDogdmFsLmRhdGFfZ2FzX2NvbnN1bWVkID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX2NvbnN1bWVkKSA6IDBuLFxuICAgICAgZGF0YV9nYXNfcHJpY2U6IHZhbC5kYXRhX2dhc19wcmljZSA/IHRvQmlnSW50KHZhbC5kYXRhX2dhc19wcmljZSkgOiAwblxuICAgIH07XG4gIH1cbiAgcGFyc2VGZWVFc3RpbWF0ZUJ1bGtSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLm1hcCgodmFsKSA9PiAoe1xuICAgICAgb3ZlcmFsbF9mZWU6IHRvQmlnSW50KHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICBnYXNfY29uc3VtZWQ6IHRvQmlnSW50KHZhbC5nYXNfY29uc3VtZWQpLFxuICAgICAgZ2FzX3ByaWNlOiB0b0JpZ0ludCh2YWwuZ2FzX3ByaWNlKSxcbiAgICAgIHVuaXQ6IHZhbC51bml0LFxuICAgICAgc3VnZ2VzdGVkTWF4RmVlOiB0aGlzLmVzdGltYXRlZEZlZVRvTWF4RmVlKHZhbC5vdmVyYWxsX2ZlZSksXG4gICAgICByZXNvdXJjZUJvdW5kczogdGhpcy5lc3RpbWF0ZUZlZVRvQm91bmRzKHZhbCksXG4gICAgICBkYXRhX2dhc19jb25zdW1lZDogdmFsLmRhdGFfZ2FzX2NvbnN1bWVkID8gdG9CaWdJbnQodmFsLmRhdGFfZ2FzX2NvbnN1bWVkKSA6IDBuLFxuICAgICAgZGF0YV9nYXNfcHJpY2U6IHZhbC5kYXRhX2dhc19wcmljZSA/IHRvQmlnSW50KHZhbC5kYXRhX2dhc19wcmljZSkgOiAwblxuICAgIH0pKTtcbiAgfVxuICBwYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLm1hcCgoaXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0LFxuICAgICAgICBzdWdnZXN0ZWRNYXhGZWU6IHRoaXMuZXN0aW1hdGVkRmVlVG9NYXhGZWUoaXQuZmVlX2VzdGltYXRpb24ub3ZlcmFsbF9mZWUpLFxuICAgICAgICByZXNvdXJjZUJvdW5kczogdGhpcy5lc3RpbWF0ZUZlZVRvQm91bmRzKGl0LmZlZV9lc3RpbWF0aW9uKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBwYXJzZUNvbnRyYWN0Q2xhc3NSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzLFxuICAgICAgYWJpOiBpc1N0cmluZyhyZXMuYWJpKSA/IEpTT04ucGFyc2UocmVzLmFiaSkgOiByZXMuYWJpXG4gICAgfTtcbiAgfVxuICBwYXJzZUwxR2FzUHJpY2VSZXNwb25zZShyZXMpIHtcbiAgICByZXR1cm4gcmVzLmwxX2dhc19wcmljZS5wcmljZV9pbl93ZWk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy90cmFuc2FjdGlvblJlY2VpcHQudHNcbnZhciBSZWNlaXB0VHggPSBjbGFzcyBfUmVjZWlwdFR4IHtcbiAgc3RhdHVzUmVjZWlwdDtcbiAgdmFsdWU7XG4gIGNvbnN0cnVjdG9yKHJlY2VpcHQpIHtcbiAgICBbdGhpcy5zdGF0dXNSZWNlaXB0LCB0aGlzLnZhbHVlXSA9IF9SZWNlaXB0VHguaXNTdWNjZXNzKHJlY2VpcHQpID8gW1wic3VjY2Vzc1wiLCByZWNlaXB0XSA6IF9SZWNlaXB0VHguaXNSZXZlcnRlZChyZWNlaXB0KSA/IFtcInJldmVydGVkXCIsIHJlY2VpcHRdIDogX1JlY2VpcHRUeC5pc1JlamVjdGVkKHJlY2VpcHQpID8gW1wicmVqZWN0ZWRcIiwgcmVjZWlwdF0gOiBbXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJVbmtub3duIHJlc3BvbnNlIHR5cGVcIildO1xuICAgIGZvciAoY29uc3QgW2tleV0gb2YgT2JqZWN0LmVudHJpZXModGhpcykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZWNlaXB0KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgbWF0Y2goY2FsbGJhY2tzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzUmVjZWlwdCBpbiBjYWxsYmFja3MpIHtcbiAgICAgIHJldHVybiBjYWxsYmFja3NbdGhpcy5zdGF0dXNSZWNlaXB0XSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrcy5fKCk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1c1JlY2VpcHQgPT09IFwic3VjY2Vzc1wiO1xuICB9XG4gIGlzUmV2ZXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJyZXZlcnRlZFwiO1xuICB9XG4gIGlzUmVqZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJyZWplY3RlZFwiO1xuICB9XG4gIGlzRXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzUmVjZWlwdCA9PT0gXCJlcnJvclwiO1xuICB9XG4gIHN0YXRpYyBpc1N1Y2Nlc3ModHJhbnNhY3Rpb25SZWNlaXB0KSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uUmVjZWlwdC5leGVjdXRpb25fc3RhdHVzID09PSBcIlNVQ0NFRURFRFwiIC8qIFNVQ0NFRURFRCAqLztcbiAgfVxuICBzdGF0aWMgaXNSZXZlcnRlZCh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LmV4ZWN1dGlvbl9zdGF0dXMgPT09IFwiUkVWRVJURURcIiAvKiBSRVZFUlRFRCAqLztcbiAgfVxuICBzdGF0aWMgaXNSZWplY3RlZCh0cmFuc2FjdGlvblJlY2VpcHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0LnN0YXR1cyA9PT0gXCJSRUpFQ1RFRFwiIC8qIFJFSkVDVEVEICovO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvcnBjLnRzXG52YXIgUnBjUHJvdmlkZXIgPSBjbGFzcyB7XG4gIHJlc3BvbnNlUGFyc2VyO1xuICBjaGFubmVsO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zT3JQcm92aWRlcikge1xuICAgIGlmIChvcHRpb25zT3JQcm92aWRlciAmJiBcImNoYW5uZWxcIiBpbiBvcHRpb25zT3JQcm92aWRlcikge1xuICAgICAgdGhpcy5jaGFubmVsID0gb3B0aW9uc09yUHJvdmlkZXIuY2hhbm5lbDtcbiAgICAgIHRoaXMucmVzcG9uc2VQYXJzZXIgPSBcInJlc3BvbnNlUGFyc2VyXCIgaW4gb3B0aW9uc09yUHJvdmlkZXIgPyBvcHRpb25zT3JQcm92aWRlci5yZXNwb25zZVBhcnNlciA6IG5ldyBSUENSZXNwb25zZVBhcnNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBuZXcgUnBjQ2hhbm5lbDIoeyAuLi5vcHRpb25zT3JQcm92aWRlciwgd2FpdE1vZGU6IGZhbHNlIH0pO1xuICAgICAgdGhpcy5yZXNwb25zZVBhcnNlciA9IG5ldyBSUENSZXNwb25zZVBhcnNlcihvcHRpb25zT3JQcm92aWRlcj8uZmVlTWFyZ2luUGVyY2VudGFnZSk7XG4gICAgfVxuICB9XG4gIGZldGNoKG1ldGhvZCwgcGFyYW1zLCBpZCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmZldGNoKG1ldGhvZCwgcGFyYW1zLCBpZCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q2hhaW5JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENoYWluSWQoKTtcbiAgfVxuICBhc3luYyBnZXRTcGVjVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFNwZWNWZXJzaW9uKCk7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VGb3JBZGRyZXNzKGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXROb25jZUZvckFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VHZXRCbG9ja1Jlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCBhY2NlcHRlZCBibG9jayBoYXNoIGFuZCBudW1iZXJcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrTGF0ZXN0QWNjZXB0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja0xhdGVzdEFjY2VwdGVkKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9zdCByZWNlbnQgYWNjZXB0ZWQgYmxvY2sgbnVtYmVyXG4gICAqIHJlZHVuZGFudCB1c2UgZ2V0QmxvY2tMYXRlc3RBY2NlcHRlZCgpO1xuICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgdGhlIGxhdGVzdCBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja051bWJlcigpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrV2l0aFR4SGFzaGVzKGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0QmxvY2tXaXRoVHhIYXNoZXMoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhUeHMoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1dpdGhUeHMoYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICAvKipcbiAgICogUGF1c2UgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgc2NyaXB0IHVudGlsIGEgc3BlY2lmaWVkIGJsb2NrIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7QmxvY2tJZGVudGlmaWVyfSBibG9ja0lkZW50aWZpZXIgYmxvYyBudW1iZXIgKEJpZ051bWJlcmlzaCkgb3IgJ3BlbmRpbmcnIG9yICdsYXRlc3QnLlxuICAgKiBVc2Ugb2YgJ2xhdGVzdFwiIG9yIG9mIGEgYmxvY2sgYWxyZWFkeSBjcmVhdGVkIHdpbGwgZ2VuZXJhdGUgbm8gcGF1c2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcmV0cnlJbnRlcnZhbF0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIDIgcmVxdWVzdHMgdG8gdGhlIG5vZGVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBhd2FpdCBteVByb3ZpZGVyLndhaXRGb3JCbG9jaygpO1xuICAgKiAvLyB3YWl0IHRoZSBjcmVhdGlvbiBvZiB0aGUgcGVuZGluZyBibG9ja1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHdhaXRGb3JCbG9jayhibG9ja0lkZW50aWZpZXIgPSBcInBlbmRpbmdcIiwgcmV0cnlJbnRlcnZhbCA9IDVlMykge1xuICAgIGlmIChibG9ja0lkZW50aWZpZXIgPT09IFwibGF0ZXN0XCIgLyogTEFURVNUICovKSByZXR1cm47XG4gICAgY29uc3QgY3VycmVudEJsb2NrID0gYXdhaXQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xuICAgIGNvbnN0IHRhcmdldEJsb2NrID0gYmxvY2tJZGVudGlmaWVyID09PSBcInBlbmRpbmdcIiAvKiBQRU5ESU5HICovID8gY3VycmVudEJsb2NrICsgMSA6IE51bWJlcih0b0hleChibG9ja0lkZW50aWZpZXIpKTtcbiAgICBpZiAodGFyZ2V0QmxvY2sgPD0gY3VycmVudEJsb2NrKSByZXR1cm47XG4gICAgY29uc3QgeyByZXRyaWVzIH0gPSB0aGlzLmNoYW5uZWw7XG4gICAgbGV0IHJldHJpZXNDb3VudCA9IHJldHJpZXM7XG4gICAgbGV0IGlzVGFyZ2V0QmxvY2sgPSBmYWxzZTtcbiAgICB3aGlsZSAoIWlzVGFyZ2V0QmxvY2spIHtcbiAgICAgIGNvbnN0IGN1cnJCbG9jayA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgIGlmIChjdXJyQmxvY2sgPT09IHRhcmdldEJsb2NrKSB7XG4gICAgICAgIGlzVGFyZ2V0QmxvY2sgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgd2FpdChyZXRyeUludGVydmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHJpZXNDb3VudCAtPSAxO1xuICAgICAgaWYgKHJldHJpZXNDb3VudCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgd2FpdEZvckJsb2NrKCkgdGltZWQtb3V0IGFmdGVyICR7cmV0cmllc30gdHJpZXMuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldEwxR2FzUHJpY2UoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1dpdGhUeEhhc2hlcyhibG9ja0lkZW50aWZpZXIpLnRoZW4odGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUwxR2FzUHJpY2VSZXNwb25zZSk7XG4gIH1cbiAgYXN5bmMgZ2V0TDFNZXNzYWdlSGFzaChsMlR4SGFzaCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uQnlIYXNoKGwyVHhIYXNoKTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJMMV9IQU5ETEVSXCIsIFwiVGhpcyBMMiB0cmFuc2FjdGlvbiBpcyBub3QgYSBMMSBtZXNzYWdlLlwiKTtcbiAgICBjb25zdCB7IGNhbGxkYXRhLCBjb250cmFjdF9hZGRyZXNzLCBlbnRyeV9wb2ludF9zZWxlY3Rvciwgbm9uY2UgfSA9IHRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IHBhcmFtcyA9IFtcbiAgICAgIGNhbGxkYXRhWzBdLFxuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIG5vbmNlLFxuICAgICAgZW50cnlfcG9pbnRfc2VsZWN0b3IsXG4gICAgICBjYWxsZGF0YS5sZW5ndGggLSAxLFxuICAgICAgLi4uY2FsbGRhdGEuc2xpY2UoMSlcbiAgICBdO1xuICAgIHJldHVybiBzb2xpZGl0eVVpbnQyNTZQYWNrZWRLZWNjYWsyNTYocGFyYW1zKTtcbiAgfVxuICBhc3luYyBnZXRCbG9ja1dpdGhSZWNlaXB0cyhibG9ja0lkZW50aWZpZXIpIHtcbiAgICBpZiAodGhpcy5jaGFubmVsIGluc3RhbmNlb2YgcnBjXzBfNl9leHBvcnRzLlJwY0NoYW5uZWwpXG4gICAgICB0aHJvdyBuZXcgTGlicmFyeUVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0aG9kIGZvciBSUEMgdmVyc2lvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrV2l0aFJlY2VpcHRzKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgZ2V0U3RhdGVVcGRhdGUgPSB0aGlzLmdldEJsb2NrU3RhdGVVcGRhdGU7XG4gIGFzeW5jIGdldEJsb2NrU3RhdGVVcGRhdGUoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1N0YXRlVXBkYXRlKGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0QmxvY2tUcmFuc2FjdGlvbnNUcmFjZXMoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRCbG9ja1RyYW5zYWN0aW9uc1RyYWNlcyhibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIGFzeW5jIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChibG9ja0lkZW50aWZpZXIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJhbnNhY3Rpb25zIGZyb20gcGVuZGluZyBibG9ja1xuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkIHVzZSBnZXRCbG9jayhCbG9ja1RhZy5QRU5ESU5HKTsgKHdpbGwgYmUgcmVtb3ZlZCBpbiBuZXh0IG1pbm9yIHZlcnNpb24pXG4gICAqIFV0aWxpdHkgbWV0aG9kLCBzYW1lIHJlc3VsdCBjYW4gYmUgYWNoaWV2ZWQgdXNpbmcgZ2V0QmxvY2tXaXRoVHhIYXNoZXMoQmxvY2tUYWcucGVuZGluZyk7XG4gICAqL1xuICBhc3luYyBnZXRQZW5kaW5nVHJhbnNhY3Rpb25zKCkge1xuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBhd2FpdCB0aGlzLmdldEJsb2NrV2l0aFR4SGFzaGVzKFwicGVuZGluZ1wiIC8qIFBFTkRJTkcgKi8pLnRoZW4oXG4gICAgICB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlR2V0QmxvY2tSZXNwb25zZVxuICAgICk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucy5tYXAoKGl0KSA9PiB0aGlzLmdldFRyYW5zYWN0aW9uQnlIYXNoKGl0KSkpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0VHJhbnNhY3Rpb25CeUhhc2godHhIYXNoKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkJ5SGFzaCh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uQnlIYXNoKHR4SGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSWRBbmRJbmRleChibG9ja0lkZW50aWZpZXIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvbkJ5QmxvY2tJZEFuZEluZGV4KGJsb2NrSWRlbnRpZmllciwgaW5kZXgpO1xuICB9XG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICBjb25zdCB0eFJlY2VpcHRXb0hlbHBlciA9IGF3YWl0IHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICBjb25zdCB0eFJlY2VpcHRXb0hlbHBlck1vZGlmaWVkID0gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVRyYW5zYWN0aW9uUmVjZWlwdCh0eFJlY2VpcHRXb0hlbHBlcik7XG4gICAgcmV0dXJuIG5ldyBSZWNlaXB0VHgodHhSZWNlaXB0V29IZWxwZXJNb2RpZmllZCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25UcmFjZSh0eEhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFRyYW5zYWN0aW9uVHJhY2UodHhIYXNoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25TdGF0dXModHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRUcmFuc2FjdGlvblN0YXR1cyh0cmFuc2FjdGlvbkhhc2gpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gaW52b2NhdGlvbnMgQWNjb3VudEludm9jYXRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zIGJsb2NrSWRlbnRpZmllciBhbmQgZmxhZ3MgdG8gc2tpcCB2YWxpZGF0aW9uIGFuZCBmZWUgY2hhcmdlPGJyLz5cbiAgICogLSBibG9ja0lkZW50aWZpZXI8YnIvPlxuICAgKiAtIHNraXBWYWxpZGF0ZSAoZGVmYXVsdCBmYWxzZSk8YnIvPlxuICAgKiAtIHNraXBGZWVDaGFyZ2UgKGRlZmF1bHQgdHJ1ZSk8YnIvPlxuICAgKi9cbiAgYXN5bmMgZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuc2ltdWxhdGVUcmFuc2FjdGlvbihpbnZvY2F0aW9ucywgb3B0aW9ucykudGhlbigocikgPT4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZVNpbXVsYXRlVHJhbnNhY3Rpb25SZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uKHR4SGFzaCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpcHRXb0hlbHBlciA9IGF3YWl0IHRoaXMuY2hhbm5lbC53YWl0Rm9yVHJhbnNhY3Rpb24oXG4gICAgICB0eEhhc2gsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IFJlY2VpcHRUeChyZWNlaXB0V29IZWxwZXIpO1xuICB9XG4gIGFzeW5jIGdldFN0b3JhZ2VBdChjb250cmFjdEFkZHJlc3MsIGtleSwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRTdG9yYWdlQXQoY29udHJhY3RBZGRyZXNzLCBrZXksIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Q2xhc3NIYXNoQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldENsYXNzSGFzaEF0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0J5SGFzaChjbGFzc0hhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDbGFzcyhjbGFzc0hhc2gpO1xuICB9XG4gIGFzeW5jIGdldENsYXNzKGNsYXNzSGFzaCwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllcikudGhlbih0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlQ29udHJhY3RDbGFzc1Jlc3BvbnNlKTtcbiAgfVxuICBhc3luYyBnZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRDbGFzc0F0KGNvbnRyYWN0QWRkcmVzcywgYmxvY2tJZGVudGlmaWVyKS50aGVuKHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VDb250cmFjdENsYXNzUmVzcG9uc2UpO1xuICB9XG4gIGFzeW5jIGdldENvbnRyYWN0VmVyc2lvbihjb250cmFjdEFkZHJlc3MsIGNsYXNzSGFzaCwge1xuICAgIGJsb2NrSWRlbnRpZmllciA9IHRoaXMuY2hhbm5lbC5ibG9ja0lkZW50aWZpZXIsXG4gICAgY29tcGlsZXIgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIGxldCBjb250cmFjdENsYXNzO1xuICAgIGlmIChjb250cmFjdEFkZHJlc3MpIHtcbiAgICAgIGNvbnRyYWN0Q2xhc3MgPSBhd2FpdCB0aGlzLmdldENsYXNzQXQoY29udHJhY3RBZGRyZXNzLCBibG9ja0lkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NIYXNoKSB7XG4gICAgICBjb250cmFjdENsYXNzID0gYXdhaXQgdGhpcy5nZXRDbGFzcyhjbGFzc0hhc2gsIGJsb2NrSWRlbnRpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiZ2V0Q29udHJhY3RWZXJzaW9uIHJlcXVpcmUgY29udHJhY3RBZGRyZXNzIG9yIGNsYXNzSGFzaFwiKTtcbiAgICB9XG4gICAgaWYgKGlzU2llcnJhKGNvbnRyYWN0Q2xhc3MpKSB7XG4gICAgICBpZiAoY29tcGlsZXIpIHtcbiAgICAgICAgY29uc3QgYWJpVGVzdCA9IGdldEFiaUNvbnRyYWN0VmVyc2lvbihjb250cmFjdENsYXNzLmFiaSk7XG4gICAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IGFiaVRlc3QuY29tcGlsZXIgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGNhaXJvOiBcIjFcIiwgY29tcGlsZXI6IHZvaWQgMCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjYWlybzogXCIwXCIsIGNvbXBpbGVyOiBcIjBcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZ2V0KnR5cGUqRXN0aW1hdGVGZWUgKHdpbGwgYmUgcmVmYWN0b3JlZCBiYXNlZCBvbiB0eXBlIGFmdGVyIHNlcXVlbmNlciBkZXByZWNhdGlvbilcbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmdldEludm9rZUVzdGltYXRlRmVlKGludm9jYXRpb24sIGludm9jYXRpb25EZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSk7XG4gIH1cbiAgYXN5bmMgZ2V0SW52b2tlRXN0aW1hdGVGZWUoaW52b2NhdGlvbiwgaW52b2NhdGlvbkRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLFxuICAgICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgICAgLi4uaW52b2NhdGlvbkRldGFpbHNcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfVxuICAgICkudGhlbigocikgPT4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocikpO1xuICB9XG4gIGFzeW5jIGdldERlY2xhcmVFc3RpbWF0ZUZlZShpbnZvY2F0aW9uLCBkZXRhaWxzLCBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0RXN0aW1hdGVGZWUoXG4gICAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIkRFQ0xBUkVcIiAvKiBERUNMQVJFICovLFxuICAgICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgICAgLi4uZGV0YWlsc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgeyBibG9ja0lkZW50aWZpZXIsIHNraXBWYWxpZGF0ZSB9XG4gICAgKS50aGVuKChyKSA9PiB0aGlzLnJlc3BvbnNlUGFyc2VyLnBhcnNlRmVlRXN0aW1hdGVSZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgZ2V0RGVwbG95QWNjb3VudEVzdGltYXRlRmVlKGludm9jYXRpb24sIGRldGFpbHMsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5nZXRFc3RpbWF0ZUZlZShcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLyxcbiAgICAgICAgICAuLi5pbnZvY2F0aW9uLFxuICAgICAgICAgIC4uLmRldGFpbHNcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHsgYmxvY2tJZGVudGlmaWVyLCBza2lwVmFsaWRhdGUgfVxuICAgICkudGhlbigocikgPT4gdGhpcy5yZXNwb25zZVBhcnNlci5wYXJzZUZlZUVzdGltYXRlUmVzcG9uc2UocikpO1xuICB9XG4gIGFzeW5jIGdldEVzdGltYXRlRmVlQnVsayhpbnZvY2F0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0RXN0aW1hdGVGZWUoaW52b2NhdGlvbnMsIG9wdGlvbnMpLnRoZW4oKHIpID0+IHRoaXMucmVzcG9uc2VQYXJzZXIucGFyc2VGZWVFc3RpbWF0ZUJ1bGtSZXNwb25zZShyKSk7XG4gIH1cbiAgYXN5bmMgaW52b2tlRnVuY3Rpb24oZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5pbnZva2UoZnVuY3Rpb25JbnZvY2F0aW9uLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBkZWNsYXJlQ29udHJhY3QodHJhbnNhY3Rpb24sIGRldGFpbHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmRlY2xhcmUodHJhbnNhY3Rpb24sIGRldGFpbHMpO1xuICB9XG4gIGFzeW5jIGRlcGxveUFjY291bnRDb250cmFjdCh0cmFuc2FjdGlvbiwgZGV0YWlscykge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZGVwbG95QWNjb3VudChcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgZGV0YWlsc1xuICAgICk7XG4gIH1cbiAgYXN5bmMgY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuY2FsbENvbnRyYWN0KGNhbGwsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgLyoqXG4gICAqIE5FVzogRXN0aW1hdGUgdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gTDFcbiAgICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSBGcm9tIEwxXG4gICAqL1xuICBhc3luYyBlc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5lc3RpbWF0ZU1lc3NhZ2VGZWUobWVzc2FnZSwgYmxvY2tJZGVudGlmaWVyKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYWJvdXQgdGhlIHN5bmMgc3RhdHVzLCBvciBmYWxzZSBpZiB0aGUgbm9kZSBpcyBub3Qgc3luY2hpbmdcbiAgICogQHJldHVybnMgT2JqZWN0IHdpdGggdGhlIHN0YXRzIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldFN5bmNpbmdTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFubmVsLmdldFN5bmNpbmdTdGF0cygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgYW5kIHRoZSBwYWdpbmF0aW9uIG9mIHRoZSBldmVudHNcbiAgICovXG4gIGFzeW5jIGdldEV2ZW50cyhldmVudEZpbHRlcikge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWwuZ2V0RXZlbnRzKGV2ZW50RmlsdGVyKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2V4dGVuc2lvbnMvZGVmYXVsdC50c1xuaW1wb3J0IHsgTWl4aW4gfSBmcm9tIFwidHMtbWl4ZXJcIjtcblxuLy8gc3JjL3V0aWxzL3N0YXJrbmV0SWQudHNcbnZhciBzdGFya25ldElkX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHN0YXJrbmV0SWRfZXhwb3J0cywge1xuICBTdGFya25ldElkQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRDb250cmFjdCxcbiAgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0LFxuICBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3Q6ICgpID0+IFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdCxcbiAgU3RhcmtuZXRJZFBmcENvbnRyYWN0OiAoKSA9PiBTdGFya25ldElkUGZwQ29udHJhY3QsXG4gIFN0YXJrbmV0SWRQb3BDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZFBvcENvbnRyYWN0LFxuICBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDogKCkgPT4gU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QsXG4gIGR5bmFtaWNDYWxsRGF0YTogKCkgPT4gZHluYW1pY0NhbGxEYXRhLFxuICBkeW5hbWljRmVsdDogKCkgPT4gZHluYW1pY0ZlbHQsXG4gIGV4ZWN1dGlvbjogKCkgPT4gZXhlY3V0aW9uLFxuICBnZXRTdGFya25ldElkQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0LFxuICBnZXRTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3Q6ICgpID0+IGdldFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdCxcbiAgZ2V0U3RhcmtuZXRJZFBmcENvbnRyYWN0OiAoKSA9PiBnZXRTdGFya25ldElkUGZwQ29udHJhY3QsXG4gIGdldFN0YXJrbmV0SWRQb3BDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZFBvcENvbnRyYWN0LFxuICBnZXRTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDogKCkgPT4gZ2V0U3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QsXG4gIHVzZURlY29kZWQ6ICgpID0+IHVzZURlY29kZWQsXG4gIHVzZUVuY29kZWQ6ICgpID0+IHVzZUVuY29kZWRcbn0pO1xudmFyIGJhc2ljQWxwaGFiZXQgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1cIjtcbnZhciBiYXNpY1NpemVQbHVzT25lID0gQmlnSW50KGJhc2ljQWxwaGFiZXQubGVuZ3RoICsgMSk7XG52YXIgYmlnQWxwaGFiZXQgPSBcIlxcdThGRDlcXHU2NzY1XCI7XG52YXIgYmFzaWNBbHBoYWJldFNpemUgPSBCaWdJbnQoYmFzaWNBbHBoYWJldC5sZW5ndGgpO1xudmFyIGJpZ0FscGhhYmV0U2l6ZSA9IEJpZ0ludChiaWdBbHBoYWJldC5sZW5ndGgpO1xudmFyIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmUgPSBCaWdJbnQoYmlnQWxwaGFiZXQubGVuZ3RoICsgMSk7XG5mdW5jdGlvbiBleHRyYWN0U3RhcnMoc3RyKSB7XG4gIGxldCBrID0gMDtcbiAgd2hpbGUgKHN0ci5lbmRzV2l0aChiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXSkpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICBrICs9IDE7XG4gIH1cbiAgcmV0dXJuIFtzdHIsIGtdO1xufVxuZnVuY3Rpb24gdXNlRGVjb2RlZChlbmNvZGVkKSB7XG4gIGxldCBkZWNvZGVkID0gXCJcIjtcbiAgZW5jb2RlZC5mb3JFYWNoKChzdWJkb21haW4pID0+IHtcbiAgICB3aGlsZSAoc3ViZG9tYWluICE9PSBaRVJPKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3ViZG9tYWluICUgYmFzaWNTaXplUGx1c09uZTtcbiAgICAgIHN1YmRvbWFpbiAvPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgaWYgKGNvZGUgPT09IEJpZ0ludChiYXNpY0FscGhhYmV0Lmxlbmd0aCkpIHtcbiAgICAgICAgY29uc3QgbmV4dFN1YmRvbWFpbiA9IHN1YmRvbWFpbiAvIGJpZ0FscGhhYmV0U2l6ZVBsdXNPbmU7XG4gICAgICAgIGlmIChuZXh0U3ViZG9tYWluID09PSBaRVJPKSB7XG4gICAgICAgICAgY29uc3QgY29kZTIgPSBzdWJkb21haW4gJSBiaWdBbHBoYWJldFNpemVQbHVzT25lO1xuICAgICAgICAgIHN1YmRvbWFpbiA9IG5leHRTdWJkb21haW47XG4gICAgICAgICAgaWYgKGNvZGUyID09PSBaRVJPKSBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbMF07XG4gICAgICAgICAgZWxzZSBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMikgLSAxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb2RlMiA9IHN1YmRvbWFpbiAlIGJpZ0FscGhhYmV0U2l6ZTtcbiAgICAgICAgICBkZWNvZGVkICs9IGJpZ0FscGhhYmV0W051bWJlcihjb2RlMildO1xuICAgICAgICAgIHN1YmRvbWFpbiAvPSBiaWdBbHBoYWJldFNpemU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBkZWNvZGVkICs9IGJhc2ljQWxwaGFiZXRbTnVtYmVyKGNvZGUpXTtcbiAgICB9XG4gICAgY29uc3QgW3N0ciwga10gPSBleHRyYWN0U3RhcnMoZGVjb2RlZCk7XG4gICAgaWYgKGspXG4gICAgICBkZWNvZGVkID0gc3RyICsgKGsgJSAyID09PSAwID8gYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KGsgLyAyIC0gMSkgKyBiaWdBbHBoYWJldFswXSArIGJhc2ljQWxwaGFiZXRbMV0gOiBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoKGsgLSAxKSAvIDIgKyAxKSk7XG4gICAgZGVjb2RlZCArPSBcIi5cIjtcbiAgfSk7XG4gIGlmICghZGVjb2RlZCkge1xuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG4gIHJldHVybiBkZWNvZGVkLmNvbmNhdChcInN0YXJrXCIpO1xufVxuZnVuY3Rpb24gdXNlRW5jb2RlZChkZWNvZGVkKSB7XG4gIGxldCBlbmNvZGVkID0gQmlnSW50KDApO1xuICBsZXQgbXVsdGlwbGllciA9IEJpZ0ludCgxKTtcbiAgaWYgKGRlY29kZWQuZW5kc1dpdGgoYmlnQWxwaGFiZXRbMF0gKyBiYXNpY0FscGhhYmV0WzFdKSkge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQuc3Vic3RyaW5nKDAsIGRlY29kZWQubGVuZ3RoIC0gMikpO1xuICAgIGRlY29kZWQgPSBzdHIgKyBiaWdBbHBoYWJldFtiaWdBbHBoYWJldC5sZW5ndGggLSAxXS5yZXBlYXQoMiAqIChrICsgMSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFtzdHIsIGtdID0gZXh0cmFjdFN0YXJzKGRlY29kZWQpO1xuICAgIGlmIChrKSBkZWNvZGVkID0gc3RyICsgYmlnQWxwaGFiZXRbYmlnQWxwaGFiZXQubGVuZ3RoIC0gMV0ucmVwZWF0KDEgKyAyICogKGsgLSAxKSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IGRlY29kZWRbaV07XG4gICAgY29uc3QgaW5kZXggPSBiYXNpY0FscGhhYmV0LmluZGV4T2YoY2hhcik7XG4gICAgY29uc3QgYm5JbmRleCA9IEJpZ0ludChiYXNpY0FscGhhYmV0LmluZGV4T2YoY2hhcikpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChpID09PSBkZWNvZGVkLmxlbmd0aCAtIDEgJiYgZGVjb2RlZFtpXSA9PT0gYmFzaWNBbHBoYWJldFswXSkge1xuICAgICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBiYXNpY0FscGhhYmV0U2l6ZTtcbiAgICAgICAgbXVsdGlwbGllciAqPSBiYXNpY1NpemVQbHVzT25lO1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNvZGVkICs9IG11bHRpcGxpZXIgKiBibkluZGV4O1xuICAgICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaWdBbHBoYWJldC5pbmRleE9mKGNoYXIpICE9PSAtMSkge1xuICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogYmFzaWNBbHBoYWJldFNpemU7XG4gICAgICBtdWx0aXBsaWVyICo9IGJhc2ljU2l6ZVBsdXNPbmU7XG4gICAgICBjb25zdCBuZXdpZCA9IChpID09PSBkZWNvZGVkLmxlbmd0aCAtIDEgPyAxIDogMCkgKyBiaWdBbHBoYWJldC5pbmRleE9mKGNoYXIpO1xuICAgICAgZW5jb2RlZCArPSBtdWx0aXBsaWVyICogQmlnSW50KG5ld2lkKTtcbiAgICAgIG11bHRpcGxpZXIgKj0gYmlnQWxwaGFiZXRTaXplO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5jb2RlZDtcbn1cbnZhciBTdGFya25ldElkQ29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRDb250cmFjdDJbXCJNQUlOTkVUXCJdID0gXCIweDZhYzU5N2Y4MTE2Zjg4NmZhMWM5N2EyM2ZhNGUwODI5OTk3NWVjYWY2YjU5ODg3M2NhNjc5MmI5YmJmYjY3OFwiO1xuICBTdGFya25ldElkQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDE1NGJjMmUxYWY5MjYwYjllNjZhZjBlOWM0NmZjNzU3ZmY4OTNiM2ZmNmE4NTcxOGE4MTBiYWYxNDc0XCI7XG4gIHJldHVybiBTdGFya25ldElkQ29udHJhY3QyO1xufSkoU3RhcmtuZXRJZENvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4NmFjNTk3ZjgxMTZmODg2ZmExYzk3YTIzZmE0ZTA4Mjk5OTc1ZWNhZjZiNTk4ODczY2E2NzkyYjliYmZiNjc4XCIgLyogTUFJTk5FVCAqLztcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gXCIweDE1NGJjMmUxYWY5MjYwYjllNjZhZjBlOWM0NmZjNzU3ZmY4OTNiM2ZmNmE4NTcxOGE4MTBiYWYxNDc0XCIgLyogVEVTVE5FVF9TRVBPTElBICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCBpcyBub3QgeWV0IGRlcGxveWVkIG9uIHRoaXMgbmV0d29ya1wiKTtcbiAgfVxufVxudmFyIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0ID0gLyogQF9fUFVSRV9fICovICgoU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MltcIk1BSU5ORVRcIl0gPSBcIjB4MDVkYmRlZGMyMDNlOTI3NDllMmU3NDZlMmQ0MGE3NjhkOTY2YmQyNDNkZjA0YTZiNzEyZTIyMmJjMDQwYTlhZlwiO1xuICBTdGFya25ldElkSWRlbnRpdHlDb250cmFjdDJbXCJURVNUTkVUX1NFUE9MSUFcIl0gPSBcIjB4MzY5NzY2MGEwOTgxZDczNDc4MDczMTk0OWVjYjJiNGEzOGQ2YTU4ZmM0MTYyOWVkNjExZThkZWZkYVwiO1xuICByZXR1cm4gU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyO1xufSkoU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QgfHwge30pO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICByZXR1cm4gXCIweDA1ZGJkZWRjMjAzZTkyNzQ5ZTJlNzQ2ZTJkNDBhNzY4ZDk2NmJkMjQzZGYwNGE2YjcxMmUyMjJiYzA0MGE5YWZcIiAvKiBNQUlOTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBcIjB4MzY5NzY2MGEwOTgxZDczNDc4MDczMTk0OWVjYjJiNGEzOGQ2YTU4ZmM0MTYyOWVkNjExZThkZWZkYVwiIC8qIFRFU1RORVRfU0VQT0xJQSAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcmtuZXQuaWQgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIik7XG4gIH1cbn1cbnZhciBTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QgPSBcIjB4MDM0ZmZiOGY0NDUyZGY3YTYxM2EwMjEwODI0ZDY0MTRkYmFkY2RkY2U2YzZlMTliZjRkZGM5ZTIyY2U1Zjk3MFwiO1xuZnVuY3Rpb24gZ2V0U3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0KGNoYWluSWQpIHtcbiAgc3dpdGNoIChjaGFpbklkKSB7XG4gICAgY2FzZSBcIjB4NTM0ZTVmNGQ0MTQ5NGVcIiAvKiBTTl9NQUlOICovOlxuICAgICAgcmV0dXJuIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDtcbiAgICBjYXNlIFwiMHg1MzRlNWY1MzQ1NTA0ZjRjNDk0MVwiIC8qIFNOX1NFUE9MSUEgKi86XG4gICAgICByZXR1cm4gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFya25ldC5pZCBtdWx0aWNhbGwgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIik7XG4gIH1cbn1cbnZhciBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MikgPT4ge1xuICBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDJbXCJNQUlOTkVUXCJdID0gXCIweDA3ZDE0ZGZkOGVlOTViNDFmY2UxNzkxNzBkODhiYTFmMGQ1YTUxMmUxM2FlYjIzMmYxOWNmZWVjMGE4OGY4YmZcIjtcbiAgU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyW1wiVEVTVE5FVF9TRVBPTElBXCJdID0gXCIweDYwQjk0ZkVEZTUyNWY4MTVBRTVFODM3N0E0NjNlMTIxQzc4N2NDQ2YzYTM2MzU4QWE5QjE4YzEyYzRENTY2XCI7XG4gIHJldHVybiBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDI7XG59KShTdGFya25ldElkVmVyaWZpZXJDb250cmFjdCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkVmVyaWZpZXJDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDdkMTRkZmQ4ZWU5NWI0MWZjZTE3OTE3MGQ4OGJhMWYwZDVhNTEyZTEzYWViMjMyZjE5Y2ZlZWMwYTg4ZjhiZlwiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFwiMHg2MEI5NGZFRGU1MjVmODE1QUU1RTgzNzdBNDYzZTEyMUM3ODdjQ0NmM2EzNjM1OEFhOUIxOGMxMmM0RDU2NlwiIC8qIFRFU1RORVRfU0VQT0xJQSAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhcmtuZXQuaWQgdmVyaWZpZXIgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZCBvbiB0aGlzIG5ldHdvcmtcIik7XG4gIH1cbn1cbnZhciBTdGFya25ldElkUGZwQ29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkUGZwQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRQZnBDb250cmFjdDJbXCJNQUlOTkVUXCJdID0gXCIweDA3MGFhYTIwZWM0YTQ2ZGE1N2M5MzJkOWZkODljYTVlNmJiOWNhMzE4OGQzZGYzNjFhMzIzMDZhZmY3ZDU5YzdcIjtcbiAgU3RhcmtuZXRJZFBmcENvbnRyYWN0MltcIlRFU1RORVRfU0VQT0xJQVwiXSA9IFwiMHg5ZTdiZGI4ZGFiZDAyZWE4Y2ZjMjNiMWQxYzUyNzhlNDY0OTBmMTkzZjg3NTE2ZWQ1ZmYyZGZlYzAyXCI7XG4gIHJldHVybiBTdGFya25ldElkUGZwQ29udHJhY3QyO1xufSkoU3RhcmtuZXRJZFBmcENvbnRyYWN0IHx8IHt9KTtcbmZ1bmN0aW9uIGdldFN0YXJrbmV0SWRQZnBDb250cmFjdChjaGFpbklkKSB7XG4gIHN3aXRjaCAoY2hhaW5JZCkge1xuICAgIGNhc2UgXCIweDUzNGU1ZjRkNDE0OTRlXCIgLyogU05fTUFJTiAqLzpcbiAgICAgIHJldHVybiBcIjB4MDcwYWFhMjBlYzRhNDZkYTU3YzkzMmQ5ZmQ4OWNhNWU2YmI5Y2EzMTg4ZDNkZjM2MWEzMjMwNmFmZjdkNTljN1wiIC8qIE1BSU5ORVQgKi87XG4gICAgY2FzZSBcIjB4NTM0ZTVmNTM0NTUwNGY0YzQ5NDFcIiAvKiBTTl9TRVBPTElBICovOlxuICAgICAgcmV0dXJuIFwiMHg5ZTdiZGI4ZGFiZDAyZWE4Y2ZjMjNiMWQxYzUyNzhlNDY0OTBmMTkzZjg3NTE2ZWQ1ZmYyZGZlYzAyXCIgLyogVEVTVE5FVF9TRVBPTElBICovO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiU3RhcmtuZXQuaWQgcHJvZmlsZSBwaWN0dXJlIHZlcmlmaWVyIGNvbnRyYWN0IGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCJcbiAgICAgICk7XG4gIH1cbn1cbnZhciBTdGFya25ldElkUG9wQ29udHJhY3QgPSAvKiBAX19QVVJFX18gKi8gKChTdGFya25ldElkUG9wQ29udHJhY3QyKSA9PiB7XG4gIFN0YXJrbmV0SWRQb3BDb250cmFjdDJbXCJNQUlOTkVUXCJdID0gXCIweDAyOTNlYjJiYTk4NjJmNzYyYmQzMDM2NTg2ZDU3NTVhNzgyYmQyMmU2ZjUwMjgzMjBmMWQwNDA1ZmQ0N2JmZjRcIjtcbiAgU3RhcmtuZXRJZFBvcENvbnRyYWN0MltcIlRFU1RORVRfU0VQT0xJQVwiXSA9IFwiMHgxNWFlODhhZTA1NGNhYTc0MDkwYjg5MDI1YzE1OTU2ODNmMTJlZGY3YTRlZDJhZDAyNzRkZTNlMWQ0YVwiO1xuICByZXR1cm4gU3RhcmtuZXRJZFBvcENvbnRyYWN0Mjtcbn0pKFN0YXJrbmV0SWRQb3BDb250cmFjdCB8fCB7fSk7XG5mdW5jdGlvbiBnZXRTdGFya25ldElkUG9wQ29udHJhY3QoY2hhaW5JZCkge1xuICBzd2l0Y2ggKGNoYWluSWQpIHtcbiAgICBjYXNlIFwiMHg1MzRlNWY0ZDQxNDk0ZVwiIC8qIFNOX01BSU4gKi86XG4gICAgICByZXR1cm4gXCIweDAyOTNlYjJiYTk4NjJmNzYyYmQzMDM2NTg2ZDU3NTVhNzgyYmQyMmU2ZjUwMjgzMjBmMWQwNDA1ZmQ0N2JmZjRcIiAvKiBNQUlOTkVUICovO1xuICAgIGNhc2UgXCIweDUzNGU1ZjUzNDU1MDRmNGM0OTQxXCIgLyogU05fU0VQT0xJQSAqLzpcbiAgICAgIHJldHVybiBcIjB4MTVhZTg4YWUwNTRjYWE3NDA5MGI4OTAyNWMxNTk1NjgzZjEyZWRmN2E0ZWQyYWQwMjc0ZGUzZTFkNGFcIiAvKiBURVNUTkVUX1NFUE9MSUEgKi87XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJTdGFya25ldC5pZCBwcm9vZiBvZiBwZXJzb25ob29kIHZlcmlmaWVyIGNvbnRyYWN0IGlzIG5vdCB5ZXQgZGVwbG95ZWQgb24gdGhpcyBuZXR3b3JrXCJcbiAgICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4ZWN1dGlvbihzdGF0aWNFeCwgaWZFcXVhbCA9IHZvaWQgMCwgaWZOb3RFcXVhbCA9IHZvaWQgMCkge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgU3RhdGljOiBzdGF0aWNFeCxcbiAgICBJZkVxdWFsOiBpZkVxdWFsID8gdHVwbGUoaWZFcXVhbFswXSwgaWZFcXVhbFsxXSwgaWZFcXVhbFsyXSkgOiB2b2lkIDAsXG4gICAgSWZOb3RFcXVhbDogaWZOb3RFcXVhbCA/IHR1cGxlKGlmTm90RXF1YWxbMF0sIGlmTm90RXF1YWxbMV0sIGlmTm90RXF1YWxbMl0pIDogdm9pZCAwXG4gIH0pO1xufVxuZnVuY3Rpb24gZHluYW1pY0ZlbHQoaGFyZGNvZGVkLCByZWZlcmVuY2UgPSB2b2lkIDApIHtcbiAgcmV0dXJuIG5ldyBDYWlyb0N1c3RvbUVudW0oe1xuICAgIEhhcmRjb2RlZDogaGFyZGNvZGVkLFxuICAgIFJlZmVyZW5jZTogcmVmZXJlbmNlID8gdHVwbGUocmVmZXJlbmNlWzBdLCByZWZlcmVuY2VbMV0pIDogdm9pZCAwXG4gIH0pO1xufVxuZnVuY3Rpb24gZHluYW1pY0NhbGxEYXRhKGhhcmRjb2RlZCwgcmVmZXJlbmNlID0gdm9pZCAwLCBhcnJheVJlZmVyZW5jZSA9IHZvaWQgMCkge1xuICByZXR1cm4gbmV3IENhaXJvQ3VzdG9tRW51bSh7XG4gICAgSGFyZGNvZGVkOiBoYXJkY29kZWQsXG4gICAgUmVmZXJlbmNlOiByZWZlcmVuY2UgPyB0dXBsZShyZWZlcmVuY2VbMF0sIHJlZmVyZW5jZVsxXSkgOiB2b2lkIDAsXG4gICAgQXJyYXlSZWZlcmVuY2U6IGFycmF5UmVmZXJlbmNlID8gdHVwbGUoYXJyYXlSZWZlcmVuY2VbMF0sIGFycmF5UmVmZXJlbmNlWzFdKSA6IHZvaWQgMFxuICB9KTtcbn1cblxuLy8gc3JjL3Byb3ZpZGVyL2V4dGVuc2lvbnMvc3RhcmtuZXRJZC50c1xudmFyIFN0YXJrbmV0SWQgPSBjbGFzcyBfU3RhcmtuZXRJZCB7XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIF9TdGFya25ldElkLmdldFN0YXJrTmFtZShcbiAgICAgIC8vIEFmdGVyIE1peGluLCB0aGlzIGlzIFByb3ZpZGVySW50ZXJmYWNlXG4gICAgICB0aGlzLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIFN0YXJrbmV0SWRDb250cmFjdDJcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NGcm9tU3RhcmtOYW1lKG5hbWUsIFN0YXJrbmV0SWRDb250cmFjdDIpIHtcbiAgICByZXR1cm4gX1N0YXJrbmV0SWQuZ2V0QWRkcmVzc0Zyb21TdGFya05hbWUoXG4gICAgICAvLyBBZnRlciBNaXhpbiwgdGhpcyBpcyBQcm92aWRlckludGVyZmFjZVxuICAgICAgdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICBTdGFya25ldElkQ29udHJhY3QyXG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTdGFya1Byb2ZpbGUoYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0MiwgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyLCBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDIsIFN0YXJrbmV0SWRQZnBDb250cmFjdDIsIFN0YXJrbmV0SWRQb3BDb250cmFjdDIsIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDIpIHtcbiAgICByZXR1cm4gX1N0YXJrbmV0SWQuZ2V0U3RhcmtQcm9maWxlKFxuICAgICAgLy8gQWZ0ZXIgTWl4aW4sIHRoaXMgaXMgUHJvdmlkZXJJbnRlcmZhY2VcbiAgICAgIHRoaXMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgU3RhcmtuZXRJZENvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0MixcbiAgICAgIFN0YXJrbmV0SWRQZnBDb250cmFjdDIsXG4gICAgICBTdGFya25ldElkUG9wQ29udHJhY3QyLFxuICAgICAgU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0MlxuICAgICk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldFN0YXJrTmFtZShwcm92aWRlciwgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGV4RG9tYWluID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdCxcbiAgICAgICAgZW50cnlwb2ludDogXCJhZGRyZXNzX3RvX2RvbWFpblwiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICBoaW50OiBbXVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZWNpbWFsRG9tYWluID0gaGV4RG9tYWluLm1hcCgoZWxlbWVudCkgPT4gQmlnSW50KGVsZW1lbnQpKS5zbGljZSgxKTtcbiAgICAgIGNvbnN0IHN0cmluZ0RvbWFpbiA9IHVzZURlY29kZWQoZGVjaW1hbERvbWFpbik7XG4gICAgICBpZiAoIXN0cmluZ0RvbWFpbikge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlN0YXJrbmFtZSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nRG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlID09PSBcIlN0YXJrbmFtZSBub3QgZm91bmRcIikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHN0YXJrIG5hbWVcIik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBnZXRBZGRyZXNzRnJvbVN0YXJrTmFtZShwcm92aWRlciwgbmFtZSwgU3RhcmtuZXRJZENvbnRyYWN0Mikge1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCBwcm92aWRlci5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBTdGFya25ldElkQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRDb250cmFjdChjaGFpbklkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jb2RlZERvbWFpbiA9IG5hbWUucmVwbGFjZShcIi5zdGFya1wiLCBcIlwiKS5zcGxpdChcIi5cIikubWFwKChwYXJ0KSA9PiB1c2VFbmNvZGVkKHBhcnQpLnRvU3RyaW5nKDEwKSk7XG4gICAgICBjb25zdCBhZGRyZXNzRGF0YSA9IGF3YWl0IHByb3ZpZGVyLmNhbGxDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogY29udHJhY3QsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFwiZG9tYWluX3RvX2FkZHJlc3NcIixcbiAgICAgICAgY2FsbGRhdGE6IENhbGxEYXRhLmNvbXBpbGUoeyBkb21haW46IGVuY29kZWREb21haW4sIGhpbnQ6IFtdIH0pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZGRyZXNzRGF0YVswXTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGdldCBhZGRyZXNzIGZyb20gc3RhcmsgbmFtZVwiKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGdldFN0YXJrUHJvZmlsZShwcm92aWRlciwgYWRkcmVzcywgU3RhcmtuZXRJZENvbnRyYWN0MiwgU3RhcmtuZXRJZElkZW50aXR5Q29udHJhY3QyLCBTdGFya25ldElkVmVyaWZpZXJDb250cmFjdDIsIFN0YXJrbmV0SWRQZnBDb250cmFjdDIsIFN0YXJrbmV0SWRQb3BDb250cmFjdDIsIFN0YXJrbmV0SWRNdWx0aWNhbGxDb250cmFjdDIpIHtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgcHJvdmlkZXIuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gU3RhcmtuZXRJZENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IFN0YXJrbmV0SWRJZGVudGl0eUNvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkSWRlbnRpdHlDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCB2ZXJpZmllckNvbnRyYWN0ID0gU3RhcmtuZXRJZFZlcmlmaWVyQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRWZXJpZmllckNvbnRyYWN0KGNoYWluSWQpO1xuICAgIGNvbnN0IHBmcENvbnRyYWN0ID0gU3RhcmtuZXRJZFBmcENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkUGZwQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgY29uc3QgcG9wQ29udHJhY3QgPSBTdGFya25ldElkUG9wQ29udHJhY3QyID8/IGdldFN0YXJrbmV0SWRQb3BDb250cmFjdChjaGFpbklkKTtcbiAgICBjb25zdCBtdWx0aWNhbGxBZGRyZXNzID0gU3RhcmtuZXRJZE11bHRpY2FsbENvbnRyYWN0MiA/PyBnZXRTdGFya25ldElkTXVsdGljYWxsQ29udHJhY3QoY2hhaW5JZCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbGxzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljQ2FsbERhdGEoY29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljQ2FsbERhdGEoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImFkZHJlc3NfdG9fZG9tYWluXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW2R5bmFtaWNDYWxsRGF0YShhZGRyZXNzKSwgZHluYW1pY0NhbGxEYXRhKFwiMFwiKV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoY29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZG9tYWluX3RvX2lkXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW2R5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIHZvaWQgMCwgWzAsIDBdKV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJ0d2l0dGVyXCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2ZXJpZmllckNvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwiZ2l0aHViXCIpKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2ZXJpZmllckNvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBleGVjdXRpb246IGV4ZWN1dGlvbih7fSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KGlkZW50aXR5Q29udHJhY3QpLFxuICAgICAgICAgIHNlbGVjdG9yOiBkeW5hbWljRmVsdChnZXRTZWxlY3RvckZyb21OYW1lKFwiZ2V0X3ZlcmlmaWVyX2RhdGFcIikpLFxuICAgICAgICAgIGNhbGxkYXRhOiBbXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodm9pZCAwLCBbMSwgMF0pLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKGVuY29kZVNob3J0U3RyaW5nKFwiZGlzY29yZFwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEodmVyaWZpZXJDb250cmFjdCksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcInByb29mX29mX3BlcnNvbmhvb2RcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHBvcENvbnRyYWN0KSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShcIjBcIilcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBGUFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24oe30pLFxuICAgICAgICAgIHRvOiBkeW5hbWljRmVsdChpZGVudGl0eUNvbnRyYWN0KSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcImdldF92ZXJpZmllcl9kYXRhXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKHZvaWQgMCwgWzEsIDBdKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShlbmNvZGVTaG9ydFN0cmluZyhcIm5mdF9wcF9jb250cmFjdFwiKSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEocGZwQ29udHJhY3QpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMFwiKVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGV4ZWN1dGlvbjogZXhlY3V0aW9uKHt9KSxcbiAgICAgICAgICB0bzogZHluYW1pY0ZlbHQoaWRlbnRpdHlDb250cmFjdCksXG4gICAgICAgICAgc2VsZWN0b3I6IGR5bmFtaWNGZWx0KGdldFNlbGVjdG9yRnJvbU5hbWUoXCJnZXRfZXh0ZW5kZWRfdmVyaWZpZXJfZGF0YVwiKSksXG4gICAgICAgICAgY2FsbGRhdGE6IFtcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFsxLCAwXSksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoZW5jb2RlU2hvcnRTdHJpbmcoXCJuZnRfcHBfaWRcIikpLFxuICAgICAgICAgICAgZHluYW1pY0NhbGxEYXRhKFwiMlwiKSxcbiAgICAgICAgICAgIGR5bmFtaWNDYWxsRGF0YShwZnBDb250cmFjdCksXG4gICAgICAgICAgICBkeW5hbWljQ2FsbERhdGEoXCIwXCIpXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgZXhlY3V0aW9uOiBleGVjdXRpb24odm9pZCAwLCB2b2lkIDAsIFs2LCAwLCAwXSksXG4gICAgICAgICAgdG86IGR5bmFtaWNGZWx0KHZvaWQgMCwgWzYsIDBdKSxcbiAgICAgICAgICBzZWxlY3RvcjogZHluYW1pY0ZlbHQoZ2V0U2VsZWN0b3JGcm9tTmFtZShcInRva2VuVVJJXCIpKSxcbiAgICAgICAgICBjYWxsZGF0YTogW2R5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFs3LCAxXSksIGR5bmFtaWNDYWxsRGF0YSh2b2lkIDAsIFs3LCAyXSldXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcHJvdmlkZXIuY2FsbENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiBtdWx0aWNhbGxBZGRyZXNzLFxuICAgICAgICBlbnRyeXBvaW50OiBcImFnZ3JlZ2F0ZVwiLFxuICAgICAgICBjYWxsZGF0YTogQ2FsbERhdGEuY29tcGlsZSh7XG4gICAgICAgICAgY2FsbHNcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KGRhdGFbMF0sIDE2KTtcbiAgICAgICAgY29uc3QgZmluYWxBcnJheSA9IFtdO1xuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChpbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJBcnJheVNpemUgPSBwYXJzZUludChkYXRhW2luZGV4XSwgMTYpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkFycmF5ID0gZGF0YS5zbGljZShpbmRleCwgaW5kZXggKyBzdWJBcnJheVNpemUpO1xuICAgICAgICAgICAgZmluYWxBcnJheS5wdXNoKHN1YkFycmF5KTtcbiAgICAgICAgICAgIGluZGV4ICs9IHN1YkFycmF5U2l6ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB1c2VEZWNvZGVkKGZpbmFsQXJyYXlbMF0uc2xpY2UoMSkubWFwKChoZXhTdHJpbmcpID0+IEJpZ0ludChoZXhTdHJpbmcpKSk7XG4gICAgICAgIGNvbnN0IHR3aXR0ZXIgPSBmaW5hbEFycmF5WzJdWzBdICE9PSBcIjB4MFwiID8gQmlnSW50KGZpbmFsQXJyYXlbMl1bMF0pLnRvU3RyaW5nKCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGdpdGh1YiA9IGZpbmFsQXJyYXlbM11bMF0gIT09IFwiMHgwXCIgPyBCaWdJbnQoZmluYWxBcnJheVszXVswXSkudG9TdHJpbmcoKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZGlzY29yZCA9IGZpbmFsQXJyYXlbNF1bMF0gIT09IFwiMHgwXCIgPyBCaWdJbnQoZmluYWxBcnJheVs0XVswXSkudG9TdHJpbmcoKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcHJvb2ZPZlBlcnNvbmhvb2QgPSBmaW5hbEFycmF5WzVdWzBdID09PSBcIjB4MVwiO1xuICAgICAgICBjb25zdCBwcm9maWxlUGljdHVyZU1ldGFkYXRhID0gZGF0YVswXSA9PT0gXCIweDlcIiA/IGZpbmFsQXJyYXlbOF0uc2xpY2UoMSkubWFwKCh2YWwpID0+IGRlY29kZVNob3J0U3RyaW5nKHZhbCkpLmpvaW4oXCJcIikgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVQaWN0dXJlID0gcHJvZmlsZVBpY3R1cmVNZXRhZGF0YSB8fCBgaHR0cHM6Ly9zdGFya25ldC5pZC9hcGkvaWRlbnRpY29ucy8ke0JpZ0ludChmaW5hbEFycmF5WzFdWzBdKS50b1N0cmluZygpfWA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0d2l0dGVyLFxuICAgICAgICAgIGdpdGh1YixcbiAgICAgICAgICBkaXNjb3JkLFxuICAgICAgICAgIHByb29mT2ZQZXJzb25ob29kLFxuICAgICAgICAgIHByb2ZpbGVQaWN0dXJlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcIkVycm9yIHdoaWxlIGNhbGxpbmcgYWdncmVnYXRlIGZ1bmN0aW9uXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGdldCB1c2VyIHN0YXJrIHByb2ZpbGUgZGF0YSBmcm9tIGFkZHJlc3NcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIvZXh0ZW5zaW9ucy9kZWZhdWx0LnRzXG52YXIgUnBjUHJvdmlkZXIyID0gY2xhc3MgZXh0ZW5kcyBNaXhpbihScGNQcm92aWRlciwgU3RhcmtuZXRJZCkge1xufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2ludGVyZmFjZS50c1xudmFyIFByb3ZpZGVySW50ZXJmYWNlID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3Byb3ZpZGVyL2luZGV4LnRzXG52YXIgZGVmYXVsdFByb3ZpZGVyID0gbmV3IFJwY1Byb3ZpZGVyKHsgZGVmYXVsdDogdHJ1ZSB9KTtcblxuLy8gc3JjL3NpZ25lci9pbnRlcmZhY2UudHNcbnZhciBTaWduZXJJbnRlcmZhY2UgPSBjbGFzcyB7XG59O1xuXG4vLyBzcmMvdXRpbHMvdHlwZWREYXRhLnRzXG52YXIgdHlwZWREYXRhX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHR5cGVkRGF0YV9leHBvcnRzLCB7XG4gIFR5cGVkRGF0YVJldmlzaW9uOiAoKSA9PiBUeXBlZERhdGFSZXZpc2lvbixcbiAgZW5jb2RlRGF0YTogKCkgPT4gZW5jb2RlRGF0YSxcbiAgZW5jb2RlVHlwZTogKCkgPT4gZW5jb2RlVHlwZSxcbiAgZW5jb2RlVmFsdWU6ICgpID0+IGVuY29kZVZhbHVlLFxuICBnZXREZXBlbmRlbmNpZXM6ICgpID0+IGdldERlcGVuZGVuY2llcyxcbiAgZ2V0TWVzc2FnZUhhc2g6ICgpID0+IGdldE1lc3NhZ2VIYXNoLFxuICBnZXRTdHJ1Y3RIYXNoOiAoKSA9PiBnZXRTdHJ1Y3RIYXNoLFxuICBnZXRUeXBlSGFzaDogKCkgPT4gZ2V0VHlwZUhhc2gsXG4gIGlzTWVya2xlVHJlZVR5cGU6ICgpID0+IGlzTWVya2xlVHJlZVR5cGUsXG4gIHByZXBhcmVTZWxlY3RvcjogKCkgPT4gcHJlcGFyZVNlbGVjdG9yXG59KTtcblxuLy8gc3JjL3V0aWxzL21lcmtsZS50c1xudmFyIG1lcmtsZV9leHBvcnRzID0ge307XG5fX2V4cG9ydChtZXJrbGVfZXhwb3J0cywge1xuICBNZXJrbGVUcmVlOiAoKSA9PiBNZXJrbGVUcmVlLFxuICBwcm9vZk1lcmtsZVBhdGg6ICgpID0+IHByb29mTWVya2xlUGF0aFxufSk7XG52YXIgTWVya2xlVHJlZSA9IGNsYXNzIF9NZXJrbGVUcmVlIHtcbiAgbGVhdmVzO1xuICBicmFuY2hlcyA9IFtdO1xuICByb290O1xuICBoYXNoTWV0aG9kO1xuICAvKipcbiAgICogQ3JlYXRlIGEgTWVya2xlIHRyZWVcbiAgICpcbiAgICogQHBhcmFtIGxlYWZIYXNoZXMgaGV4LXN0cmluZyBhcnJheVxuICAgKiBAcGFyYW0gaGFzaE1ldGhvZCBoYXNoIG1ldGhvZCB0byB1c2UsIGRlZmF1bHQ6IFBlZGVyc2VuXG4gICAqIEByZXR1cm5zIGNyZWF0ZWQgTWVya2xlIHRyZWVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBsZWF2ZXMgPSBbJzB4MScsICcweDInLCAnMHgzJywgJzB4NCcsICcweDUnLCAnMHg2JywgJzB4NyddO1xuICAgKiBjb25zdCB0cmVlID0gbmV3IE1lcmtsZVRyZWUobGVhdmVzKTtcbiAgICogLy8gdHJlZSA9IHtcbiAgICogLy8gICBicmFuY2hlczogW1snMHg1YmI5NDQwZTIuLi4nLCAnMHgyNjI2OTdiODguLi4nLCAuLi5dLCBbJzB4MzgxMThhMzQwLi4uJywgLi4uXSwgLi4uXSxcbiAgICogLy8gICBsZWF2ZXM6IFsnMHgxJywgJzB4MicsICcweDMnLCAnMHg0JywgJzB4NScsICcweDYnLCAnMHg3J10sXG4gICAqIC8vICAgcm9vdDogJzB4N2Y3NDhjNzVlNWJkYjdhZTI4MDEzZjA3NmI4YWI2NTBjNGUwMWQzNTMwYzZlNWFiNjY1ZjlmMWFjY2JlN2Q0JyxcbiAgICogLy8gICBoYXNoTWV0aG9kOiBbRnVuY3Rpb24gY29tcHV0ZVBlZGVyc2VuSGFzaF0sXG4gICAqIC8vIH1cbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsZWFmSGFzaGVzLCBoYXNoTWV0aG9kID0gY29tcHV0ZVBlZGVyc2VuSGFzaCkge1xuICAgIHRoaXMuaGFzaE1ldGhvZCA9IGhhc2hNZXRob2Q7XG4gICAgdGhpcy5sZWF2ZXMgPSBsZWFmSGFzaGVzO1xuICAgIHRoaXMucm9vdCA9IHRoaXMuYnVpbGQobGVhZkhhc2hlcyk7XG4gIH1cbiAgLyoqIEBpZ25vcmUgKi9cbiAgYnVpbGQobGVhdmVzKSB7XG4gICAgaWYgKGxlYXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBsZWF2ZXNbMF07XG4gICAgfVxuICAgIGlmIChsZWF2ZXMubGVuZ3RoICE9PSB0aGlzLmxlYXZlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYnJhbmNoZXMucHVzaChsZWF2ZXMpO1xuICAgIH1cbiAgICBjb25zdCBuZXdMZWF2ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGkgKyAxID09PSBsZWF2ZXMubGVuZ3RoKSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKF9NZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBcIjB4MFwiLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0xlYXZlcy5wdXNoKF9NZXJrbGVUcmVlLmhhc2gobGVhdmVzW2ldLCBsZWF2ZXNbaSArIDFdLCB0aGlzLmhhc2hNZXRob2QpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVpbGQobmV3TGVhdmVzKTtcbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIGhhc2ggZnJvbSBvcmRlcmVkIGEgYW5kIGIsIFBlZGVyc2VuIGhhc2ggZGVmYXVsdFxuICAgKlxuICAgKiBAcGFyYW0gYSBmaXJzdCB2YWx1ZVxuICAgKiBAcGFyYW0gYiBzZWNvbmQgdmFsdWVcbiAgICogQHBhcmFtIGhhc2hNZXRob2QgaGFzaCBtZXRob2QgdG8gdXNlLCBkZWZhdWx0OiBQZWRlcnNlblxuICAgKiBAcmV0dXJucyByZXN1bHQgb2YgdGhlIGhhc2ggZnVuY3Rpb25cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQxID0gTWVya2xlVHJlZS5oYXNoKCcweGFiYycsICcweGRlZicpO1xuICAgKiAvLyByZXN1bHQxID0gJzB4NDg0ZjAyOWRhNzkxNGFkYTAzOGIxYWRmNjdmYzgzNjMyMzY0YTNlYmMyY2Q5MzQ5YjQxYWI2MTYyNmQ5ZTgyJ1xuICAgKlxuICAgKiBjb25zdCBjdXN0b21IYXNoTWV0aG9kID0gKGEsIGIpID0+IGBjdXN0b21fJHthfV8ke2J9YDtcbiAgICogY29uc3QgcmVzdWx0MiA9IE1lcmtsZVRyZWUuaGFzaCgnMHhhYmMnLCAnMHhkZWYnLCBjdXN0b21IYXNoTWV0aG9kKTtcbiAgICogLy8gcmVzdWx0MiA9ICdjdXN0b21fMjc0OF8zNTY3J1xuICAgKiBgYGBcbiAgICovXG4gIHN0YXRpYyBoYXNoKGEsIGIsIGhhc2hNZXRob2QgPSBjb21wdXRlUGVkZXJzZW5IYXNoKSB7XG4gICAgY29uc3QgW2FTb3J0ZWQsIGJTb3J0ZWRdID0gW0JpZ0ludChhKSwgQmlnSW50KGIpXS5zb3J0KCh4LCB5KSA9PiB4ID49IHkgPyAxIDogLTEpO1xuICAgIHJldHVybiBoYXNoTWV0aG9kKGFTb3J0ZWQsIGJTb3J0ZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBtZXJrbGUgbWVtYmVyc2hpcCBwcm9vZiBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBsZWFmIGhleC1zdHJpbmdcbiAgICogQHBhcmFtIGJyYW5jaCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEBwYXJhbSBoYXNoUGF0aCBoZXgtc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm5zIGNvbGxlY3Rpb24gb2YgbWVya2xlIHByb29mIGhleC1zdHJpbmcgaGFzaGVzXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgbGVhdmVzID0gWycweDEnLCAnMHgyJywgJzB4MycsICcweDQnLCAnMHg1JywgJzB4NicsICcweDcnXTtcbiAgICogY29uc3QgdHJlZSA9IG5ldyBNZXJrbGVUcmVlKGxlYXZlcyk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IHRyZWUuZ2V0UHJvb2YoJzB4MycpO1xuICAgKiAvLyByZXN1bHQgPSBbXG4gICAqIC8vICAgJzB4NCcsXG4gICAqIC8vICAgJzB4NWJiOTQ0MGUyNzg4OWEzNjRiY2I2NzhiMWY2NzllY2QxMzQ3YWNkZWRjYmYzNmU4MzQ5NGY4NTdjYzU4MDI2JyxcbiAgICogLy8gICAnMHg4YzBlNDZkZDJkZjlhYWYzYThlYmZiYzI1NDA4YTU4MmFkN2ZhNzE3MWYwNjk4ZGRiYmM1MTMwYjRiNGU2MCcsXG4gICAqIC8vIF1cbiAgICogYGBgXG4gICAqL1xuICBnZXRQcm9vZihsZWFmLCBicmFuY2ggPSB0aGlzLmxlYXZlcywgaGFzaFBhdGggPSBbXSkge1xuICAgIGNvbnN0IGluZGV4ID0gYnJhbmNoLmluZGV4T2YobGVhZik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGVhZiBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIGlmIChicmFuY2gubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaGFzaFBhdGg7XG4gICAgfVxuICAgIGNvbnN0IGlzTGVmdCA9IGluZGV4ICUgMiA9PT0gMDtcbiAgICBjb25zdCBuZWVkZWRCcmFuY2ggPSAoaXNMZWZ0ID8gYnJhbmNoW2luZGV4ICsgMV0gOiBicmFuY2hbaW5kZXggLSAxXSkgPz8gXCIweDBcIjtcbiAgICBjb25zdCBuZXdIYXNoUGF0aCA9IFsuLi5oYXNoUGF0aCwgbmVlZGVkQnJhbmNoXTtcbiAgICBjb25zdCBjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCA9IHRoaXMubGVhdmVzLmxlbmd0aCA9PT0gYnJhbmNoLmxlbmd0aCA/IC0xIDogdGhpcy5icmFuY2hlcy5maW5kSW5kZXgoKGIpID0+IGIubGVuZ3RoID09PSBicmFuY2gubGVuZ3RoKTtcbiAgICBjb25zdCBuZXh0QnJhbmNoID0gdGhpcy5icmFuY2hlc1tjdXJyZW50QnJhbmNoTGV2ZWxJbmRleCArIDFdID8/IFt0aGlzLnJvb3RdO1xuICAgIHJldHVybiB0aGlzLmdldFByb29mKFxuICAgICAgX01lcmtsZVRyZWUuaGFzaChpc0xlZnQgPyBsZWFmIDogbmVlZGVkQnJhbmNoLCBpc0xlZnQgPyBuZWVkZWRCcmFuY2ggOiBsZWFmLCB0aGlzLmhhc2hNZXRob2QpLFxuICAgICAgbmV4dEJyYW5jaCxcbiAgICAgIG5ld0hhc2hQYXRoXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb29mTWVya2xlUGF0aChyb290LCBsZWFmLCBwYXRoLCBoYXNoTWV0aG9kID0gY29tcHV0ZVBlZGVyc2VuSGFzaCkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcm9vdCA9PT0gbGVhZjtcbiAgfVxuICBjb25zdCBbbmV4dCwgLi4ucmVzdF0gPSBwYXRoO1xuICByZXR1cm4gcHJvb2ZNZXJrbGVQYXRoKHJvb3QsIE1lcmtsZVRyZWUuaGFzaChsZWFmLCBuZXh0LCBoYXNoTWV0aG9kKSwgcmVzdCwgaGFzaE1ldGhvZCk7XG59XG5cbi8vIHNyYy91dGlscy90eXBlZERhdGEudHNcbnZhciBwcmVzZXRUeXBlcyA9IHtcbiAgdTI1NjogSlNPTi5wYXJzZSgnW3sgXCJuYW1lXCI6IFwibG93XCIsIFwidHlwZVwiOiBcInUxMjhcIiB9LCB7IFwibmFtZVwiOiBcImhpZ2hcIiwgXCJ0eXBlXCI6IFwidTEyOFwiIH1dJyksXG4gIFRva2VuQW1vdW50OiBKU09OLnBhcnNlKFxuICAgICdbeyBcIm5hbWVcIjogXCJ0b2tlbl9hZGRyZXNzXCIsIFwidHlwZVwiOiBcIkNvbnRyYWN0QWRkcmVzc1wiIH0sIHsgXCJuYW1lXCI6IFwiYW1vdW50XCIsIFwidHlwZVwiOiBcInUyNTZcIiB9XSdcbiAgKSxcbiAgTmZ0SWQ6IEpTT04ucGFyc2UoXG4gICAgJ1t7IFwibmFtZVwiOiBcImNvbGxlY3Rpb25fYWRkcmVzc1wiLCBcInR5cGVcIjogXCJDb250cmFjdEFkZHJlc3NcIiB9LCB7IFwibmFtZVwiOiBcInRva2VuX2lkXCIsIFwidHlwZVwiOiBcInUyNTZcIiB9XSdcbiAgKVxufTtcbnZhciByZXZpc2lvbkNvbmZpZ3VyYXRpb24gPSB7XG4gIFtUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkVdOiB7XG4gICAgZG9tYWluOiBcIlN0YXJrbmV0RG9tYWluXCIsXG4gICAgaGFzaE1ldGhvZDogY29tcHV0ZVBvc2VpZG9uSGFzaE9uRWxlbWVudHMsXG4gICAgaGFzaE1lcmtsZU1ldGhvZDogY29tcHV0ZVBvc2VpZG9uSGFzaCxcbiAgICBlc2NhcGVUeXBlU3RyaW5nOiAocykgPT4gYFwiJHtzfVwiYCxcbiAgICBwcmVzZXRUeXBlc1xuICB9LFxuICBbVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZXToge1xuICAgIGRvbWFpbjogXCJTdGFya05ldERvbWFpblwiLFxuICAgIGhhc2hNZXRob2Q6IGNvbXB1dGVQZWRlcnNlbkhhc2hPbkVsZW1lbnRzLFxuICAgIGhhc2hNZXJrbGVNZXRob2Q6IGNvbXB1dGVQZWRlcnNlbkhhc2gsXG4gICAgZXNjYXBlVHlwZVN0cmluZzogKHMpID0+IHMsXG4gICAgcHJlc2V0VHlwZXM6IHt9XG4gIH1cbn07XG5mdW5jdGlvbiBhc3NlcnRSYW5nZShkYXRhLCB0eXBlLCB7IG1pbiwgbWF4IH0pIHtcbiAgY29uc3QgdmFsdWUgPSBCaWdJbnQoZGF0YSk7XG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4gJiYgdmFsdWUgPD0gbWF4LCBgJHt2YWx1ZX0gKCR7dHlwZX0pIGlzIG91dCBvZiBib3VuZHMgWyR7bWlufSwgJHttYXh9XWApO1xufVxuZnVuY3Rpb24gaWRlbnRpZnlSZXZpc2lvbih7IHR5cGVzLCBkb21haW4gfSkge1xuICBpZiAocmV2aXNpb25Db25maWd1cmF0aW9uW1R5cGVkRGF0YVJldmlzaW9uLkFDVElWRV0uZG9tYWluIGluIHR5cGVzICYmIGRvbWFpbi5yZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKVxuICAgIHJldHVybiBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkU7XG4gIGlmIChyZXZpc2lvbkNvbmZpZ3VyYXRpb25bVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZXS5kb21haW4gaW4gdHlwZXMgJiYgKGRvbWFpbi5yZXZpc2lvbiA/PyBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpID09PSBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpXG4gICAgcmV0dXJuIFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWTtcbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldEhleCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0b0hleCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdG9IZXgoZW5jb2RlU2hvcnRTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJpZ051bWJlcmlzaDogJHt2YWx1ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlZERhdGEoZGF0YSkge1xuICBjb25zdCB0eXBlZERhdGEgPSBkYXRhO1xuICByZXR1cm4gQm9vbGVhbihcbiAgICB0eXBlZERhdGEubWVzc2FnZSAmJiB0eXBlZERhdGEucHJpbWFyeVR5cGUgJiYgdHlwZWREYXRhLnR5cGVzICYmIGlkZW50aWZ5UmV2aXNpb24odHlwZWREYXRhKVxuICApO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBpc0hleChzZWxlY3RvcikgPyBzZWxlY3RvciA6IGdldFNlbGVjdG9yRnJvbU5hbWUoc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gaXNNZXJrbGVUcmVlVHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnR5cGUgPT09IFwibWVya2xldHJlZVwiO1xufVxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKHR5cGVzLCB0eXBlLCBkZXBlbmRlbmNpZXMgPSBbXSwgY29udGFpbnMgPSBcIlwiLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICBpZiAodHlwZVt0eXBlLmxlbmd0aCAtIDFdID09PSBcIipcIikge1xuICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIC0xKTtcbiAgfSBlbHNlIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiZW51bVwiKSB7XG4gICAgICB0eXBlID0gY29udGFpbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlLm1hdGNoKC9eXFwoLipcXCkkLykpIHtcbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlcGVuZGVuY2llcy5pbmNsdWRlcyh0eXBlKSB8fCAhdHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG4gIHJldHVybiBbXG4gICAgdHlwZSxcbiAgICAuLi50eXBlc1t0eXBlXS5yZWR1Y2UoXG4gICAgICAocHJldmlvdXMsIHQpID0+IFtcbiAgICAgICAgLi4ucHJldmlvdXMsXG4gICAgICAgIC4uLmdldERlcGVuZGVuY2llcyh0eXBlcywgdC50eXBlLCBwcmV2aW91cywgdC5jb250YWlucywgcmV2aXNpb24pLmZpbHRlcihcbiAgICAgICAgICAoZGVwZW5kZW5jeSkgPT4gIXByZXZpb3VzLmluY2x1ZGVzKGRlcGVuZGVuY3kpXG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICBbXVxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIGdldE1lcmtsZVRyZWVUeXBlKHR5cGVzLCBjdHgpIHtcbiAgaWYgKGN0eC5wYXJlbnQgJiYgY3R4LmtleSkge1xuICAgIGNvbnN0IHBhcmVudFR5cGUgPSB0eXBlc1tjdHgucGFyZW50XTtcbiAgICBjb25zdCBtZXJrbGVUeXBlID0gcGFyZW50VHlwZS5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGN0eC5rZXkpO1xuICAgIGNvbnN0IGlzTWVya2xlVHJlZSA9IGlzTWVya2xlVHJlZVR5cGUobWVya2xlVHlwZSk7XG4gICAgaWYgKCFpc01lcmtsZVRyZWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjdHgua2V5fSBpcyBub3QgYSBtZXJrbGUgdHJlZWApO1xuICAgIH1cbiAgICBpZiAobWVya2xlVHlwZS5jb250YWlucy5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWVya2xlIHRyZWUgY29udGFpbiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSBhbiBhcnJheSBidXQgd2FzIGdpdmVuICR7Y3R4LmtleX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmtsZVR5cGUuY29udGFpbnM7XG4gIH1cbiAgcmV0dXJuIFwicmF3XCI7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKHR5cGVzLCB0eXBlLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICBjb25zdCBhbGxUeXBlcyA9IHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUgPyB7IC4uLnR5cGVzLCAuLi5yZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzIH0gOiB0eXBlcztcbiAgY29uc3QgW3ByaW1hcnksIC4uLmRlcGVuZGVuY2llc10gPSBnZXREZXBlbmRlbmNpZXMoXG4gICAgYWxsVHlwZXMsXG4gICAgdHlwZSxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIHJldmlzaW9uXG4gICk7XG4gIGNvbnN0IG5ld1R5cGVzID0gIXByaW1hcnkgPyBbXSA6IFtwcmltYXJ5LCAuLi5kZXBlbmRlbmNpZXMuc29ydCgpXTtcbiAgY29uc3QgZXNjID0gcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5lc2NhcGVUeXBlU3RyaW5nO1xuICByZXR1cm4gbmV3VHlwZXMubWFwKChkZXBlbmRlbmN5KSA9PiB7XG4gICAgY29uc3QgZGVwZW5kZW5jeUVsZW1lbnRzID0gYWxsVHlwZXNbZGVwZW5kZW5jeV0ubWFwKCh0KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRUeXBlID0gdC50eXBlID09PSBcImVudW1cIiAmJiByZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFID8gdC5jb250YWlucyA6IHQudHlwZTtcbiAgICAgIGNvbnN0IHR5cGVTdHJpbmcgPSB0YXJnZXRUeXBlLm1hdGNoKC9eXFwoLipcXCkkLykgPyBgKCR7dGFyZ2V0VHlwZS5zbGljZSgxLCAtMSkuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gZSA/IGVzYyhlKSA6IGUpLmpvaW4oXCIsXCIpfSlgIDogZXNjKHRhcmdldFR5cGUpO1xuICAgICAgcmV0dXJuIGAke2VzYyh0Lm5hbWUpfToke3R5cGVTdHJpbmd9YDtcbiAgICB9KTtcbiAgICByZXR1cm4gYCR7ZXNjKGRlcGVuZGVuY3kpfSgke2RlcGVuZGVuY3lFbGVtZW50c30pYDtcbiAgfSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVIYXNoKHR5cGVzLCB0eXBlLCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICByZXR1cm4gZ2V0U2VsZWN0b3JGcm9tTmFtZShlbmNvZGVUeXBlKHR5cGVzLCB0eXBlLCByZXZpc2lvbikpO1xufVxuZnVuY3Rpb24gZW5jb2RlVmFsdWUodHlwZXMsIHR5cGUsIGRhdGEsIGN0eCA9IHt9LCByZXZpc2lvbiA9IFR5cGVkRGF0YVJldmlzaW9uLkxFR0FDWSkge1xuICBpZiAodHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gW3R5cGUsIGdldFN0cnVjdEhhc2godHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uKV07XG4gIH1cbiAgaWYgKHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXNbdHlwZV0pIHtcbiAgICByZXR1cm4gW1xuICAgICAgdHlwZSxcbiAgICAgIGdldFN0cnVjdEhhc2goXG4gICAgICAgIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0ucHJlc2V0VHlwZXMsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHJldmlzaW9uXG4gICAgICApXG4gICAgXTtcbiAgfVxuICBpZiAodHlwZS5lbmRzV2l0aChcIipcIikpIHtcbiAgICBjb25zdCBoYXNoZXMgPSBkYXRhLm1hcChcbiAgICAgIChlbnRyeSkgPT4gZW5jb2RlVmFsdWUodHlwZXMsIHR5cGUuc2xpY2UoMCwgLTEpLCBlbnRyeSwgdm9pZCAwLCByZXZpc2lvbilbMV1cbiAgICApO1xuICAgIHJldHVybiBbdHlwZSwgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGhhc2hlcyldO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJlbnVtXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IFt2YXJpYW50S2V5LCB2YXJpYW50RGF0YV0gPSBPYmplY3QuZW50cmllcyhkYXRhKVswXTtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IHR5cGVzW2N0eC5wYXJlbnRdWzBdO1xuICAgICAgICBjb25zdCBlbnVtVHlwZSA9IHR5cGVzW3BhcmVudFR5cGUuY29udGFpbnNdO1xuICAgICAgICBjb25zdCB2YXJpYW50VHlwZSA9IGVudW1UeXBlLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gdmFyaWFudEtleSk7XG4gICAgICAgIGNvbnN0IHZhcmlhbnRJbmRleCA9IGVudW1UeXBlLmluZGV4T2YodmFyaWFudFR5cGUpO1xuICAgICAgICBjb25zdCBlbmNvZGVkU3VidHlwZXMgPSB2YXJpYW50VHlwZS50eXBlLnNsaWNlKDEsIC0xKS5zcGxpdChcIixcIikubWFwKChzdWJ0eXBlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmICghc3VidHlwZSkgcmV0dXJuIHN1YnR5cGU7XG4gICAgICAgICAgY29uc3Qgc3VidHlwZURhdGEgPSB2YXJpYW50RGF0YVtpbmRleF07XG4gICAgICAgICAgcmV0dXJuIGVuY29kZVZhbHVlKHR5cGVzLCBzdWJ0eXBlLCBzdWJ0eXBlRGF0YSwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKFt2YXJpYW50SW5kZXgsIC4uLmVuY29kZWRTdWJ0eXBlc10pXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJtZXJrbGV0cmVlXCI6IHtcbiAgICAgIGNvbnN0IG1lcmtsZVRyZWVUeXBlID0gZ2V0TWVya2xlVHJlZVR5cGUodHlwZXMsIGN0eCk7XG4gICAgICBjb25zdCBzdHJ1Y3RIYXNoZXMgPSBkYXRhLm1hcCgoc3RydWN0KSA9PiB7XG4gICAgICAgIHJldHVybiBlbmNvZGVWYWx1ZSh0eXBlcywgbWVya2xlVHJlZVR5cGUsIHN0cnVjdCwgdm9pZCAwLCByZXZpc2lvbilbMV07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHsgcm9vdCB9ID0gbmV3IE1lcmtsZVRyZWUoXG4gICAgICAgIHN0cnVjdEhhc2hlcyxcbiAgICAgICAgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWVya2xlTWV0aG9kXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtcImZlbHRcIiwgcm9vdF07XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3RvclwiOiB7XG4gICAgICByZXR1cm4gW1wiZmVsdFwiLCBwcmVwYXJlU2VsZWN0b3IoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IGJ5dGVBcnJheUZyb21TdHJpbmcoZGF0YSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW1xuICAgICAgICAgIGJ5dGVBcnJheS5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5ieXRlQXJyYXkuZGF0YSxcbiAgICAgICAgICBieXRlQXJyYXkucGVuZGluZ193b3JkLFxuICAgICAgICAgIGJ5dGVBcnJheS5wZW5kaW5nX3dvcmRfbGVuXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBbdHlwZSwgcmV2aXNpb25Db25maWd1cmF0aW9uW3JldmlzaW9uXS5oYXNoTWV0aG9kKGVsZW1lbnRzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3R5cGUsIGdldEhleChkYXRhKV07XG4gICAgfVxuICAgIGNhc2UgXCJpMTI4XCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KGRhdGEpO1xuICAgICAgICBhc3NlcnRSYW5nZSh2YWx1ZSwgdHlwZSwgUkFOR0VfSTEyOCk7XG4gICAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KHZhbHVlIDwgMG4gPyBQUklNRSArIHZhbHVlIDogdmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcInRpbWVzdGFtcFwiOlxuICAgIGNhc2UgXCJ1MTI4XCI6IHtcbiAgICAgIGlmIChyZXZpc2lvbiA9PT0gVHlwZWREYXRhUmV2aXNpb24uQUNUSVZFKSB7XG4gICAgICAgIGFzc2VydFJhbmdlKGRhdGEsIHR5cGUsIFJBTkdFX1UxMjgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiZmVsdFwiOlxuICAgIGNhc2UgXCJzaG9ydHN0cmluZ1wiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICBhc3NlcnRSYW5nZShnZXRIZXgoZGF0YSksIHR5cGUsIFJBTkdFX0ZFTFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBjYXNlIFwiQ2xhc3NIYXNoXCI6XG4gICAgY2FzZSBcIkNvbnRyYWN0QWRkcmVzc1wiOiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICBhc3NlcnRSYW5nZShkYXRhLCB0eXBlLCBSQU5HRV9GRUxUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gICAgY2FzZSBcImJvb2xcIjoge1xuICAgICAgaWYgKHJldmlzaW9uID09PSBUeXBlZERhdGFSZXZpc2lvbi5BQ1RJVkUpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIiwgYFR5cGUgbWlzbWF0Y2ggZm9yICR7dHlwZX0gJHtkYXRhfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0eXBlLCBnZXRIZXgoZGF0YSldO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAocmV2aXNpb24gPT09IFR5cGVkRGF0YVJldmlzaW9uLkFDVElWRSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdHlwZSwgZ2V0SGV4KGRhdGEpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZXMsIHR5cGUsIGRhdGEsIHJldmlzaW9uID0gVHlwZWREYXRhUmV2aXNpb24uTEVHQUNZKSB7XG4gIGNvbnN0IHRhcmdldFR5cGUgPSB0eXBlc1t0eXBlXSA/PyByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dLnByZXNldFR5cGVzW3R5cGVdO1xuICBjb25zdCBbcmV0dXJuVHlwZXMsIHZhbHVlc10gPSB0YXJnZXRUeXBlLnJlZHVjZShcbiAgICAoW3RzLCB2c10sIGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZGF0YVtmaWVsZC5uYW1lXSA9PT0gdm9pZCAwIHx8IGRhdGFbZmllbGQubmFtZV0gPT09IG51bGwgJiYgZmllbGQudHlwZSAhPT0gXCJlbnVtXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZW5jb2RlIGRhdGE6IG1pc3NpbmcgZGF0YSBmb3IgJyR7ZmllbGQubmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICBjb25zdCBjdHggPSB7IHBhcmVudDogdHlwZSwga2V5OiBmaWVsZC5uYW1lIH07XG4gICAgICBjb25zdCBbdCwgZW5jb2RlZFZhbHVlXSA9IGVuY29kZVZhbHVlKHR5cGVzLCBmaWVsZC50eXBlLCB2YWx1ZSwgY3R4LCByZXZpc2lvbik7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4udHMsIHRdLFxuICAgICAgICBbLi4udnMsIGVuY29kZWRWYWx1ZV1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW1wiZmVsdFwiXSwgW2dldFR5cGVIYXNoKHR5cGVzLCB0eXBlLCByZXZpc2lvbildXVxuICApO1xuICByZXR1cm4gW3JldHVyblR5cGVzLCB2YWx1ZXNdO1xufVxuZnVuY3Rpb24gZ2V0U3RydWN0SGFzaCh0eXBlcywgdHlwZSwgZGF0YSwgcmV2aXNpb24gPSBUeXBlZERhdGFSZXZpc2lvbi5MRUdBQ1kpIHtcbiAgcmV0dXJuIHJldmlzaW9uQ29uZmlndXJhdGlvbltyZXZpc2lvbl0uaGFzaE1ldGhvZChlbmNvZGVEYXRhKHR5cGVzLCB0eXBlLCBkYXRhLCByZXZpc2lvbilbMV0pO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50KSB7XG4gIGlmICghdmFsaWRhdGVUeXBlZERhdGEodHlwZWREYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVkIGRhdGEgZG9lcyBub3QgbWF0Y2ggSlNPTiBzY2hlbWFcIik7XG4gIH1cbiAgY29uc3QgcmV2aXNpb24gPSBpZGVudGlmeVJldmlzaW9uKHR5cGVkRGF0YSk7XG4gIGNvbnN0IHsgZG9tYWluLCBoYXNoTWV0aG9kIH0gPSByZXZpc2lvbkNvbmZpZ3VyYXRpb25bcmV2aXNpb25dO1xuICBjb25zdCBtZXNzYWdlID0gW1xuICAgIGVuY29kZVNob3J0U3RyaW5nKFwiU3RhcmtOZXQgTWVzc2FnZVwiKSxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgZG9tYWluLCB0eXBlZERhdGEuZG9tYWluLCByZXZpc2lvbiksXG4gICAgYWNjb3VudCxcbiAgICBnZXRTdHJ1Y3RIYXNoKHR5cGVkRGF0YS50eXBlcywgdHlwZWREYXRhLnByaW1hcnlUeXBlLCB0eXBlZERhdGEubWVzc2FnZSwgcmV2aXNpb24pXG4gIF07XG4gIHJldHVybiBoYXNoTWV0aG9kKG1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvc2lnbmVyL2RlZmF1bHQudHNcbnZhciBTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICBjb25zdHJ1Y3RvcihwayA9IHN0YXJrQ3VydmUudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKSB7XG4gICAgdGhpcy5wayA9IHBrIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZjJoZXgocGspIDogdG9IZXgocGspO1xuICB9XG4gIGFzeW5jIGdldFB1YktleSgpIHtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5nZXRTdGFya0tleSh0aGlzLnBrKTtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGEsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEodHJhbnNhY3Rpb25zLCBkZXRhaWxzLmNhaXJvVmVyc2lvbik7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25UcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbihkZXRhaWxzKSB7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduUmF3KG1zZ0hhc2gpIHtcbiAgICByZXR1cm4gc3RhcmtDdXJ2ZS5zaWduKG1zZ0hhc2gsIHRoaXMucGspO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVyL2V0aFNpZ25lci50c1xuaW1wb3J0IHsgc2VjcDI1NmsxIGFzIHNlY3AyNTZrMTIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcblxuLy8gc3JjL3V0aWxzL3VpbnQyNTYudHNcbnZhciB1aW50MjU2X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHVpbnQyNTZfZXhwb3J0cywge1xuICBVSU5UXzEyOF9NQVg6ICgpID0+IFVJTlRfMTI4X01BWCxcbiAgVUlOVF8yNTZfTUFYOiAoKSA9PiBVSU5UXzI1Nl9NQVgsXG4gIGJuVG9VaW50MjU2OiAoKSA9PiBiblRvVWludDI1NixcbiAgaXNVaW50MjU2OiAoKSA9PiBpc1VpbnQyNTYsXG4gIHVpbnQyNTZUb0JOOiAoKSA9PiB1aW50MjU2VG9CTlxufSk7XG5mdW5jdGlvbiB1aW50MjU2VG9CTih1aW50MjU2Mikge1xuICByZXR1cm4gbmV3IENhaXJvVWludDI1Nih1aW50MjU2MikudG9CaWdJbnQoKTtcbn1cbmZ1bmN0aW9uIGlzVWludDI1Nihibikge1xuICByZXR1cm4gQ2Fpcm9VaW50MjU2LmlzKGJuKTtcbn1cbmZ1bmN0aW9uIGJuVG9VaW50MjU2KGJuKSB7XG4gIHJldHVybiBuZXcgQ2Fpcm9VaW50MjU2KGJuKS50b1VpbnQyNTZIZXhTdHJpbmcoKTtcbn1cblxuLy8gc3JjL3NpZ25lci9ldGhTaWduZXIudHNcbnZhciBFdGhTaWduZXIgPSBjbGFzcyB7XG4gIHBrO1xuICAvLyBoZXggc3RyaW5nIHdpdGhvdXQgMHggYW5kIHdpdGggYW4gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gIGNvbnN0cnVjdG9yKHBrID0gZXRoUmFuZG9tUHJpdmF0ZUtleSgpKSB7XG4gICAgdGhpcy5wayA9IHBrIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ1ZjJoZXgocGspLnBhZFN0YXJ0KDY0LCBcIjBcIikgOiByZW1vdmVIZXhQcmVmaXgodG9IZXgocGspKS5wYWRTdGFydCg2NCwgXCIwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBwcm92aWRlcyB0aGUgRXRoZXJldW0gZnVsbCBwdWJsaWMga2V5ICh3aXRob3V0IHBhcml0eSBwcmVmaXgpXG4gICAqIEByZXR1cm5zIGFuIGhleCBzdHJpbmcgOiA2NCBmaXJzdCBjaGFyYWN0ZXJzIGFyZSBQb2ludCBYIGNvb3JkaW5hdGUuIDY0IGxhc3QgY2hhcmFjdGVycyBhcmUgUG9pbnQgWSBjb29yZGluYXRlLlxuICAgKi9cbiAgYXN5bmMgZ2V0UHViS2V5KCkge1xuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoXG4gICAgICBidWYyaGV4KHNlY3AyNTZrMTIuZ2V0UHVibGljS2V5KHRoaXMucGssIGZhbHNlKSkucGFkU3RhcnQoMTMwLCBcIjBcIikuc2xpY2UoMilcbiAgICApO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSwgYWNjb3VudEFkZHJlc3MpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gZ2V0TWVzc2FnZUhhc2godHlwZWREYXRhLCBhY2NvdW50QWRkcmVzcyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbnMsIGRldGFpbHMpIHtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKHRyYW5zYWN0aW9ucywgZGV0YWlscy5jYWlyb1ZlcnNpb24pO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvblxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QudmFsdWVzKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zKS5pbmNsdWRlcyhkZXRhaWxzLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSBkZXRhaWxzO1xuICAgICAgbXNnSGFzaCA9IGNhbGN1bGF0ZUludm9rZVRyYW5zYWN0aW9uSGFzaDIoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNlbmRlckFkZHJlc3M6IGRldC53YWxsZXRBZGRyZXNzLFxuICAgICAgICBjb21waWxlZENhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxMi5zaWduKFxuICAgICAgcmVtb3ZlSGV4UHJlZml4KHNhbml0aXplSGV4KG1zZ0hhc2gpKSxcbiAgICAgIHRoaXMucGtcbiAgICApO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdEV0aFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMTIuc2lnbihcbiAgICAgIHJlbW92ZUhleFByZWZpeChzYW5pdGl6ZUhleChtc2dIYXNoKSksXG4gICAgICB0aGlzLnBrXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRFdGhTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgfVxuICBhc3luYyBzaWduRGVjbGFyZVRyYW5zYWN0aW9uKGRldGFpbHMpIHtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZWNsYXJlVHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb24sXG4gICAgICAgIG5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQubm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZSksXG4gICAgICAgIGZlZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0LmZlZURhdGFBdmFpbGFiaWxpdHlNb2RlKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5zdXBwb3J0ZWQgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEyLnNpZ24oXG4gICAgICByZW1vdmVIZXhQcmVmaXgoc2FuaXRpemVIZXgobXNnSGFzaCkpLFxuICAgICAgdGhpcy5wa1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0RXRoU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgc2lnbmF0dXJlIGluIGNvbmZvcm1pdHkgd2l0aCBzdGFya25ldDo6ZXRoX3NpZ25hdHVyZTo6U2lnbmF0dXJlXG4gICAqIEBwYXJhbSBldGhTaWduYXR1cmUgc2VjcDI1NmsxIHNpZ25hdHVyZSBmcm9tIE5vYmxlIGN1cnZlcyBsaWJyYXJ5XG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgZmVsdHMsIHJlcHJlc2VudGluZyBhIENhaXJvIEV0aCBTaWduYXR1cmUuXG4gICAqL1xuICBmb3JtYXRFdGhTaWduYXR1cmUoZXRoU2lnbmF0dXJlKSB7XG4gICAgY29uc3QgciA9IGJuVG9VaW50MjU2KGV0aFNpZ25hdHVyZS5yKTtcbiAgICBjb25zdCBzID0gYm5Ub1VpbnQyNTYoZXRoU2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBbXG4gICAgICB0b0hleChyLmxvdyksXG4gICAgICB0b0hleChyLmhpZ2gpLFxuICAgICAgdG9IZXgocy5sb3cpLFxuICAgICAgdG9IZXgocy5oaWdoKSxcbiAgICAgIHRvSGV4KGV0aFNpZ25hdHVyZS5yZWNvdmVyeSlcbiAgICBdO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVyL2xlZGdlclNpZ25lci50c1xudmFyIExlZGdlclNpZ25lciA9IGNsYXNzIHtcbiAgdHJhbnNwb3J0ZXI7XG4gIC8vIHRoaXMgaXMgYSBoYWNrIHRvIGFsbG93IHRoZSAnQGxlZGdlcmhxL2h3LXRyYW5zcG9ydCcgdHlwZSB0byBiZSB1c2VkIGFzIGEgZGV2IGRlcGVuZGVuY3kgYnV0IG5vdCBleHBvc2VkIGluIHRoZSBwcm9kdWN0aW9uIGJ1aWxkXG4gIF90cmFuc3BvcnRlcjtcbiAgYWNjb3VudElEO1xuICBlaXAyNjQ1YXBwbGljYXRpb25OYW1lO1xuICBwYXRoQnVmZmVyO1xuICBhcHBWZXJzaW9uO1xuICBwdWJLZXk7XG4gIGZ1bGxQdWJLZXk7XG4gIC8qKlxuICAgKiBjb25zdHJ1Y3RvciBvZiB0aGUgTGVkZ2VyU2lnbmVyIGNsYXNzLlxuICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0IDUgdHJhbnNwb3J0cyBhcmUgYXZhaWxhYmxlIHRvIGhhbmRsZSBVU0IsIGJsdWV0b290aCwgTm9kZSwgV2ViLCBNb2JpbGUuXG4gICAqIFNlZSBHdWlkZXMgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFjY291bnRJRCBJRCBvZiBMZWRnZXIgTmFubyAoY2FuIGhhbmRsZSAyKiozMSBhY2NvdW50cykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZWlwMjY0NWFwcGxpY2F0aW9uPSdMZWRnZXJXJ10gQSB3YWxsZXQgaXMgZGVmaW5lZCBieSBhbiBFUkMyNjQ1IGRlcml2YXRpb24gcGF0aCAoNiBpdGVtcykuXG4gICAqIE9uZSBpdGVtIGlzIHRoZSBgYXBwbGljYXRpb25gLiBEZWZhdWx0IHZhbHVlIGlzIGBMZWRnZXJXYC5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgVHJhbnNwb3J0Tm9kZUhpZCBmcm9tIFwiQGxlZGdlcmhxL2h3LXRyYW5zcG9ydC1ub2RlLWhpZFwiO1xuICAgKiBjb25zdCBteU5vZGVUcmFuc3BvcnQgPSBhd2FpdCBUcmFuc3BvcnROb2RlSGlkLmNyZWF0ZSgpO1xuICAgKiBjb25zdCBteUxlZGdlclNpZ25lciA9IG5ldyBMZWRnZXJTaWduZXIobXlOb2RlVHJhbnNwb3J0LCAwKTtcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGFjY291bnRJRCwgZWlwMjY0NWFwcGxpY2F0aW9uID0gXCJMZWRnZXJXXCIpIHtcbiAgICBhc3NlcnQoYWNjb3VudElEID49IDAsIFwiTGVkZ2VyIGFjY291bnQgSUQgc2hhbGwgbm90IGJlIGEgbmVnYXRpdmUgbnVtYmVyLlwiKTtcbiAgICBhc3NlcnQoYWNjb3VudElEIDw9IE1BU0tfMzEsIFwiTGVkZ2VyIGFjY291bnQgSUQgc2hhbGwgYmUgPCAyKiozMS5cIik7XG4gICAgYXNzZXJ0KCEhZWlwMjY0NWFwcGxpY2F0aW9uLCBcIkxlZGdlciBhcHBsaWNhdGlvbiBuYW1lIHNoYWxsIG5vdCBiZSBlbXB0eS5cIik7XG4gICAgdGhpcy50cmFuc3BvcnRlciA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLl90cmFuc3BvcnRlciA9IHRoaXMudHJhbnNwb3J0ZXI7XG4gICAgdGhpcy5hY2NvdW50SUQgPSBhY2NvdW50SUQ7XG4gICAgdGhpcy5wdWJLZXkgPSBcIlwiO1xuICAgIHRoaXMuZnVsbFB1YktleSA9IFwiXCI7XG4gICAgdGhpcy5laXAyNjQ1YXBwbGljYXRpb25OYW1lID0gZWlwMjY0NWFwcGxpY2F0aW9uO1xuICAgIHRoaXMuYXBwVmVyc2lvbiA9IFwiXCI7XG4gICAgdGhpcy5wYXRoQnVmZmVyID0gZ2V0TGVkZ2VyUGF0aEJ1ZmZlcih0aGlzLmFjY291bnRJRCwgdGhpcy5laXAyNjQ1YXBwbGljYXRpb25OYW1lKTtcbiAgfVxuICAvKipcbiAgICogcHJvdmlkZXMgdGhlIFN0YXJrbmV0IHB1YmxpYyBrZXlcbiAgICogQHJldHVybnMgYW4gaGV4IHN0cmluZyA6IDY0IGNoYXJhY3RlcnMgYXJlIFBvaW50IFggY29vcmRpbmF0ZS5cbiAgICovXG4gIGFzeW5jIGdldFB1YktleSgpIHtcbiAgICBpZiAoIXRoaXMucHViS2V5KSBhd2FpdCB0aGlzLmdldFB1YmxpY0tleXMoKTtcbiAgICByZXR1cm4gdGhpcy5wdWJLZXk7XG4gIH1cbiAgLyoqXG4gICAqIHByb3ZpZGVzIHRoZSBmdWxsIHB1YmxpYyBrZXkgKHdpdGggcGFyaXR5IHByZWZpeClcbiAgICogQHJldHVybnMgYW4gaGV4IHN0cmluZyA6IDIgZmlyc3QgY2hhcmFjdGVycyBhcmUgdGhlIHBhcml0eSwgdGhlIDY0IGZvbGxvd2luZyBjaGFyYWN0ZXJzIGFyZSBQb2ludCBYIGNvb3JkaW5hdGUuIDY0IGxhc3QgY2hhcmFjdGVycyBhcmUgUG9pbnQgWSBjb29yZGluYXRlLlxuICAgKi9cbiAgYXN5bmMgZ2V0RnVsbFB1YktleSgpIHtcbiAgICBpZiAoIXRoaXMuZnVsbFB1YktleSkgYXdhaXQgdGhpcy5nZXRQdWJsaWNLZXlzKCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFB1YktleTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGUgU3RhcmtuZXQgQVBQIGltcGxlbWVudGVkIGluIHRoZSBMZWRnZXIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHZlcnNpb24uXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlMZWRnZXJTaWduZXIuZ2V0QXBwVmVyc2lvbigpO1xuICAgKiAvLyByZXN1bHQ9IFwiMS4xLjFcIlxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldEFwcFZlcnNpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFwcFZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDAsIDAsIDApO1xuICAgICAgdGhpcy5hcHBWZXJzaW9uID0gYCR7cmVzcFswXX0uJHtyZXNwWzFdfS4ke3Jlc3BbMl19YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXBwVmVyc2lvbjtcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZSh0eXBlZERhdGFUb0hhc2gsIGFjY291bnRBZGRyZXNzKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YVRvSGFzaCwgYWNjb3VudEFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25zRGV0YWlsKSB7XG4gICAgY29uc3QgY29tcGlsZWRDYWxsZGF0YSA9IGdldEV4ZWN1dGVDYWxsZGF0YSh0cmFuc2FjdGlvbnMsIHRyYW5zYWN0aW9uc0RldGFpbC5jYWlyb1ZlcnNpb24pO1xuICAgIGxldCBtc2dIYXNoO1xuICAgIGlmIChPYmplY3QudmFsdWVzKEVUcmFuc2FjdGlvblZlcnNpb24yKS5pbmNsdWRlcyh0cmFuc2FjdGlvbnNEZXRhaWwudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IHRyYW5zYWN0aW9uc0RldGFpbDtcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVJbnZva2VUcmFuc2FjdGlvbkhhc2gyKHtcbiAgICAgICAgLi4uZGV0LFxuICAgICAgICBzZW5kZXJBZGRyZXNzOiBkZXQud2FsbGV0QWRkcmVzcyxcbiAgICAgICAgY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgICAgdmVyc2lvbjogZGV0LnZlcnNpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnZhbHVlcyhhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uMykuaW5jbHVkZXModHJhbnNhY3Rpb25zRGV0YWlsLnZlcnNpb24pKSB7XG4gICAgICBjb25zdCBkZXQgPSB0cmFuc2FjdGlvbnNEZXRhaWw7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlSW52b2tlVHJhbnNhY3Rpb25IYXNoMih7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2VuZGVyQWRkcmVzczogZGV0LndhbGxldEFkZHJlc3MsXG4gICAgICAgIGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25UcmFuc2FjdGlvbiB2ZXJzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaWduUmF3KG1zZ0hhc2gpO1xuICB9XG4gIGFzeW5jIHNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ29uc3RydWN0b3JDYWxsZGF0YSA9IENhbGxEYXRhLmNvbXBpbGUoZGV0YWlscy5jb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBsZXQgbXNnSGFzaDtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhFVHJhbnNhY3Rpb25WZXJzaW9uMikuaW5jbHVkZXMoZGV0YWlscy52ZXJzaW9uKSkge1xuICAgICAgY29uc3QgZGV0ID0gZGV0YWlscztcbiAgICAgIG1zZ0hhc2ggPSBjYWxjdWxhdGVEZXBsb3lBY2NvdW50VHJhbnNhY3Rpb25IYXNoMyh7XG4gICAgICAgIC4uLmRldCxcbiAgICAgICAgc2FsdDogZGV0LmFkZHJlc3NTYWx0LFxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxkYXRhOiBjb21waWxlZENvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHNhbHQ6IGRldC5hZGRyZXNzU2FsdCxcbiAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxkYXRhLFxuICAgICAgICB2ZXJzaW9uOiBkZXQudmVyc2lvbixcbiAgICAgICAgbm9uY2VEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5ub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlKSxcbiAgICAgICAgZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGU6IGludERBTShkZXQuZmVlRGF0YUF2YWlsYWJpbGl0eU1vZGUpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uIHZlcnNpb25cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25SYXcobXNnSGFzaCk7XG4gIH1cbiAgYXN5bmMgc2lnbkRlY2xhcmVUcmFuc2FjdGlvbihkZXRhaWxzKSB7XG4gICAgbGV0IG1zZ0hhc2g7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoRVRyYW5zYWN0aW9uVmVyc2lvbjIpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMpLmluY2x1ZGVzKGRldGFpbHMudmVyc2lvbikpIHtcbiAgICAgIGNvbnN0IGRldCA9IGRldGFpbHM7XG4gICAgICBtc2dIYXNoID0gY2FsY3VsYXRlRGVjbGFyZVRyYW5zYWN0aW9uSGFzaDMoe1xuICAgICAgICAuLi5kZXQsXG4gICAgICAgIHZlcnNpb246IGRldC52ZXJzaW9uLFxuICAgICAgICBub25jZURhdGFBdmFpbGFiaWxpdHlNb2RlOiBpbnREQU0oZGV0Lm5vbmNlRGF0YUF2YWlsYWJpbGl0eU1vZGUpLFxuICAgICAgICBmZWVEYXRhQXZhaWxhYmlsaXR5TW9kZTogaW50REFNKGRldC5mZWVEYXRhQXZhaWxhYmlsaXR5TW9kZSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcInVuc3VwcG9ydGVkIHNpZ25EZWNsYXJlVHJhbnNhY3Rpb24gdmVyc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJhdyhtc2dIYXNoKTtcbiAgfVxuICBhc3luYyBzaWduUmF3KG1zZ0hhc2gpIHtcbiAgICBhZGRIZXhQcmVmaXgoXG4gICAgICBidWYyaGV4KGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgMiwgMCwgMCwgQnVmZmVyLmZyb20odGhpcy5wYXRoQnVmZmVyKSkpXG4gICAgKTtcbiAgICBjb25zdCBzaGlmdGVkSGFzaCA9IHRvSGV4KEJpZ0ludChtc2dIYXNoKSA8PCA0bik7XG4gICAgY29uc3QgYnVmZjIgPSBoZXhUb0J5dGVzKHNoaWZ0ZWRIYXNoKTtcbiAgICBjb25zdCByZXNwU2lnbjIgPSBVaW50OEFycmF5LmZyb20oXG4gICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnRlci5zZW5kKE51bWJlcihcIjB4NWFcIiksIDIsIDEsIDAsIEJ1ZmZlci5mcm9tKGJ1ZmYyKSlcbiAgICApO1xuICAgIGNvbnN0IHIgPSBCaWdJbnQoYWRkSGV4UHJlZml4KGJ1ZjJoZXgocmVzcFNpZ24yLnN1YmFycmF5KDEsIDMzKSkpKTtcbiAgICBjb25zdCBzID0gQmlnSW50KGFkZEhleFByZWZpeChidWYyaGV4KHJlc3BTaWduMi5zdWJhcnJheSgzMywgNjUpKSkpO1xuICAgIGNvbnN0IHYgPSByZXNwU2lnbjJbNjVdO1xuICAgIGNvbnN0IHNpZ24wID0gbmV3IHN0YXJrQ3VydmUuU2lnbmF0dXJlKHIsIHMpO1xuICAgIGNvbnN0IHNpZ24xID0gc2lnbjAuYWRkUmVjb3ZlcnlCaXQodik7XG4gICAgcmV0dXJuIHNpZ24xO1xuICB9XG4gIGFzeW5jIGdldFB1YmxpY0tleXMoKSB7XG4gICAgY29uc3QgcGF0aEJ1ZmYgPSB0aGlzLnBhdGhCdWZmZXI7XG4gICAgY29uc3QgcmVzcEdldFB1YmxpYyA9IFVpbnQ4QXJyYXkuZnJvbShcbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydGVyLnNlbmQoTnVtYmVyKFwiMHg1YVwiKSwgMSwgMCwgMCwgQnVmZmVyLmZyb20ocGF0aEJ1ZmYpKVxuICAgICk7XG4gICAgdGhpcy5wdWJLZXkgPSBhZGRIZXhQcmVmaXgoYnVmMmhleChyZXNwR2V0UHVibGljLnN1YmFycmF5KDEsIDMzKSkpO1xuICAgIHRoaXMuZnVsbFB1YktleSA9IGFkZEhleFByZWZpeChidWYyaGV4KHJlc3BHZXRQdWJsaWMuc3ViYXJyYXkoMCwgNjUpKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRMZWRnZXJQYXRoQnVmZmVyKGFjY291bnRJZCwgYXBwbGljYXRpb25OYW1lKSB7XG4gIGNvbnN0IHBhdGgwYnVmZiA9IG5ldyBVaW50OEFycmF5KFsxMjgsIDAsIDEwLCA4NV0pO1xuICBjb25zdCBwYXRoMWJ1ZmYgPSBuZXcgVWludDhBcnJheShbNzEsIDY1LCAyMzMsIDIwMV0pO1xuICBjb25zdCBwYXRoMmJ1ZmYgPSBhcHBsaWNhdGlvbk5hbWUgPT09IFwiTGVkZ2VyV1wiID8gbmV3IFVpbnQ4QXJyYXkoWzQzLCAyMDYsIDIzMSwgMjE5XSkgOiBzdHJpbmdUb1NoYTI1NlRvQXJyYXlCdWZmNChhcHBsaWNhdGlvbk5hbWUpO1xuICBjb25zdCBwYXRoM2J1ZmYgPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMF0pO1xuICBjb25zdCBoZXggPSB0b0hleChhY2NvdW50SWQpO1xuICBjb25zdCBwYWRkZWQgPSBhZGRIZXhQcmVmaXgocmVtb3ZlSGV4UHJlZml4KGhleCkucGFkU3RhcnQoOCwgXCIwXCIpKTtcbiAgY29uc3QgcGF0aDRidWZmID0gaGV4VG9CeXRlcyhwYWRkZWQpO1xuICBjb25zdCBwYXRoNWJ1ZmYgPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMF0pO1xuICBjb25zdCBwYXRoQnVmZiA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXIoW1xuICAgIHBhdGgwYnVmZixcbiAgICBwYXRoMWJ1ZmYsXG4gICAgcGF0aDJidWZmLFxuICAgIHBhdGgzYnVmZixcbiAgICBwYXRoNGJ1ZmYsXG4gICAgcGF0aDVidWZmXG4gIF0pO1xuICByZXR1cm4gcGF0aEJ1ZmY7XG59XG5cbi8vIHNyYy91dGlscy9ldmVudHMvaW5kZXgudHNcbnZhciBldmVudHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZXZlbnRzX2V4cG9ydHMsIHtcbiAgZ2V0QWJpRXZlbnRzOiAoKSA9PiBnZXRBYmlFdmVudHMsXG4gIGlzQWJpRXZlbnQ6ICgpID0+IGlzQWJpRXZlbnQsXG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdCxcbiAgcGFyc2VFdmVudHM6ICgpID0+IHBhcnNlRXZlbnRzLFxuICBwYXJzZVVEQ0V2ZW50OiAoKSA9PiBwYXJzZVVEQ0V2ZW50XG59KTtcbmZ1bmN0aW9uIGlzQWJpRXZlbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QudHlwZSA9PT0gXCJldmVudFwiO1xufVxuZnVuY3Rpb24gZ2V0Q2Fpcm8wQWJpRXZlbnRzKGFiaSkge1xuICByZXR1cm4gYWJpLmZpbHRlcigoYWJpRW50cnkpID0+IGFiaUVudHJ5LnR5cGUgPT09IFwiZXZlbnRcIikucmVkdWNlKChhY2MsIGFiaUVudHJ5KSA9PiB7XG4gICAgY29uc3QgZW50cnlOYW1lID0gYWJpRW50cnkubmFtZTtcbiAgICBjb25zdCBhYmlFbnRyeU1vZCA9IHsgLi4uYWJpRW50cnkgfTtcbiAgICBhYmlFbnRyeU1vZC5uYW1lID0gZW50cnlOYW1lO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBbYWRkSGV4UHJlZml4KHN0YXJrQ3VydmUua2VjY2FrKHV0ZjhUb0FycmF5KGVudHJ5TmFtZSkpLnRvU3RyaW5nKDE2KSldOiBhYmlFbnRyeU1vZFxuICAgIH07XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldENhaXJvMUFiaUV2ZW50cyhhYmkpIHtcbiAgY29uc3QgYWJpRXZlbnRzU3RydWN0cyA9IGFiaS5maWx0ZXIoKG9iaikgPT4gaXNBYmlFdmVudChvYmopICYmIG9iai5raW5kID09PSBcInN0cnVjdFwiKTtcbiAgY29uc3QgYWJpRXZlbnRzRW51bXMgPSBhYmkuZmlsdGVyKChvYmopID0+IGlzQWJpRXZlbnQob2JqKSAmJiBvYmoua2luZCA9PT0gXCJlbnVtXCIpO1xuICBjb25zdCBhYmlFdmVudHNEYXRhID0gYWJpRXZlbnRzU3RydWN0cy5yZWR1Y2UoKGFjYywgZXZlbnQpID0+IHtcbiAgICBsZXQgbmFtZUxpc3QgPSBbXTtcbiAgICBsZXQgeyBuYW1lIH0gPSBldmVudDtcbiAgICBsZXQgZmxhdCA9IGZhbHNlO1xuICAgIGNvbnN0IGZpbmROYW1lID0gKHZhcmlhbnQpID0+IHZhcmlhbnQudHlwZSA9PT0gbmFtZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgZXZlbnRFbnVtID0gYWJpRXZlbnRzRW51bXMuZmluZCgoZXZlbnRFKSA9PiBldmVudEUudmFyaWFudHMuc29tZShmaW5kTmFtZSkpO1xuICAgICAgaWYgKHR5cGVvZiBldmVudEVudW0gPT09IFwidW5kZWZpbmVkXCIpIGJyZWFrO1xuICAgICAgY29uc3QgdmFyaWFudCA9IGV2ZW50RW51bS52YXJpYW50cy5maW5kKGZpbmROYW1lKTtcbiAgICAgIG5hbWVMaXN0LnVuc2hpZnQodmFyaWFudC5uYW1lKTtcbiAgICAgIGlmICh2YXJpYW50LmtpbmQgPT09IFwiZmxhdFwiKSBmbGF0ID0gdHJ1ZTtcbiAgICAgIG5hbWUgPSBldmVudEVudW0ubmFtZTtcbiAgICB9XG4gICAgaWYgKG5hbWVMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW5jeSBpbiBBQkkgZXZlbnRzIGRlZmluaXRpb24uXCIpO1xuICAgIH1cbiAgICBpZiAoZmxhdCkgbmFtZUxpc3QgPSBbbmFtZUxpc3RbbmFtZUxpc3QubGVuZ3RoIC0gMV1dO1xuICAgIGNvbnN0IGZpbmFsID0gbmFtZUxpc3QucG9wKCk7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkoZmluYWwpKS50b1N0cmluZygxNikpXTogZXZlbnRcbiAgICB9O1xuICAgIHdoaWxlIChuYW1lTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIFthZGRIZXhQcmVmaXgoc3RhcmtDdXJ2ZS5rZWNjYWsodXRmOFRvQXJyYXkobmFtZUxpc3QucG9wKCkpKS50b1N0cmluZygxNikpXTogcmVzdWx0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXN1bHQgPSB7IC4uLnJlc3VsdCB9O1xuICAgIHJldHVybiBtZXJnZUFiaUV2ZW50cyhhY2MsIHJlc3VsdCk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGFiaUV2ZW50c0RhdGE7XG59XG5mdW5jdGlvbiBnZXRBYmlFdmVudHMoYWJpKSB7XG4gIHJldHVybiBpc0NhaXJvMUFiaShhYmkpID8gZ2V0Q2Fpcm8xQWJpRXZlbnRzKGFiaSkgOiBnZXRDYWlybzBBYmlFdmVudHMoYWJpKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSk7XG59XG5mdW5jdGlvbiBtZXJnZUFiaUV2ZW50cyh0YXJnZXQsIHNvdXJjZSkge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuICBpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRhcmdldCkpIE9iamVjdC5hc3NpZ24ob3V0cHV0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KTtcbiAgICAgICAgZWxzZSBvdXRwdXRba2V5XSA9IG1lcmdlQWJpRXZlbnRzKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgeyBba2V5XTogc291cmNlW2tleV0gfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnRzKHByb3ZpZGVyUmVjZWl2ZWRFdmVudHMsIGFiaUV2ZW50cywgYWJpU3RydWN0cywgYWJpRW51bXMpIHtcbiAgY29uc3QgcmV0ID0gcHJvdmlkZXJSZWNlaXZlZEV2ZW50cy5mbGF0KCkucmVkdWNlKChhY2MsIHJlY0V2ZW50KSA9PiB7XG4gICAgbGV0IGFiaUV2ZW50ID0gYWJpRXZlbnRzW3JlY0V2ZW50LmtleXMuc2hpZnQoKSA/PyAwXTtcbiAgICBpZiAoIWFiaUV2ZW50KSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICB3aGlsZSAoIWFiaUV2ZW50Lm5hbWUpIHtcbiAgICAgIGNvbnN0IGhhc2hOYW1lID0gcmVjRXZlbnQua2V5cy5zaGlmdCgpO1xuICAgICAgYXNzZXJ0KCEhaGFzaE5hbWUsICdOb3QgZW5vdWdoIGRhdGEgaW4gXCJrZXlcIiBwcm9wZXJ0eSBvZiB0aGlzIGV2ZW50LicpO1xuICAgICAgYWJpRXZlbnQgPSBhYmlFdmVudFtoYXNoTmFtZV07XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0ge307XG4gICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV0gPSB7fTtcbiAgICBjb25zdCBrZXlzSXRlciA9IHJlY0V2ZW50LmtleXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IGRhdGFJdGVyID0gcmVjRXZlbnQuZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgY29uc3QgYWJpRXZlbnRLZXlzID0gYWJpRXZlbnQubWVtYmVycz8uZmlsdGVyKChpdCkgPT4gaXQua2luZCA9PT0gXCJrZXlcIikgfHwgYWJpRXZlbnQua2V5cztcbiAgICBjb25zdCBhYmlFdmVudERhdGEgPSBhYmlFdmVudC5tZW1iZXJzPy5maWx0ZXIoKGl0KSA9PiBpdC5raW5kID09PSBcImRhdGFcIikgfHwgYWJpRXZlbnQuZGF0YTtcbiAgICBhYmlFdmVudEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtrZXkubmFtZV0gPSByZXNwb25zZVBhcnNlcihcbiAgICAgICAga2V5c0l0ZXIsXG4gICAgICAgIGtleSxcbiAgICAgICAgYWJpU3RydWN0cyxcbiAgICAgICAgYWJpRW51bXMsXG4gICAgICAgIHBhcnNlZEV2ZW50W2FiaUV2ZW50Lm5hbWVdXG4gICAgICApO1xuICAgIH0pO1xuICAgIGFiaUV2ZW50RGF0YS5mb3JFYWNoKChkYXRhKSA9PiB7XG4gICAgICBwYXJzZWRFdmVudFthYmlFdmVudC5uYW1lXVtkYXRhLm5hbWVdID0gcmVzcG9uc2VQYXJzZXIoXG4gICAgICAgIGRhdGFJdGVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICBhYmlTdHJ1Y3RzLFxuICAgICAgICBhYmlFbnVtcyxcbiAgICAgICAgcGFyc2VkRXZlbnRbYWJpRXZlbnQubmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgYWNjLnB1c2gocGFyc2VkRXZlbnQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHBhcnNlVURDRXZlbnQodHhSZWNlaXB0KSB7XG4gIGlmICghdHhSZWNlaXB0LmV2ZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVEQyBlbWl0dGVkIGV2ZW50IGlzIGVtcHR5XCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gdHhSZWNlaXB0LmV2ZW50cy5maW5kKFxuICAgIChpdCkgPT4gY2xlYW5IZXgoaXQuZnJvbV9hZGRyZXNzKSA9PT0gY2xlYW5IZXgoVURDLkFERFJFU1MpXG4gICkgfHwge1xuICAgIGRhdGE6IFtdXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHJhbnNhY3Rpb25faGFzaDogdHhSZWNlaXB0LnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgY29udHJhY3RfYWRkcmVzczogZXZlbnQuZGF0YVswXSxcbiAgICBhZGRyZXNzOiBldmVudC5kYXRhWzBdLFxuICAgIGRlcGxveWVyOiBldmVudC5kYXRhWzFdLFxuICAgIHVuaXF1ZTogZXZlbnQuZGF0YVsyXSxcbiAgICBjbGFzc0hhc2g6IGV2ZW50LmRhdGFbM10sXG4gICAgY2FsbGRhdGFfbGVuOiBldmVudC5kYXRhWzRdLFxuICAgIGNhbGxkYXRhOiBldmVudC5kYXRhLnNsaWNlKDUsIDUgKyBwYXJzZUludChldmVudC5kYXRhWzRdLCAxNikpLFxuICAgIHNhbHQ6IGV2ZW50LmRhdGFbZXZlbnQuZGF0YS5sZW5ndGggLSAxXVxuICB9O1xufVxuXG4vLyBzcmMvYWNjb3VudC9kZWZhdWx0LnRzXG52YXIgQWNjb3VudCA9IGNsYXNzIGV4dGVuZHMgUnBjUHJvdmlkZXIyIHtcbiAgc2lnbmVyO1xuICBhZGRyZXNzO1xuICBjYWlyb1ZlcnNpb247XG4gIHRyYW5zYWN0aW9uVmVyc2lvbjtcbiAgY29uc3RydWN0b3IocHJvdmlkZXJPck9wdGlvbnMsIGFkZHJlc3MsIHBrT3JTaWduZXIsIGNhaXJvVmVyc2lvbiwgdHJhbnNhY3Rpb25WZXJzaW9uID0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMikge1xuICAgIHN1cGVyKHByb3ZpZGVyT3JPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zaWduZXIgPSBpc1N0cmluZyhwa09yU2lnbmVyKSB8fCBwa09yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBTaWduZXIocGtPclNpZ25lcikgOiBwa09yU2lnbmVyO1xuICAgIGlmIChjYWlyb1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm9WZXJzaW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNhY3Rpb25WZXJzaW9uID0gdHJhbnNhY3Rpb25WZXJzaW9uO1xuICB9XG4gIC8vIHByb3ZpZGVkIHZlcnNpb24gb3IgY29udHJhY3QgYmFzZWQgcHJlZmVycmVkIHRyYW5zYWN0aW9uVmVyc2lvblxuICBnZXRQcmVmZXJyZWRWZXJzaW9uKHR5cGUxMiwgdHlwZTMpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpIHJldHVybiB0eXBlMztcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvblZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjIpIHJldHVybiB0eXBlMTI7XG4gICAgcmV0dXJuIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjM7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2UoYmxvY2tJZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldE5vbmNlRm9yQWRkcmVzcyh0aGlzLmFkZHJlc3MsIGJsb2NrSWRlbnRpZmllcik7XG4gIH1cbiAgYXN5bmMgZ2V0Tm9uY2VTYWZlKG5vbmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b0JpZ0ludChub25jZSA/PyBhd2FpdCB0aGlzLmdldE5vbmNlKCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gMG47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIENhaXJvIHZlcnNpb24gZnJvbSB0aGUgbmV0d29yayBhbmQgc2V0cyBgY2Fpcm9WZXJzaW9uYCBpZiBub3QgYWxyZWFkeSBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gY2xhc3NIYXNoIGlmIHByb3ZpZGVkIGRldGVjdHMgQ2Fpcm8gdmVyc2lvbiBmcm9tIGNsYXNzSGFzaCwgb3RoZXJ3aXNlIGZyb20gdGhlIGFjY291bnQgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q2Fpcm9WZXJzaW9uKGNsYXNzSGFzaCkge1xuICAgIGlmICghdGhpcy5jYWlyb1ZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHsgY2Fpcm8gfSA9IGNsYXNzSGFzaCA/IGF3YWl0IHN1cGVyLmdldENvbnRyYWN0VmVyc2lvbih2b2lkIDAsIGNsYXNzSGFzaCkgOiBhd2FpdCBzdXBlci5nZXRDb250cmFjdFZlcnNpb24odGhpcy5hZGRyZXNzKTtcbiAgICAgIHRoaXMuY2Fpcm9WZXJzaW9uID0gY2Fpcm87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhaXJvVmVyc2lvbjtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZUludm9rZUZlZShjYWxscywgZXN0aW1hdGVGZWVEZXRhaWxzKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUludm9rZUZlZShjYWxscywgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9uY2U6IHByb3ZpZGVkTm9uY2UsXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICB2ZXJzaW9uOiBwcm92aWRlZFZlcnNpb24sXG4gICAgICBza2lwVmFsaWRhdGUgPSB0cnVlXG4gICAgfSA9IGRldGFpbHM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25zID0gQXJyYXkuaXNBcnJheShjYWxscykgPyBjYWxscyA6IFtjYWxsc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjEsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uRjMpLFxuICAgICAgdG9GZWVWZXJzaW9uKHByb3ZpZGVkVmVyc2lvbilcbiAgICApO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBzaWduZXJEZXRhaWxzID0ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgbm9uY2UsXG4gICAgICBtYXhGZWU6IFpFUk8sXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIGNhaXJvVmVyc2lvbjogYXdhaXQgdGhpcy5nZXRDYWlyb1ZlcnNpb24oKSxcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH07XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKHRyYW5zYWN0aW9ucywgc2lnbmVyRGV0YWlscyk7XG4gICAgcmV0dXJuIHN1cGVyLmdldEludm9rZUVzdGltYXRlRmVlKFxuICAgICAgeyAuLi5pbnZvY2F0aW9uIH0sXG4gICAgICB7IC4uLnYzRGV0YWlscyhkZXRhaWxzKSwgdmVyc2lvbiwgbm9uY2UgfSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIGRldGFpbHMuc2tpcFZhbGlkYXRlXG4gICAgKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlY2xhcmVGZWUocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgbm9uY2U6IHByb3ZpZGVkTm9uY2UsXG4gICAgICB2ZXJzaW9uOiBwcm92aWRlZFZlcnNpb24sXG4gICAgICBza2lwVmFsaWRhdGUgPSB0cnVlXG4gICAgfSA9IGRldGFpbHM7XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChwcm92aWRlZE5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgIWlzU2llcnJhKHBheWxvYWQuY29udHJhY3QpID8gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSA6IHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYyLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLkYzKSxcbiAgICAgIHRvRmVlVmVyc2lvbihwcm92aWRlZFZlcnNpb24pXG4gICAgKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0VHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLmJ1aWxkRGVjbGFyZVBheWxvYWQocGF5bG9hZCwge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgbm9uY2UsXG4gICAgICBjaGFpbklkLFxuICAgICAgdmVyc2lvbixcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwLFxuICAgICAgLy8gdW51c2VkIHBhcmFtZXRlclxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldERlY2xhcmVFc3RpbWF0ZUZlZShcbiAgICAgIGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uLFxuICAgICAgeyAuLi52M0RldGFpbHMoZGV0YWlscyksIHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBkZXRhaWxzLnNraXBWYWxpZGF0ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVBY2NvdW50RGVwbG95RmVlKHtcbiAgICBjbGFzc0hhc2gsXG4gICAgYWRkcmVzc1NhbHQgPSAwLFxuICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXSxcbiAgICBjb250cmFjdEFkZHJlc3NcbiAgfSwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgeyBibG9ja0lkZW50aWZpZXIsIHZlcnNpb246IHByb3ZpZGVkVmVyc2lvbiwgc2tpcFZhbGlkYXRlID0gdHJ1ZSB9ID0gZGV0YWlscztcbiAgICBjb25zdCB2ZXJzaW9uID0gdG9UcmFuc2FjdGlvblZlcnNpb24oXG4gICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMyksXG4gICAgICB0b0ZlZVZlcnNpb24ocHJvdmlkZWRWZXJzaW9uKVxuICAgICk7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKFxuICAgICAgeyBjbGFzc0hhc2gsIGFkZHJlc3NTYWx0LCBjb25zdHJ1Y3RvckNhbGxkYXRhLCBjb250cmFjdEFkZHJlc3MgfSxcbiAgICAgIHtcbiAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICBub25jZSxcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgd2FsbGV0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAvLyB1bnVzZWQgcGFyYW1ldGVyXG4gICAgICAgIG1heEZlZTogWkVSTyxcbiAgICAgICAgY2Fpcm9WZXJzaW9uOiB2b2lkIDAsXG4gICAgICAgIC8vIHVudXNlZCBwYXJhbWV0ZXIsXG4gICAgICAgIHNraXBWYWxpZGF0ZVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHN1cGVyLmdldERlcGxveUFjY291bnRFc3RpbWF0ZUZlZShcbiAgICAgIHsgLi4ucGF5bG9hZCB9LFxuICAgICAgeyAuLi52M0RldGFpbHMoZGV0YWlscyksIHZlcnNpb24sIG5vbmNlIH0sXG4gICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICBkZXRhaWxzLnNraXBWYWxpZGF0ZVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlSW52b2tlRmVlKGNhbGxzLCBkZXRhaWxzKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZUZlZUJ1bGsoaW52b2NhdGlvbnMsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgdmVyc2lvbiwgc2tpcFZhbGlkYXRlIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IGFjY291bnRJbnZvY2F0aW9ucyA9IGF3YWl0IHRoaXMuYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgdmVyc2lvbnM6IFtcbiAgICAgICAgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMSxcbiAgICAgICAgLy8gbm9uLXNpZXJyYVxuICAgICAgICB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgICAgICB0aGlzLmdldFByZWZlcnJlZFZlcnNpb24oYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMiwgYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5GMyksXG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICApXG4gICAgICAgIC8vIHNpZXJyYVxuICAgICAgXSxcbiAgICAgIG5vbmNlLFxuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1cGVyLmdldEVzdGltYXRlRmVlQnVsayhhY2NvdW50SW52b2NhdGlvbnMsIHtcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24oaW52b2NhdGlvbnMsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gdHJ1ZSwgc2tpcEV4ZWN1dGUsIHZlcnNpb24gfSA9IGRldGFpbHM7XG4gICAgY29uc3QgYWNjb3VudEludm9jYXRpb25zID0gYXdhaXQgdGhpcy5hY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5KGludm9jYXRpb25zLCB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICB2ZXJzaW9uczogW1xuICAgICAgICBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLFxuICAgICAgICAvLyBub24tc2llcnJhXG4gICAgICAgIHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSxcbiAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICBub25jZSxcbiAgICAgIGJsb2NrSWRlbnRpZmllcixcbiAgICAgIHNraXBWYWxpZGF0ZVxuICAgIH0pO1xuICAgIHJldHVybiBzdXBlci5nZXRTaW11bGF0ZVRyYW5zYWN0aW9uKGFjY291bnRJbnZvY2F0aW9ucywge1xuICAgICAgYmxvY2tJZGVudGlmaWVyLFxuICAgICAgc2tpcFZhbGlkYXRlLFxuICAgICAgc2tpcEV4ZWN1dGVcbiAgICB9KTtcbiAgfVxuICBhc3luYyBleGVjdXRlKHRyYW5zYWN0aW9ucywgYXJnMiwgdHJhbnNhY3Rpb25zRGV0YWlsID0ge30pIHtcbiAgICBjb25zdCBkZXRhaWxzID0gYXJnMiA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkoYXJnMikgPyB0cmFuc2FjdGlvbnNEZXRhaWwgOiBhcmcyO1xuICAgIGNvbnN0IGNhbGxzID0gQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpID8gdHJhbnNhY3Rpb25zIDogW3RyYW5zYWN0aW9uc107XG4gICAgY29uc3Qgbm9uY2UgPSB0b0JpZ0ludChkZXRhaWxzLm5vbmNlID8/IGF3YWl0IHRoaXMuZ2V0Tm9uY2UoKSk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgdGhpcy5nZXRQcmVmZXJyZWRWZXJzaW9uKGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjEsIGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24uVjMpLFxuICAgICAgLy8gVE9ETzogZG9lcyB0aGlzIGRlcGVuZCBvbiBjYWlybyB2ZXJzaW9uID9cbiAgICAgIGRldGFpbHMudmVyc2lvblxuICAgICk7XG4gICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0aGlzLmdldFVuaXZlcnNhbFN1Z2dlc3RlZEZlZShcbiAgICAgIHZlcnNpb24sXG4gICAgICB7IHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovLCBwYXlsb2FkOiB0cmFuc2FjdGlvbnMgfSxcbiAgICAgIHtcbiAgICAgICAgLi4uZGV0YWlscyxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICB3YWxsZXRBZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICBub25jZSxcbiAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGNoYWluSWQsXG4gICAgICBjYWlyb1ZlcnNpb246IGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKClcbiAgICB9O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbihjYWxscywgc2lnbmVyRGV0YWlscyk7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRFeGVjdXRlQ2FsbGRhdGEoY2FsbHMsIGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCkpO1xuICAgIHJldHVybiB0aGlzLmludm9rZUZ1bmN0aW9uKFxuICAgICAgeyBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcywgY2FsbGRhdGEsIHNpZ25hdHVyZSB9LFxuICAgICAge1xuICAgICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIG1heEZlZTogZXN0aW1hdGUubWF4RmVlLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRmlyc3QgY2hlY2sgaWYgY29udHJhY3QgaXMgYWxyZWFkeSBkZWNsYXJlZCwgaWYgbm90IGRlY2xhcmUgaXRcbiAgICogSWYgY29udHJhY3QgYWxyZWFkeSBkZWNsYXJlZCByZXR1cm5lZCB0cmFuc2FjdGlvbl9oYXNoIGlzICcnLlxuICAgKiBNZXRob2Qgd2lsbCBwYXNzIGV2ZW4gaWYgY29udHJhY3QgaXMgYWxyZWFkeSBkZWNsYXJlZFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zRGV0YWlsIChvcHRpb25hbClcbiAgICovXG4gIGFzeW5jIGRlY2xhcmVJZk5vdChwYXlsb2FkLCB0cmFuc2FjdGlvbnNEZXRhaWwgPSB7fSkge1xuICAgIGNvbnN0IGRlY2xhcmVDb250cmFjdFBheWxvYWQgPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0Q2xhc3NCeUhhc2goZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jbGFzc0hhc2gpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJlKHBheWxvYWQsIHRyYW5zYWN0aW9uc0RldGFpbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2FjdGlvbl9oYXNoOiBcIlwiLFxuICAgICAgY2xhc3NfaGFzaDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jbGFzc0hhc2hcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRlY2xhcmUocGF5bG9hZCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgZGVjbGFyZUNvbnRyYWN0UGF5bG9hZCA9IGV4dHJhY3RDb250cmFjdEhhc2hlcyhwYXlsb2FkKTtcbiAgICBjb25zdCB7IG5vbmNlLCB2ZXJzaW9uOiBwcm92aWRlZFZlcnNpb24gfSA9IGRldGFpbHM7XG4gICAgY29uc3QgdmVyc2lvbiA9IHRvVHJhbnNhY3Rpb25WZXJzaW9uKFxuICAgICAgIWlzU2llcnJhKHBheWxvYWQuY29udHJhY3QpID8gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMSA6IHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYyLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSxcbiAgICAgIHByb3ZpZGVkVmVyc2lvblxuICAgICk7XG4gICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0aGlzLmdldFVuaXZlcnNhbFN1Z2dlc3RlZEZlZShcbiAgICAgIHZlcnNpb24sXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiREVDTEFSRVwiIC8qIERFQ0xBUkUgKi8sXG4gICAgICAgIHBheWxvYWQ6IGRlY2xhcmVDb250cmFjdFBheWxvYWRcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC4uLmRldGFpbHMsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IGRlY2xhcmVEZXRhaWxzID0ge1xuICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgcmVzb3VyY2VCb3VuZHM6IGVzdGltYXRlLnJlc291cmNlQm91bmRzLFxuICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICBub25jZTogdG9CaWdJbnQobm9uY2UgPz8gYXdhaXQgdGhpcy5nZXROb25jZSgpKSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBjaGFpbklkOiBhd2FpdCB0aGlzLmdldENoYWluSWQoKSxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhaXJvVmVyc2lvbjogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZChcbiAgICAgIGRlY2xhcmVDb250cmFjdFBheWxvYWQsXG4gICAgICBkZWNsYXJlRGV0YWlsc1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZGVjbGFyZUNvbnRyYWN0KGRlY2xhcmVDb250cmFjdFRyYW5zYWN0aW9uLCBkZWNsYXJlRGV0YWlscyk7XG4gIH1cbiAgYXN5bmMgZGVwbG95KHBheWxvYWQsIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2FsbHMsIGFkZHJlc3NlcyB9ID0gYnVpbGRVRENDYWxsKHBheWxvYWQsIHRoaXMuYWRkcmVzcyk7XG4gICAgY29uc3QgaW52b2tlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGUoY2FsbHMsIHZvaWQgMCwgZGV0YWlscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludm9rZVJlc3BvbnNlLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogYWRkcmVzc2VzXG4gICAgfTtcbiAgfVxuICBhc3luYyBkZXBsb3lDb250cmFjdChwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBkZXBsb3lUeCA9IGF3YWl0IHRoaXMuZGVwbG95KHBheWxvYWQsIGRldGFpbHMpO1xuICAgIGNvbnN0IHR4UmVjZWlwdCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKGRlcGxveVR4LnRyYW5zYWN0aW9uX2hhc2gpO1xuICAgIHJldHVybiBwYXJzZVVEQ0V2ZW50KHR4UmVjZWlwdCk7XG4gIH1cbiAgYXN5bmMgZGVjbGFyZUFuZERlcGxveShwYXlsb2FkLCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yQ2FsbGRhdGEsIHNhbHQsIHVuaXF1ZSB9ID0gcGF5bG9hZDtcbiAgICBsZXQgZGVjbGFyZSA9IGF3YWl0IHRoaXMuZGVjbGFyZUlmTm90KHBheWxvYWQsIGRldGFpbHMpO1xuICAgIGlmIChkZWNsYXJlLnRyYW5zYWN0aW9uX2hhc2ggIT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy53YWl0Rm9yVHJhbnNhY3Rpb24oZGVjbGFyZS50cmFuc2FjdGlvbl9oYXNoKTtcbiAgICAgIGRlY2xhcmUgPSB7IC4uLmRlY2xhcmUsIC4uLnR4IH07XG4gICAgfVxuICAgIGNvbnN0IGRlcGxveSA9IGF3YWl0IHRoaXMuZGVwbG95Q29udHJhY3QoXG4gICAgICB7IGNsYXNzSGFzaDogZGVjbGFyZS5jbGFzc19oYXNoLCBzYWx0LCB1bmlxdWUsIGNvbnN0cnVjdG9yQ2FsbGRhdGEgfSxcbiAgICAgIGRldGFpbHNcbiAgICApO1xuICAgIHJldHVybiB7IGRlY2xhcmU6IHsgLi4uZGVjbGFyZSB9LCBkZXBsb3kgfTtcbiAgfVxuICBkZXBsb3lTZWxmID0gdGhpcy5kZXBsb3lBY2NvdW50O1xuICBhc3luYyBkZXBsb3lBY2NvdW50KHtcbiAgICBjbGFzc0hhc2gsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGFkZHJlc3NTYWx0ID0gMCxcbiAgICBjb250cmFjdEFkZHJlc3M6IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzXG4gIH0sIGRldGFpbHMgPSB7fSkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB0b1RyYW5zYWN0aW9uVmVyc2lvbihcbiAgICAgIHRoaXMuZ2V0UHJlZmVycmVkVmVyc2lvbihhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYxLCBhcGlfZXhwb3J0cy5FVHJhbnNhY3Rpb25WZXJzaW9uLlYzKSxcbiAgICAgIGRldGFpbHMudmVyc2lvblxuICAgICk7XG4gICAgY29uc3Qgbm9uY2UgPSBaRVJPO1xuICAgIGNvbnN0IGNoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICBjb25zdCBjb21waWxlZENhbGxkYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSBwcm92aWRlZENvbnRyYWN0QWRkcmVzcyA/PyBjYWxjdWxhdGVDb250cmFjdEFkZHJlc3NGcm9tSGFzaChhZGRyZXNzU2FsdCwgY2xhc3NIYXNoLCBjb21waWxlZENhbGxkYXRhLCAwKTtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICAgICAgYWRkcmVzc1NhbHQsXG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXRhaWxzXG4gICAgKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVwbG95QWNjb3VudFRyYW5zYWN0aW9uKHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGE6IGNvbXBpbGVkQ2FsbGRhdGEsXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBhZGRyZXNzU2FsdCxcbiAgICAgIGNoYWluSWQsXG4gICAgICByZXNvdXJjZUJvdW5kczogZXN0aW1hdGUucmVzb3VyY2VCb3VuZHMsXG4gICAgICBtYXhGZWU6IGVzdGltYXRlLm1heEZlZSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBub25jZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmRlcGxveUFjY291bnRDb250cmFjdChcbiAgICAgIHsgY2xhc3NIYXNoLCBhZGRyZXNzU2FsdCwgY29uc3RydWN0b3JDYWxsZGF0YSwgc2lnbmF0dXJlIH0sXG4gICAgICB7XG4gICAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZS5yZXNvdXJjZUJvdW5kcyxcbiAgICAgICAgbWF4RmVlOiBlc3RpbWF0ZS5tYXhGZWUsXG4gICAgICAgIHZlcnNpb25cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKHR5cGVkRGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25lci5zaWduTWVzc2FnZSh0eXBlZERhdGEsIHRoaXMuYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgaGFzaE1lc3NhZ2UodHlwZWREYXRhKSB7XG4gICAgcmV0dXJuIGdldE1lc3NhZ2VIYXNoKHR5cGVkRGF0YSwgdGhpcy5hZGRyZXNzKTtcbiAgfVxuICBhc3luYyB2ZXJpZnlNZXNzYWdlSGFzaChoYXNoLCBzaWduYXR1cmUsIHNpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uTmFtZSwgc2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2UpIHtcbiAgICBjb25zdCBrbm93blNpZ1ZlcmlmaWNhdGlvbkZOYW1lID0gc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lID8gW3NpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uTmFtZV0gOiBbXCJpc1ZhbGlkU2lnbmF0dXJlXCIsIFwiaXNfdmFsaWRfc2lnbmF0dXJlXCJdO1xuICAgIGNvbnN0IGtub3duU2lnbmF0dXJlUmVzcG9uc2UgPSBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZSB8fCB7XG4gICAgICBva1Jlc3BvbnNlOiBbXG4gICAgICAgIC8vIGFueSBub24tbm9rIHJlc3BvbnNlIGlzIHRydWVcbiAgICAgIF0sXG4gICAgICBub2tSZXNwb25zZTogW1xuICAgICAgICBcIjB4MFwiLFxuICAgICAgICAvLyBEZXZuZXRcbiAgICAgICAgXCIweDAwXCJcbiAgICAgICAgLy8gT3BlblplcHBlbGluIDAuNy4wIHRvIDAuOS4wIGludmFsaWQgc2lnbmF0dXJlXG4gICAgICBdLFxuICAgICAgZXJyb3I6IFtcbiAgICAgICAgXCJhcmdlbnQvaW52YWxpZC1zaWduYXR1cmVcIixcbiAgICAgICAgLy8gQXJnZW50WCAwLjMuMCB0byAwLjMuMVxuICAgICAgICBcImlzIGludmFsaWQsIHdpdGggcmVzcGVjdCB0byB0aGUgcHVibGljIGtleVwiLFxuICAgICAgICAvLyBPcGVuWmVwcGVsaW4gdW50aWwgMC42LjEsIEJyYWF2b3MgMC4wLjExXG4gICAgICAgIFwiSU5WQUxJRF9TSUdcIlxuICAgICAgICAvLyBCcmFhdm9zIDEuMC4wXG4gICAgICBdXG4gICAgfTtcbiAgICBsZXQgZXJyb3I7XG4gICAgZm9yIChjb25zdCBTaWdWZXJpZmljYXRpb25GTmFtZSBvZiBrbm93blNpZ1ZlcmlmaWNhdGlvbkZOYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5jYWxsQ29udHJhY3Qoe1xuICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgIGVudHJ5cG9pbnQ6IFNpZ1ZlcmlmaWNhdGlvbkZOYW1lLFxuICAgICAgICAgIGNhbGxkYXRhOiBDYWxsRGF0YS5jb21waWxlKHtcbiAgICAgICAgICAgIGhhc2g6IHRvQmlnSW50KGhhc2gpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZvcm1hdFNpZ25hdHVyZShzaWduYXR1cmUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrbm93blNpZ25hdHVyZVJlc3BvbnNlLm5va1Jlc3BvbnNlLmluY2x1ZGVzKHJlc3BbMF0udG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtub3duU2lnbmF0dXJlUmVzcG9uc2Uub2tSZXNwb25zZS5sZW5ndGggPT09IDAgfHwga25vd25TaWduYXR1cmVSZXNwb25zZS5va1Jlc3BvbnNlLmluY2x1ZGVzKHJlc3BbMF0udG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBFcnJvcihcInNpZ25hdHVyZVZlcmlmaWNhdGlvblJlc3BvbnNlIEVycm9yOiByZXNwb25zZSBpcyBub3QgcGFydCBvZiBrbm93biByZXNwb25zZXNcIik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGtub3duU2lnbmF0dXJlUmVzcG9uc2UuZXJyb3Iuc29tZShcbiAgICAgICAgICAoZXJyTWVzc2FnZSkgPT4gZXJyLm1lc3NhZ2UuaW5jbHVkZXMoZXJyTWVzc2FnZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoYFNpZ25hdHVyZSB2ZXJpZmljYXRpb24gRXJyb3I6ICR7ZXJyb3J9YCk7XG4gIH1cbiAgYXN5bmMgdmVyaWZ5TWVzc2FnZSh0eXBlZERhdGEsIHNpZ25hdHVyZSwgc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lLCBzaWduYXR1cmVWZXJpZmljYXRpb25SZXNwb25zZSkge1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLmhhc2hNZXNzYWdlKHR5cGVkRGF0YSk7XG4gICAgcmV0dXJuIHRoaXMudmVyaWZ5TWVzc2FnZUhhc2goXG4gICAgICBoYXNoLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb25OYW1lLFxuICAgICAgc2lnbmF0dXJlVmVyaWZpY2F0aW9uUmVzcG9uc2VcbiAgICApO1xuICB9XG4gIC8qXG4gICAqIFN1cHBvcnQgbWV0aG9kc1xuICAgKi9cbiAgYXN5bmMgZ2V0VW5pdmVyc2FsU3VnZ2VzdGVkRmVlKHZlcnNpb24sIHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IG1heEZlZSA9IDA7XG4gICAgbGV0IHJlc291cmNlQm91bmRzID0gZXN0aW1hdGVGZWVUb0JvdW5kcyhaRVJPKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbi5WMykge1xuICAgICAgcmVzb3VyY2VCb3VuZHMgPSBkZXRhaWxzLnJlc291cmNlQm91bmRzID8/IChhd2FpdCB0aGlzLmdldFN1Z2dlc3RlZEZlZSh7IHR5cGUsIHBheWxvYWQgfSwgZGV0YWlscykpLnJlc291cmNlQm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhGZWUgPSBkZXRhaWxzLm1heEZlZSA/PyAoYXdhaXQgdGhpcy5nZXRTdWdnZXN0ZWRGZWUoeyB0eXBlLCBwYXlsb2FkIH0sIGRldGFpbHMpKS5zdWdnZXN0ZWRNYXhGZWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYXhGZWUsXG4gICAgICByZXNvdXJjZUJvdW5kc1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZ2V0U3VnZ2VzdGVkRmVlKHsgdHlwZSwgcGF5bG9hZCB9LCBkZXRhaWxzKSB7XG4gICAgbGV0IGZlZUVzdGltYXRlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIklOVk9LRV9GVU5DVElPTlwiIC8qIElOVk9LRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlSW52b2tlRmVlKHBheWxvYWQsIGRldGFpbHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVjbGFyZUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZX0FDQ09VTlRcIiAvKiBERVBMT1lfQUNDT1VOVCAqLzpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSBhd2FpdCB0aGlzLmVzdGltYXRlQWNjb3VudERlcGxveUZlZShwYXlsb2FkLCBkZXRhaWxzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVQTE9ZXCIgLyogREVQTE9ZICovOlxuICAgICAgICBmZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVEZXBsb3lGZWUocGF5bG9hZCwgZGV0YWlscyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmVlRXN0aW1hdGUgPSB7XG4gICAgICAgICAgZ2FzX2NvbnN1bWVkOiAwbixcbiAgICAgICAgICBnYXNfcHJpY2U6IDBuLFxuICAgICAgICAgIG92ZXJhbGxfZmVlOiBaRVJPLFxuICAgICAgICAgIHVuaXQ6IFwiRlJJXCIsXG4gICAgICAgICAgc3VnZ2VzdGVkTWF4RmVlOiBaRVJPLFxuICAgICAgICAgIHJlc291cmNlQm91bmRzOiBlc3RpbWF0ZUZlZVRvQm91bmRzKFpFUk8pLFxuICAgICAgICAgIGRhdGFfZ2FzX2NvbnN1bWVkOiAwbixcbiAgICAgICAgICBkYXRhX2dhc19wcmljZTogMG5cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBmZWVFc3RpbWF0ZTtcbiAgfVxuICBhc3luYyBidWlsZEludm9jYXRpb24oY2FsbCwgZGV0YWlscykge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0RXhlY3V0ZUNhbGxkYXRhKGNhbGwsIGF3YWl0IHRoaXMuZ2V0Q2Fpcm9WZXJzaW9uKCkpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICFkZXRhaWxzLnNraXBWYWxpZGF0ZSA/IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25UcmFuc2FjdGlvbihjYWxsLCBkZXRhaWxzKSA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhbGxkYXRhLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuICBhc3luYyBidWlsZERlY2xhcmVQYXlsb2FkKHBheWxvYWQsIGRldGFpbHMpIHtcbiAgICBjb25zdCB7IGNsYXNzSGFzaCwgY29udHJhY3QsIGNvbXBpbGVkQ2xhc3NIYXNoIH0gPSBleHRyYWN0Q29udHJhY3RIYXNoZXMocGF5bG9hZCk7XG4gICAgY29uc3QgY29tcHJlc3NlZENvbXBpbGVkQ29udHJhY3QgPSBwYXJzZUNvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICBpZiAodHlwZW9mIGNvbXBpbGVkQ2xhc3NIYXNoID09PSBcInVuZGVmaW5lZFwiICYmIChkZXRhaWxzLnZlcnNpb24gPT09IGFwaV9leHBvcnRzLkVUcmFuc2FjdGlvblZlcnNpb24zLkYzIHx8IGRldGFpbHMudmVyc2lvbiA9PT0gYXBpX2V4cG9ydHMuRVRyYW5zYWN0aW9uVmVyc2lvbjMuVjMpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlYzIFRyYW5zYWN0aW9uIHdvcmsgd2l0aCBDYWlybzEgQ29udHJhY3RzIGFuZCByZXF1aXJlIGNvbXBpbGVkQ2xhc3NIYXNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSAhZGV0YWlscy5za2lwVmFsaWRhdGUgPyBhd2FpdCB0aGlzLnNpZ25lci5zaWduRGVjbGFyZVRyYW5zYWN0aW9uKHtcbiAgICAgIC4uLmRldGFpbHMsXG4gICAgICAuLi52M0RldGFpbHMoZGV0YWlscyksXG4gICAgICBjbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaCxcbiAgICAgIC8vIFRPRE86IFRTLCBjYXN0IGJlY2F1c2Ugb3B0aW9uYWwgZm9yIHYyIGFuZCByZXF1aXJlZCBmb3IgdjMsIHRocm93biBpZiBub3QgcHJlc2VudFxuICAgICAgc2VuZGVyQWRkcmVzczogZGV0YWlscy53YWxsZXRBZGRyZXNzXG4gICAgfSkgOiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VuZGVyQWRkcmVzczogZGV0YWlscy53YWxsZXRBZGRyZXNzLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgY29udHJhY3Q6IGNvbXByZXNzZWRDb21waWxlZENvbnRyYWN0LFxuICAgICAgY29tcGlsZWRDbGFzc0hhc2hcbiAgICB9O1xuICB9XG4gIGFzeW5jIGJ1aWxkQWNjb3VudERlcGxveVBheWxvYWQoe1xuICAgIGNsYXNzSGFzaCxcbiAgICBhZGRyZXNzU2FsdCA9IDAsXG4gICAgY29uc3RydWN0b3JDYWxsZGF0YSA9IFtdLFxuICAgIGNvbnRyYWN0QWRkcmVzczogcHJvdmlkZWRDb250cmFjdEFkZHJlc3NcbiAgfSwgZGV0YWlscykge1xuICAgIGNvbnN0IGNvbXBpbGVkQ2FsbGRhdGEgPSBDYWxsRGF0YS5jb21waWxlKGNvbnN0cnVjdG9yQ2FsbGRhdGEpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb3ZpZGVkQ29udHJhY3RBZGRyZXNzID8/IGNhbGN1bGF0ZUNvbnRyYWN0QWRkcmVzc0Zyb21IYXNoKGFkZHJlc3NTYWx0LCBjbGFzc0hhc2gsIGNvbXBpbGVkQ2FsbGRhdGEsIDApO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICFkZXRhaWxzLnNraXBWYWxpZGF0ZSA/IGF3YWl0IHRoaXMuc2lnbmVyLnNpZ25EZXBsb3lBY2NvdW50VHJhbnNhY3Rpb24oe1xuICAgICAgLi4uZGV0YWlscyxcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YVxuICAgIH0pIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnYzRGV0YWlscyhkZXRhaWxzKSxcbiAgICAgIGNsYXNzSGFzaCxcbiAgICAgIGFkZHJlc3NTYWx0LFxuICAgICAgY29uc3RydWN0b3JDYWxsZGF0YTogY29tcGlsZWRDYWxsZGF0YSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH1cbiAgYnVpbGRVRENDb250cmFjdFBheWxvYWQocGF5bG9hZCkge1xuICAgIGNvbnN0IGNhbGxzID0gW10uY29uY2F0KHBheWxvYWQpLm1hcCgoaXQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NIYXNoLFxuICAgICAgICBzYWx0ID0gXCIwXCIsXG4gICAgICAgIHVuaXF1ZSA9IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEgPSBbXVxuICAgICAgfSA9IGl0O1xuICAgICAgY29uc3QgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhID0gQ2FsbERhdGEuY29tcGlsZShjb25zdHJ1Y3RvckNhbGxkYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogVURDLkFERFJFU1MsXG4gICAgICAgIGVudHJ5cG9pbnQ6IFVEQy5FTlRSWVBPSU5ULFxuICAgICAgICBjYWxsZGF0YTogW1xuICAgICAgICAgIGNsYXNzSGFzaCxcbiAgICAgICAgICBzYWx0LFxuICAgICAgICAgIHRvQ2Fpcm9Cb29sKHVuaXF1ZSksXG4gICAgICAgICAgY29tcGlsZWRDb25zdHJ1Y3RvckNhbGxEYXRhLmxlbmd0aCxcbiAgICAgICAgICAuLi5jb21waWxlZENvbnN0cnVjdG9yQ2FsbERhdGFcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbHM7XG4gIH1cbiAgYXN5bmMgYWNjb3VudEludm9jYXRpb25zRmFjdG9yeShpbnZvY2F0aW9ucywgZGV0YWlscykge1xuICAgIGNvbnN0IHsgbm9uY2UsIGJsb2NrSWRlbnRpZmllciwgc2tpcFZhbGlkYXRlID0gdHJ1ZSB9ID0gZGV0YWlscztcbiAgICBjb25zdCBzYWZlTm9uY2UgPSBhd2FpdCB0aGlzLmdldE5vbmNlU2FmZShub25jZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHZlcnNpb25zID0gZGV0YWlscy52ZXJzaW9ucy5tYXAoKGl0KSA9PiB0b1RyYW5zYWN0aW9uVmVyc2lvbihpdCkpO1xuICAgIGNvbnN0IHR4MFBheWxvYWQgPSBcInBheWxvYWRcIiBpbiBpbnZvY2F0aW9uc1swXSA/IGludm9jYXRpb25zWzBdLnBheWxvYWQgOiBpbnZvY2F0aW9uc1swXTtcbiAgICBjb25zdCBjYWlyb1ZlcnNpb24gPSBpbnZvY2F0aW9uc1swXS50eXBlID09PSBcIkRFUExPWV9BQ0NPVU5UXCIgLyogREVQTE9ZX0FDQ09VTlQgKi8gPyBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbih0eDBQYXlsb2FkLmNsYXNzSGFzaCkgOiBhd2FpdCB0aGlzLmdldENhaXJvVmVyc2lvbigpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIFtdLmNvbmNhdChpbnZvY2F0aW9ucykubWFwKGFzeW5jICh0cmFuc2FjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdHhQYXlsb2FkID0gXCJwYXlsb2FkXCIgaW4gdHJhbnNhY3Rpb24gPyB0cmFuc2FjdGlvbi5wYXlsb2FkIDogdHJhbnNhY3Rpb247XG4gICAgICAgIGNvbnN0IHNpZ25lckRldGFpbHMgPSB7XG4gICAgICAgICAgLi4udjNEZXRhaWxzKGRldGFpbHMpLFxuICAgICAgICAgIHdhbGxldEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICBub25jZTogdG9CaWdJbnQoTnVtYmVyKHNhZmVOb25jZSkgKyBpbmRleCksXG4gICAgICAgICAgbWF4RmVlOiBaRVJPLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgY2Fpcm9WZXJzaW9uLFxuICAgICAgICAgIHZlcnNpb246IFwiXCIsXG4gICAgICAgICAgc2tpcFZhbGlkYXRlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbW1vbiA9IHtcbiAgICAgICAgICB0eXBlOiB0cmFuc2FjdGlvbi50eXBlLFxuICAgICAgICAgIG5vbmNlOiB0b0JpZ0ludChOdW1iZXIoc2FmZU5vbmNlKSArIGluZGV4KSxcbiAgICAgICAgICBibG9ja0lkZW50aWZpZXIsXG4gICAgICAgICAgdmVyc2lvbjogXCJcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJJTlZPS0VfRlVOQ1RJT05cIiAvKiBJTlZPS0UgKi8pIHtcbiAgICAgICAgICBjb25zdCB2ZXJzaW9uWCA9IHJlZHVjZVYyKHZlcnNpb25zWzFdKTtcbiAgICAgICAgICBzaWduZXJEZXRhaWxzLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb21tb24udmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCB0aGlzLmJ1aWxkSW52b2NhdGlvbihcbiAgICAgICAgICAgIFtdLmNvbmNhdCh0eFBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmVyRGV0YWlsc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcIkRFUExPWVwiIC8qIERFUExPWSAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25YID0gcmVkdWNlVjIodmVyc2lvbnNbMV0pO1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbW1vbi52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29uc3QgY2FsbHMgPSB0aGlzLmJ1aWxkVURDQ29udHJhY3RQYXlsb2FkKHR4UGF5bG9hZCk7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGRJbnZvY2F0aW9uKGNhbGxzLCBzaWduZXJEZXRhaWxzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgIHR5cGU6IFwiSU5WT0tFX0ZVTkNUSU9OXCIgLyogSU5WT0tFICovXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERUNMQVJFXCIgLyogREVDTEFSRSAqLykge1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25YID0gIWlzU2llcnJhKHR4UGF5bG9hZC5jb250cmFjdCkgPyB2ZXJzaW9uc1swXSA6IHZlcnNpb25zWzFdO1xuICAgICAgICAgIHNpZ25lckRldGFpbHMudmVyc2lvbiA9IHZlcnNpb25YO1xuICAgICAgICAgIGNvbW1vbi52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHRoaXMuYnVpbGREZWNsYXJlUGF5bG9hZCh0eFBheWxvYWQsIHNpZ25lckRldGFpbHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAuLi5wYXlsb2FkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gXCJERVBMT1lfQUNDT1VOVFwiIC8qIERFUExPWV9BQ0NPVU5UICovKSB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvblggPSByZWR1Y2VWMih2ZXJzaW9uc1sxXSk7XG4gICAgICAgICAgc2lnbmVyRGV0YWlscy52ZXJzaW9uID0gdmVyc2lvblg7XG4gICAgICAgICAgY29tbW9uLnZlcnNpb24gPSB2ZXJzaW9uWDtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgdGhpcy5idWlsZEFjY291bnREZXBsb3lQYXlsb2FkKHR4UGF5bG9hZCwgc2lnbmVyRGV0YWlscyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIC4uLnBheWxvYWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKGBhY2NvdW50SW52b2NhdGlvbnNGYWN0b3J5OiB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3RyYW5zYWN0aW9ufWApO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGdldFN0YXJrTmFtZShhZGRyZXNzID0gdGhpcy5hZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFN0YXJrTmFtZShhZGRyZXNzLCBTdGFya25ldElkQ29udHJhY3QyKTtcbiAgfVxufTtcblxuLy8gc3JjL2FjY291bnQvaW50ZXJmYWNlLnRzXG52YXIgQWNjb3VudEludGVyZmFjZSA9IGNsYXNzIGV4dGVuZHMgUHJvdmlkZXJJbnRlcmZhY2Uge1xufTtcblxuLy8gc3JjL3dhbGxldC9jb25uZWN0LnRzXG52YXIgY29ubmVjdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChjb25uZWN0X2V4cG9ydHMsIHtcbiAgYWRkRGVjbGFyZVRyYW5zYWN0aW9uOiAoKSA9PiBhZGREZWNsYXJlVHJhbnNhY3Rpb24sXG4gIGFkZEludm9rZVRyYW5zYWN0aW9uOiAoKSA9PiBhZGRJbnZva2VUcmFuc2FjdGlvbixcbiAgYWRkU3RhcmtuZXRDaGFpbjogKCkgPT4gYWRkU3RhcmtuZXRDaGFpbixcbiAgZGVwbG95bWVudERhdGE6ICgpID0+IGRlcGxveW1lbnREYXRhLFxuICBnZXRQZXJtaXNzaW9uczogKCkgPT4gZ2V0UGVybWlzc2lvbnMsXG4gIG9uQWNjb3VudENoYW5nZTogKCkgPT4gb25BY2NvdW50Q2hhbmdlLFxuICBvbk5ldHdvcmtDaGFuZ2VkOiAoKSA9PiBvbk5ldHdvcmtDaGFuZ2VkLFxuICByZXF1ZXN0QWNjb3VudHM6ICgpID0+IHJlcXVlc3RBY2NvdW50cyxcbiAgcmVxdWVzdENoYWluSWQ6ICgpID0+IHJlcXVlc3RDaGFpbklkLFxuICBzaWduTWVzc2FnZTogKCkgPT4gc2lnbk1lc3NhZ2UsXG4gIHN1cHBvcnRlZFNwZWNzOiAoKSA9PiBzdXBwb3J0ZWRTcGVjcyxcbiAgc3dpdGNoU3RhcmtuZXRDaGFpbjogKCkgPT4gc3dpdGNoU3RhcmtuZXRDaGFpbixcbiAgd2F0Y2hBc3NldDogKCkgPT4gd2F0Y2hBc3NldFxufSk7XG5mdW5jdGlvbiByZXF1ZXN0QWNjb3VudHMoc3dvLCBzaWxlbnRfbW9kZSA9IGZhbHNlKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgcGFyYW1zOiB7XG4gICAgICBzaWxlbnRfbW9kZVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9ucyhzd28pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIiB9KTtcbn1cbmZ1bmN0aW9uIHdhdGNoQXNzZXQoc3dvLCBhc3NldCkge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3dhdGNoQXNzZXRcIixcbiAgICBwYXJhbXM6IGFzc2V0XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkU3RhcmtuZXRDaGFpbihzd28sIGNoYWluKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfYWRkU3RhcmtuZXRDaGFpblwiLFxuICAgIHBhcmFtczogY2hhaW5cbiAgfSk7XG59XG5mdW5jdGlvbiBzd2l0Y2hTdGFya25ldENoYWluKHN3bywgY2hhaW5JZCkge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3N3aXRjaFN0YXJrbmV0Q2hhaW5cIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIGNoYWluSWRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVxdWVzdENoYWluSWQoc3dvKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7IHR5cGU6IFwid2FsbGV0X3JlcXVlc3RDaGFpbklkXCIgfSk7XG59XG5mdW5jdGlvbiBkZXBsb3ltZW50RGF0YShzd28pIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHsgdHlwZTogXCJ3YWxsZXRfZGVwbG95bWVudERhdGFcIiB9KTtcbn1cbmZ1bmN0aW9uIGFkZEludm9rZVRyYW5zYWN0aW9uKHN3bywgcGFyYW1zKSB7XG4gIHJldHVybiBzd28ucmVxdWVzdCh7XG4gICAgdHlwZTogXCJ3YWxsZXRfYWRkSW52b2tlVHJhbnNhY3Rpb25cIixcbiAgICBwYXJhbXNcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNsYXJlVHJhbnNhY3Rpb24oc3dvLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHN3by5yZXF1ZXN0KHtcbiAgICB0eXBlOiBcIndhbGxldF9hZGREZWNsYXJlVHJhbnNhY3Rpb25cIixcbiAgICBwYXJhbXNcbiAgfSk7XG59XG5mdW5jdGlvbiBzaWduTWVzc2FnZShzd28sIHR5cGVkRGF0YSkge1xuICByZXR1cm4gc3dvLnJlcXVlc3Qoe1xuICAgIHR5cGU6IFwid2FsbGV0X3NpZ25UeXBlZERhdGFcIixcbiAgICBwYXJhbXM6IHR5cGVkRGF0YVxuICB9KTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRlZFNwZWNzKHN3bykge1xuICByZXR1cm4gc3dvLnJlcXVlc3QoeyB0eXBlOiBcIndhbGxldF9zdXBwb3J0ZWRTcGVjc1wiIH0pO1xufVxuZnVuY3Rpb24gb25BY2NvdW50Q2hhbmdlKHN3bywgY2FsbGJhY2spIHtcbiAgc3dvLm9uKFwiYWNjb3VudHNDaGFuZ2VkXCIsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG9uTmV0d29ya0NoYW5nZWQoc3dvLCBjYWxsYmFjaykge1xuICBzd28ub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCBjYWxsYmFjayk7XG59XG5cbi8vIHNyYy93YWxsZXQvYWNjb3VudC50c1xudmFyIFdhbGxldEFjY291bnQgPSBjbGFzcyBleHRlbmRzIEFjY291bnQge1xuICBhZGRyZXNzID0gXCJcIjtcbiAgd2FsbGV0UHJvdmlkZXI7XG4gIGNvbnN0cnVjdG9yKHByb3ZpZGVyT3JPcHRpb25zLCB3YWxsZXRQcm92aWRlciwgY2Fpcm9WZXJzaW9uKSB7XG4gICAgc3VwZXIocHJvdmlkZXJPck9wdGlvbnMsIFwiXCIsIFwiXCIsIGNhaXJvVmVyc2lvbik7XG4gICAgdGhpcy53YWxsZXRQcm92aWRlciA9IHdhbGxldFByb3ZpZGVyO1xuICAgIHRoaXMud2FsbGV0UHJvdmlkZXIub24oXCJhY2NvdW50c0NoYW5nZWRcIiwgKHJlcykgPT4ge1xuICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgIHRoaXMuYWRkcmVzcyA9IHJlc1swXS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICAgIHRoaXMud2FsbGV0UHJvdmlkZXIub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCAocmVzKSA9PiB7XG4gICAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgICAgdGhpcy5jaGFubmVsLnNldENoYWluSWQocmVzKTtcbiAgICB9KTtcbiAgICB3YWxsZXRQcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIHR5cGU6IFwid2FsbGV0X3JlcXVlc3RBY2NvdW50c1wiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHNpbGVudF9tb2RlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgdGhpcy5hZGRyZXNzID0gcmVzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFdBTExFVCBFVkVOVFNcbiAgICovXG4gIG9uQWNjb3VudENoYW5nZShjYWxsYmFjaykge1xuICAgIG9uQWNjb3VudENoYW5nZSh0aGlzLndhbGxldFByb3ZpZGVyLCBjYWxsYmFjayk7XG4gIH1cbiAgb25OZXR3b3JrQ2hhbmdlZChjYWxsYmFjaykge1xuICAgIG9uTmV0d29ya0NoYW5nZWQodGhpcy53YWxsZXRQcm92aWRlciwgY2FsbGJhY2spO1xuICB9XG4gIC8qKlxuICAgKiBXQUxMRVQgU1BFQ0lGSUMgTUVUSE9EU1xuICAgKi9cbiAgcmVxdWVzdEFjY291bnRzKHNpbGVudE1vZGUgPSBmYWxzZSkge1xuICAgIHJldHVybiByZXF1ZXN0QWNjb3VudHModGhpcy53YWxsZXRQcm92aWRlciwgc2lsZW50TW9kZSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIGdldFBlcm1pc3Npb25zKHRoaXMud2FsbGV0UHJvdmlkZXIpO1xuICB9XG4gIHN3aXRjaFN0YXJrbmV0Q2hhaW4oY2hhaW5JZCkge1xuICAgIHJldHVybiBzd2l0Y2hTdGFya25ldENoYWluKHRoaXMud2FsbGV0UHJvdmlkZXIsIGNoYWluSWQpO1xuICB9XG4gIHdhdGNoQXNzZXQoYXNzZXQpIHtcbiAgICByZXR1cm4gd2F0Y2hBc3NldCh0aGlzLndhbGxldFByb3ZpZGVyLCBhc3NldCk7XG4gIH1cbiAgYWRkU3RhcmtuZXRDaGFpbihjaGFpbikge1xuICAgIHJldHVybiBhZGRTdGFya25ldENoYWluKHRoaXMud2FsbGV0UHJvdmlkZXIsIGNoYWluKTtcbiAgfVxuICAvKipcbiAgICogQUNDT1VOVCBNRVRIT0RTXG4gICAqL1xuICBleGVjdXRlKGNhbGxzKSB7XG4gICAgY29uc3QgdHhDYWxscyA9IFtdLmNvbmNhdChjYWxscykubWFwKChpdCkgPT4ge1xuICAgICAgY29uc3QgeyBjb250cmFjdEFkZHJlc3MsIGVudHJ5cG9pbnQsIGNhbGxkYXRhIH0gPSBpdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgZW50cnlfcG9pbnQ6IGVudHJ5cG9pbnQsXG4gICAgICAgIGNhbGxkYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGNhbGxzOiB0eENhbGxzXG4gICAgfTtcbiAgICByZXR1cm4gYWRkSW52b2tlVHJhbnNhY3Rpb24odGhpcy53YWxsZXRQcm92aWRlciwgcGFyYW1zKTtcbiAgfVxuICBkZWNsYXJlKHBheWxvYWQpIHtcbiAgICBjb25zdCBkZWNsYXJlQ29udHJhY3RQYXlsb2FkID0gZXh0cmFjdENvbnRyYWN0SGFzaGVzKHBheWxvYWQpO1xuICAgIGNvbnN0IHBDb250cmFjdCA9IHBheWxvYWQuY29udHJhY3Q7XG4gICAgY29uc3QgY2Fpcm8xQ29udHJhY3QgPSB7XG4gICAgICAuLi5wQ29udHJhY3QsXG4gICAgICBhYmk6IHN0cmluZ2lmeTIocENvbnRyYWN0LmFiaSlcbiAgICB9O1xuICAgIGlmICghZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJjb21waWxlZENsYXNzSGFzaCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgY29tcGlsZWRfY2xhc3NfaGFzaDogZGVjbGFyZUNvbnRyYWN0UGF5bG9hZC5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnRyYWN0X2NsYXNzOiBjYWlybzFDb250cmFjdFxuICAgIH07XG4gICAgcmV0dXJuIGFkZERlY2xhcmVUcmFuc2FjdGlvbih0aGlzLndhbGxldFByb3ZpZGVyLCBwYXJhbXMpO1xuICB9XG4gIGFzeW5jIGRlcGxveShwYXlsb2FkKSB7XG4gICAgY29uc3QgeyBjYWxscywgYWRkcmVzc2VzIH0gPSBidWlsZFVEQ0NhbGwocGF5bG9hZCwgdGhpcy5hZGRyZXNzKTtcbiAgICBjb25zdCBpbnZva2VSZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZShjYWxscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmludm9rZVJlc3BvbnNlLFxuICAgICAgY29udHJhY3RfYWRkcmVzczogYWRkcmVzc2VzXG4gICAgfTtcbiAgfVxuICBzaWduTWVzc2FnZSh0eXBlZERhdGEpIHtcbiAgICByZXR1cm4gc2lnbk1lc3NhZ2UodGhpcy53YWxsZXRQcm92aWRlciwgdHlwZWREYXRhKTtcbiAgfVxuICAvLyBUT0RPOiBNSVNTSU5HIEVTVElNQVRFU1xufTtcblxuLy8gc3JjL2NvbnRyYWN0L2RlZmF1bHQudHNcbnZhciBzcGxpdEFyZ3NBbmRPcHRpb25zID0gKGFyZ3MpID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICBcImJsb2NrSWRlbnRpZmllclwiLFxuICAgIFwicGFyc2VSZXF1ZXN0XCIsXG4gICAgXCJwYXJzZVJlc3BvbnNlXCIsXG4gICAgXCJmb3JtYXRSZXNwb25zZVwiLFxuICAgIFwibWF4RmVlXCIsXG4gICAgXCJub25jZVwiLFxuICAgIFwic2lnbmF0dXJlXCIsXG4gICAgXCJhZGRyZXNzU2FsdFwiXG4gIF07XG4gIGNvbnN0IGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLnNvbWUoKHgpID0+IHggaW4gbGFzdEFyZykpIHtcbiAgICByZXR1cm4geyBhcmdzLCBvcHRpb25zOiBhcmdzLnBvcCgpIH07XG4gIH1cbiAgcmV0dXJuIHsgYXJncyB9O1xufTtcbmZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzcGxpdEFyZ3NBbmRPcHRpb25zKGFyZ3MpO1xuICAgIHJldHVybiBjb250cmFjdC5jYWxsKGZ1bmN0aW9uQWJpLm5hbWUsIHBhcmFtcy5hcmdzLCB7XG4gICAgICBwYXJzZVJlcXVlc3Q6IHRydWUsXG4gICAgICBwYXJzZVJlc3BvbnNlOiB0cnVlLFxuICAgICAgLi4ucGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkSW52b2tlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0QXJnc0FuZE9wdGlvbnMoYXJncyk7XG4gICAgcmV0dXJuIGNvbnRyYWN0Lmludm9rZShmdW5jdGlvbkFiaS5uYW1lLCBwYXJhbXMuYXJncywge1xuICAgICAgcGFyc2VSZXF1ZXN0OiB0cnVlLFxuICAgICAgLi4ucGFyYW1zLm9wdGlvbnNcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCwgZnVuY3Rpb25BYmkpIHtcbiAgaWYgKGZ1bmN0aW9uQWJpLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIgfHwgZnVuY3Rpb25BYmkuc3RhdGVfbXV0YWJpbGl0eSA9PT0gXCJ2aWV3XCIpIHtcbiAgICByZXR1cm4gYnVpbGRDYWxsKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSk7XG4gIH1cbiAgcmV0dXJuIGJ1aWxkSW52b2tlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSk7XG59XG5mdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LCBmdW5jdGlvbkFiaSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHJldHVybiBjb250cmFjdC5wb3B1bGF0ZShmdW5jdGlvbkFiaS5uYW1lLCBhcmdzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXN0aW1hdGUoY29udHJhY3QsIGZ1bmN0aW9uQWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmVzdGltYXRlKGZ1bmN0aW9uQWJpLm5hbWUsIGFyZ3MpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2FsbGRhdGEoYXJncywgY2FsbGJhY2spIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgXCJfX2NvbXBpbGVkX19cIiBpbiBhcmdzKSByZXR1cm4gYXJncztcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSAmJiBcIl9fY29tcGlsZWRfX1wiIGluIGFyZ3NbMF0pXG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIHJldHVybiBjYWxsYmFjaygpO1xufVxudmFyIENvbnRyYWN0ID0gY2xhc3Mge1xuICBhYmk7XG4gIGFkZHJlc3M7XG4gIHByb3ZpZGVyT3JBY2NvdW50O1xuICBkZXBsb3lUcmFuc2FjdGlvbkhhc2g7XG4gIHN0cnVjdHM7XG4gIGV2ZW50cztcbiAgZnVuY3Rpb25zO1xuICBjYWxsU3RhdGljO1xuICBwb3B1bGF0ZVRyYW5zYWN0aW9uO1xuICBlc3RpbWF0ZUZlZTtcbiAgY2FsbERhdGE7XG4gIC8qKlxuICAgKiBDb250cmFjdCBjbGFzcyB0byBoYW5kbGUgY29udHJhY3QgbWV0aG9kc1xuICAgKlxuICAgKiBAcGFyYW0gYWJpIC0gQWJpIG9mIHRoZSBjb250cmFjdCBvYmplY3RcbiAgICogQHBhcmFtIGFkZHJlc3MgKG9wdGlvbmFsKSAtIGFkZHJlc3MgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0gcHJvdmlkZXJPckFjY291bnQgKG9wdGlvbmFsKSAtIFByb3ZpZGVyIG9yIEFjY291bnQgdG8gYXR0YWNoIHRvXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhYmksIGFkZHJlc3MsIHByb3ZpZGVyT3JBY2NvdW50ID0gZGVmYXVsdFByb3ZpZGVyKSB7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcyAmJiBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm92aWRlck9yQWNjb3VudCA9IHByb3ZpZGVyT3JBY2NvdW50O1xuICAgIHRoaXMuY2FsbERhdGEgPSBuZXcgQ2FsbERhdGEoYWJpKTtcbiAgICB0aGlzLnN0cnVjdHMgPSBDYWxsRGF0YS5nZXRBYmlTdHJ1Y3QoYWJpKTtcbiAgICB0aGlzLmV2ZW50cyA9IGdldEFiaUV2ZW50cyhhYmkpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUFiaVBhcnNlcihhYmkpO1xuICAgIHRoaXMuYWJpID0gcGFyc2VyLmdldExlZ2FjeUZvcm1hdCgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgZnVuY3Rpb25zOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBjYWxsU3RhdGljOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB7fSwgd3JpdGFibGU6IGZhbHNlIH0sXG4gICAgICBlc3RpbWF0ZUZlZTogeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZToge30sIHdyaXRhYmxlOiBmYWxzZSB9XG4gICAgfSk7XG4gICAgdGhpcy5hYmkuZm9yRWFjaCgoYWJpRWxlbWVudCkgPT4ge1xuICAgICAgaWYgKGFiaUVsZW1lbnQudHlwZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm47XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhYmlFbGVtZW50Lm5hbWU7XG4gICAgICBpZiAoIXRoaXNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmZ1bmN0aW9ucywgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGREZWZhdWx0KHRoaXMsIGFiaUVsZW1lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHZhbHVlOiBidWlsZENhbGwodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgdmFsdWU6IGJ1aWxkUG9wdWxhdGUodGhpcywgYWJpRWxlbWVudClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXN0aW1hdGVGZWVbc2lnbmF0dXJlXSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lc3RpbWF0ZUZlZSwgc2lnbmF0dXJlLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB2YWx1ZTogYnVpbGRFc3RpbWF0ZSh0aGlzLCBhYmlFbGVtZW50KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gIH1cbiAgY29ubmVjdChwcm92aWRlck9yQWNjb3VudCkge1xuICAgIHRoaXMucHJvdmlkZXJPckFjY291bnQgPSBwcm92aWRlck9yQWNjb3VudDtcbiAgfVxuICBhc3luYyBkZXBsb3llZCgpIHtcbiAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXJPckFjY291bnQud2FpdEZvclRyYW5zYWN0aW9uKHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIHRoaXMuZGVwbG95VHJhbnNhY3Rpb25IYXNoID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyBjYWxsKG1ldGhvZCwgYXJncyA9IFtdLCB7XG4gICAgcGFyc2VSZXF1ZXN0ID0gdHJ1ZSxcbiAgICBwYXJzZVJlc3BvbnNlID0gdHJ1ZSxcbiAgICBmb3JtYXRSZXNwb25zZSA9IHZvaWQgMCxcbiAgICBibG9ja0lkZW50aWZpZXIgPSB2b2lkIDBcbiAgfSA9IHt9KSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgY29uc3QgY2FsbGRhdGEgPSBnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiB7XG4gICAgICBpZiAocGFyc2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJDQUxMXCIgLyogQ0FMTCAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuY29tcGlsZShtZXRob2QsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiQ2FsbCBza2lwcGVkIHBhcnNpbmcgYnV0IHByb3ZpZGVkIHJhd0FyZ3MsIHBvc3NpYmxlIG1hbGZ1bmN0aW9uIHJlcXVlc3RcIik7XG4gICAgICByZXR1cm4gYXJncztcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5jYWxsQ29udHJhY3QoXG4gICAgICB7XG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICBjYWxsZGF0YSxcbiAgICAgICAgZW50cnlwb2ludDogbWV0aG9kXG4gICAgICB9LFxuICAgICAgYmxvY2tJZGVudGlmaWVyXG4gICAgKS50aGVuKChpdCkgPT4ge1xuICAgICAgaWYgKCFwYXJzZVJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBpdDtcbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXRSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsRGF0YS5mb3JtYXQobWV0aG9kLCBpdCwgZm9ybWF0UmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEucGFyc2UobWV0aG9kLCBpdCk7XG4gICAgfSk7XG4gIH1cbiAgaW52b2tlKG1ldGhvZCwgYXJncyA9IFtdLCB7IHBhcnNlUmVxdWVzdCA9IHRydWUsIG1heEZlZSwgbm9uY2UsIHNpZ25hdHVyZSB9ID0ge30pIHtcbiAgICBhc3NlcnQodGhpcy5hZGRyZXNzICE9PSBudWxsLCBcImNvbnRyYWN0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYW4gYWRkcmVzc1wiKTtcbiAgICBjb25zdCBjYWxsZGF0YSA9IGdldENhbGxkYXRhKGFyZ3MsICgpID0+IHtcbiAgICAgIGlmIChwYXJzZVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5jYWxsRGF0YS52YWxpZGF0ZShcIklOVk9LRVwiIC8qIElOVk9LRSAqLywgbWV0aG9kLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbERhdGEuY29tcGlsZShtZXRob2QsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiSW52b2tlIHNraXBwZWQgcGFyc2luZyBidXQgcHJvdmlkZWQgcmF3QXJncywgcG9zc2libGUgbWFsZnVuY3Rpb24gcmVxdWVzdFwiKTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH0pO1xuICAgIGNvbnN0IGludm9jYXRpb24gPSB7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGNhbGxkYXRhLFxuICAgICAgZW50cnlwb2ludDogbWV0aG9kXG4gICAgfTtcbiAgICBpZiAoXCJleGVjdXRlXCIgaW4gdGhpcy5wcm92aWRlck9yQWNjb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuZXhlY3V0ZShpbnZvY2F0aW9uLCB2b2lkIDAsIHtcbiAgICAgICAgbWF4RmVlLFxuICAgICAgICBub25jZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghbm9uY2UpIHRocm93IG5ldyBFcnJvcihgTm9uY2UgaXMgcmVxdWlyZWQgd2hlbiBpbnZva2luZyBhIGZ1bmN0aW9uIHdpdGhvdXQgYW4gYWNjb3VudGApO1xuICAgIGNvbnNvbGUud2FybihgSW52b2tpbmcgJHttZXRob2R9IHdpdGhvdXQgYW4gYWNjb3VudC4gVGhpcyB3aWxsIG5vdCB3b3JrIG9uIGEgcHVibGljIG5vZGUuYCk7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXJPckFjY291bnQuaW52b2tlRnVuY3Rpb24oXG4gICAgICB7XG4gICAgICAgIC4uLmludm9jYXRpb24sXG4gICAgICAgIHNpZ25hdHVyZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2VcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlKG1ldGhvZCwgYXJncyA9IFtdKSB7XG4gICAgYXNzZXJ0KHRoaXMuYWRkcmVzcyAhPT0gbnVsbCwgXCJjb250cmFjdCBpcyBub3QgY29ubmVjdGVkIHRvIGFuIGFkZHJlc3NcIik7XG4gICAgaWYgKCFnZXRDYWxsZGF0YShhcmdzLCAoKSA9PiBmYWxzZSkpIHtcbiAgICAgIHRoaXMuY2FsbERhdGEudmFsaWRhdGUoXCJJTlZPS0VcIiAvKiBJTlZPS0UgKi8sIG1ldGhvZCwgYXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGludm9jYXRpb24gPSB0aGlzLnBvcHVsYXRlKG1ldGhvZCwgYXJncyk7XG4gICAgaWYgKFwiZXN0aW1hdGVJbnZva2VGZWVcIiBpbiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm92aWRlck9yQWNjb3VudC5lc3RpbWF0ZUludm9rZUZlZShpbnZvY2F0aW9uKTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJDb250cmFjdCBtdXN0IGJlIGNvbm5lY3RlZCB0byB0aGUgYWNjb3VudCBjb250cmFjdCB0byBlc3RpbWF0ZVwiKTtcbiAgfVxuICBwb3B1bGF0ZShtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIGNvbnN0IGNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEoYXJncywgKCkgPT4gdGhpcy5jYWxsRGF0YS5jb21waWxlKG1ldGhvZCwgYXJncykpO1xuICAgIHJldHVybiB7XG4gICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgIGVudHJ5cG9pbnQ6IG1ldGhvZCxcbiAgICAgIGNhbGxkYXRhXG4gICAgfTtcbiAgfVxuICBwYXJzZUV2ZW50cyhyZWNlaXB0KSB7XG4gICAgcmV0dXJuIHBhcnNlRXZlbnRzKFxuICAgICAgcmVjZWlwdC5ldmVudHM/LmZpbHRlcihcbiAgICAgICAgKGV2ZW50KSA9PiBjbGVhbkhleChldmVudC5mcm9tX2FkZHJlc3MpID09PSBjbGVhbkhleCh0aGlzLmFkZHJlc3MpLFxuICAgICAgICBbXVxuICAgICAgKSB8fCBbXSxcbiAgICAgIHRoaXMuZXZlbnRzLFxuICAgICAgdGhpcy5zdHJ1Y3RzLFxuICAgICAgQ2FsbERhdGEuZ2V0QWJpRW51bSh0aGlzLmFiaSlcbiAgICApO1xuICB9XG4gIGlzQ2Fpcm8xKCkge1xuICAgIHJldHVybiBjYWlyb19leHBvcnRzLmlzQ2Fpcm8xQWJpKHRoaXMuYWJpKTtcbiAgfVxuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyT3JBY2NvdW50LmdldENvbnRyYWN0VmVyc2lvbih0aGlzLmFkZHJlc3MpO1xuICB9XG4gIHR5cGVkdjIodEFiaSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG4vLyBzcmMvY29udHJhY3QvaW50ZXJmYWNlLnRzXG52YXIgQ29udHJhY3RJbnRlcmZhY2UgPSBjbGFzcyB7XG4gIGZ1bmN0aW9ucztcbiAgY2FsbFN0YXRpYztcbiAgcG9wdWxhdGVUcmFuc2FjdGlvbjtcbiAgZXN0aW1hdGVGZWU7XG59O1xuXG4vLyBzcmMvY29udHJhY3QvY29udHJhY3RGYWN0b3J5LnRzXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gY2xhc3Mge1xuICBjb21waWxlZENvbnRyYWN0O1xuICBhY2NvdW50O1xuICBhYmk7XG4gIGNsYXNzSGFzaDtcbiAgY2FzbTtcbiAgY29tcGlsZWRDbGFzc0hhc2g7XG4gIENhbGxEYXRhO1xuICAvKipcbiAgICogQHBhcmFtIHBhcmFtcyBDRlBhcmFtc1xuICAgKiAgLSBjb21waWxlZENvbnRyYWN0OiBDb21waWxlZENvbnRyYWN0O1xuICAgKiAgLSBhY2NvdW50OiBBY2NvdW50SW50ZXJmYWNlO1xuICAgKiAgLSBjYXNtPzogQ2Fpcm9Bc3NlbWJseTtcbiAgICogIC0gY2xhc3NIYXNoPzogc3RyaW5nO1xuICAgKiAgLSBjb21waWxlZENsYXNzSGFzaD86IHN0cmluZztcbiAgICogIC0gYWJpPzogQWJpO1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgdGhpcy5jb21waWxlZENvbnRyYWN0ID0gcGFyYW1zLmNvbXBpbGVkQ29udHJhY3Q7XG4gICAgdGhpcy5hY2NvdW50ID0gcGFyYW1zLmFjY291bnQ7XG4gICAgdGhpcy5jYXNtID0gcGFyYW1zLmNhc207XG4gICAgdGhpcy5hYmkgPSBwYXJhbXMuYWJpID8/IHBhcmFtcy5jb21waWxlZENvbnRyYWN0LmFiaTtcbiAgICB0aGlzLmNsYXNzSGFzaCA9IHBhcmFtcy5jbGFzc0hhc2g7XG4gICAgdGhpcy5jb21waWxlZENsYXNzSGFzaCA9IHBhcmFtcy5jb21waWxlZENsYXNzSGFzaDtcbiAgICB0aGlzLkNhbGxEYXRhID0gbmV3IENhbGxEYXRhKHRoaXMuYWJpKTtcbiAgfVxuICAvKipcbiAgICogRGVwbG95cyBjb250cmFjdCBhbmQgcmV0dXJucyBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbnRyYWN0XG4gICAqXG4gICAqIElmIGNvbnRyYWN0IGlzIG5vdCBkZWNsYXJlZCBpdCB3aWxsIGZpcnN0IGRlY2xhcmUgaXQsIGFuZCB0aGVuIGRlcGxveVxuICAgKi9cbiAgYXN5bmMgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IGFyZ3M6IHBhcmFtLCBvcHRpb25zID0geyBwYXJzZVJlcXVlc3Q6IHRydWUgfSB9ID0gc3BsaXRBcmdzQW5kT3B0aW9ucyhhcmdzKTtcbiAgICBjb25zdCBjb25zdHJ1Y3RvckNhbGxkYXRhID0gZ2V0Q2FsbGRhdGEocGFyYW0sICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlUmVxdWVzdCkge1xuICAgICAgICB0aGlzLkNhbGxEYXRhLnZhbGlkYXRlKFwiREVQTE9ZXCIgLyogREVQTE9ZICovLCBcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbERhdGEuY29tcGlsZShcImNvbnN0cnVjdG9yXCIsIHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIkNhbGwgc2tpcHBlZCBwYXJzaW5nIGJ1dCBwcm92aWRlZCByYXdBcmdzLCBwb3NzaWJsZSBtYWxmdW5jdGlvbiByZXF1ZXN0XCIpO1xuICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGRlcGxveTogeyBjb250cmFjdF9hZGRyZXNzLCB0cmFuc2FjdGlvbl9oYXNoIH1cbiAgICB9ID0gYXdhaXQgdGhpcy5hY2NvdW50LmRlY2xhcmVBbmREZXBsb3koe1xuICAgICAgY29udHJhY3Q6IHRoaXMuY29tcGlsZWRDb250cmFjdCxcbiAgICAgIGNhc206IHRoaXMuY2FzbSxcbiAgICAgIGNsYXNzSGFzaDogdGhpcy5jbGFzc0hhc2gsXG4gICAgICBjb21waWxlZENsYXNzSGFzaDogdGhpcy5jb21waWxlZENsYXNzSGFzaCxcbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGRhdGEsXG4gICAgICBzYWx0OiBvcHRpb25zLmFkZHJlc3NTYWx0XG4gICAgfSk7XG4gICAgYXNzZXJ0KEJvb2xlYW4oY29udHJhY3RfYWRkcmVzcyksIFwiRGVwbG95bWVudCBvZiB0aGUgY29udHJhY3QgZmFpbGVkXCIpO1xuICAgIGNvbnN0IGNvbnRyYWN0SW5zdGFuY2UgPSBuZXcgQ29udHJhY3QoXG4gICAgICB0aGlzLmNvbXBpbGVkQ29udHJhY3QuYWJpLFxuICAgICAgY29udHJhY3RfYWRkcmVzcyxcbiAgICAgIHRoaXMuYWNjb3VudFxuICAgICk7XG4gICAgY29udHJhY3RJbnN0YW5jZS5kZXBsb3lUcmFuc2FjdGlvbkhhc2ggPSB0cmFuc2FjdGlvbl9oYXNoO1xuICAgIHJldHVybiBjb250cmFjdEluc3RhbmNlO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyB0byBuZXcgQWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudCAtIG5ldyBBY2NvdW50IHRvIGF0dGFjaCB0b1xuICAgKi9cbiAgY29ubmVjdChhY2NvdW50KSB7XG4gICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQXR0YWNoZXMgY3VycmVudCBhYmkgYW5kIGFjY291bnQgdG8gdGhlIG5ldyBhZGRyZXNzXG4gICAqL1xuICBhdHRhY2goYWRkcmVzcykge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3QodGhpcy5hYmksIGFkZHJlc3MsIHRoaXMuYWNjb3VudCk7XG4gIH1cbiAgLy8gZXRoZXJzLmpzJyBnZXREZXBsb3lUcmFuc2FjdGlvbiBjYW4ndCBiZSBzdXBwb3J0ZWQgYXMgaXQgcmVxdWlyZXMgdGhlIGFjY291bnQgb3Igc2lnbmVyIHRvIHJldHVybiBhIHNpZ25lZCB0cmFuc2FjdGlvbiB3aGljaCBpcyBub3QgcG9zc2libGUgd2l0aCB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvblxufTtcblxuLy8gc3JjL3V0aWxzL3Jlc3BvbnNlUGFyc2VyL2ludGVyZmFjZS50c1xudmFyIFJlc3BvbnNlUGFyc2VyID0gY2xhc3Mge1xufTtcblxuLy8gc3JjL3V0aWxzL2FkZHJlc3MudHNcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiO1xuZnVuY3Rpb24gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcykge1xuICBjb25zdCBoZXggPSB0b0hleChhZGRIZXhQcmVmaXgoYWRkcmVzcy50b1N0cmluZygpKSk7XG4gIGNvbnN0IHBhZGRlZCA9IHJlbW92ZUhleFByZWZpeChoZXgpLnBhZFN0YXJ0KDY0LCBcIjBcIik7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgocGFkZGVkKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gYWRkQWRkcmVzc1BhZGRpbmcoYWRkcmVzcyk7XG4gIGlmICghcmVzdWx0Lm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs2NH0kLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEFkZHJlc3MgRm9ybWF0XCIpO1xuICB9XG4gIGFzc2VydEluUmFuZ2UocmVzdWx0LCBaRVJPLCBBRERSX0JPVU5EIC0gMW4sIFwiU3RhcmtuZXQgQWRkcmVzc1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIGNvbnN0IGNoYXJzID0gcmVtb3ZlSGV4UHJlZml4KHZhbGlkYXRlQW5kUGFyc2VBZGRyZXNzKGFkZHJlc3MpKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiXCIpO1xuICBjb25zdCBoZXggPSByZW1vdmVIZXhQcmVmaXgoa2VjY2FrQm4oYWRkcmVzcykpO1xuICBjb25zdCBoYXNoZWQgPSBoZXhUb0J5dGVzMihoZXgucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoaGFzaGVkW2kgPj4gMV0gPj4gNCA+PSA4KSB7XG4gICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAxNSkgPj0gOCkge1xuICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoY2hhcnMuam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59XG5cbi8vIHNyYy91dGlscy91cmwudHNcbmltcG9ydCB1cmxqb2luIGZyb20gXCJ1cmwtam9pblwiO1xudmFyIHByb3RvY29sQW5kRG9tYWluUkUgPSAvXig/Olxcdys6KT9cXC9cXC8oXFxTKykkLztcbnZhciBsb2NhbGhvc3REb21haW5SRSA9IC9ebG9jYWxob3N0Wzo/XFxkXSooPzpbXjo/XFxkXVxcUyopPyQvO1xudmFyIG5vbkxvY2FsaG9zdERvbWFpblJFID0gL15bXlxccy5dK1xcLlxcU3syLH0kLztcbmZ1bmN0aW9uIGlzVXJsKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHMubWF0Y2gocHJvdG9jb2xBbmREb21haW5SRSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZXZlcnl0aGluZ0FmdGVyUHJvdG9jb2wgPSBtYXRjaFsxXTtcbiAgaWYgKCFldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkgfHwgbm9uTG9jYWxob3N0RG9tYWluUkUudGVzdChldmVyeXRoaW5nQWZ0ZXJQcm90b2NvbCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBidWlsZFVybChiYXNlVXJsLCBkZWZhdWx0UGF0aCwgdXJsT3JQYXRoKSB7XG4gIHJldHVybiBpc1VybCh1cmxPclBhdGgpID8gdXJsT3JQYXRoIDogdXJsam9pbihiYXNlVXJsLCB1cmxPclBhdGggPz8gZGVmYXVsdFBhdGgpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBudW1iZXIgPSBudW1fZXhwb3J0cztcbmV4cG9ydCB7XG4gIEFjY291bnQsXG4gIEFjY291bnRJbnRlcmZhY2UsXG4gIEJsb2NrU3RhdHVzLFxuICBCbG9ja1RhZyxcbiAgQ2Fpcm9DdXN0b21FbnVtLFxuICBDYWlyb09wdGlvbixcbiAgQ2Fpcm9PcHRpb25WYXJpYW50LFxuICBDYWlyb1Jlc3VsdCxcbiAgQ2Fpcm9SZXN1bHRWYXJpYW50LFxuICBDYWlyb1VpbnQyNTYsXG4gIENhaXJvVWludDUxMixcbiAgQ2FsbERhdGEsXG4gIENvbnRyYWN0LFxuICBDb250cmFjdEZhY3RvcnksXG4gIENvbnRyYWN0SW50ZXJmYWNlLFxuICBDdXN0b21FcnJvcixcbiAgRW50cnlQb2ludFR5cGUsXG4gIEV0aFNpZ25lcixcbiAgR2F0ZXdheUVycm9yLFxuICBIdHRwRXJyb3IsXG4gIExlZGdlclNpZ25lcixcbiAgTGlicmFyeUVycm9yLFxuICBMaXRlcmFsLFxuICBScGNQcm92aWRlcjIgYXMgUHJvdmlkZXIsXG4gIFByb3ZpZGVySW50ZXJmYWNlLFxuICBhcGlfZXhwb3J0cyBhcyBSUEMsXG4gIHJwY18wXzZfZXhwb3J0cyBhcyBSUEMwNixcbiAgcnBjXzBfN19leHBvcnRzIGFzIFJQQzA3LFxuICBSUENSZXNwb25zZVBhcnNlcixcbiAgUmVjZWlwdFR4LFxuICBSZXNwb25zZVBhcnNlcixcbiAgUnBjQ2hhbm5lbDIgYXMgUnBjQ2hhbm5lbCxcbiAgUnBjUHJvdmlkZXIyIGFzIFJwY1Byb3ZpZGVyLFxuICBTaWduZXIsXG4gIFNpZ25lckludGVyZmFjZSxcbiAgVHJhbnNhY3Rpb25FeGVjdXRpb25TdGF0dXMsXG4gIFRyYW5zYWN0aW9uRmluYWxpdHlTdGF0dXMsXG4gIFRyYW5zYWN0aW9uU3RhdHVzLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFR5cGVkRGF0YVJldmlzaW9uLFxuICBVSU5UXzEyOF9NQVgsXG4gIFVJTlRfMTI4X01JTixcbiAgVUlOVF8yNTZfSElHSF9NQVgsXG4gIFVJTlRfMjU2X0hJR0hfTUlOLFxuICBVSU5UXzI1Nl9MT1dfTUFYLFxuICBVSU5UXzI1Nl9MT1dfTUlOLFxuICBVSU5UXzI1Nl9NQVgsXG4gIFVJTlRfMjU2X01JTixcbiAgVUlOVF81MTJfTUFYLFxuICBVSU5UXzUxMl9NSU4sXG4gIFVpbnQsXG4gIFZhbGlkYXRlVHlwZSxcbiAgV2FsbGV0QWNjb3VudCxcbiAgYWRkQWRkcmVzc1BhZGRpbmcsXG4gIGJ1aWxkVXJsLFxuICBieXRlQXJyYXlfZXhwb3J0cyBhcyBieXRlQXJyYXksXG4gIGNhaXJvX2V4cG9ydHMgYXMgY2Fpcm8sXG4gIGNvbnN0YW50c19leHBvcnRzIGFzIGNvbnN0YW50cyxcbiAgY29udHJhY3RDbGFzc1Jlc3BvbnNlVG9MZWdhY3lDb21waWxlZENvbnRyYWN0LFxuICBkZWZhdWx0UHJvdmlkZXIsXG4gIGVjX2V4cG9ydHMgYXMgZWMsXG4gIGVuY29kZV9leHBvcnRzIGFzIGVuY29kZSxcbiAgZXRoX2V4cG9ydHMgYXMgZXRoLFxuICBldmVudHNfZXhwb3J0cyBhcyBldmVudHMsXG4gIGV4dHJhY3RDb250cmFjdEhhc2hlcyxcbiAgZml4UHJvdG8sXG4gIGZpeFN0YWNrLFxuICBnZXRDYWxsZGF0YSxcbiAgZ2V0Q2hlY2tzdW1BZGRyZXNzLFxuICBnZXRMZWRnZXJQYXRoQnVmZmVyLFxuICBoYXNoX2V4cG9ydHMgYXMgaGFzaCxcbiAgaXNTaWVycmEsXG4gIGlzVXJsLFxuICBqc29uX2V4cG9ydHMgYXMganNvbixcbiAgbWVya2xlX2V4cG9ydHMgYXMgbWVya2xlLFxuICBudW1fZXhwb3J0cyBhcyBudW0sXG4gIG51bWJlcixcbiAgcGFyc2VDYWxsZGF0YUZpZWxkLFxuICBwcm92aWRlcl9leHBvcnRzIGFzIHByb3ZpZGVyLFxuICBzZWxlY3Rvcl9leHBvcnRzIGFzIHNlbGVjdG9yLFxuICBzaG9ydFN0cmluZ19leHBvcnRzIGFzIHNob3J0U3RyaW5nLFxuICBzcGxpdEFyZ3NBbmRPcHRpb25zLFxuICBzdGFya19leHBvcnRzIGFzIHN0YXJrLFxuICBzdGFya25ldElkX2V4cG9ydHMgYXMgc3RhcmtuZXRJZCxcbiAgdHJhbnNhY3Rpb25fZXhwb3J0cyBhcyB0cmFuc2FjdGlvbixcbiAgdHlwZWREYXRhX2V4cG9ydHMgYXMgdHlwZWREYXRhLFxuICB0eXBlc19leHBvcnRzIGFzIHR5cGVzLFxuICB1aW50MjU2X2V4cG9ydHMgYXMgdWludDI1NixcbiAgdjJfZXhwb3J0cyBhcyB2Mmhhc2gsXG4gIHYzX2V4cG9ydHMgYXMgdjNoYXNoLFxuICB2YWxpZGF0ZUFuZFBhcnNlQWRkcmVzcyxcbiAgdmFsaWRhdGVDaGVja3N1bUFkZHJlc3MsXG4gIGNvbm5lY3RfZXhwb3J0cyBhcyB3YWxsZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/starknet/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/tailwind-merge/dist/bundle-mjs.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTailwindMerge: function() { return /* binding */ createTailwindMerge; },\n/* harmony export */   extendTailwindMerge: function() { return /* binding */ extendTailwindMerge; },\n/* harmony export */   fromTheme: function() { return /* binding */ fromTheme; },\n/* harmony export */   getDefaultConfig: function() { return /* binding */ getDefaultConfig; },\n/* harmony export */   mergeConfigs: function() { return /* binding */ mergeConfigs; },\n/* harmony export */   twJoin: function() { return /* binding */ twJoin; },\n/* harmony export */   twMerge: function() { return /* binding */ twMerge; },\n/* harmony export */   validators: function() { return /* binding */ validators; }\n/* harmony export */ });\nconst CLASS_PART_SEPARATOR = '-';\nconst createClassGroupUtils = config => {\n  const classMap = createClassMap(config);\n  const {\n    conflictingClassGroups,\n    conflictingClassGroupModifiers\n  } = config;\n  const getClassGroupId = className => {\n    const classParts = className.split(CLASS_PART_SEPARATOR);\n    // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n    if (classParts[0] === '' && classParts.length !== 1) {\n      classParts.shift();\n    }\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  };\n  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {\n    const conflicts = conflictingClassGroups[classGroupId] || [];\n    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {\n      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];\n    }\n    return conflicts;\n  };\n  return {\n    getClassGroupId,\n    getConflictingClassGroupIds\n  };\n};\nconst getGroupRecursive = (classParts, classPartObject) => {\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n  const currentClassPart = classParts[0];\n  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n  if (classPartObject.validators.length === 0) {\n    return undefined;\n  }\n  const classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return classPartObject.validators.find(({\n    validator\n  }) => validator(classRest))?.classGroupId;\n};\nconst arbitraryPropertyRegex = /^\\[(.+)\\]$/;\nconst getGroupIdForArbitraryProperty = className => {\n  if (arbitraryPropertyRegex.test(className)) {\n    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));\n    if (property) {\n      // I use two dots here because one dot is used as prefix for class groups in plugins\n      return 'arbitrary..' + property;\n    }\n  }\n};\n/**\n * Exported for testing only\n */\nconst createClassMap = config => {\n  const {\n    theme,\n    prefix\n  } = config;\n  const classMap = {\n    nextPart: new Map(),\n    validators: []\n  };\n  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);\n  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {\n    processClassesRecursively(classGroup, classMap, classGroupId, theme);\n  });\n  return classMap;\n};\nconst processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {\n  classGroup.forEach(classDefinition => {\n    if (typeof classDefinition === 'string') {\n      const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n    if (typeof classDefinition === 'function') {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId\n      });\n      return;\n    }\n    Object.entries(classDefinition).forEach(([key, classGroup]) => {\n      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n};\nconst getPart = (classPartObject, path) => {\n  let currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(pathPart => {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: new Map(),\n        validators: []\n      });\n    }\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n};\nconst isThemeGetter = func => func.isThemeGetter;\nconst getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {\n  if (!prefix) {\n    return classGroupEntries;\n  }\n  return classGroupEntries.map(([classGroupId, classGroup]) => {\n    const prefixedClassGroup = classGroup.map(classDefinition => {\n      if (typeof classDefinition === 'string') {\n        return prefix + classDefinition;\n      }\n      if (typeof classDefinition === 'object') {\n        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));\n      }\n      return classDefinition;\n    });\n    return [classGroupId, prefixedClassGroup];\n  });\n};\n\n// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance\nconst createLruCache = maxCacheSize => {\n  if (maxCacheSize < 1) {\n    return {\n      get: () => undefined,\n      set: () => {}\n    };\n  }\n  let cacheSize = 0;\n  let cache = new Map();\n  let previousCache = new Map();\n  const update = (key, value) => {\n    cache.set(key, value);\n    cacheSize++;\n    if (cacheSize > maxCacheSize) {\n      cacheSize = 0;\n      previousCache = cache;\n      cache = new Map();\n    }\n  };\n  return {\n    get(key) {\n      let value = cache.get(key);\n      if (value !== undefined) {\n        return value;\n      }\n      if ((value = previousCache.get(key)) !== undefined) {\n        update(key, value);\n        return value;\n      }\n    },\n    set(key, value) {\n      if (cache.has(key)) {\n        cache.set(key, value);\n      } else {\n        update(key, value);\n      }\n    }\n  };\n};\nconst IMPORTANT_MODIFIER = '!';\nconst createParseClassName = config => {\n  const {\n    separator,\n    experimentalParseClassName\n  } = config;\n  const isSeparatorSingleCharacter = separator.length === 1;\n  const firstSeparatorCharacter = separator[0];\n  const separatorLength = separator.length;\n  // parseClassName inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n  const parseClassName = className => {\n    const modifiers = [];\n    let bracketDepth = 0;\n    let modifierStart = 0;\n    let postfixModifierPosition;\n    for (let index = 0; index < className.length; index++) {\n      let currentCharacter = className[index];\n      if (bracketDepth === 0) {\n        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + separatorLength;\n          continue;\n        }\n        if (currentCharacter === '/') {\n          postfixModifierPosition = index;\n          continue;\n        }\n      }\n      if (currentCharacter === '[') {\n        bracketDepth++;\n      } else if (currentCharacter === ']') {\n        bracketDepth--;\n      }\n    }\n    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;\n    return {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    };\n  };\n  if (experimentalParseClassName) {\n    return className => experimentalParseClassName({\n      className,\n      parseClassName\n    });\n  }\n  return parseClassName;\n};\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nconst sortModifiers = modifiers => {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n  const sortedModifiers = [];\n  let unsortedModifiers = [];\n  modifiers.forEach(modifier => {\n    const isArbitraryVariant = modifier[0] === '[';\n    if (isArbitraryVariant) {\n      sortedModifiers.push(...unsortedModifiers.sort(), modifier);\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push(...unsortedModifiers.sort());\n  return sortedModifiers;\n};\nconst createConfigUtils = config => ({\n  cache: createLruCache(config.cacheSize),\n  parseClassName: createParseClassName(config),\n  ...createClassGroupUtils(config)\n});\nconst SPLIT_CLASSES_REGEX = /\\s+/;\nconst mergeClassList = (classList, configUtils) => {\n  const {\n    parseClassName,\n    getClassGroupId,\n    getConflictingClassGroupIds\n  } = configUtils;\n  /**\n   * Set of classGroupIds in following format:\n   * `{importantModifier}{variantModifiers}{classGroupId}`\n   * @example 'float'\n   * @example 'hover:focus:bg-color'\n   * @example 'md:!pr'\n   */\n  const classGroupsInConflict = [];\n  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);\n  let result = '';\n  for (let index = classNames.length - 1; index >= 0; index -= 1) {\n    const originalClassName = classNames[index];\n    const {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    } = parseClassName(originalClassName);\n    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);\n    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);\n    if (!classGroupId) {\n      if (!hasPostfixModifier) {\n        // Not a Tailwind class\n        result = originalClassName + (result.length > 0 ? ' ' + result : result);\n        continue;\n      }\n      classGroupId = getClassGroupId(baseClassName);\n      if (!classGroupId) {\n        // Not a Tailwind class\n        result = originalClassName + (result.length > 0 ? ' ' + result : result);\n        continue;\n      }\n      hasPostfixModifier = false;\n    }\n    const variantModifier = sortModifiers(modifiers).join(':');\n    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    const classId = modifierId + classGroupId;\n    if (classGroupsInConflict.includes(classId)) {\n      // Tailwind class omitted due to conflict\n      continue;\n    }\n    classGroupsInConflict.push(classId);\n    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);\n    for (let i = 0; i < conflictGroups.length; ++i) {\n      const group = conflictGroups[i];\n      classGroupsInConflict.push(modifierId + group);\n    }\n    // Tailwind class not in conflict\n    result = originalClassName + (result.length > 0 ? ' ' + result : result);\n  }\n  return result;\n};\n\n/**\n * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.\n *\n * Specifically:\n * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js\n * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts\n *\n * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)\n */\nfunction twJoin() {\n  let index = 0;\n  let argument;\n  let resolvedValue;\n  let string = '';\n  while (index < arguments.length) {\n    if (argument = arguments[index++]) {\n      if (resolvedValue = toValue(argument)) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n}\nconst toValue = mix => {\n  if (typeof mix === 'string') {\n    return mix;\n  }\n  let resolvedValue;\n  let string = '';\n  for (let k = 0; k < mix.length; k++) {\n    if (mix[k]) {\n      if (resolvedValue = toValue(mix[k])) {\n        string && (string += ' ');\n        string += resolvedValue;\n      }\n    }\n  }\n  return string;\n};\nfunction createTailwindMerge(createConfigFirst, ...createConfigRest) {\n  let configUtils;\n  let cacheGet;\n  let cacheSet;\n  let functionToCall = initTailwindMerge;\n  function initTailwindMerge(classList) {\n    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());\n    configUtils = createConfigUtils(config);\n    cacheGet = configUtils.cache.get;\n    cacheSet = configUtils.cache.set;\n    functionToCall = tailwindMerge;\n    return tailwindMerge(classList);\n  }\n  function tailwindMerge(classList) {\n    const cachedResult = cacheGet(classList);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    const result = mergeClassList(classList, configUtils);\n    cacheSet(classList, result);\n    return result;\n  }\n  return function callTailwindMerge() {\n    return functionToCall(twJoin.apply(null, arguments));\n  };\n}\nconst fromTheme = key => {\n  const themeGetter = theme => theme[key] || [];\n  themeGetter.isThemeGetter = true;\n  return themeGetter;\n};\nconst arbitraryValueRegex = /^\\[(?:([a-z-]+):)?(.+)\\]$/i;\nconst fractionRegex = /^\\d+\\/\\d+$/;\nconst stringLengths = /*#__PURE__*/new Set(['px', 'full', 'screen']);\nconst tshirtUnitRegex = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/;\nconst lengthUnitRegex = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/;\nconst colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\\(.+\\)$/;\n// Shadow always begins with x and y offset separated by underscore optionally prepended by inset\nconst shadowRegex = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/;\nconst imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nconst isLength = value => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);\nconst isArbitraryLength = value => getIsArbitraryValue(value, 'length', isLengthOnly);\nconst isNumber = value => Boolean(value) && !Number.isNaN(Number(value));\nconst isArbitraryNumber = value => getIsArbitraryValue(value, 'number', isNumber);\nconst isInteger = value => Boolean(value) && Number.isInteger(Number(value));\nconst isPercent = value => value.endsWith('%') && isNumber(value.slice(0, -1));\nconst isArbitraryValue = value => arbitraryValueRegex.test(value);\nconst isTshirtSize = value => tshirtUnitRegex.test(value);\nconst sizeLabels = /*#__PURE__*/new Set(['length', 'size', 'percentage']);\nconst isArbitrarySize = value => getIsArbitraryValue(value, sizeLabels, isNever);\nconst isArbitraryPosition = value => getIsArbitraryValue(value, 'position', isNever);\nconst imageLabels = /*#__PURE__*/new Set(['image', 'url']);\nconst isArbitraryImage = value => getIsArbitraryValue(value, imageLabels, isImage);\nconst isArbitraryShadow = value => getIsArbitraryValue(value, '', isShadow);\nconst isAny = () => true;\nconst getIsArbitraryValue = (value, label, testValue) => {\n  const result = arbitraryValueRegex.exec(value);\n  if (result) {\n    if (result[1]) {\n      return typeof label === 'string' ? result[1] === label : label.has(result[1]);\n    }\n    return testValue(result[2]);\n  }\n  return false;\n};\nconst isLengthOnly = value =>\n// `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.\n// For example, `hsl(0 0% 0%)` would be classified as a length without this check.\n// I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.\nlengthUnitRegex.test(value) && !colorFunctionRegex.test(value);\nconst isNever = () => false;\nconst isShadow = value => shadowRegex.test(value);\nconst isImage = value => imageRegex.test(value);\nconst validators = /*#__PURE__*/Object.defineProperty({\n  __proto__: null,\n  isAny,\n  isArbitraryImage,\n  isArbitraryLength,\n  isArbitraryNumber,\n  isArbitraryPosition,\n  isArbitraryShadow,\n  isArbitrarySize,\n  isArbitraryValue,\n  isInteger,\n  isLength,\n  isNumber,\n  isPercent,\n  isTshirtSize\n}, Symbol.toStringTag, {\n  value: 'Module'\n});\nconst getDefaultConfig = () => {\n  const colors = fromTheme('colors');\n  const spacing = fromTheme('spacing');\n  const blur = fromTheme('blur');\n  const brightness = fromTheme('brightness');\n  const borderColor = fromTheme('borderColor');\n  const borderRadius = fromTheme('borderRadius');\n  const borderSpacing = fromTheme('borderSpacing');\n  const borderWidth = fromTheme('borderWidth');\n  const contrast = fromTheme('contrast');\n  const grayscale = fromTheme('grayscale');\n  const hueRotate = fromTheme('hueRotate');\n  const invert = fromTheme('invert');\n  const gap = fromTheme('gap');\n  const gradientColorStops = fromTheme('gradientColorStops');\n  const gradientColorStopPositions = fromTheme('gradientColorStopPositions');\n  const inset = fromTheme('inset');\n  const margin = fromTheme('margin');\n  const opacity = fromTheme('opacity');\n  const padding = fromTheme('padding');\n  const saturate = fromTheme('saturate');\n  const scale = fromTheme('scale');\n  const sepia = fromTheme('sepia');\n  const skew = fromTheme('skew');\n  const space = fromTheme('space');\n  const translate = fromTheme('translate');\n  const getOverscroll = () => ['auto', 'contain', 'none'];\n  const getOverflow = () => ['auto', 'hidden', 'clip', 'visible', 'scroll'];\n  const getSpacingWithAutoAndArbitrary = () => ['auto', isArbitraryValue, spacing];\n  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];\n  const getLengthWithEmptyAndArbitrary = () => ['', isLength, isArbitraryLength];\n  const getNumberWithAutoAndArbitrary = () => ['auto', isNumber, isArbitraryValue];\n  const getPositions = () => ['bottom', 'center', 'left', 'left-bottom', 'left-top', 'right', 'right-bottom', 'right-top', 'top'];\n  const getLineStyles = () => ['solid', 'dashed', 'dotted', 'double', 'none'];\n  const getBlendModes = () => ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];\n  const getAlign = () => ['start', 'end', 'center', 'between', 'around', 'evenly', 'stretch'];\n  const getZeroAndEmpty = () => ['', '0', isArbitraryValue];\n  const getBreaks = () => ['auto', 'avoid', 'all', 'avoid-page', 'page', 'left', 'right', 'column'];\n  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];\n  return {\n    cacheSize: 500,\n    separator: ':',\n    theme: {\n      colors: [isAny],\n      spacing: [isLength, isArbitraryLength],\n      blur: ['none', '', isTshirtSize, isArbitraryValue],\n      brightness: getNumberAndArbitrary(),\n      borderColor: [colors],\n      borderRadius: ['none', '', 'full', isTshirtSize, isArbitraryValue],\n      borderSpacing: getSpacingWithArbitrary(),\n      borderWidth: getLengthWithEmptyAndArbitrary(),\n      contrast: getNumberAndArbitrary(),\n      grayscale: getZeroAndEmpty(),\n      hueRotate: getNumberAndArbitrary(),\n      invert: getZeroAndEmpty(),\n      gap: getSpacingWithArbitrary(),\n      gradientColorStops: [colors],\n      gradientColorStopPositions: [isPercent, isArbitraryLength],\n      inset: getSpacingWithAutoAndArbitrary(),\n      margin: getSpacingWithAutoAndArbitrary(),\n      opacity: getNumberAndArbitrary(),\n      padding: getSpacingWithArbitrary(),\n      saturate: getNumberAndArbitrary(),\n      scale: getNumberAndArbitrary(),\n      sepia: getZeroAndEmpty(),\n      skew: getNumberAndArbitrary(),\n      space: getSpacingWithArbitrary(),\n      translate: getSpacingWithArbitrary()\n    },\n    classGroups: {\n      // Layout\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: ['auto', 'square', 'video', isArbitraryValue]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       */\n      container: ['container'],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [isTshirtSize]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      'break-after': [{\n        'break-after': getBreaks()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      'break-before': [{\n        'break-before': getBreaks()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      'break-inside': [{\n        'break-inside': ['auto', 'avoid', 'avoid-page', 'avoid-column']\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      'box-decoration': [{\n        'box-decoration': ['slice', 'clone']\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: ['border', 'content']\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: ['block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'inline-table', 'table-caption', 'table-cell', 'table-column', 'table-column-group', 'table-footer-group', 'table-header-group', 'table-row-group', 'table-row', 'flow-root', 'grid', 'inline-grid', 'contents', 'list-item', 'hidden'],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: ['right', 'left', 'none', 'start', 'end']\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: ['left', 'right', 'both', 'none', 'start', 'end']\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: ['isolate', 'isolation-auto'],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      'object-fit': [{\n        object: ['contain', 'cover', 'fill', 'none', 'scale-down']\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      'object-position': [{\n        object: [...getPositions(), isArbitraryValue]\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: getOverflow()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-x': [{\n        'overflow-x': getOverflow()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      'overflow-y': [{\n        'overflow-y': getOverflow()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-x': [{\n        'overscroll-x': getOverscroll()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      'overscroll-y': [{\n        'overscroll-y': getOverscroll()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: ['static', 'fixed', 'absolute', 'relative', 'sticky'],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: [inset]\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-x': [{\n        'inset-x': [inset]\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      'inset-y': [{\n        'inset-y': [inset]\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: [inset]\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: [inset]\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: [inset]\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: [inset]\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: [inset]\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: [inset]\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: ['visible', 'invisible', 'collapse'],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: ['auto', isInteger, isArbitraryValue]\n      }],\n      // Flexbox and Grid\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: getSpacingWithAutoAndArbitrary()\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      'flex-direction': [{\n        flex: ['row', 'row-reverse', 'col', 'col-reverse']\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      'flex-wrap': [{\n        flex: ['wrap', 'wrap-reverse', 'nowrap']\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: ['1', 'auto', 'initial', 'none', isArbitraryValue]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: getZeroAndEmpty()\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: getZeroAndEmpty()\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: ['first', 'last', 'none', isInteger, isArbitraryValue]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      'grid-cols': [{\n        'grid-cols': [isAny]\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start-end': [{\n        col: ['auto', {\n          span: ['full', isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-start': [{\n        'col-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      'col-end': [{\n        'col-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      'grid-rows': [{\n        'grid-rows': [isAny]\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start-end': [{\n        row: ['auto', {\n          span: [isInteger, isArbitraryValue]\n        }, isArbitraryValue]\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-start': [{\n        'row-start': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      'row-end': [{\n        'row-end': getNumberWithAutoAndArbitrary()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      'grid-flow': [{\n        'grid-flow': ['row', 'col', 'dense', 'row-dense', 'col-dense']\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      'auto-cols': [{\n        'auto-cols': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      'auto-rows': [{\n        'auto-rows': ['auto', 'min', 'max', 'fr', isArbitraryValue]\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: [gap]\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-x': [{\n        'gap-x': [gap]\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      'gap-y': [{\n        'gap-y': [gap]\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      'justify-content': [{\n        justify: ['normal', ...getAlign()]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      'justify-items': [{\n        'justify-items': ['start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      'justify-self': [{\n        'justify-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      'align-content': [{\n        content: ['normal', ...getAlign(), 'baseline']\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      'align-items': [{\n        items: ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      'align-self': [{\n        self: ['auto', 'start', 'end', 'center', 'stretch', 'baseline']\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      'place-content': [{\n        'place-content': [...getAlign(), 'baseline']\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      'place-items': [{\n        'place-items': ['start', 'end', 'center', 'baseline', 'stretch']\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      'place-self': [{\n        'place-self': ['auto', 'start', 'end', 'center', 'stretch']\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: [padding]\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: [padding]\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: [padding]\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: [padding]\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: [padding]\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: [padding]\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: [padding]\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: [padding]\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: [padding]\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: [margin]\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: [margin]\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: [margin]\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: [margin]\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: [margin]\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: [margin]\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: [margin]\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: [margin]\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: [margin]\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x': [{\n        'space-x': [space]\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-x-reverse': ['space-x-reverse'],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y': [{\n        'space-y': [space]\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      'space-y-reverse': ['space-y-reverse'],\n      // Sizing\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: ['auto', 'min', 'max', 'fit', 'svw', 'lvw', 'dvw', isArbitraryValue, spacing]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      'min-w': [{\n        'min-w': [isArbitraryValue, spacing, 'min', 'max', 'fit']\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      'max-w': [{\n        'max-w': [isArbitraryValue, spacing, 'none', 'full', 'min', 'max', 'fit', 'prose', {\n          screen: [isTshirtSize]\n        }, isTshirtSize]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      'min-h': [{\n        'min-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      'max-h': [{\n        'max-h': [isArbitraryValue, spacing, 'min', 'max', 'fit', 'svh', 'lvh', 'dvh']\n      }],\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/size\n       */\n      size: [{\n        size: [isArbitraryValue, spacing, 'auto', 'min', 'max', 'fit']\n      }],\n      // Typography\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      'font-size': [{\n        text: ['base', isTshirtSize, isArbitraryLength]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      'font-smoothing': ['antialiased', 'subpixel-antialiased'],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      'font-style': ['italic', 'not-italic'],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      'font-weight': [{\n        font: ['thin', 'extralight', 'light', 'normal', 'medium', 'semibold', 'bold', 'extrabold', 'black', isArbitraryNumber]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      'font-family': [{\n        font: [isAny]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-normal': ['normal-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-ordinal': ['ordinal'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-slashed-zero': ['slashed-zero'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-figure': ['lining-nums', 'oldstyle-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-spacing': ['proportional-nums', 'tabular-nums'],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      'fvn-fraction': ['diagonal-fractions', 'stacked-fractons'],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: ['tighter', 'tight', 'normal', 'wide', 'wider', 'widest', isArbitraryValue]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      'line-clamp': [{\n        'line-clamp': ['none', isNumber, isArbitraryNumber]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: ['none', 'tight', 'snug', 'normal', 'relaxed', 'loose', isLength, isArbitraryValue]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      'list-image': [{\n        'list-image': ['none', isArbitraryValue]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      'list-style-type': [{\n        list: ['none', 'disc', 'decimal', isArbitraryValue]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      'list-style-position': [{\n        list: ['inside', 'outside']\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/placeholder-color\n       */\n      'placeholder-color': [{\n        placeholder: [colors]\n      }],\n      /**\n       * Placeholder Opacity\n       * @see https://tailwindcss.com/docs/placeholder-opacity\n       */\n      'placeholder-opacity': [{\n        'placeholder-opacity': [opacity]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      'text-alignment': [{\n        text: ['left', 'center', 'right', 'justify', 'start', 'end']\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      'text-color': [{\n        text: [colors]\n      }],\n      /**\n       * Text Opacity\n       * @see https://tailwindcss.com/docs/text-opacity\n       */\n      'text-opacity': [{\n        'text-opacity': [opacity]\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      'text-decoration': ['underline', 'overline', 'line-through', 'no-underline'],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      'text-decoration-style': [{\n        decoration: [...getLineStyles(), 'wavy']\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      'text-decoration-thickness': [{\n        decoration: ['auto', 'from-font', isLength, isArbitraryLength]\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      'underline-offset': [{\n        'underline-offset': ['auto', isLength, isArbitraryValue]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      'text-decoration-color': [{\n        decoration: [colors]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      'text-transform': ['uppercase', 'lowercase', 'capitalize', 'normal-case'],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      'text-overflow': ['truncate', 'text-ellipsis', 'text-clip'],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      'text-wrap': [{\n        text: ['wrap', 'nowrap', 'balance', 'pretty']\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: getSpacingWithArbitrary()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      'vertical-align': [{\n        align: ['baseline', 'top', 'middle', 'bottom', 'text-top', 'text-bottom', 'sub', 'super', isArbitraryValue]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: ['normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'break-spaces']\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: ['normal', 'words', 'all', 'keep']\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: ['none', 'manual', 'auto']\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: ['none', isArbitraryValue]\n      }],\n      // Backgrounds\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      'bg-attachment': [{\n        bg: ['fixed', 'local', 'scroll']\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      'bg-clip': [{\n        'bg-clip': ['border', 'padding', 'content', 'text']\n      }],\n      /**\n       * Background Opacity\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/background-opacity\n       */\n      'bg-opacity': [{\n        'bg-opacity': [opacity]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      'bg-origin': [{\n        'bg-origin': ['border', 'padding', 'content']\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      'bg-position': [{\n        bg: [...getPositions(), isArbitraryPosition]\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      'bg-repeat': [{\n        bg: ['no-repeat', {\n          repeat: ['', 'x', 'y', 'round', 'space']\n        }]\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      'bg-size': [{\n        bg: ['auto', 'cover', 'contain', isArbitrarySize]\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      'bg-image': [{\n        bg: ['none', {\n          'gradient-to': ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl']\n        }, isArbitraryImage]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      'bg-color': [{\n        bg: [colors]\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from-pos': [{\n        from: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via-pos': [{\n        via: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to-pos': [{\n        to: [gradientColorStopPositions]\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-from': [{\n        from: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-via': [{\n        via: [gradientColorStops]\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      'gradient-to': [{\n        to: [gradientColorStops]\n      }],\n      // Borders\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: [borderRadius]\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-s': [{\n        'rounded-s': [borderRadius]\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-e': [{\n        'rounded-e': [borderRadius]\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-t': [{\n        'rounded-t': [borderRadius]\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-r': [{\n        'rounded-r': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-b': [{\n        'rounded-b': [borderRadius]\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-l': [{\n        'rounded-l': [borderRadius]\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ss': [{\n        'rounded-ss': [borderRadius]\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-se': [{\n        'rounded-se': [borderRadius]\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-ee': [{\n        'rounded-ee': [borderRadius]\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-es': [{\n        'rounded-es': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tl': [{\n        'rounded-tl': [borderRadius]\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-tr': [{\n        'rounded-tr': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-br': [{\n        'rounded-br': [borderRadius]\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      'rounded-bl': [{\n        'rounded-bl': [borderRadius]\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w': [{\n        border: [borderWidth]\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-x': [{\n        'border-x': [borderWidth]\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-y': [{\n        'border-y': [borderWidth]\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-s': [{\n        'border-s': [borderWidth]\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-e': [{\n        'border-e': [borderWidth]\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-t': [{\n        'border-t': [borderWidth]\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-r': [{\n        'border-r': [borderWidth]\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-b': [{\n        'border-b': [borderWidth]\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      'border-w-l': [{\n        'border-l': [borderWidth]\n      }],\n      /**\n       * Border Opacity\n       * @see https://tailwindcss.com/docs/border-opacity\n       */\n      'border-opacity': [{\n        'border-opacity': [opacity]\n      }],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      'border-style': [{\n        border: [...getLineStyles(), 'hidden']\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x': [{\n        'divide-x': [borderWidth]\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-x-reverse': ['divide-x-reverse'],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y': [{\n        'divide-y': [borderWidth]\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      'divide-y-reverse': ['divide-y-reverse'],\n      /**\n       * Divide Opacity\n       * @see https://tailwindcss.com/docs/divide-opacity\n       */\n      'divide-opacity': [{\n        'divide-opacity': [opacity]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/divide-style\n       */\n      'divide-style': [{\n        divide: getLineStyles()\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color': [{\n        border: [borderColor]\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-x': [{\n        'border-x': [borderColor]\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-y': [{\n        'border-y': [borderColor]\n      }],\n      /**\n       * Border Color S\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-s': [{\n        'border-s': [borderColor]\n      }],\n      /**\n       * Border Color E\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-e': [{\n        'border-e': [borderColor]\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-t': [{\n        'border-t': [borderColor]\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-r': [{\n        'border-r': [borderColor]\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-b': [{\n        'border-b': [borderColor]\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      'border-color-l': [{\n        'border-l': [borderColor]\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      'divide-color': [{\n        divide: [borderColor]\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      'outline-style': [{\n        outline: ['', ...getLineStyles()]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      'outline-offset': [{\n        'outline-offset': [isLength, isArbitraryValue]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      'outline-w': [{\n        outline: [isLength, isArbitraryLength]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      'outline-color': [{\n        outline: [colors]\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w': [{\n        ring: getLengthWithEmptyAndArbitrary()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      'ring-w-inset': ['ring-inset'],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/ring-color\n       */\n      'ring-color': [{\n        ring: [colors]\n      }],\n      /**\n       * Ring Opacity\n       * @see https://tailwindcss.com/docs/ring-opacity\n       */\n      'ring-opacity': [{\n        'ring-opacity': [opacity]\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://tailwindcss.com/docs/ring-offset-width\n       */\n      'ring-offset-w': [{\n        'ring-offset': [isLength, isArbitraryLength]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://tailwindcss.com/docs/ring-offset-color\n       */\n      'ring-offset-color': [{\n        'ring-offset': [colors]\n      }],\n      // Effects\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: ['', 'inner', 'none', isTshirtSize, isArbitraryShadow]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow-color\n       */\n      'shadow-color': [{\n        shadow: [isAny]\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [opacity]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      'mix-blend': [{\n        'mix-blend': [...getBlendModes(), 'plus-lighter', 'plus-darker']\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      'bg-blend': [{\n        'bg-blend': getBlendModes()\n      }],\n      // Filters\n      /**\n       * Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: ['', 'none']\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: [blur]\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [brightness]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [contrast]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      'drop-shadow': [{\n        'drop-shadow': ['', 'none', isTshirtSize, isArbitraryValue]\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [grayscale]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      'hue-rotate': [{\n        'hue-rotate': [hueRotate]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [invert]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [saturate]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [sepia]\n      }],\n      /**\n       * Backdrop Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      'backdrop-filter': [{\n        'backdrop-filter': ['', 'none']\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      'backdrop-blur': [{\n        'backdrop-blur': [blur]\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      'backdrop-brightness': [{\n        'backdrop-brightness': [brightness]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      'backdrop-contrast': [{\n        'backdrop-contrast': [contrast]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      'backdrop-grayscale': [{\n        'backdrop-grayscale': [grayscale]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      'backdrop-hue-rotate': [{\n        'backdrop-hue-rotate': [hueRotate]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      'backdrop-invert': [{\n        'backdrop-invert': [invert]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      'backdrop-opacity': [{\n        'backdrop-opacity': [opacity]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      'backdrop-saturate': [{\n        'backdrop-saturate': [saturate]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      'backdrop-sepia': [{\n        'backdrop-sepia': [sepia]\n      }],\n      // Tables\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      'border-collapse': [{\n        border: ['collapse', 'separate']\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing': [{\n        'border-spacing': [borderSpacing]\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-x': [{\n        'border-spacing-x': [borderSpacing]\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      'border-spacing-y': [{\n        'border-spacing-y': [borderSpacing]\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      'table-layout': [{\n        table: ['auto', 'fixed']\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: ['top', 'bottom']\n      }],\n      // Transitions and Animation\n      /**\n       * Tranisition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: ['none', 'all', '', 'colors', 'opacity', 'shadow', 'transform', isArbitraryValue]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: getNumberAndArbitrary()\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: ['linear', 'in', 'out', 'in-out', isArbitraryValue]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: getNumberAndArbitrary()\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: ['none', 'spin', 'ping', 'pulse', 'bounce', isArbitraryValue]\n      }],\n      // Transforms\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: ['', 'gpu', 'none']\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: [scale]\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-x': [{\n        'scale-x': [scale]\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      'scale-y': [{\n        'scale-y': [scale]\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: [isInteger, isArbitraryValue]\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-x': [{\n        'translate-x': [translate]\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      'translate-y': [{\n        'translate-y': [translate]\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-x': [{\n        'skew-x': [skew]\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      'skew-y': [{\n        'skew-y': [skew]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      'transform-origin': [{\n        origin: ['center', 'top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left', isArbitraryValue]\n      }],\n      // Interactivity\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: ['auto', colors]\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: ['none', 'auto']\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: ['auto', 'default', 'pointer', 'wait', 'text', 'move', 'help', 'not-allowed', 'none', 'context-menu', 'progress', 'cell', 'crosshair', 'vertical-text', 'alias', 'copy', 'no-drop', 'grab', 'grabbing', 'all-scroll', 'col-resize', 'row-resize', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'ew-resize', 'ns-resize', 'nesw-resize', 'nwse-resize', 'zoom-in', 'zoom-out', isArbitraryValue]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      'caret-color': [{\n        caret: [colors]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      'pointer-events': [{\n        'pointer-events': ['none', 'auto']\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: ['none', 'y', 'x', '']\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      'scroll-behavior': [{\n        scroll: ['auto', 'smooth']\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-m': [{\n        'scroll-m': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mx': [{\n        'scroll-mx': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-my': [{\n        'scroll-my': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ms': [{\n        'scroll-ms': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-me': [{\n        'scroll-me': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mt': [{\n        'scroll-mt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mr': [{\n        'scroll-mr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-mb': [{\n        'scroll-mb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      'scroll-ml': [{\n        'scroll-ml': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-p': [{\n        'scroll-p': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-px': [{\n        'scroll-px': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-py': [{\n        'scroll-py': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-ps': [{\n        'scroll-ps': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pe': [{\n        'scroll-pe': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pt': [{\n        'scroll-pt': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pr': [{\n        'scroll-pr': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pb': [{\n        'scroll-pb': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      'scroll-pl': [{\n        'scroll-pl': getSpacingWithArbitrary()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      'snap-align': [{\n        snap: ['start', 'end', 'center', 'align-none']\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      'snap-stop': [{\n        snap: ['normal', 'always']\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-type': [{\n        snap: ['none', 'x', 'y', 'both']\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      'snap-strictness': [{\n        snap: ['mandatory', 'proximity']\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: ['auto', 'none', 'manipulation']\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-x': [{\n        'touch-pan': ['x', 'left', 'right']\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-y': [{\n        'touch-pan': ['y', 'up', 'down']\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      'touch-pz': ['touch-pinch-zoom'],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: ['none', 'text', 'all', 'auto']\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      'will-change': [{\n        'will-change': ['auto', 'scroll', 'contents', 'transform', isArbitraryValue]\n      }],\n      // SVG\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [colors, 'none']\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      'stroke-w': [{\n        stroke: [isLength, isArbitraryLength, isArbitraryNumber]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [colors, 'none']\n      }],\n      // Accessibility\n      /**\n       * Screen Readers\n       * @see https://tailwindcss.com/docs/screen-readers\n       */\n      sr: ['sr-only', 'not-sr-only'],\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      'forced-color-adjust': [{\n        'forced-color-adjust': ['auto', 'none']\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: ['overflow-x', 'overflow-y'],\n      overscroll: ['overscroll-x', 'overscroll-y'],\n      inset: ['inset-x', 'inset-y', 'start', 'end', 'top', 'right', 'bottom', 'left'],\n      'inset-x': ['right', 'left'],\n      'inset-y': ['top', 'bottom'],\n      flex: ['basis', 'grow', 'shrink'],\n      gap: ['gap-x', 'gap-y'],\n      p: ['px', 'py', 'ps', 'pe', 'pt', 'pr', 'pb', 'pl'],\n      px: ['pr', 'pl'],\n      py: ['pt', 'pb'],\n      m: ['mx', 'my', 'ms', 'me', 'mt', 'mr', 'mb', 'ml'],\n      mx: ['mr', 'ml'],\n      my: ['mt', 'mb'],\n      size: ['w', 'h'],\n      'font-size': ['leading'],\n      'fvn-normal': ['fvn-ordinal', 'fvn-slashed-zero', 'fvn-figure', 'fvn-spacing', 'fvn-fraction'],\n      'fvn-ordinal': ['fvn-normal'],\n      'fvn-slashed-zero': ['fvn-normal'],\n      'fvn-figure': ['fvn-normal'],\n      'fvn-spacing': ['fvn-normal'],\n      'fvn-fraction': ['fvn-normal'],\n      'line-clamp': ['display', 'overflow'],\n      rounded: ['rounded-s', 'rounded-e', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-ss', 'rounded-se', 'rounded-ee', 'rounded-es', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'],\n      'rounded-s': ['rounded-ss', 'rounded-es'],\n      'rounded-e': ['rounded-se', 'rounded-ee'],\n      'rounded-t': ['rounded-tl', 'rounded-tr'],\n      'rounded-r': ['rounded-tr', 'rounded-br'],\n      'rounded-b': ['rounded-br', 'rounded-bl'],\n      'rounded-l': ['rounded-tl', 'rounded-bl'],\n      'border-spacing': ['border-spacing-x', 'border-spacing-y'],\n      'border-w': ['border-w-s', 'border-w-e', 'border-w-t', 'border-w-r', 'border-w-b', 'border-w-l'],\n      'border-w-x': ['border-w-r', 'border-w-l'],\n      'border-w-y': ['border-w-t', 'border-w-b'],\n      'border-color': ['border-color-s', 'border-color-e', 'border-color-t', 'border-color-r', 'border-color-b', 'border-color-l'],\n      'border-color-x': ['border-color-r', 'border-color-l'],\n      'border-color-y': ['border-color-t', 'border-color-b'],\n      'scroll-m': ['scroll-mx', 'scroll-my', 'scroll-ms', 'scroll-me', 'scroll-mt', 'scroll-mr', 'scroll-mb', 'scroll-ml'],\n      'scroll-mx': ['scroll-mr', 'scroll-ml'],\n      'scroll-my': ['scroll-mt', 'scroll-mb'],\n      'scroll-p': ['scroll-px', 'scroll-py', 'scroll-ps', 'scroll-pe', 'scroll-pt', 'scroll-pr', 'scroll-pb', 'scroll-pl'],\n      'scroll-px': ['scroll-pr', 'scroll-pl'],\n      'scroll-py': ['scroll-pt', 'scroll-pb'],\n      touch: ['touch-x', 'touch-y', 'touch-pz'],\n      'touch-x': ['touch'],\n      'touch-y': ['touch'],\n      'touch-pz': ['touch']\n    },\n    conflictingClassGroupModifiers: {\n      'font-size': ['leading']\n    }\n  };\n};\n\n/**\n * @param baseConfig Config where other config will be merged into. This object will be mutated.\n * @param configExtension Partial config to merge into the `baseConfig`.\n */\nconst mergeConfigs = (baseConfig, {\n  cacheSize,\n  prefix,\n  separator,\n  experimentalParseClassName,\n  extend = {},\n  override = {}\n}) => {\n  overrideProperty(baseConfig, 'cacheSize', cacheSize);\n  overrideProperty(baseConfig, 'prefix', prefix);\n  overrideProperty(baseConfig, 'separator', separator);\n  overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);\n  for (const configKey in override) {\n    overrideConfigProperties(baseConfig[configKey], override[configKey]);\n  }\n  for (const key in extend) {\n    mergeConfigProperties(baseConfig[key], extend[key]);\n  }\n  return baseConfig;\n};\nconst overrideProperty = (baseObject, overrideKey, overrideValue) => {\n  if (overrideValue !== undefined) {\n    baseObject[overrideKey] = overrideValue;\n  }\n};\nconst overrideConfigProperties = (baseObject, overrideObject) => {\n  if (overrideObject) {\n    for (const key in overrideObject) {\n      overrideProperty(baseObject, key, overrideObject[key]);\n    }\n  }\n};\nconst mergeConfigProperties = (baseObject, mergeObject) => {\n  if (mergeObject) {\n    for (const key in mergeObject) {\n      const mergeValue = mergeObject[key];\n      if (mergeValue !== undefined) {\n        baseObject[key] = (baseObject[key] || []).concat(mergeValue);\n      }\n    }\n  }\n};\nconst extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);\nconst twMerge = /*#__PURE__*/createTailwindMerge(getDefaultConfig);\n\n//# sourceMappingURL=bundle-mjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90YWlsd2luZC1tZXJnZS9kaXN0L2J1bmRsZS1tanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxPQUFPLG1CQUFtQixrQkFBa0IsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEg7QUFDNUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RhaWx3aW5kLW1lcmdlL2Rpc3QvYnVuZGxlLW1qcy5tanM/OGZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDTEFTU19QQVJUX1NFUEFSQVRPUiA9ICctJztcbmNvbnN0IGNyZWF0ZUNsYXNzR3JvdXBVdGlscyA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IGNsYXNzTWFwID0gY3JlYXRlQ2xhc3NNYXAoY29uZmlnKTtcbiAgY29uc3Qge1xuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHMsXG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGdldENsYXNzR3JvdXBJZCA9IGNsYXNzTmFtZSA9PiB7XG4gICAgY29uc3QgY2xhc3NQYXJ0cyA9IGNsYXNzTmFtZS5zcGxpdChDTEFTU19QQVJUX1NFUEFSQVRPUik7XG4gICAgLy8gQ2xhc3NlcyBsaWtlIGAtaW5zZXQtMWAgcHJvZHVjZSBhbiBlbXB0eSBzdHJpbmcgYXMgZmlyc3QgY2xhc3NQYXJ0LiBXZSBhc3N1bWUgdGhhdCBjbGFzc2VzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgY29ycmVjdGx5IGFuZCByZW1vdmUgaXQgZnJvbSBjbGFzc1BhcnRzLlxuICAgIGlmIChjbGFzc1BhcnRzWzBdID09PSAnJyAmJiBjbGFzc1BhcnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgY2xhc3NQYXJ0cy5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0R3JvdXBSZWN1cnNpdmUoY2xhc3NQYXJ0cywgY2xhc3NNYXApIHx8IGdldEdyb3VwSWRGb3JBcmJpdHJhcnlQcm9wZXJ0eShjbGFzc05hbWUpO1xuICB9O1xuICBjb25zdCBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHMgPSAoY2xhc3NHcm91cElkLCBoYXNQb3N0Zml4TW9kaWZpZXIpID0+IHtcbiAgICBjb25zdCBjb25mbGljdHMgPSBjb25mbGljdGluZ0NsYXNzR3JvdXBzW2NsYXNzR3JvdXBJZF0gfHwgW107XG4gICAgaWYgKGhhc1Bvc3RmaXhNb2RpZmllciAmJiBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnNbY2xhc3NHcm91cElkXSkge1xuICAgICAgcmV0dXJuIFsuLi5jb25mbGljdHMsIC4uLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1tjbGFzc0dyb3VwSWRdXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZsaWN0cztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXRDbGFzc0dyb3VwSWQsXG4gICAgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzXG4gIH07XG59O1xuY29uc3QgZ2V0R3JvdXBSZWN1cnNpdmUgPSAoY2xhc3NQYXJ0cywgY2xhc3NQYXJ0T2JqZWN0KSA9PiB7XG4gIGlmIChjbGFzc1BhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjbGFzc1BhcnRPYmplY3QuY2xhc3NHcm91cElkO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRDbGFzc1BhcnQgPSBjbGFzc1BhcnRzWzBdO1xuICBjb25zdCBuZXh0Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmdldChjdXJyZW50Q2xhc3NQYXJ0KTtcbiAgY29uc3QgY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0ID0gbmV4dENsYXNzUGFydE9iamVjdCA/IGdldEdyb3VwUmVjdXJzaXZlKGNsYXNzUGFydHMuc2xpY2UoMSksIG5leHRDbGFzc1BhcnRPYmplY3QpIDogdW5kZWZpbmVkO1xuICBpZiAoY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0KSB7XG4gICAgcmV0dXJuIGNsYXNzR3JvdXBGcm9tTmV4dENsYXNzUGFydDtcbiAgfVxuICBpZiAoY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBjbGFzc1Jlc3QgPSBjbGFzc1BhcnRzLmpvaW4oQ0xBU1NfUEFSVF9TRVBBUkFUT1IpO1xuICByZXR1cm4gY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMuZmluZCgoe1xuICAgIHZhbGlkYXRvclxuICB9KSA9PiB2YWxpZGF0b3IoY2xhc3NSZXN0KSk/LmNsYXNzR3JvdXBJZDtcbn07XG5jb25zdCBhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4ID0gL15cXFsoLispXFxdJC87XG5jb25zdCBnZXRHcm91cElkRm9yQXJiaXRyYXJ5UHJvcGVydHkgPSBjbGFzc05hbWUgPT4ge1xuICBpZiAoYXJiaXRyYXJ5UHJvcGVydHlSZWdleC50ZXN0KGNsYXNzTmFtZSkpIHtcbiAgICBjb25zdCBhcmJpdHJhcnlQcm9wZXJ0eUNsYXNzTmFtZSA9IGFyYml0cmFyeVByb3BlcnR5UmVnZXguZXhlYyhjbGFzc05hbWUpWzFdO1xuICAgIGNvbnN0IHByb3BlcnR5ID0gYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWU/LnN1YnN0cmluZygwLCBhcmJpdHJhcnlQcm9wZXJ0eUNsYXNzTmFtZS5pbmRleE9mKCc6JykpO1xuICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgLy8gSSB1c2UgdHdvIGRvdHMgaGVyZSBiZWNhdXNlIG9uZSBkb3QgaXMgdXNlZCBhcyBwcmVmaXggZm9yIGNsYXNzIGdyb3VwcyBpbiBwbHVnaW5zXG4gICAgICByZXR1cm4gJ2FyYml0cmFyeS4uJyArIHByb3BlcnR5O1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogRXhwb3J0ZWQgZm9yIHRlc3Rpbmcgb25seVxuICovXG5jb25zdCBjcmVhdGVDbGFzc01hcCA9IGNvbmZpZyA9PiB7XG4gIGNvbnN0IHtcbiAgICB0aGVtZSxcbiAgICBwcmVmaXhcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgY2xhc3NNYXAgPSB7XG4gICAgbmV4dFBhcnQ6IG5ldyBNYXAoKSxcbiAgICB2YWxpZGF0b3JzOiBbXVxuICB9O1xuICBjb25zdCBwcmVmaXhlZENsYXNzR3JvdXBFbnRyaWVzID0gZ2V0UHJlZml4ZWRDbGFzc0dyb3VwRW50cmllcyhPYmplY3QuZW50cmllcyhjb25maWcuY2xhc3NHcm91cHMpLCBwcmVmaXgpO1xuICBwcmVmaXhlZENsYXNzR3JvdXBFbnRyaWVzLmZvckVhY2goKFtjbGFzc0dyb3VwSWQsIGNsYXNzR3JvdXBdKSA9PiB7XG4gICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShjbGFzc0dyb3VwLCBjbGFzc01hcCwgY2xhc3NHcm91cElkLCB0aGVtZSk7XG4gIH0pO1xuICByZXR1cm4gY2xhc3NNYXA7XG59O1xuY29uc3QgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseSA9IChjbGFzc0dyb3VwLCBjbGFzc1BhcnRPYmplY3QsIGNsYXNzR3JvdXBJZCwgdGhlbWUpID0+IHtcbiAgY2xhc3NHcm91cC5mb3JFYWNoKGNsYXNzRGVmaW5pdGlvbiA9PiB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc0RlZmluaXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjbGFzc1BhcnRPYmplY3RUb0VkaXQgPSBjbGFzc0RlZmluaXRpb24gPT09ICcnID8gY2xhc3NQYXJ0T2JqZWN0IDogZ2V0UGFydChjbGFzc1BhcnRPYmplY3QsIGNsYXNzRGVmaW5pdGlvbik7XG4gICAgICBjbGFzc1BhcnRPYmplY3RUb0VkaXQuY2xhc3NHcm91cElkID0gY2xhc3NHcm91cElkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNsYXNzRGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGlzVGhlbWVHZXR0ZXIoY2xhc3NEZWZpbml0aW9uKSkge1xuICAgICAgICBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5KGNsYXNzRGVmaW5pdGlvbih0aGVtZSksIGNsYXNzUGFydE9iamVjdCwgY2xhc3NHcm91cElkLCB0aGVtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNsYXNzUGFydE9iamVjdC52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgICB2YWxpZGF0b3I6IGNsYXNzRGVmaW5pdGlvbixcbiAgICAgICAgY2xhc3NHcm91cElkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmVudHJpZXMoY2xhc3NEZWZpbml0aW9uKS5mb3JFYWNoKChba2V5LCBjbGFzc0dyb3VwXSkgPT4ge1xuICAgICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShjbGFzc0dyb3VwLCBnZXRQYXJ0KGNsYXNzUGFydE9iamVjdCwga2V5KSwgY2xhc3NHcm91cElkLCB0aGVtZSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbmNvbnN0IGdldFBhcnQgPSAoY2xhc3NQYXJ0T2JqZWN0LCBwYXRoKSA9PiB7XG4gIGxldCBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0O1xuICBwYXRoLnNwbGl0KENMQVNTX1BBUlRfU0VQQVJBVE9SKS5mb3JFYWNoKHBhdGhQYXJ0ID0+IHtcbiAgICBpZiAoIWN1cnJlbnRDbGFzc1BhcnRPYmplY3QubmV4dFBhcnQuaGFzKHBhdGhQYXJ0KSkge1xuICAgICAgY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5zZXQocGF0aFBhcnQsIHtcbiAgICAgICAgbmV4dFBhcnQ6IG5ldyBNYXAoKSxcbiAgICAgICAgdmFsaWRhdG9yczogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5nZXQocGF0aFBhcnQpO1xuICB9KTtcbiAgcmV0dXJuIGN1cnJlbnRDbGFzc1BhcnRPYmplY3Q7XG59O1xuY29uc3QgaXNUaGVtZUdldHRlciA9IGZ1bmMgPT4gZnVuYy5pc1RoZW1lR2V0dGVyO1xuY29uc3QgZ2V0UHJlZml4ZWRDbGFzc0dyb3VwRW50cmllcyA9IChjbGFzc0dyb3VwRW50cmllcywgcHJlZml4KSA9PiB7XG4gIGlmICghcHJlZml4KSB7XG4gICAgcmV0dXJuIGNsYXNzR3JvdXBFbnRyaWVzO1xuICB9XG4gIHJldHVybiBjbGFzc0dyb3VwRW50cmllcy5tYXAoKFtjbGFzc0dyb3VwSWQsIGNsYXNzR3JvdXBdKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZWRDbGFzc0dyb3VwID0gY2xhc3NHcm91cC5tYXAoY2xhc3NEZWZpbml0aW9uID0+IHtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgY2xhc3NEZWZpbml0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjbGFzc0RlZmluaXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2xhc3NEZWZpbml0aW9uKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW3ByZWZpeCArIGtleSwgdmFsdWVdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xhc3NEZWZpbml0aW9uO1xuICAgIH0pO1xuICAgIHJldHVybiBbY2xhc3NHcm91cElkLCBwcmVmaXhlZENsYXNzR3JvdXBdO1xuICB9KTtcbn07XG5cbi8vIExSVSBjYWNoZSBpbnNwaXJlZCBmcm9tIGhhc2hscnUgKGh0dHBzOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9oYXNobHJ1L2Jsb2IvdjEuMC40L2luZGV4LmpzKSBidXQgb2JqZWN0IHJlcGxhY2VkIHdpdGggTWFwIHRvIGltcHJvdmUgcGVyZm9ybWFuY2VcbmNvbnN0IGNyZWF0ZUxydUNhY2hlID0gbWF4Q2FjaGVTaXplID0+IHtcbiAgaWYgKG1heENhY2hlU2l6ZSA8IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICBzZXQ6ICgpID0+IHt9XG4gICAgfTtcbiAgfVxuICBsZXQgY2FjaGVTaXplID0gMDtcbiAgbGV0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBsZXQgcHJldmlvdXNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdXBkYXRlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgY2FjaGVTaXplKys7XG4gICAgaWYgKGNhY2hlU2l6ZSA+IG1heENhY2hlU2l6ZSkge1xuICAgICAgY2FjaGVTaXplID0gMDtcbiAgICAgIHByZXZpb3VzQ2FjaGUgPSBjYWNoZTtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgodmFsdWUgPSBwcmV2aW91c0NhY2hlLmdldChrZXkpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbmNvbnN0IElNUE9SVEFOVF9NT0RJRklFUiA9ICchJztcbmNvbnN0IGNyZWF0ZVBhcnNlQ2xhc3NOYW1lID0gY29uZmlnID0+IHtcbiAgY29uc3Qge1xuICAgIHNlcGFyYXRvcixcbiAgICBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBpc1NlcGFyYXRvclNpbmdsZUNoYXJhY3RlciA9IHNlcGFyYXRvci5sZW5ndGggPT09IDE7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9yQ2hhcmFjdGVyID0gc2VwYXJhdG9yWzBdO1xuICBjb25zdCBzZXBhcmF0b3JMZW5ndGggPSBzZXBhcmF0b3IubGVuZ3RoO1xuICAvLyBwYXJzZUNsYXNzTmFtZSBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2Jsb2IvdjMuMi4yL3NyYy91dGlsL3NwbGl0QXRUb3BMZXZlbE9ubHkuanNcbiAgY29uc3QgcGFyc2VDbGFzc05hbWUgPSBjbGFzc05hbWUgPT4ge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IFtdO1xuICAgIGxldCBicmFja2V0RGVwdGggPSAwO1xuICAgIGxldCBtb2RpZmllclN0YXJ0ID0gMDtcbiAgICBsZXQgcG9zdGZpeE1vZGlmaWVyUG9zaXRpb247XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsYXNzTmFtZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBjdXJyZW50Q2hhcmFjdGVyID0gY2xhc3NOYW1lW2luZGV4XTtcbiAgICAgIGlmIChicmFja2V0RGVwdGggPT09IDApIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09IGZpcnN0U2VwYXJhdG9yQ2hhcmFjdGVyICYmIChpc1NlcGFyYXRvclNpbmdsZUNoYXJhY3RlciB8fCBjbGFzc05hbWUuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VwYXJhdG9yTGVuZ3RoKSA9PT0gc2VwYXJhdG9yKSkge1xuICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGNsYXNzTmFtZS5zbGljZShtb2RpZmllclN0YXJ0LCBpbmRleCkpO1xuICAgICAgICAgIG1vZGlmaWVyU3RhcnQgPSBpbmRleCArIHNlcGFyYXRvckxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJy8nKSB7XG4gICAgICAgICAgcG9zdGZpeE1vZGlmaWVyUG9zaXRpb24gPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09ICdbJykge1xuICAgICAgICBicmFja2V0RGVwdGgrKztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudENoYXJhY3RlciA9PT0gJ10nKSB7XG4gICAgICAgIGJyYWNrZXREZXB0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyID0gbW9kaWZpZXJzLmxlbmd0aCA9PT0gMCA/IGNsYXNzTmFtZSA6IGNsYXNzTmFtZS5zdWJzdHJpbmcobW9kaWZpZXJTdGFydCk7XG4gICAgY29uc3QgaGFzSW1wb3J0YW50TW9kaWZpZXIgPSBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyLnN0YXJ0c1dpdGgoSU1QT1JUQU5UX01PRElGSUVSKTtcbiAgICBjb25zdCBiYXNlQ2xhc3NOYW1lID0gaGFzSW1wb3J0YW50TW9kaWZpZXIgPyBiYXNlQ2xhc3NOYW1lV2l0aEltcG9ydGFudE1vZGlmaWVyLnN1YnN0cmluZygxKSA6IGJhc2VDbGFzc05hbWVXaXRoSW1wb3J0YW50TW9kaWZpZXI7XG4gICAgY29uc3QgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA9IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uICYmIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID4gbW9kaWZpZXJTdGFydCA/IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uIC0gbW9kaWZpZXJTdGFydCA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZXJzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvblxuICAgIH07XG4gIH07XG4gIGlmIChleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSkge1xuICAgIHJldHVybiBjbGFzc05hbWUgPT4gZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUoe1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcGFyc2VDbGFzc05hbWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGFyc2VDbGFzc05hbWU7XG59O1xuLyoqXG4gKiBTb3J0cyBtb2RpZmllcnMgYWNjb3JkaW5nIHRvIGZvbGxvd2luZyBzY2hlbWE6XG4gKiAtIFByZWRlZmluZWQgbW9kaWZpZXJzIGFyZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHlcbiAqIC0gV2hlbiBhbiBhcmJpdHJhcnkgdmFyaWFudCBhcHBlYXJzLCBpdCBtdXN0IGJlIHByZXNlcnZlZCB3aGljaCBtb2RpZmllcnMgYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgaXRcbiAqL1xuY29uc3Qgc29ydE1vZGlmaWVycyA9IG1vZGlmaWVycyA9PiB7XG4gIGlmIChtb2RpZmllcnMubGVuZ3RoIDw9IDEpIHtcbiAgICByZXR1cm4gbW9kaWZpZXJzO1xuICB9XG4gIGNvbnN0IHNvcnRlZE1vZGlmaWVycyA9IFtdO1xuICBsZXQgdW5zb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4ge1xuICAgIGNvbnN0IGlzQXJiaXRyYXJ5VmFyaWFudCA9IG1vZGlmaWVyWzBdID09PSAnWyc7XG4gICAgaWYgKGlzQXJiaXRyYXJ5VmFyaWFudCkge1xuICAgICAgc29ydGVkTW9kaWZpZXJzLnB1c2goLi4udW5zb3J0ZWRNb2RpZmllcnMuc29ydCgpLCBtb2RpZmllcik7XG4gICAgICB1bnNvcnRlZE1vZGlmaWVycyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnNvcnRlZE1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICBzb3J0ZWRNb2RpZmllcnMucHVzaCguLi51bnNvcnRlZE1vZGlmaWVycy5zb3J0KCkpO1xuICByZXR1cm4gc29ydGVkTW9kaWZpZXJzO1xufTtcbmNvbnN0IGNyZWF0ZUNvbmZpZ1V0aWxzID0gY29uZmlnID0+ICh7XG4gIGNhY2hlOiBjcmVhdGVMcnVDYWNoZShjb25maWcuY2FjaGVTaXplKSxcbiAgcGFyc2VDbGFzc05hbWU6IGNyZWF0ZVBhcnNlQ2xhc3NOYW1lKGNvbmZpZyksXG4gIC4uLmNyZWF0ZUNsYXNzR3JvdXBVdGlscyhjb25maWcpXG59KTtcbmNvbnN0IFNQTElUX0NMQVNTRVNfUkVHRVggPSAvXFxzKy87XG5jb25zdCBtZXJnZUNsYXNzTGlzdCA9IChjbGFzc0xpc3QsIGNvbmZpZ1V0aWxzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwYXJzZUNsYXNzTmFtZSxcbiAgICBnZXRDbGFzc0dyb3VwSWQsXG4gICAgZ2V0Q29uZmxpY3RpbmdDbGFzc0dyb3VwSWRzXG4gIH0gPSBjb25maWdVdGlscztcbiAgLyoqXG4gICAqIFNldCBvZiBjbGFzc0dyb3VwSWRzIGluIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAqIGB7aW1wb3J0YW50TW9kaWZpZXJ9e3ZhcmlhbnRNb2RpZmllcnN9e2NsYXNzR3JvdXBJZH1gXG4gICAqIEBleGFtcGxlICdmbG9hdCdcbiAgICogQGV4YW1wbGUgJ2hvdmVyOmZvY3VzOmJnLWNvbG9yJ1xuICAgKiBAZXhhbXBsZSAnbWQ6IXByJ1xuICAgKi9cbiAgY29uc3QgY2xhc3NHcm91cHNJbkNvbmZsaWN0ID0gW107XG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc0xpc3QudHJpbSgpLnNwbGl0KFNQTElUX0NMQVNTRVNfUkVHRVgpO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGluZGV4ID0gY2xhc3NOYW1lcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleCAtPSAxKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxDbGFzc05hbWUgPSBjbGFzc05hbWVzW2luZGV4XTtcbiAgICBjb25zdCB7XG4gICAgICBtb2RpZmllcnMsXG4gICAgICBoYXNJbXBvcnRhbnRNb2RpZmllcixcbiAgICAgIGJhc2VDbGFzc05hbWUsXG4gICAgICBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uXG4gICAgfSA9IHBhcnNlQ2xhc3NOYW1lKG9yaWdpbmFsQ2xhc3NOYW1lKTtcbiAgICBsZXQgaGFzUG9zdGZpeE1vZGlmaWVyID0gQm9vbGVhbihtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uKTtcbiAgICBsZXQgY2xhc3NHcm91cElkID0gZ2V0Q2xhc3NHcm91cElkKGhhc1Bvc3RmaXhNb2RpZmllciA/IGJhc2VDbGFzc05hbWUuc3Vic3RyaW5nKDAsIG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb24pIDogYmFzZUNsYXNzTmFtZSk7XG4gICAgaWYgKCFjbGFzc0dyb3VwSWQpIHtcbiAgICAgIGlmICghaGFzUG9zdGZpeE1vZGlmaWVyKSB7XG4gICAgICAgIC8vIE5vdCBhIFRhaWx3aW5kIGNsYXNzXG4gICAgICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gJyAnICsgcmVzdWx0IDogcmVzdWx0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjbGFzc0dyb3VwSWQgPSBnZXRDbGFzc0dyb3VwSWQoYmFzZUNsYXNzTmFtZSk7XG4gICAgICBpZiAoIWNsYXNzR3JvdXBJZCkge1xuICAgICAgICAvLyBOb3QgYSBUYWlsd2luZCBjbGFzc1xuICAgICAgICByZXN1bHQgPSBvcmlnaW5hbENsYXNzTmFtZSArIChyZXN1bHQubGVuZ3RoID4gMCA/ICcgJyArIHJlc3VsdCA6IHJlc3VsdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaGFzUG9zdGZpeE1vZGlmaWVyID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhbnRNb2RpZmllciA9IHNvcnRNb2RpZmllcnMobW9kaWZpZXJzKS5qb2luKCc6Jyk7XG4gICAgY29uc3QgbW9kaWZpZXJJZCA9IGhhc0ltcG9ydGFudE1vZGlmaWVyID8gdmFyaWFudE1vZGlmaWVyICsgSU1QT1JUQU5UX01PRElGSUVSIDogdmFyaWFudE1vZGlmaWVyO1xuICAgIGNvbnN0IGNsYXNzSWQgPSBtb2RpZmllcklkICsgY2xhc3NHcm91cElkO1xuICAgIGlmIChjbGFzc0dyb3Vwc0luQ29uZmxpY3QuaW5jbHVkZXMoY2xhc3NJZCkpIHtcbiAgICAgIC8vIFRhaWx3aW5kIGNsYXNzIG9taXR0ZWQgZHVlIHRvIGNvbmZsaWN0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY2xhc3NHcm91cHNJbkNvbmZsaWN0LnB1c2goY2xhc3NJZCk7XG4gICAgY29uc3QgY29uZmxpY3RHcm91cHMgPSBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHMoY2xhc3NHcm91cElkLCBoYXNQb3N0Zml4TW9kaWZpZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uZmxpY3RHcm91cHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdyb3VwID0gY29uZmxpY3RHcm91cHNbaV07XG4gICAgICBjbGFzc0dyb3Vwc0luQ29uZmxpY3QucHVzaChtb2RpZmllcklkICsgZ3JvdXApO1xuICAgIH1cbiAgICAvLyBUYWlsd2luZCBjbGFzcyBub3QgaW4gY29uZmxpY3RcbiAgICByZXN1bHQgPSBvcmlnaW5hbENsYXNzTmFtZSArIChyZXN1bHQubGVuZ3RoID4gMCA/ICcgJyArIHJlc3VsdCA6IHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWtlZWQvY2xzeCBhbmQgbW9kaWZpZWQgdG8gc3VpdCB0aGUgbmVlZHMgb2YgdGFpbHdpbmQtbWVyZ2UgYmV0dGVyLlxuICpcbiAqIFNwZWNpZmljYWxseTpcbiAqIC0gUnVudGltZSBjb2RlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4L2Jsb2IvdjEuMi4xL3NyYy9pbmRleC5qc1xuICogLSBUeXBlU2NyaXB0IHR5cGVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2x1a2VlZC9jbHN4L2Jsb2IvdjEuMi4xL2Nsc3guZC50c1xuICpcbiAqIE9yaWdpbmFsIGNvZGUgaGFzIE1JVCBsaWNlbnNlOiBDb3B5cmlnaHQgKGMpIEx1a2UgRWR3YXJkcyA8bHVrZS5lZHdhcmRzMDVAZ21haWwuY29tPiAobHVrZWVkLmNvbSlcbiAqL1xuZnVuY3Rpb24gdHdKb2luKCkge1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgYXJndW1lbnQ7XG4gIGxldCByZXNvbHZlZFZhbHVlO1xuICBsZXQgc3RyaW5nID0gJyc7XG4gIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoYXJndW1lbnQgPSBhcmd1bWVudHNbaW5kZXgrK10pIHtcbiAgICAgIGlmIChyZXNvbHZlZFZhbHVlID0gdG9WYWx1ZShhcmd1bWVudCkpIHtcbiAgICAgICAgc3RyaW5nICYmIChzdHJpbmcgKz0gJyAnKTtcbiAgICAgICAgc3RyaW5nICs9IHJlc29sdmVkVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5jb25zdCB0b1ZhbHVlID0gbWl4ID0+IHtcbiAgaWYgKHR5cGVvZiBtaXggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1peDtcbiAgfVxuICBsZXQgcmVzb2x2ZWRWYWx1ZTtcbiAgbGV0IHN0cmluZyA9ICcnO1xuICBmb3IgKGxldCBrID0gMDsgayA8IG1peC5sZW5ndGg7IGsrKykge1xuICAgIGlmIChtaXhba10pIHtcbiAgICAgIGlmIChyZXNvbHZlZFZhbHVlID0gdG9WYWx1ZShtaXhba10pKSB7XG4gICAgICAgIHN0cmluZyAmJiAoc3RyaW5nICs9ICcgJyk7XG4gICAgICAgIHN0cmluZyArPSByZXNvbHZlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVRhaWx3aW5kTWVyZ2UoY3JlYXRlQ29uZmlnRmlyc3QsIC4uLmNyZWF0ZUNvbmZpZ1Jlc3QpIHtcbiAgbGV0IGNvbmZpZ1V0aWxzO1xuICBsZXQgY2FjaGVHZXQ7XG4gIGxldCBjYWNoZVNldDtcbiAgbGV0IGZ1bmN0aW9uVG9DYWxsID0gaW5pdFRhaWx3aW5kTWVyZ2U7XG4gIGZ1bmN0aW9uIGluaXRUYWlsd2luZE1lcmdlKGNsYXNzTGlzdCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUNvbmZpZ1Jlc3QucmVkdWNlKChwcmV2aW91c0NvbmZpZywgY3JlYXRlQ29uZmlnQ3VycmVudCkgPT4gY3JlYXRlQ29uZmlnQ3VycmVudChwcmV2aW91c0NvbmZpZyksIGNyZWF0ZUNvbmZpZ0ZpcnN0KCkpO1xuICAgIGNvbmZpZ1V0aWxzID0gY3JlYXRlQ29uZmlnVXRpbHMoY29uZmlnKTtcbiAgICBjYWNoZUdldCA9IGNvbmZpZ1V0aWxzLmNhY2hlLmdldDtcbiAgICBjYWNoZVNldCA9IGNvbmZpZ1V0aWxzLmNhY2hlLnNldDtcbiAgICBmdW5jdGlvblRvQ2FsbCA9IHRhaWx3aW5kTWVyZ2U7XG4gICAgcmV0dXJuIHRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KTtcbiAgfVxuICBmdW5jdGlvbiB0YWlsd2luZE1lcmdlKGNsYXNzTGlzdCkge1xuICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlR2V0KGNsYXNzTGlzdCk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VDbGFzc0xpc3QoY2xhc3NMaXN0LCBjb25maWdVdGlscyk7XG4gICAgY2FjaGVTZXQoY2xhc3NMaXN0LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhbGxUYWlsd2luZE1lcmdlKCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvQ2FsbCh0d0pvaW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5jb25zdCBmcm9tVGhlbWUgPSBrZXkgPT4ge1xuICBjb25zdCB0aGVtZUdldHRlciA9IHRoZW1lID0+IHRoZW1lW2tleV0gfHwgW107XG4gIHRoZW1lR2V0dGVyLmlzVGhlbWVHZXR0ZXIgPSB0cnVlO1xuICByZXR1cm4gdGhlbWVHZXR0ZXI7XG59O1xuY29uc3QgYXJiaXRyYXJ5VmFsdWVSZWdleCA9IC9eXFxbKD86KFthLXotXSspOik/KC4rKVxcXSQvaTtcbmNvbnN0IGZyYWN0aW9uUmVnZXggPSAvXlxcZCtcXC9cXGQrJC87XG5jb25zdCBzdHJpbmdMZW5ndGhzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydweCcsICdmdWxsJywgJ3NjcmVlbiddKTtcbmNvbnN0IHRzaGlydFVuaXRSZWdleCA9IC9eKFxcZCsoXFwuXFxkKyk/KT8oeHN8c218bWR8bGd8eGwpJC87XG5jb25zdCBsZW5ndGhVbml0UmVnZXggPSAvXFxkKyglfHB4fHI/ZW18W3NkbF0/dihbaHdpYl18bWlufG1heCl8cHR8cGN8aW58Y218bW18Y2FwfGNofGV4fHI/bGh8Y3Eod3xofGl8YnxtaW58bWF4KSl8XFxiKGNhbGN8bWlufG1heHxjbGFtcClcXCguK1xcKXxeMCQvO1xuY29uc3QgY29sb3JGdW5jdGlvblJlZ2V4ID0gL14ocmdiYT98aHNsYT98aHdifChvayk/KGxhYnxsY2gpKVxcKC4rXFwpJC87XG4vLyBTaGFkb3cgYWx3YXlzIGJlZ2lucyB3aXRoIHggYW5kIHkgb2Zmc2V0IHNlcGFyYXRlZCBieSB1bmRlcnNjb3JlIG9wdGlvbmFsbHkgcHJlcGVuZGVkIGJ5IGluc2V0XG5jb25zdCBzaGFkb3dSZWdleCA9IC9eKGluc2V0Xyk/LT8oKFxcZCspP1xcLj8oXFxkKylbYS16XSt8MClfLT8oKFxcZCspP1xcLj8oXFxkKylbYS16XSt8MCkvO1xuY29uc3QgaW1hZ2VSZWdleCA9IC9eKHVybHxpbWFnZXxpbWFnZS1zZXR8Y3Jvc3MtZmFkZXxlbGVtZW50fChyZXBlYXRpbmctKT8obGluZWFyfHJhZGlhbHxjb25pYyktZ3JhZGllbnQpXFwoLitcXCkkLztcbmNvbnN0IGlzTGVuZ3RoID0gdmFsdWUgPT4gaXNOdW1iZXIodmFsdWUpIHx8IHN0cmluZ0xlbmd0aHMuaGFzKHZhbHVlKSB8fCBmcmFjdGlvblJlZ2V4LnRlc3QodmFsdWUpO1xuY29uc3QgaXNBcmJpdHJhcnlMZW5ndGggPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCAnbGVuZ3RoJywgaXNMZW5ndGhPbmx5KTtcbmNvbnN0IGlzTnVtYmVyID0gdmFsdWUgPT4gQm9vbGVhbih2YWx1ZSkgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKTtcbmNvbnN0IGlzQXJiaXRyYXJ5TnVtYmVyID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgJ251bWJlcicsIGlzTnVtYmVyKTtcbmNvbnN0IGlzSW50ZWdlciA9IHZhbHVlID0+IEJvb2xlYW4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbHVlKSk7XG5jb25zdCBpc1BlcmNlbnQgPSB2YWx1ZSA9PiB2YWx1ZS5lbmRzV2l0aCgnJScpICYmIGlzTnVtYmVyKHZhbHVlLnNsaWNlKDAsIC0xKSk7XG5jb25zdCBpc0FyYml0cmFyeVZhbHVlID0gdmFsdWUgPT4gYXJiaXRyYXJ5VmFsdWVSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzVHNoaXJ0U2l6ZSA9IHZhbHVlID0+IHRzaGlydFVuaXRSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IHNpemVMYWJlbHMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ2xlbmd0aCcsICdzaXplJywgJ3BlcmNlbnRhZ2UnXSk7XG5jb25zdCBpc0FyYml0cmFyeVNpemUgPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCBzaXplTGFiZWxzLCBpc05ldmVyKTtcbmNvbnN0IGlzQXJiaXRyYXJ5UG9zaXRpb24gPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCAncG9zaXRpb24nLCBpc05ldmVyKTtcbmNvbnN0IGltYWdlTGFiZWxzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydpbWFnZScsICd1cmwnXSk7XG5jb25zdCBpc0FyYml0cmFyeUltYWdlID0gdmFsdWUgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaW1hZ2VMYWJlbHMsIGlzSW1hZ2UpO1xuY29uc3QgaXNBcmJpdHJhcnlTaGFkb3cgPSB2YWx1ZSA9PiBnZXRJc0FyYml0cmFyeVZhbHVlKHZhbHVlLCAnJywgaXNTaGFkb3cpO1xuY29uc3QgaXNBbnkgPSAoKSA9PiB0cnVlO1xuY29uc3QgZ2V0SXNBcmJpdHJhcnlWYWx1ZSA9ICh2YWx1ZSwgbGFiZWwsIHRlc3RWYWx1ZSkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBhcmJpdHJhcnlWYWx1ZVJlZ2V4LmV4ZWModmFsdWUpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycgPyByZXN1bHRbMV0gPT09IGxhYmVsIDogbGFiZWwuaGFzKHJlc3VsdFsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXN0VmFsdWUocmVzdWx0WzJdKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuY29uc3QgaXNMZW5ndGhPbmx5ID0gdmFsdWUgPT5cbi8vIGBjb2xvckZ1bmN0aW9uUmVnZXhgIGNoZWNrIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbG9yIGZ1bmN0aW9ucyBjYW4gaGF2ZSBwZXJjZW50YWdlcyBpbiB0aGVtIHdoaWNoIHdoaWNoIHdvdWxkIGJlIGluY29ycmVjdGx5IGNsYXNzaWZpZWQgYXMgbGVuZ3Rocy5cbi8vIEZvciBleGFtcGxlLCBgaHNsKDAgMCUgMCUpYCB3b3VsZCBiZSBjbGFzc2lmaWVkIGFzIGEgbGVuZ3RoIHdpdGhvdXQgdGhpcyBjaGVjay5cbi8vIEkgY291bGQgYWxzbyB1c2UgbG9va2JlaGluZCBhc3NlcnRpb24gaW4gYGxlbmd0aFVuaXRSZWdleGAgYnV0IHRoYXQgaXNuJ3Qgc3VwcG9ydGVkIHdpZGVseSBlbm91Z2guXG5sZW5ndGhVbml0UmVnZXgudGVzdCh2YWx1ZSkgJiYgIWNvbG9yRnVuY3Rpb25SZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IGlzTmV2ZXIgPSAoKSA9PiBmYWxzZTtcbmNvbnN0IGlzU2hhZG93ID0gdmFsdWUgPT4gc2hhZG93UmVnZXgudGVzdCh2YWx1ZSk7XG5jb25zdCBpc0ltYWdlID0gdmFsdWUgPT4gaW1hZ2VSZWdleC50ZXN0KHZhbHVlKTtcbmNvbnN0IHZhbGlkYXRvcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBpc0FueSxcbiAgaXNBcmJpdHJhcnlJbWFnZSxcbiAgaXNBcmJpdHJhcnlMZW5ndGgsXG4gIGlzQXJiaXRyYXJ5TnVtYmVyLFxuICBpc0FyYml0cmFyeVBvc2l0aW9uLFxuICBpc0FyYml0cmFyeVNoYWRvdyxcbiAgaXNBcmJpdHJhcnlTaXplLFxuICBpc0FyYml0cmFyeVZhbHVlLFxuICBpc0ludGVnZXIsXG4gIGlzTGVuZ3RoLFxuICBpc051bWJlcixcbiAgaXNQZXJjZW50LFxuICBpc1RzaGlydFNpemVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICB2YWx1ZTogJ01vZHVsZSdcbn0pO1xuY29uc3QgZ2V0RGVmYXVsdENvbmZpZyA9ICgpID0+IHtcbiAgY29uc3QgY29sb3JzID0gZnJvbVRoZW1lKCdjb2xvcnMnKTtcbiAgY29uc3Qgc3BhY2luZyA9IGZyb21UaGVtZSgnc3BhY2luZycpO1xuICBjb25zdCBibHVyID0gZnJvbVRoZW1lKCdibHVyJyk7XG4gIGNvbnN0IGJyaWdodG5lc3MgPSBmcm9tVGhlbWUoJ2JyaWdodG5lc3MnKTtcbiAgY29uc3QgYm9yZGVyQ29sb3IgPSBmcm9tVGhlbWUoJ2JvcmRlckNvbG9yJyk7XG4gIGNvbnN0IGJvcmRlclJhZGl1cyA9IGZyb21UaGVtZSgnYm9yZGVyUmFkaXVzJyk7XG4gIGNvbnN0IGJvcmRlclNwYWNpbmcgPSBmcm9tVGhlbWUoJ2JvcmRlclNwYWNpbmcnKTtcbiAgY29uc3QgYm9yZGVyV2lkdGggPSBmcm9tVGhlbWUoJ2JvcmRlcldpZHRoJyk7XG4gIGNvbnN0IGNvbnRyYXN0ID0gZnJvbVRoZW1lKCdjb250cmFzdCcpO1xuICBjb25zdCBncmF5c2NhbGUgPSBmcm9tVGhlbWUoJ2dyYXlzY2FsZScpO1xuICBjb25zdCBodWVSb3RhdGUgPSBmcm9tVGhlbWUoJ2h1ZVJvdGF0ZScpO1xuICBjb25zdCBpbnZlcnQgPSBmcm9tVGhlbWUoJ2ludmVydCcpO1xuICBjb25zdCBnYXAgPSBmcm9tVGhlbWUoJ2dhcCcpO1xuICBjb25zdCBncmFkaWVudENvbG9yU3RvcHMgPSBmcm9tVGhlbWUoJ2dyYWRpZW50Q29sb3JTdG9wcycpO1xuICBjb25zdCBncmFkaWVudENvbG9yU3RvcFBvc2l0aW9ucyA9IGZyb21UaGVtZSgnZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnMnKTtcbiAgY29uc3QgaW5zZXQgPSBmcm9tVGhlbWUoJ2luc2V0Jyk7XG4gIGNvbnN0IG1hcmdpbiA9IGZyb21UaGVtZSgnbWFyZ2luJyk7XG4gIGNvbnN0IG9wYWNpdHkgPSBmcm9tVGhlbWUoJ29wYWNpdHknKTtcbiAgY29uc3QgcGFkZGluZyA9IGZyb21UaGVtZSgncGFkZGluZycpO1xuICBjb25zdCBzYXR1cmF0ZSA9IGZyb21UaGVtZSgnc2F0dXJhdGUnKTtcbiAgY29uc3Qgc2NhbGUgPSBmcm9tVGhlbWUoJ3NjYWxlJyk7XG4gIGNvbnN0IHNlcGlhID0gZnJvbVRoZW1lKCdzZXBpYScpO1xuICBjb25zdCBza2V3ID0gZnJvbVRoZW1lKCdza2V3Jyk7XG4gIGNvbnN0IHNwYWNlID0gZnJvbVRoZW1lKCdzcGFjZScpO1xuICBjb25zdCB0cmFuc2xhdGUgPSBmcm9tVGhlbWUoJ3RyYW5zbGF0ZScpO1xuICBjb25zdCBnZXRPdmVyc2Nyb2xsID0gKCkgPT4gWydhdXRvJywgJ2NvbnRhaW4nLCAnbm9uZSddO1xuICBjb25zdCBnZXRPdmVyZmxvdyA9ICgpID0+IFsnYXV0bycsICdoaWRkZW4nLCAnY2xpcCcsICd2aXNpYmxlJywgJ3Njcm9sbCddO1xuICBjb25zdCBnZXRTcGFjaW5nV2l0aEF1dG9BbmRBcmJpdHJhcnkgPSAoKSA9PiBbJ2F1dG8nLCBpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nXTtcbiAgY29uc3QgZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkgPSAoKSA9PiBbaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZ107XG4gIGNvbnN0IGdldExlbmd0aFdpdGhFbXB0eUFuZEFyYml0cmFyeSA9ICgpID0+IFsnJywgaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXTtcbiAgY29uc3QgZ2V0TnVtYmVyV2l0aEF1dG9BbmRBcmJpdHJhcnkgPSAoKSA9PiBbJ2F1dG8nLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYWx1ZV07XG4gIGNvbnN0IGdldFBvc2l0aW9ucyA9ICgpID0+IFsnYm90dG9tJywgJ2NlbnRlcicsICdsZWZ0JywgJ2xlZnQtYm90dG9tJywgJ2xlZnQtdG9wJywgJ3JpZ2h0JywgJ3JpZ2h0LWJvdHRvbScsICdyaWdodC10b3AnLCAndG9wJ107XG4gIGNvbnN0IGdldExpbmVTdHlsZXMgPSAoKSA9PiBbJ3NvbGlkJywgJ2Rhc2hlZCcsICdkb3R0ZWQnLCAnZG91YmxlJywgJ25vbmUnXTtcbiAgY29uc3QgZ2V0QmxlbmRNb2RlcyA9ICgpID0+IFsnbm9ybWFsJywgJ211bHRpcGx5JywgJ3NjcmVlbicsICdvdmVybGF5JywgJ2RhcmtlbicsICdsaWdodGVuJywgJ2NvbG9yLWRvZGdlJywgJ2NvbG9yLWJ1cm4nLCAnaGFyZC1saWdodCcsICdzb2Z0LWxpZ2h0JywgJ2RpZmZlcmVuY2UnLCAnZXhjbHVzaW9uJywgJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2NvbG9yJywgJ2x1bWlub3NpdHknXTtcbiAgY29uc3QgZ2V0QWxpZ24gPSAoKSA9PiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYmV0d2VlbicsICdhcm91bmQnLCAnZXZlbmx5JywgJ3N0cmV0Y2gnXTtcbiAgY29uc3QgZ2V0WmVyb0FuZEVtcHR5ID0gKCkgPT4gWycnLCAnMCcsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICBjb25zdCBnZXRCcmVha3MgPSAoKSA9PiBbJ2F1dG8nLCAnYXZvaWQnLCAnYWxsJywgJ2F2b2lkLXBhZ2UnLCAncGFnZScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NvbHVtbiddO1xuICBjb25zdCBnZXROdW1iZXJBbmRBcmJpdHJhcnkgPSAoKSA9PiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFsdWVdO1xuICByZXR1cm4ge1xuICAgIGNhY2hlU2l6ZTogNTAwLFxuICAgIHNlcGFyYXRvcjogJzonLFxuICAgIHRoZW1lOiB7XG4gICAgICBjb2xvcnM6IFtpc0FueV0sXG4gICAgICBzcGFjaW5nOiBbaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoXSxcbiAgICAgIGJsdXI6IFsnbm9uZScsICcnLCBpc1RzaGlydFNpemUsIGlzQXJiaXRyYXJ5VmFsdWVdLFxuICAgICAgYnJpZ2h0bmVzczogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBib3JkZXJDb2xvcjogW2NvbG9yc10sXG4gICAgICBib3JkZXJSYWRpdXM6IFsnbm9uZScsICcnLCAnZnVsbCcsIGlzVHNoaXJ0U2l6ZSwgaXNBcmJpdHJhcnlWYWx1ZV0sXG4gICAgICBib3JkZXJTcGFjaW5nOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpLFxuICAgICAgYm9yZGVyV2lkdGg6IGdldExlbmd0aFdpdGhFbXB0eUFuZEFyYml0cmFyeSgpLFxuICAgICAgY29udHJhc3Q6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgZ3JheXNjYWxlOiBnZXRaZXJvQW5kRW1wdHkoKSxcbiAgICAgIGh1ZVJvdGF0ZTogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBpbnZlcnQ6IGdldFplcm9BbmRFbXB0eSgpLFxuICAgICAgZ2FwOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpLFxuICAgICAgZ3JhZGllbnRDb2xvclN0b3BzOiBbY29sb3JzXSxcbiAgICAgIGdyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zOiBbaXNQZXJjZW50LCBpc0FyYml0cmFyeUxlbmd0aF0sXG4gICAgICBpbnNldDogZ2V0U3BhY2luZ1dpdGhBdXRvQW5kQXJiaXRyYXJ5KCksXG4gICAgICBtYXJnaW46IGdldFNwYWNpbmdXaXRoQXV0b0FuZEFyYml0cmFyeSgpLFxuICAgICAgb3BhY2l0eTogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBwYWRkaW5nOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpLFxuICAgICAgc2F0dXJhdGU6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgc2NhbGU6IGdldE51bWJlckFuZEFyYml0cmFyeSgpLFxuICAgICAgc2VwaWE6IGdldFplcm9BbmRFbXB0eSgpLFxuICAgICAgc2tldzogZ2V0TnVtYmVyQW5kQXJiaXRyYXJ5KCksXG4gICAgICBzcGFjZTogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKSxcbiAgICAgIHRyYW5zbGF0ZTogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgIH0sXG4gICAgY2xhc3NHcm91cHM6IHtcbiAgICAgIC8vIExheW91dFxuICAgICAgLyoqXG4gICAgICAgKiBBc3BlY3QgUmF0aW9cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hc3BlY3QtcmF0aW9cbiAgICAgICAqL1xuICAgICAgYXNwZWN0OiBbe1xuICAgICAgICBhc3BlY3Q6IFsnYXV0bycsICdzcXVhcmUnLCAndmlkZW8nLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbnRhaW5lclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRhaW5lclxuICAgICAgICovXG4gICAgICBjb250YWluZXI6IFsnY29udGFpbmVyJ10sXG4gICAgICAvKipcbiAgICAgICAqIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb2x1bW5zXG4gICAgICAgKi9cbiAgICAgIGNvbHVtbnM6IFt7XG4gICAgICAgIGNvbHVtbnM6IFtpc1RzaGlydFNpemVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgQWZ0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1hZnRlclxuICAgICAgICovXG4gICAgICAnYnJlYWstYWZ0ZXInOiBbe1xuICAgICAgICAnYnJlYWstYWZ0ZXInOiBnZXRCcmVha3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEJlZm9yZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWJlZm9yZVxuICAgICAgICovXG4gICAgICAnYnJlYWstYmVmb3JlJzogW3tcbiAgICAgICAgJ2JyZWFrLWJlZm9yZSc6IGdldEJyZWFrcygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgSW5zaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstaW5zaWRlXG4gICAgICAgKi9cbiAgICAgICdicmVhay1pbnNpZGUnOiBbe1xuICAgICAgICAnYnJlYWstaW5zaWRlJzogWydhdXRvJywgJ2F2b2lkJywgJ2F2b2lkLXBhZ2UnLCAnYXZvaWQtY29sdW1uJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggRGVjb3JhdGlvbiBCcmVha1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1kZWNvcmF0aW9uLWJyZWFrXG4gICAgICAgKi9cbiAgICAgICdib3gtZGVjb3JhdGlvbic6IFt7XG4gICAgICAgICdib3gtZGVjb3JhdGlvbic6IFsnc2xpY2UnLCAnY2xvbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaXppbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2l6aW5nXG4gICAgICAgKi9cbiAgICAgIGJveDogW3tcbiAgICAgICAgYm94OiBbJ2JvcmRlcicsICdjb250ZW50J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwbGF5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGlzcGxheVxuICAgICAgICovXG4gICAgICBkaXNwbGF5OiBbJ2Jsb2NrJywgJ2lubGluZS1ibG9jaycsICdpbmxpbmUnLCAnZmxleCcsICdpbmxpbmUtZmxleCcsICd0YWJsZScsICdpbmxpbmUtdGFibGUnLCAndGFibGUtY2FwdGlvbicsICd0YWJsZS1jZWxsJywgJ3RhYmxlLWNvbHVtbicsICd0YWJsZS1jb2x1bW4tZ3JvdXAnLCAndGFibGUtZm9vdGVyLWdyb3VwJywgJ3RhYmxlLWhlYWRlci1ncm91cCcsICd0YWJsZS1yb3ctZ3JvdXAnLCAndGFibGUtcm93JywgJ2Zsb3ctcm9vdCcsICdncmlkJywgJ2lubGluZS1ncmlkJywgJ2NvbnRlbnRzJywgJ2xpc3QtaXRlbScsICdoaWRkZW4nXSxcbiAgICAgIC8qKlxuICAgICAgICogRmxvYXRzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxvYXRcbiAgICAgICAqL1xuICAgICAgZmxvYXQ6IFt7XG4gICAgICAgIGZsb2F0OiBbJ3JpZ2h0JywgJ2xlZnQnLCAnbm9uZScsICdzdGFydCcsICdlbmQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENsZWFyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2xlYXJcbiAgICAgICAqL1xuICAgICAgY2xlYXI6IFt7XG4gICAgICAgIGNsZWFyOiBbJ2xlZnQnLCAncmlnaHQnLCAnYm90aCcsICdub25lJywgJ3N0YXJ0JywgJ2VuZCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSXNvbGF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaXNvbGF0aW9uXG4gICAgICAgKi9cbiAgICAgIGlzb2xhdGlvbjogWydpc29sYXRlJywgJ2lzb2xhdGlvbi1hdXRvJ10sXG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdCBGaXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vYmplY3QtZml0XG4gICAgICAgKi9cbiAgICAgICdvYmplY3QtZml0JzogW3tcbiAgICAgICAgb2JqZWN0OiBbJ2NvbnRhaW4nLCAnY292ZXInLCAnZmlsbCcsICdub25lJywgJ3NjYWxlLWRvd24nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdCBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29iamVjdC1wb3NpdGlvblxuICAgICAgICovXG4gICAgICAnb2JqZWN0LXBvc2l0aW9uJzogW3tcbiAgICAgICAgb2JqZWN0OiBbLi4uZ2V0UG9zaXRpb25zKCksIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyZmxvd1xuICAgICAgICovXG4gICAgICBvdmVyZmxvdzogW3tcbiAgICAgICAgb3ZlcmZsb3c6IGdldE92ZXJmbG93KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvdyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ292ZXJmbG93LXgnOiBbe1xuICAgICAgICAnb3ZlcmZsb3cteCc6IGdldE92ZXJmbG93KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvdyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgJ292ZXJmbG93LXknOiBbe1xuICAgICAgICAnb3ZlcmZsb3cteSc6IGdldE92ZXJmbG93KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICBvdmVyc2Nyb2xsOiBbe1xuICAgICAgICBvdmVyc2Nyb2xsOiBnZXRPdmVyc2Nyb2xsKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgICdvdmVyc2Nyb2xsLXgnOiBbe1xuICAgICAgICAnb3ZlcnNjcm9sbC14JzogZ2V0T3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICAnb3ZlcnNjcm9sbC15JzogW3tcbiAgICAgICAgJ292ZXJzY3JvbGwteSc6IGdldE92ZXJzY3JvbGwoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IFsnc3RhdGljJywgJ2ZpeGVkJywgJ2Fic29sdXRlJywgJ3JlbGF0aXZlJywgJ3N0aWNreSddLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3AgLyBSaWdodCAvIEJvdHRvbSAvIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgaW5zZXQ6IFt7XG4gICAgICAgIGluc2V0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHQgLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgICdpbnNldC14JzogW3tcbiAgICAgICAgJ2luc2V0LXgnOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgICdpbnNldC15JzogW3tcbiAgICAgICAgJ2luc2V0LXknOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgc3RhcnQ6IFt7XG4gICAgICAgIHN0YXJ0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGVuZDogW3tcbiAgICAgICAgZW5kOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHRvcDogW3tcbiAgICAgICAgdG9wOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgcmlnaHQ6IFt7XG4gICAgICAgIHJpZ2h0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGJvdHRvbTogW3tcbiAgICAgICAgYm90dG9tOiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBsZWZ0OiBbe1xuICAgICAgICBsZWZ0OiBbaW5zZXRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVmlzaWJpbGl0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Zpc2liaWxpdHlcbiAgICAgICAqL1xuICAgICAgdmlzaWJpbGl0eTogWyd2aXNpYmxlJywgJ2ludmlzaWJsZScsICdjb2xsYXBzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBaLUluZGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvei1pbmRleFxuICAgICAgICovXG4gICAgICB6OiBbe1xuICAgICAgICB6OiBbJ2F1dG8nLCBpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIEZsZXhib3ggYW5kIEdyaWRcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBCYXNpc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtYmFzaXNcbiAgICAgICAqL1xuICAgICAgYmFzaXM6IFt7XG4gICAgICAgIGJhc2lzOiBnZXRTcGFjaW5nV2l0aEF1dG9BbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggRGlyZWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1kaXJlY3Rpb25cbiAgICAgICAqL1xuICAgICAgJ2ZsZXgtZGlyZWN0aW9uJzogW3tcbiAgICAgICAgZmxleDogWydyb3cnLCAncm93LXJldmVyc2UnLCAnY29sJywgJ2NvbC1yZXZlcnNlJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFdyYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LXdyYXBcbiAgICAgICAqL1xuICAgICAgJ2ZsZXgtd3JhcCc6IFt7XG4gICAgICAgIGZsZXg6IFsnd3JhcCcsICd3cmFwLXJldmVyc2UnLCAnbm93cmFwJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleFxuICAgICAgICovXG4gICAgICBmbGV4OiBbe1xuICAgICAgICBmbGV4OiBbJzEnLCAnYXV0bycsICdpbml0aWFsJywgJ25vbmUnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggR3Jvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtZ3Jvd1xuICAgICAgICovXG4gICAgICBncm93OiBbe1xuICAgICAgICBncm93OiBnZXRaZXJvQW5kRW1wdHkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggU2hyaW5rXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1zaHJpbmtcbiAgICAgICAqL1xuICAgICAgc2hyaW5rOiBbe1xuICAgICAgICBzaHJpbms6IGdldFplcm9BbmRFbXB0eSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3JkZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vcmRlclxuICAgICAgICovXG4gICAgICBvcmRlcjogW3tcbiAgICAgICAgb3JkZXI6IFsnZmlyc3QnLCAnbGFzdCcsICdub25lJywgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgVGVtcGxhdGUgQ29sdW1uc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtdGVtcGxhdGUtY29sdW1uc1xuICAgICAgICovXG4gICAgICAnZ3JpZC1jb2xzJzogW3tcbiAgICAgICAgJ2dyaWQtY29scyc6IFtpc0FueV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydCAvIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgICdjb2wtc3RhcnQtZW5kJzogW3tcbiAgICAgICAgY29sOiBbJ2F1dG8nLCB7XG4gICAgICAgICAgc3BhbjogWydmdWxsJywgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgICB9LCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQ29sdW1uIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1jb2x1bW5cbiAgICAgICAqL1xuICAgICAgJ2NvbC1zdGFydCc6IFt7XG4gICAgICAgICdjb2wtc3RhcnQnOiBnZXROdW1iZXJXaXRoQXV0b0FuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBDb2x1bW4gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1jb2x1bW5cbiAgICAgICAqL1xuICAgICAgJ2NvbC1lbmQnOiBbe1xuICAgICAgICAnY29sLWVuZCc6IGdldE51bWJlcldpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFRlbXBsYXRlIFJvd3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXRlbXBsYXRlLXJvd3NcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtcm93cyc6IFt7XG4gICAgICAgICdncmlkLXJvd3MnOiBbaXNBbnldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgU3RhcnQgLyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICAncm93LXN0YXJ0LWVuZCc6IFt7XG4gICAgICAgIHJvdzogWydhdXRvJywge1xuICAgICAgICAgIHNwYW46IFtpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICAgIH0sIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICAncm93LXN0YXJ0JzogW3tcbiAgICAgICAgJ3Jvdy1zdGFydCc6IGdldE51bWJlcldpdGhBdXRvQW5kQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFJvdyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICAncm93LWVuZCc6IFt7XG4gICAgICAgICdyb3ctZW5kJzogZ2V0TnVtYmVyV2l0aEF1dG9BbmRBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBGbG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLWZsb3dcbiAgICAgICAqL1xuICAgICAgJ2dyaWQtZmxvdyc6IFt7XG4gICAgICAgICdncmlkLWZsb3cnOiBbJ3JvdycsICdjb2wnLCAnZGVuc2UnLCAncm93LWRlbnNlJywgJ2NvbC1kZW5zZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tY29sdW1uc1xuICAgICAgICovXG4gICAgICAnYXV0by1jb2xzJzogW3tcbiAgICAgICAgJ2F1dG8tY29scyc6IFsnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZyJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIEF1dG8gUm93c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1yb3dzXG4gICAgICAgKi9cbiAgICAgICdhdXRvLXJvd3MnOiBbe1xuICAgICAgICAnYXV0by1yb3dzJzogWydhdXRvJywgJ21pbicsICdtYXgnLCAnZnInLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICBnYXA6IFt7XG4gICAgICAgIGdhcDogW2dhcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXAgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICAnZ2FwLXgnOiBbe1xuICAgICAgICAnZ2FwLXgnOiBbZ2FwXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ2FwXG4gICAgICAgKi9cbiAgICAgICdnYXAteSc6IFt7XG4gICAgICAgICdnYXAteSc6IFtnYXBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1jb250ZW50XG4gICAgICAgKi9cbiAgICAgICdqdXN0aWZ5LWNvbnRlbnQnOiBbe1xuICAgICAgICBqdXN0aWZ5OiBbJ25vcm1hbCcsIC4uLmdldEFsaWduKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBJdGVtc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktaXRlbXNcbiAgICAgICAqL1xuICAgICAgJ2p1c3RpZnktaXRlbXMnOiBbe1xuICAgICAgICAnanVzdGlmeS1pdGVtcyc6IFsnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBKdXN0aWZ5IFNlbGZcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0aWZ5LXNlbGZcbiAgICAgICAqL1xuICAgICAgJ2p1c3RpZnktc2VsZic6IFt7XG4gICAgICAgICdqdXN0aWZ5LXNlbGYnOiBbJ2F1dG8nLCAnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tY29udGVudFxuICAgICAgICovXG4gICAgICAnYWxpZ24tY29udGVudCc6IFt7XG4gICAgICAgIGNvbnRlbnQ6IFsnbm9ybWFsJywgLi4uZ2V0QWxpZ24oKSwgJ2Jhc2VsaW5lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBJdGVtc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWl0ZW1zXG4gICAgICAgKi9cbiAgICAgICdhbGlnbi1pdGVtcyc6IFt7XG4gICAgICAgIGl0ZW1zOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYmFzZWxpbmUnLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLXNlbGZcbiAgICAgICAqL1xuICAgICAgJ2FsaWduLXNlbGYnOiBbe1xuICAgICAgICBzZWxmOiBbJ2F1dG8nLCAnc3RhcnQnLCAnZW5kJywgJ2NlbnRlcicsICdzdHJldGNoJywgJ2Jhc2VsaW5lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZSBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2UtY29udGVudFxuICAgICAgICovXG4gICAgICAncGxhY2UtY29udGVudCc6IFt7XG4gICAgICAgICdwbGFjZS1jb250ZW50JzogWy4uLmdldEFsaWduKCksICdiYXNlbGluZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1pdGVtc1xuICAgICAgICovXG4gICAgICAncGxhY2UtaXRlbXMnOiBbe1xuICAgICAgICAncGxhY2UtaXRlbXMnOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYmFzZWxpbmUnLCAnc3RyZXRjaCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLXNlbGZcbiAgICAgICAqL1xuICAgICAgJ3BsYWNlLXNlbGYnOiBbe1xuICAgICAgICAncGxhY2Utc2VsZic6IFsnYXV0bycsICdzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ3N0cmV0Y2gnXVxuICAgICAgfV0sXG4gICAgICAvLyBTcGFjaW5nXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHA6IFt7XG4gICAgICAgIHA6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHg6IFt7XG4gICAgICAgIHB4OiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB5OiBbe1xuICAgICAgICBweTogW3BhZGRpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHM6IFt7XG4gICAgICAgIHBzOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGU6IFt7XG4gICAgICAgIHBlOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHQ6IFt7XG4gICAgICAgIHB0OiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwcjogW3tcbiAgICAgICAgcHI6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwYjogW3tcbiAgICAgICAgcGI6IFtwYWRkaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGw6IFt7XG4gICAgICAgIHBsOiBbcGFkZGluZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbTogW3tcbiAgICAgICAgbTogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBteDogW3tcbiAgICAgICAgbXg6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXk6IFt7XG4gICAgICAgIG15OiBbbWFyZ2luXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtczogW3tcbiAgICAgICAgbXM6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtZTogW3tcbiAgICAgICAgbWU6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtdDogW3tcbiAgICAgICAgbXQ6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1yOiBbe1xuICAgICAgICBtcjogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1iOiBbe1xuICAgICAgICBtYjogW21hcmdpbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtbDogW3tcbiAgICAgICAgbWw6IFttYXJnaW5dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3BhY2UgQmV0d2VlbiBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXgnOiBbe1xuICAgICAgICAnc3BhY2UteCc6IFtzcGFjZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NwYWNlXG4gICAgICAgKi9cbiAgICAgICdzcGFjZS14LXJldmVyc2UnOiBbJ3NwYWNlLXgtcmV2ZXJzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICAnc3BhY2UteSc6IFt7XG4gICAgICAgICdzcGFjZS15JzogW3NwYWNlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWSBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgJ3NwYWNlLXktcmV2ZXJzZSc6IFsnc3BhY2UteS1yZXZlcnNlJ10sXG4gICAgICAvLyBTaXppbmdcbiAgICAgIC8qKlxuICAgICAgICogV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aFxuICAgICAgICovXG4gICAgICB3OiBbe1xuICAgICAgICB3OiBbJ2F1dG8nLCAnbWluJywgJ21heCcsICdmaXQnLCAnc3Z3JywgJ2x2dycsICdkdncnLCBpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1pbi1XaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi13aWR0aFxuICAgICAgICovXG4gICAgICAnbWluLXcnOiBbe1xuICAgICAgICAnbWluLXcnOiBbaXNBcmJpdHJhcnlWYWx1ZSwgc3BhY2luZywgJ21pbicsICdtYXgnLCAnZml0J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXgtV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXgtd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ21heC13JzogW3tcbiAgICAgICAgJ21heC13JzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdub25lJywgJ2Z1bGwnLCAnbWluJywgJ21heCcsICdmaXQnLCAncHJvc2UnLCB7XG4gICAgICAgICAgc2NyZWVuOiBbaXNUc2hpcnRTaXplXVxuICAgICAgICB9LCBpc1RzaGlydFNpemVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIGg6IFt7XG4gICAgICAgIGg6IFtpc0FyYml0cmFyeVZhbHVlLCBzcGFjaW5nLCAnYXV0bycsICdtaW4nLCAnbWF4JywgJ2ZpdCcsICdzdmgnLCAnbHZoJywgJ2R2aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWluLUhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgJ21pbi1oJzogW3tcbiAgICAgICAgJ21pbi1oJzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdtaW4nLCAnbWF4JywgJ2ZpdCcsICdzdmgnLCAnbHZoJywgJ2R2aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWF4LUhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21heC1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgJ21heC1oJzogW3tcbiAgICAgICAgJ21heC1oJzogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdtaW4nLCAnbWF4JywgJ2ZpdCcsICdzdmgnLCAnbHZoJywgJ2R2aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NpemVcbiAgICAgICAqL1xuICAgICAgc2l6ZTogW3tcbiAgICAgICAgc2l6ZTogW2lzQXJiaXRyYXJ5VmFsdWUsIHNwYWNpbmcsICdhdXRvJywgJ21pbicsICdtYXgnLCAnZml0J11cbiAgICAgIH1dLFxuICAgICAgLy8gVHlwb2dyYXBoeVxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNpemVcbiAgICAgICAqL1xuICAgICAgJ2ZvbnQtc2l6ZSc6IFt7XG4gICAgICAgIHRleHQ6IFsnYmFzZScsIGlzVHNoaXJ0U2l6ZSwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTbW9vdGhpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNtb290aGluZ1xuICAgICAgICovXG4gICAgICAnZm9udC1zbW9vdGhpbmcnOiBbJ2FudGlhbGlhc2VkJywgJ3N1YnBpeGVsLWFudGlhbGlhc2VkJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXN0eWxlXG4gICAgICAgKi9cbiAgICAgICdmb250LXN0eWxlJzogWydpdGFsaWMnLCAnbm90LWl0YWxpYyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFdlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtd2VpZ2h0XG4gICAgICAgKi9cbiAgICAgICdmb250LXdlaWdodCc6IFt7XG4gICAgICAgIGZvbnQ6IFsndGhpbicsICdleHRyYWxpZ2h0JywgJ2xpZ2h0JywgJ25vcm1hbCcsICdtZWRpdW0nLCAnc2VtaWJvbGQnLCAnYm9sZCcsICdleHRyYWJvbGQnLCAnYmxhY2snLCBpc0FyYml0cmFyeU51bWJlcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IEZhbWlseVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtZmFtaWx5XG4gICAgICAgKi9cbiAgICAgICdmb250LWZhbWlseSc6IFt7XG4gICAgICAgIGZvbnQ6IFtpc0FueV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tbm9ybWFsJzogWydub3JtYWwtbnVtcyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tb3JkaW5hbCc6IFsnb3JkaW5hbCddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tc2xhc2hlZC16ZXJvJzogWydzbGFzaGVkLXplcm8nXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICAnZnZuLWZpZ3VyZSc6IFsnbGluaW5nLW51bXMnLCAnb2xkc3R5bGUtbnVtcyddLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgICdmdm4tc3BhY2luZyc6IFsncHJvcG9ydGlvbmFsLW51bXMnLCAndGFidWxhci1udW1zJ10sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgJ2Z2bi1mcmFjdGlvbic6IFsnZGlhZ29uYWwtZnJhY3Rpb25zJywgJ3N0YWNrZWQtZnJhY3RvbnMnXSxcbiAgICAgIC8qKlxuICAgICAgICogTGV0dGVyIFNwYWNpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9sZXR0ZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICB0cmFja2luZzogW3tcbiAgICAgICAgdHJhY2tpbmc6IFsndGlnaHRlcicsICd0aWdodCcsICdub3JtYWwnLCAnd2lkZScsICd3aWRlcicsICd3aWRlc3QnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpbmUgQ2xhbXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saW5lLWNsYW1wXG4gICAgICAgKi9cbiAgICAgICdsaW5lLWNsYW1wJzogW3tcbiAgICAgICAgJ2xpbmUtY2xhbXAnOiBbJ25vbmUnLCBpc051bWJlciwgaXNBcmJpdHJhcnlOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGluZSBIZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saW5lLWhlaWdodFxuICAgICAgICovXG4gICAgICBsZWFkaW5nOiBbe1xuICAgICAgICBsZWFkaW5nOiBbJ25vbmUnLCAndGlnaHQnLCAnc251ZycsICdub3JtYWwnLCAncmVsYXhlZCcsICdsb29zZScsIGlzTGVuZ3RoLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgSW1hZ2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saXN0LXN0eWxlLWltYWdlXG4gICAgICAgKi9cbiAgICAgICdsaXN0LWltYWdlJzogW3tcbiAgICAgICAgJ2xpc3QtaW1hZ2UnOiBbJ25vbmUnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgVHlwZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpc3Qtc3R5bGUtdHlwZVxuICAgICAgICovXG4gICAgICAnbGlzdC1zdHlsZS10eXBlJzogW3tcbiAgICAgICAgbGlzdDogWydub25lJywgJ2Rpc2MnLCAnZGVjaW1hbCcsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGlzdCBTdHlsZSBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpc3Qtc3R5bGUtcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgJ2xpc3Qtc3R5bGUtcG9zaXRpb24nOiBbe1xuICAgICAgICBsaXN0OiBbJ2luc2lkZScsICdvdXRzaWRlJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZWhvbGRlciBDb2xvclxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlaG9sZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdwbGFjZWhvbGRlci1jb2xvcic6IFt7XG4gICAgICAgIHBsYWNlaG9sZGVyOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlaG9sZGVyIE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZWhvbGRlci1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdwbGFjZWhvbGRlci1vcGFjaXR5JzogW3tcbiAgICAgICAgJ3BsYWNlaG9sZGVyLW9wYWNpdHknOiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IEFsaWdubWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtYWxpZ25cbiAgICAgICAqL1xuICAgICAgJ3RleHQtYWxpZ25tZW50JzogW3tcbiAgICAgICAgdGV4dDogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcsICdqdXN0aWZ5JywgJ3N0YXJ0JywgJ2VuZCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtY29sb3JcbiAgICAgICAqL1xuICAgICAgJ3RleHQtY29sb3InOiBbe1xuICAgICAgICB0ZXh0OiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtb3BhY2l0eVxuICAgICAgICovXG4gICAgICAndGV4dC1vcGFjaXR5JzogW3tcbiAgICAgICAgJ3RleHQtb3BhY2l0eSc6IFtvcGFjaXR5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgRGVjb3JhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvblxuICAgICAgICovXG4gICAgICAndGV4dC1kZWNvcmF0aW9uJzogWyd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJywgJ25vLXVuZGVybGluZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb24gU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb24tc3R5bGVcbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbi1zdHlsZSc6IFt7XG4gICAgICAgIGRlY29yYXRpb246IFsuLi5nZXRMaW5lU3R5bGVzKCksICd3YXZ5J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb24gVGhpY2tuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzc1xuICAgICAgICovXG4gICAgICAndGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzcyc6IFt7XG4gICAgICAgIGRlY29yYXRpb246IFsnYXV0bycsICdmcm9tLWZvbnQnLCBpc0xlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBVbmRlcmxpbmUgT2Zmc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC11bmRlcmxpbmUtb2Zmc2V0XG4gICAgICAgKi9cbiAgICAgICd1bmRlcmxpbmUtb2Zmc2V0JzogW3tcbiAgICAgICAgJ3VuZGVybGluZS1vZmZzZXQnOiBbJ2F1dG8nLCBpc0xlbmd0aCwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb24gQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb24tY29sb3JcbiAgICAgICAqL1xuICAgICAgJ3RleHQtZGVjb3JhdGlvbi1jb2xvcic6IFt7XG4gICAgICAgIGRlY29yYXRpb246IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBUcmFuc2Zvcm1cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXRyYW5zZm9ybVxuICAgICAgICovXG4gICAgICAndGV4dC10cmFuc2Zvcm0nOiBbJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnLCAnY2FwaXRhbGl6ZScsICdub3JtYWwtY2FzZSddLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IE92ZXJmbG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1vdmVyZmxvd1xuICAgICAgICovXG4gICAgICAndGV4dC1vdmVyZmxvdyc6IFsndHJ1bmNhdGUnLCAndGV4dC1lbGxpcHNpcycsICd0ZXh0LWNsaXAnXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBXcmFwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC13cmFwXG4gICAgICAgKi9cbiAgICAgICd0ZXh0LXdyYXAnOiBbe1xuICAgICAgICB0ZXh0OiBbJ3dyYXAnLCAnbm93cmFwJywgJ2JhbGFuY2UnLCAncHJldHR5J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IEluZGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtaW5kZW50XG4gICAgICAgKi9cbiAgICAgIGluZGVudDogW3tcbiAgICAgICAgaW5kZW50OiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVmVydGljYWwgQWxpZ25tZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdmVydGljYWwtYWxpZ25cbiAgICAgICAqL1xuICAgICAgJ3ZlcnRpY2FsLWFsaWduJzogW3tcbiAgICAgICAgYWxpZ246IFsnYmFzZWxpbmUnLCAndG9wJywgJ21pZGRsZScsICdib3R0b20nLCAndGV4dC10b3AnLCAndGV4dC1ib3R0b20nLCAnc3ViJywgJ3N1cGVyJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGl0ZXNwYWNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2hpdGVzcGFjZVxuICAgICAgICovXG4gICAgICB3aGl0ZXNwYWNlOiBbe1xuICAgICAgICB3aGl0ZXNwYWNlOiBbJ25vcm1hbCcsICdub3dyYXAnLCAncHJlJywgJ3ByZS1saW5lJywgJ3ByZS13cmFwJywgJ2JyZWFrLXNwYWNlcyddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV29yZCBCcmVha1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3dvcmQtYnJlYWtcbiAgICAgICAqL1xuICAgICAgYnJlYWs6IFt7XG4gICAgICAgIGJyZWFrOiBbJ25vcm1hbCcsICd3b3JkcycsICdhbGwnLCAna2VlcCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSHlwaGVuc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2h5cGhlbnNcbiAgICAgICAqL1xuICAgICAgaHlwaGVuczogW3tcbiAgICAgICAgaHlwaGVuczogWydub25lJywgJ21hbnVhbCcsICdhdXRvJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udGVudFxuICAgICAgICovXG4gICAgICBjb250ZW50OiBbe1xuICAgICAgICBjb250ZW50OiBbJ25vbmUnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBCYWNrZ3JvdW5kc1xuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIEF0dGFjaG1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWF0dGFjaG1lbnRcbiAgICAgICAqL1xuICAgICAgJ2JnLWF0dGFjaG1lbnQnOiBbe1xuICAgICAgICBiZzogWydmaXhlZCcsICdsb2NhbCcsICdzY3JvbGwnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQ2xpcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtY2xpcFxuICAgICAgICovXG4gICAgICAnYmctY2xpcCc6IFt7XG4gICAgICAgICdiZy1jbGlwJzogWydib3JkZXInLCAncGFkZGluZycsICdjb250ZW50JywgJ3RleHQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgT3BhY2l0eVxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtb3BhY2l0eVxuICAgICAgICovXG4gICAgICAnYmctb3BhY2l0eSc6IFt7XG4gICAgICAgICdiZy1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBPcmlnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLW9yaWdpblxuICAgICAgICovXG4gICAgICAnYmctb3JpZ2luJzogW3tcbiAgICAgICAgJ2JnLW9yaWdpbic6IFsnYm9yZGVyJywgJ3BhZGRpbmcnLCAnY29udGVudCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgJ2JnLXBvc2l0aW9uJzogW3tcbiAgICAgICAgYmc6IFsuLi5nZXRQb3NpdGlvbnMoKSwgaXNBcmJpdHJhcnlQb3NpdGlvbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFJlcGVhdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcmVwZWF0XG4gICAgICAgKi9cbiAgICAgICdiZy1yZXBlYXQnOiBbe1xuICAgICAgICBiZzogWyduby1yZXBlYXQnLCB7XG4gICAgICAgICAgcmVwZWF0OiBbJycsICd4JywgJ3knLCAncm91bmQnLCAnc3BhY2UnXVxuICAgICAgICB9XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtc2l6ZVxuICAgICAgICovXG4gICAgICAnYmctc2l6ZSc6IFt7XG4gICAgICAgIGJnOiBbJ2F1dG8nLCAnY292ZXInLCAnY29udGFpbicsIGlzQXJiaXRyYXJ5U2l6ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1pbWFnZVxuICAgICAgICovXG4gICAgICAnYmctaW1hZ2UnOiBbe1xuICAgICAgICBiZzogWydub25lJywge1xuICAgICAgICAgICdncmFkaWVudC10byc6IFsndCcsICd0cicsICdyJywgJ2JyJywgJ2InLCAnYmwnLCAnbCcsICd0bCddXG4gICAgICAgIH0sIGlzQXJiaXRyYXJ5SW1hZ2VdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JnLWNvbG9yJzogW3tcbiAgICAgICAgYmc6IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgRnJvbSBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC1mcm9tLXBvcyc6IFt7XG4gICAgICAgIGZyb206IFtncmFkaWVudENvbG9yU3RvcFBvc2l0aW9uc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBWaWEgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtdmlhLXBvcyc6IFt7XG4gICAgICAgIHZpYTogW2dyYWRpZW50Q29sb3JTdG9wUG9zaXRpb25zXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIFRvIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXRvLXBvcyc6IFt7XG4gICAgICAgIHRvOiBbZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgRnJvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgICdncmFkaWVudC1mcm9tJzogW3tcbiAgICAgICAgZnJvbTogW2dyYWRpZW50Q29sb3JTdG9wc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBWaWFcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICAnZ3JhZGllbnQtdmlhJzogW3tcbiAgICAgICAgdmlhOiBbZ3JhZGllbnRDb2xvclN0b3BzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIFRvXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgJ2dyYWRpZW50LXRvJzogW3tcbiAgICAgICAgdG86IFtncmFkaWVudENvbG9yU3RvcHNdXG4gICAgICB9XSxcbiAgICAgIC8vIEJvcmRlcnNcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgcm91bmRlZDogW3tcbiAgICAgICAgcm91bmRlZDogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1zJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtcyc6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWUnOiBbe1xuICAgICAgICAncm91bmRlZC1lJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdCc6IFt7XG4gICAgICAgICdyb3VuZGVkLXQnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXInOiBbe1xuICAgICAgICAncm91bmRlZC1yJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtYic6IFt7XG4gICAgICAgICdyb3VuZGVkLWInOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtbCc6IFt7XG4gICAgICAgICdyb3VuZGVkLWwnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgU3RhcnQgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLXNzJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtc3MnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgU3RhcnQgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1zZSc6IFt7XG4gICAgICAgICdyb3VuZGVkLXNlJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWVlJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtZWUnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC1lcyc6IFt7XG4gICAgICAgICdyb3VuZGVkLWVzJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcCBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICAncm91bmRlZC10bCc6IFt7XG4gICAgICAgICdyb3VuZGVkLXRsJzogW2JvcmRlclJhZGl1c11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFRvcCBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgJ3JvdW5kZWQtdHInOiBbe1xuICAgICAgICAncm91bmRlZC10cic6IFtib3JkZXJSYWRpdXNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b20gUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWJyJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtYnInOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgICdyb3VuZGVkLWJsJzogW3tcbiAgICAgICAgJ3JvdW5kZWQtYmwnOiBbYm9yZGVyUmFkaXVzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXcnOiBbe1xuICAgICAgICBib3JkZXI6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXcteCc6IFt7XG4gICAgICAgICdib3JkZXIteCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXcteSc6IFt7XG4gICAgICAgICdib3JkZXIteSc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci13LXMnOiBbe1xuICAgICAgICAnYm9yZGVyLXMnOiBbYm9yZGVyV2lkdGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctZSc6IFt7XG4gICAgICAgICdib3JkZXItZSc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy10JzogW3tcbiAgICAgICAgJ2JvcmRlci10JzogW2JvcmRlcldpZHRoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICAnYm9yZGVyLXctcic6IFt7XG4gICAgICAgICdib3JkZXItcic6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy1iJzogW3tcbiAgICAgICAgJ2JvcmRlci1iJzogW2JvcmRlcldpZHRoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItdy1sJzogW3tcbiAgICAgICAgJ2JvcmRlci1sJzogW2JvcmRlcldpZHRoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1vcGFjaXR5JzogW3tcbiAgICAgICAgJ2JvcmRlci1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXN0eWxlXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItc3R5bGUnOiBbe1xuICAgICAgICBib3JkZXI6IFsuLi5nZXRMaW5lU3R5bGVzKCksICdoaWRkZW4nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBXaWR0aCBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUteCc6IFt7XG4gICAgICAgICdkaXZpZGUteCc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWCBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUteC1yZXZlcnNlJzogWydkaXZpZGUteC1yZXZlcnNlJ10sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBXaWR0aCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUteSc6IFt7XG4gICAgICAgICdkaXZpZGUteSc6IFtib3JkZXJXaWR0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWSBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUteS1yZXZlcnNlJzogWydkaXZpZGUteS1yZXZlcnNlJ10sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgJ2RpdmlkZS1vcGFjaXR5JzogW3tcbiAgICAgICAgJ2RpdmlkZS1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLXN0eWxlXG4gICAgICAgKi9cbiAgICAgICdkaXZpZGUtc3R5bGUnOiBbe1xuICAgICAgICBkaXZpZGU6IGdldExpbmVTdHlsZXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yJzogW3tcbiAgICAgICAgYm9yZGVyOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci14JzogW3tcbiAgICAgICAgJ2JvcmRlci14JzogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItY29sb3IteSc6IFt7XG4gICAgICAgICdib3JkZXIteSc6IFtib3JkZXJDb2xvcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgU1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXMnOiBbe1xuICAgICAgICAnYm9yZGVyLXMnOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIEVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1lJzogW3tcbiAgICAgICAgJ2JvcmRlci1lJzogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci10JzogW3tcbiAgICAgICAgJ2JvcmRlci10JzogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLXInOiBbe1xuICAgICAgICAnYm9yZGVyLXInOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbG9yLWInOiBbe1xuICAgICAgICAnYm9yZGVyLWInOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgJ2JvcmRlci1jb2xvci1sJzogW3tcbiAgICAgICAgJ2JvcmRlci1sJzogW2JvcmRlckNvbG9yXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1jb2xvclxuICAgICAgICovXG4gICAgICAnZGl2aWRlLWNvbG9yJzogW3tcbiAgICAgICAgZGl2aWRlOiBbYm9yZGVyQ29sb3JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtc3R5bGVcbiAgICAgICAqL1xuICAgICAgJ291dGxpbmUtc3R5bGUnOiBbe1xuICAgICAgICBvdXRsaW5lOiBbJycsIC4uLmdldExpbmVTdHlsZXMoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIE9mZnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtb2Zmc2V0XG4gICAgICAgKi9cbiAgICAgICdvdXRsaW5lLW9mZnNldCc6IFt7XG4gICAgICAgICdvdXRsaW5lLW9mZnNldCc6IFtpc0xlbmd0aCwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS13aWR0aFxuICAgICAgICovXG4gICAgICAnb3V0bGluZS13JzogW3tcbiAgICAgICAgb3V0bGluZTogW2lzTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1jb2xvclxuICAgICAgICovXG4gICAgICAnb3V0bGluZS1jb2xvcic6IFt7XG4gICAgICAgIG91dGxpbmU6IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ3Jpbmctdyc6IFt7XG4gICAgICAgIHJpbmc6IGdldExlbmd0aFdpdGhFbXB0eUFuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBXaWR0aCBJbnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ3Jpbmctdy1pbnNldCc6IFsncmluZy1pbnNldCddLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1jb2xvclxuICAgICAgICovXG4gICAgICAncmluZy1jb2xvcic6IFt7XG4gICAgICAgIHJpbmc6IFtjb2xvcnNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdyaW5nLW9wYWNpdHknOiBbe1xuICAgICAgICAncmluZy1vcGFjaXR5JzogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBPZmZzZXQgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLW9mZnNldC13aWR0aFxuICAgICAgICovXG4gICAgICAncmluZy1vZmZzZXQtdyc6IFt7XG4gICAgICAgICdyaW5nLW9mZnNldCc6IFtpc0xlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBPZmZzZXQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLW9mZnNldC1jb2xvclxuICAgICAgICovXG4gICAgICAncmluZy1vZmZzZXQtY29sb3InOiBbe1xuICAgICAgICAncmluZy1vZmZzZXQnOiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvLyBFZmZlY3RzXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaGFkb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93XG4gICAgICAgKi9cbiAgICAgIHNoYWRvdzogW3tcbiAgICAgICAgc2hhZG93OiBbJycsICdpbm5lcicsICdub25lJywgaXNUc2hpcnRTaXplLCBpc0FyYml0cmFyeVNoYWRvd11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2hhZG93IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvdy1jb2xvclxuICAgICAgICovXG4gICAgICAnc2hhZG93LWNvbG9yJzogW3tcbiAgICAgICAgc2hhZG93OiBbaXNBbnldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29wYWNpdHlcbiAgICAgICAqL1xuICAgICAgb3BhY2l0eTogW3tcbiAgICAgICAgb3BhY2l0eTogW29wYWNpdHldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWl4IEJsZW5kIE1vZGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9taXgtYmxlbmQtbW9kZVxuICAgICAgICovXG4gICAgICAnbWl4LWJsZW5kJzogW3tcbiAgICAgICAgJ21peC1ibGVuZCc6IFsuLi5nZXRCbGVuZE1vZGVzKCksICdwbHVzLWxpZ2h0ZXInLCAncGx1cy1kYXJrZXInXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQmxlbmQgTW9kZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtYmxlbmQtbW9kZVxuICAgICAgICovXG4gICAgICAnYmctYmxlbmQnOiBbe1xuICAgICAgICAnYmctYmxlbmQnOiBnZXRCbGVuZE1vZGVzKClcbiAgICAgIH1dLFxuICAgICAgLy8gRmlsdGVyc1xuICAgICAgLyoqXG4gICAgICAgKiBGaWx0ZXJcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9maWx0ZXJcbiAgICAgICAqL1xuICAgICAgZmlsdGVyOiBbe1xuICAgICAgICBmaWx0ZXI6IFsnJywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJsdXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ibHVyXG4gICAgICAgKi9cbiAgICAgIGJsdXI6IFt7XG4gICAgICAgIGJsdXI6IFtibHVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyaWdodG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmlnaHRuZXNzXG4gICAgICAgKi9cbiAgICAgIGJyaWdodG5lc3M6IFt7XG4gICAgICAgIGJyaWdodG5lc3M6IFticmlnaHRuZXNzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbnRyYXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udHJhc3RcbiAgICAgICAqL1xuICAgICAgY29udHJhc3Q6IFt7XG4gICAgICAgIGNvbnRyYXN0OiBbY29udHJhc3RdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRHJvcCBTaGFkb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kcm9wLXNoYWRvd1xuICAgICAgICovXG4gICAgICAnZHJvcC1zaGFkb3cnOiBbe1xuICAgICAgICAnZHJvcC1zaGFkb3cnOiBbJycsICdub25lJywgaXNUc2hpcnRTaXplLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYXlzY2FsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYXlzY2FsZVxuICAgICAgICovXG4gICAgICBncmF5c2NhbGU6IFt7XG4gICAgICAgIGdyYXlzY2FsZTogW2dyYXlzY2FsZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBIdWUgUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaHVlLXJvdGF0ZVxuICAgICAgICovXG4gICAgICAnaHVlLXJvdGF0ZSc6IFt7XG4gICAgICAgICdodWUtcm90YXRlJzogW2h1ZVJvdGF0ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJbnZlcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9pbnZlcnRcbiAgICAgICAqL1xuICAgICAgaW52ZXJ0OiBbe1xuICAgICAgICBpbnZlcnQ6IFtpbnZlcnRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2F0dXJhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zYXR1cmF0ZVxuICAgICAgICovXG4gICAgICBzYXR1cmF0ZTogW3tcbiAgICAgICAgc2F0dXJhdGU6IFtzYXR1cmF0ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTZXBpYVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NlcGlhXG4gICAgICAgKi9cbiAgICAgIHNlcGlhOiBbe1xuICAgICAgICBzZXBpYTogW3NlcGlhXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEZpbHRlclxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWZpbHRlclxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtZmlsdGVyJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWZpbHRlcic6IFsnJywgJ25vbmUnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEJsdXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ibHVyXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1ibHVyJzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLWJsdXInOiBbYmx1cl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBCcmlnaHRuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtYnJpZ2h0bmVzc1xuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtYnJpZ2h0bmVzcyc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1icmlnaHRuZXNzJzogW2JyaWdodG5lc3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQ29udHJhc3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1jb250cmFzdFxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtY29udHJhc3QnOiBbe1xuICAgICAgICAnYmFja2Ryb3AtY29udHJhc3QnOiBbY29udHJhc3RdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgR3JheXNjYWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtZ3JheXNjYWxlXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1ncmF5c2NhbGUnOiBbe1xuICAgICAgICAnYmFja2Ryb3AtZ3JheXNjYWxlJzogW2dyYXlzY2FsZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBIdWUgUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtaHVlLXJvdGF0ZVxuICAgICAgICovXG4gICAgICAnYmFja2Ryb3AtaHVlLXJvdGF0ZSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1odWUtcm90YXRlJzogW2h1ZVJvdGF0ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBJbnZlcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1pbnZlcnRcbiAgICAgICAqL1xuICAgICAgJ2JhY2tkcm9wLWludmVydCc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1pbnZlcnQnOiBbaW52ZXJ0XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1vcGFjaXR5JzogW3tcbiAgICAgICAgJ2JhY2tkcm9wLW9wYWNpdHknOiBbb3BhY2l0eV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBTYXR1cmF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLXNhdHVyYXRlXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1zYXR1cmF0ZSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1zYXR1cmF0ZSc6IFtzYXR1cmF0ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBTZXBpYVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLXNlcGlhXG4gICAgICAgKi9cbiAgICAgICdiYWNrZHJvcC1zZXBpYSc6IFt7XG4gICAgICAgICdiYWNrZHJvcC1zZXBpYSc6IFtzZXBpYV1cbiAgICAgIH1dLFxuICAgICAgLy8gVGFibGVzXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xsYXBzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xsYXBzZVxuICAgICAgICovXG4gICAgICAnYm9yZGVyLWNvbGxhcHNlJzogW3tcbiAgICAgICAgYm9yZGVyOiBbJ2NvbGxhcHNlJywgJ3NlcGFyYXRlJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zcGFjaW5nXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItc3BhY2luZyc6IFt7XG4gICAgICAgICdib3JkZXItc3BhY2luZyc6IFtib3JkZXJTcGFjaW5nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICAnYm9yZGVyLXNwYWNpbmcteCc6IFt7XG4gICAgICAgICdib3JkZXItc3BhY2luZy14JzogW2JvcmRlclNwYWNpbmddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFNwYWNpbmcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zcGFjaW5nXG4gICAgICAgKi9cbiAgICAgICdib3JkZXItc3BhY2luZy15JzogW3tcbiAgICAgICAgJ2JvcmRlci1zcGFjaW5nLXknOiBbYm9yZGVyU3BhY2luZ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUYWJsZSBMYXlvdXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90YWJsZS1sYXlvdXRcbiAgICAgICAqL1xuICAgICAgJ3RhYmxlLWxheW91dCc6IFt7XG4gICAgICAgIHRhYmxlOiBbJ2F1dG8nLCAnZml4ZWQnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENhcHRpb24gU2lkZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NhcHRpb24tc2lkZVxuICAgICAgICovXG4gICAgICBjYXB0aW9uOiBbe1xuICAgICAgICBjYXB0aW9uOiBbJ3RvcCcsICdib3R0b20nXVxuICAgICAgfV0sXG4gICAgICAvLyBUcmFuc2l0aW9ucyBhbmQgQW5pbWF0aW9uXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5pc2l0aW9uIFByb3BlcnR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1wcm9wZXJ0eVxuICAgICAgICovXG4gICAgICB0cmFuc2l0aW9uOiBbe1xuICAgICAgICB0cmFuc2l0aW9uOiBbJ25vbmUnLCAnYWxsJywgJycsICdjb2xvcnMnLCAnb3BhY2l0eScsICdzaGFkb3cnLCAndHJhbnNmb3JtJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIER1cmF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1kdXJhdGlvblxuICAgICAgICovXG4gICAgICBkdXJhdGlvbjogW3tcbiAgICAgICAgZHVyYXRpb246IGdldE51bWJlckFuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBUaW1pbmcgRnVuY3Rpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuICAgICAgICovXG4gICAgICBlYXNlOiBbe1xuICAgICAgICBlYXNlOiBbJ2xpbmVhcicsICdpbicsICdvdXQnLCAnaW4tb3V0JywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIERlbGF5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1kZWxheVxuICAgICAgICovXG4gICAgICBkZWxheTogW3tcbiAgICAgICAgZGVsYXk6IGdldE51bWJlckFuZEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQW5pbWF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYW5pbWF0aW9uXG4gICAgICAgKi9cbiAgICAgIGFuaW1hdGU6IFt7XG4gICAgICAgIGFuaW1hdGU6IFsnbm9uZScsICdzcGluJywgJ3BpbmcnLCAncHVsc2UnLCAnYm91bmNlJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gVHJhbnNmb3Jtc1xuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm1cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm1cbiAgICAgICAqL1xuICAgICAgdHJhbnNmb3JtOiBbe1xuICAgICAgICB0cmFuc2Zvcm06IFsnJywgJ2dwdScsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgIHNjYWxlOiBbe1xuICAgICAgICBzY2FsZTogW3NjYWxlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICAnc2NhbGUteCc6IFt7XG4gICAgICAgICdzY2FsZS14JzogW3NjYWxlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICAnc2NhbGUteSc6IFt7XG4gICAgICAgICdzY2FsZS15JzogW3NjYWxlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJvdGF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3JvdGF0ZVxuICAgICAgICovXG4gICAgICByb3RhdGU6IFt7XG4gICAgICAgIHJvdGF0ZTogW2lzSW50ZWdlciwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGUgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICovXG4gICAgICAndHJhbnNsYXRlLXgnOiBbe1xuICAgICAgICAndHJhbnNsYXRlLXgnOiBbdHJhbnNsYXRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgICd0cmFuc2xhdGUteSc6IFt7XG4gICAgICAgICd0cmFuc2xhdGUteSc6IFt0cmFuc2xhdGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2tldyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICovXG4gICAgICAnc2tldy14JzogW3tcbiAgICAgICAgJ3NrZXcteCc6IFtza2V3XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNrZXcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NrZXdcbiAgICAgICAqL1xuICAgICAgJ3NrZXcteSc6IFt7XG4gICAgICAgICdza2V3LXknOiBbc2tld11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gT3JpZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNmb3JtLW9yaWdpblxuICAgICAgICovXG4gICAgICAndHJhbnNmb3JtLW9yaWdpbic6IFt7XG4gICAgICAgIG9yaWdpbjogWydjZW50ZXInLCAndG9wJywgJ3RvcC1yaWdodCcsICdyaWdodCcsICdib3R0b20tcmlnaHQnLCAnYm90dG9tJywgJ2JvdHRvbS1sZWZ0JywgJ2xlZnQnLCAndG9wLWxlZnQnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyBJbnRlcmFjdGl2aXR5XG4gICAgICAvKipcbiAgICAgICAqIEFjY2VudCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FjY2VudC1jb2xvclxuICAgICAgICovXG4gICAgICBhY2NlbnQ6IFt7XG4gICAgICAgIGFjY2VudDogWydhdXRvJywgY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEFwcGVhcmFuY2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hcHBlYXJhbmNlXG4gICAgICAgKi9cbiAgICAgIGFwcGVhcmFuY2U6IFt7XG4gICAgICAgIGFwcGVhcmFuY2U6IFsnbm9uZScsICdhdXRvJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDdXJzb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jdXJzb3JcbiAgICAgICAqL1xuICAgICAgY3Vyc29yOiBbe1xuICAgICAgICBjdXJzb3I6IFsnYXV0bycsICdkZWZhdWx0JywgJ3BvaW50ZXInLCAnd2FpdCcsICd0ZXh0JywgJ21vdmUnLCAnaGVscCcsICdub3QtYWxsb3dlZCcsICdub25lJywgJ2NvbnRleHQtbWVudScsICdwcm9ncmVzcycsICdjZWxsJywgJ2Nyb3NzaGFpcicsICd2ZXJ0aWNhbC10ZXh0JywgJ2FsaWFzJywgJ2NvcHknLCAnbm8tZHJvcCcsICdncmFiJywgJ2dyYWJiaW5nJywgJ2FsbC1zY3JvbGwnLCAnY29sLXJlc2l6ZScsICdyb3ctcmVzaXplJywgJ24tcmVzaXplJywgJ2UtcmVzaXplJywgJ3MtcmVzaXplJywgJ3ctcmVzaXplJywgJ25lLXJlc2l6ZScsICdudy1yZXNpemUnLCAnc2UtcmVzaXplJywgJ3N3LXJlc2l6ZScsICdldy1yZXNpemUnLCAnbnMtcmVzaXplJywgJ25lc3ctcmVzaXplJywgJ253c2UtcmVzaXplJywgJ3pvb20taW4nLCAnem9vbS1vdXQnLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENhcmV0IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdC1pbi10aW1lLW1vZGUjY2FyZXQtY29sb3ItdXRpbGl0aWVzXG4gICAgICAgKi9cbiAgICAgICdjYXJldC1jb2xvcic6IFt7XG4gICAgICAgIGNhcmV0OiBbY29sb3JzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBvaW50ZXIgRXZlbnRzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9pbnRlci1ldmVudHNcbiAgICAgICAqL1xuICAgICAgJ3BvaW50ZXItZXZlbnRzJzogW3tcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogWydub25lJywgJ2F1dG8nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJlc2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jlc2l6ZVxuICAgICAgICovXG4gICAgICByZXNpemU6IFt7XG4gICAgICAgIHJlc2l6ZTogWydub25lJywgJ3knLCAneCcsICcnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBCZWhhdmlvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLWJlaGF2aW9yJzogW3tcbiAgICAgICAgc2Nyb2xsOiBbJ2F1dG8nLCAnc21vb3RoJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW0nOiBbe1xuICAgICAgICAnc2Nyb2xsLW0nOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW14JzogW3tcbiAgICAgICAgJ3Njcm9sbC1teCc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXknOiBbe1xuICAgICAgICAnc2Nyb2xsLW15JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbXMnOiBbe1xuICAgICAgICAnc2Nyb2xsLW1zJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICAnc2Nyb2xsLW1lJzogW3tcbiAgICAgICAgJ3Njcm9sbC1tZSc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tdCc6IFt7XG4gICAgICAgICdzY3JvbGwtbXQnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tcic6IFt7XG4gICAgICAgICdzY3JvbGwtbXInOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtbWInOiBbe1xuICAgICAgICAnc2Nyb2xsLW1iJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1tbCc6IFt7XG4gICAgICAgICdzY3JvbGwtbWwnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXAnOiBbe1xuICAgICAgICAnc2Nyb2xsLXAnOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcHgnOiBbe1xuICAgICAgICAnc2Nyb2xsLXB4JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICAnc2Nyb2xsLXB5JzogW3tcbiAgICAgICAgJ3Njcm9sbC1weSc6IGdldFNwYWNpbmdXaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcHMnOiBbe1xuICAgICAgICAnc2Nyb2xsLXBzJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcGUnOiBbe1xuICAgICAgICAnc2Nyb2xsLXBlJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcHQnOiBbe1xuICAgICAgICAnc2Nyb2xsLXB0JzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wcic6IFt7XG4gICAgICAgICdzY3JvbGwtcHInOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgJ3Njcm9sbC1wYic6IFt7XG4gICAgICAgICdzY3JvbGwtcGInOiBnZXRTcGFjaW5nV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgICdzY3JvbGwtcGwnOiBbe1xuICAgICAgICAnc2Nyb2xsLXBsJzogZ2V0U3BhY2luZ1dpdGhBcmJpdHJhcnkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIEFsaWduXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtYWxpZ25cbiAgICAgICAqL1xuICAgICAgJ3NuYXAtYWxpZ24nOiBbe1xuICAgICAgICBzbmFwOiBbJ3N0YXJ0JywgJ2VuZCcsICdjZW50ZXInLCAnYWxpZ24tbm9uZSddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgU3RvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXN0b3BcbiAgICAgICAqL1xuICAgICAgJ3NuYXAtc3RvcCc6IFt7XG4gICAgICAgIHNuYXA6IFsnbm9ybWFsJywgJ2Fsd2F5cyddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgVHlwZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXR5cGVcbiAgICAgICAqL1xuICAgICAgJ3NuYXAtdHlwZSc6IFt7XG4gICAgICAgIHNuYXA6IFsnbm9uZScsICd4JywgJ3knLCAnYm90aCddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgVHlwZSBTdHJpY3RuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXNuYXAtdHlwZVxuICAgICAgICovXG4gICAgICAnc25hcC1zdHJpY3RuZXNzJzogW3tcbiAgICAgICAgc25hcDogWydtYW5kYXRvcnknLCAncHJveGltaXR5J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgdG91Y2g6IFt7XG4gICAgICAgIHRvdWNoOiBbJ2F1dG8nLCAnbm9uZScsICdtYW5pcHVsYXRpb24nXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgICd0b3VjaC14JzogW3tcbiAgICAgICAgJ3RvdWNoLXBhbic6IFsneCcsICdsZWZ0JywgJ3JpZ2h0J11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICAndG91Y2gteSc6IFt7XG4gICAgICAgICd0b3VjaC1wYW4nOiBbJ3knLCAndXAnLCAnZG93biddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFBpbmNoIFpvb21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgJ3RvdWNoLXB6JzogWyd0b3VjaC1waW5jaC16b29tJ10sXG4gICAgICAvKipcbiAgICAgICAqIFVzZXIgU2VsZWN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdXNlci1zZWxlY3RcbiAgICAgICAqL1xuICAgICAgc2VsZWN0OiBbe1xuICAgICAgICBzZWxlY3Q6IFsnbm9uZScsICd0ZXh0JywgJ2FsbCcsICdhdXRvJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBXaWxsIENoYW5nZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3dpbGwtY2hhbmdlXG4gICAgICAgKi9cbiAgICAgICd3aWxsLWNoYW5nZSc6IFt7XG4gICAgICAgICd3aWxsLWNoYW5nZSc6IFsnYXV0bycsICdzY3JvbGwnLCAnY29udGVudHMnLCAndHJhbnNmb3JtJywgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gU1ZHXG4gICAgICAvKipcbiAgICAgICAqIEZpbGxcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9maWxsXG4gICAgICAgKi9cbiAgICAgIGZpbGw6IFt7XG4gICAgICAgIGZpbGw6IFtjb2xvcnMsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTdHJva2UgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zdHJva2Utd2lkdGhcbiAgICAgICAqL1xuICAgICAgJ3N0cm9rZS13JzogW3tcbiAgICAgICAgc3Ryb2tlOiBbaXNMZW5ndGgsIGlzQXJiaXRyYXJ5TGVuZ3RoLCBpc0FyYml0cmFyeU51bWJlcl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTdHJva2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zdHJva2VcbiAgICAgICAqL1xuICAgICAgc3Ryb2tlOiBbe1xuICAgICAgICBzdHJva2U6IFtjb2xvcnMsICdub25lJ11cbiAgICAgIH1dLFxuICAgICAgLy8gQWNjZXNzaWJpbGl0eVxuICAgICAgLyoqXG4gICAgICAgKiBTY3JlZW4gUmVhZGVyc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjcmVlbi1yZWFkZXJzXG4gICAgICAgKi9cbiAgICAgIHNyOiBbJ3NyLW9ubHknLCAnbm90LXNyLW9ubHknXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9yY2VkIENvbG9yIEFkanVzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvcmNlZC1jb2xvci1hZGp1c3RcbiAgICAgICAqL1xuICAgICAgJ2ZvcmNlZC1jb2xvci1hZGp1c3QnOiBbe1xuICAgICAgICAnZm9yY2VkLWNvbG9yLWFkanVzdCc6IFsnYXV0bycsICdub25lJ11cbiAgICAgIH1dXG4gICAgfSxcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBzOiB7XG4gICAgICBvdmVyZmxvdzogWydvdmVyZmxvdy14JywgJ292ZXJmbG93LXknXSxcbiAgICAgIG92ZXJzY3JvbGw6IFsnb3ZlcnNjcm9sbC14JywgJ292ZXJzY3JvbGwteSddLFxuICAgICAgaW5zZXQ6IFsnaW5zZXQteCcsICdpbnNldC15JywgJ3N0YXJ0JywgJ2VuZCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgICAgICdpbnNldC14JzogWydyaWdodCcsICdsZWZ0J10sXG4gICAgICAnaW5zZXQteSc6IFsndG9wJywgJ2JvdHRvbSddLFxuICAgICAgZmxleDogWydiYXNpcycsICdncm93JywgJ3NocmluayddLFxuICAgICAgZ2FwOiBbJ2dhcC14JywgJ2dhcC15J10sXG4gICAgICBwOiBbJ3B4JywgJ3B5JywgJ3BzJywgJ3BlJywgJ3B0JywgJ3ByJywgJ3BiJywgJ3BsJ10sXG4gICAgICBweDogWydwcicsICdwbCddLFxuICAgICAgcHk6IFsncHQnLCAncGInXSxcbiAgICAgIG06IFsnbXgnLCAnbXknLCAnbXMnLCAnbWUnLCAnbXQnLCAnbXInLCAnbWInLCAnbWwnXSxcbiAgICAgIG14OiBbJ21yJywgJ21sJ10sXG4gICAgICBteTogWydtdCcsICdtYiddLFxuICAgICAgc2l6ZTogWyd3JywgJ2gnXSxcbiAgICAgICdmb250LXNpemUnOiBbJ2xlYWRpbmcnXSxcbiAgICAgICdmdm4tbm9ybWFsJzogWydmdm4tb3JkaW5hbCcsICdmdm4tc2xhc2hlZC16ZXJvJywgJ2Z2bi1maWd1cmUnLCAnZnZuLXNwYWNpbmcnLCAnZnZuLWZyYWN0aW9uJ10sXG4gICAgICAnZnZuLW9yZGluYWwnOiBbJ2Z2bi1ub3JtYWwnXSxcbiAgICAgICdmdm4tc2xhc2hlZC16ZXJvJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAnZnZuLWZpZ3VyZSc6IFsnZnZuLW5vcm1hbCddLFxuICAgICAgJ2Z2bi1zcGFjaW5nJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAnZnZuLWZyYWN0aW9uJzogWydmdm4tbm9ybWFsJ10sXG4gICAgICAnbGluZS1jbGFtcCc6IFsnZGlzcGxheScsICdvdmVyZmxvdyddLFxuICAgICAgcm91bmRlZDogWydyb3VuZGVkLXMnLCAncm91bmRlZC1lJywgJ3JvdW5kZWQtdCcsICdyb3VuZGVkLXInLCAncm91bmRlZC1iJywgJ3JvdW5kZWQtbCcsICdyb3VuZGVkLXNzJywgJ3JvdW5kZWQtc2UnLCAncm91bmRlZC1lZScsICdyb3VuZGVkLWVzJywgJ3JvdW5kZWQtdGwnLCAncm91bmRlZC10cicsICdyb3VuZGVkLWJyJywgJ3JvdW5kZWQtYmwnXSxcbiAgICAgICdyb3VuZGVkLXMnOiBbJ3JvdW5kZWQtc3MnLCAncm91bmRlZC1lcyddLFxuICAgICAgJ3JvdW5kZWQtZSc6IFsncm91bmRlZC1zZScsICdyb3VuZGVkLWVlJ10sXG4gICAgICAncm91bmRlZC10JzogWydyb3VuZGVkLXRsJywgJ3JvdW5kZWQtdHInXSxcbiAgICAgICdyb3VuZGVkLXInOiBbJ3JvdW5kZWQtdHInLCAncm91bmRlZC1iciddLFxuICAgICAgJ3JvdW5kZWQtYic6IFsncm91bmRlZC1icicsICdyb3VuZGVkLWJsJ10sXG4gICAgICAncm91bmRlZC1sJzogWydyb3VuZGVkLXRsJywgJ3JvdW5kZWQtYmwnXSxcbiAgICAgICdib3JkZXItc3BhY2luZyc6IFsnYm9yZGVyLXNwYWNpbmcteCcsICdib3JkZXItc3BhY2luZy15J10sXG4gICAgICAnYm9yZGVyLXcnOiBbJ2JvcmRlci13LXMnLCAnYm9yZGVyLXctZScsICdib3JkZXItdy10JywgJ2JvcmRlci13LXInLCAnYm9yZGVyLXctYicsICdib3JkZXItdy1sJ10sXG4gICAgICAnYm9yZGVyLXcteCc6IFsnYm9yZGVyLXctcicsICdib3JkZXItdy1sJ10sXG4gICAgICAnYm9yZGVyLXcteSc6IFsnYm9yZGVyLXctdCcsICdib3JkZXItdy1iJ10sXG4gICAgICAnYm9yZGVyLWNvbG9yJzogWydib3JkZXItY29sb3ItcycsICdib3JkZXItY29sb3ItZScsICdib3JkZXItY29sb3ItdCcsICdib3JkZXItY29sb3ItcicsICdib3JkZXItY29sb3ItYicsICdib3JkZXItY29sb3ItbCddLFxuICAgICAgJ2JvcmRlci1jb2xvci14JzogWydib3JkZXItY29sb3ItcicsICdib3JkZXItY29sb3ItbCddLFxuICAgICAgJ2JvcmRlci1jb2xvci15JzogWydib3JkZXItY29sb3ItdCcsICdib3JkZXItY29sb3ItYiddLFxuICAgICAgJ3Njcm9sbC1tJzogWydzY3JvbGwtbXgnLCAnc2Nyb2xsLW15JywgJ3Njcm9sbC1tcycsICdzY3JvbGwtbWUnLCAnc2Nyb2xsLW10JywgJ3Njcm9sbC1tcicsICdzY3JvbGwtbWInLCAnc2Nyb2xsLW1sJ10sXG4gICAgICAnc2Nyb2xsLW14JzogWydzY3JvbGwtbXInLCAnc2Nyb2xsLW1sJ10sXG4gICAgICAnc2Nyb2xsLW15JzogWydzY3JvbGwtbXQnLCAnc2Nyb2xsLW1iJ10sXG4gICAgICAnc2Nyb2xsLXAnOiBbJ3Njcm9sbC1weCcsICdzY3JvbGwtcHknLCAnc2Nyb2xsLXBzJywgJ3Njcm9sbC1wZScsICdzY3JvbGwtcHQnLCAnc2Nyb2xsLXByJywgJ3Njcm9sbC1wYicsICdzY3JvbGwtcGwnXSxcbiAgICAgICdzY3JvbGwtcHgnOiBbJ3Njcm9sbC1wcicsICdzY3JvbGwtcGwnXSxcbiAgICAgICdzY3JvbGwtcHknOiBbJ3Njcm9sbC1wdCcsICdzY3JvbGwtcGInXSxcbiAgICAgIHRvdWNoOiBbJ3RvdWNoLXgnLCAndG91Y2gteScsICd0b3VjaC1weiddLFxuICAgICAgJ3RvdWNoLXgnOiBbJ3RvdWNoJ10sXG4gICAgICAndG91Y2gteSc6IFsndG91Y2gnXSxcbiAgICAgICd0b3VjaC1weic6IFsndG91Y2gnXVxuICAgIH0sXG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzOiB7XG4gICAgICAnZm9udC1zaXplJzogWydsZWFkaW5nJ11cbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSBiYXNlQ29uZmlnIENvbmZpZyB3aGVyZSBvdGhlciBjb25maWcgd2lsbCBiZSBtZXJnZWQgaW50by4gVGhpcyBvYmplY3Qgd2lsbCBiZSBtdXRhdGVkLlxuICogQHBhcmFtIGNvbmZpZ0V4dGVuc2lvbiBQYXJ0aWFsIGNvbmZpZyB0byBtZXJnZSBpbnRvIHRoZSBgYmFzZUNvbmZpZ2AuXG4gKi9cbmNvbnN0IG1lcmdlQ29uZmlncyA9IChiYXNlQ29uZmlnLCB7XG4gIGNhY2hlU2l6ZSxcbiAgcHJlZml4LFxuICBzZXBhcmF0b3IsXG4gIGV4cGVyaW1lbnRhbFBhcnNlQ2xhc3NOYW1lLFxuICBleHRlbmQgPSB7fSxcbiAgb3ZlcnJpZGUgPSB7fVxufSkgPT4ge1xuICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdjYWNoZVNpemUnLCBjYWNoZVNpemUpO1xuICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdwcmVmaXgnLCBwcmVmaXgpO1xuICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdzZXBhcmF0b3InLCBzZXBhcmF0b3IpO1xuICBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsICdleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZScsIGV4cGVyaW1lbnRhbFBhcnNlQ2xhc3NOYW1lKTtcbiAgZm9yIChjb25zdCBjb25maWdLZXkgaW4gb3ZlcnJpZGUpIHtcbiAgICBvdmVycmlkZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZ1tjb25maWdLZXldLCBvdmVycmlkZVtjb25maWdLZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBleHRlbmQpIHtcbiAgICBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZ1trZXldLCBleHRlbmRba2V5XSk7XG4gIH1cbiAgcmV0dXJuIGJhc2VDb25maWc7XG59O1xuY29uc3Qgb3ZlcnJpZGVQcm9wZXJ0eSA9IChiYXNlT2JqZWN0LCBvdmVycmlkZUtleSwgb3ZlcnJpZGVWYWx1ZSkgPT4ge1xuICBpZiAob3ZlcnJpZGVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYmFzZU9iamVjdFtvdmVycmlkZUtleV0gPSBvdmVycmlkZVZhbHVlO1xuICB9XG59O1xuY29uc3Qgb3ZlcnJpZGVDb25maWdQcm9wZXJ0aWVzID0gKGJhc2VPYmplY3QsIG92ZXJyaWRlT2JqZWN0KSA9PiB7XG4gIGlmIChvdmVycmlkZU9iamVjdCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlT2JqZWN0KSB7XG4gICAgICBvdmVycmlkZVByb3BlcnR5KGJhc2VPYmplY3QsIGtleSwgb3ZlcnJpZGVPYmplY3Rba2V5XSk7XG4gICAgfVxuICB9XG59O1xuY29uc3QgbWVyZ2VDb25maWdQcm9wZXJ0aWVzID0gKGJhc2VPYmplY3QsIG1lcmdlT2JqZWN0KSA9PiB7XG4gIGlmIChtZXJnZU9iamVjdCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1lcmdlT2JqZWN0KSB7XG4gICAgICBjb25zdCBtZXJnZVZhbHVlID0gbWVyZ2VPYmplY3Rba2V5XTtcbiAgICAgIGlmIChtZXJnZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmFzZU9iamVjdFtrZXldID0gKGJhc2VPYmplY3Rba2V5XSB8fCBbXSkuY29uY2F0KG1lcmdlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmNvbnN0IGV4dGVuZFRhaWx3aW5kTWVyZ2UgPSAoY29uZmlnRXh0ZW5zaW9uLCAuLi5jcmVhdGVDb25maWcpID0+IHR5cGVvZiBjb25maWdFeHRlbnNpb24gPT09ICdmdW5jdGlvbicgPyBjcmVhdGVUYWlsd2luZE1lcmdlKGdldERlZmF1bHRDb25maWcsIGNvbmZpZ0V4dGVuc2lvbiwgLi4uY3JlYXRlQ29uZmlnKSA6IGNyZWF0ZVRhaWx3aW5kTWVyZ2UoKCkgPT4gbWVyZ2VDb25maWdzKGdldERlZmF1bHRDb25maWcoKSwgY29uZmlnRXh0ZW5zaW9uKSwgLi4uY3JlYXRlQ29uZmlnKTtcbmNvbnN0IHR3TWVyZ2UgPSAvKiNfX1BVUkVfXyovY3JlYXRlVGFpbHdpbmRNZXJnZShnZXREZWZhdWx0Q29uZmlnKTtcbmV4cG9ydCB7IGNyZWF0ZVRhaWx3aW5kTWVyZ2UsIGV4dGVuZFRhaWx3aW5kTWVyZ2UsIGZyb21UaGVtZSwgZ2V0RGVmYXVsdENvbmZpZywgbWVyZ2VDb25maWdzLCB0d0pvaW4sIHR3TWVyZ2UsIHZhbGlkYXRvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS1tanMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_esm/utils/unit/formatUnits.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatUnits: function() { return /* binding */ formatUnits; }\n/* harmony export */ });\n/**\n *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..\n *\n * - Docs: https://viem.sh/docs/utilities/formatUnits\n *\n * @example\n * import { formatUnits } from 'viem'\n *\n * formatUnits(420000000000n, 9)\n * // '420'\n */\nfunction formatUnits(value, decimals) {\n    let display = value.toString();\n    const negative = display.startsWith('-');\n    if (negative)\n        display = display.slice(1);\n    display = display.padStart(decimals, '0');\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals),\n    ];\n    fraction = fraction.replace(/(0+)$/, '');\n    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n}\n//# sourceMappingURL=formatUnits.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdW5pdC9mb3JtYXRVbml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CLEVBQUUsZUFBZSxFQUFFLGVBQWUsU0FBUyxPQUFPO0FBQ3BGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy91bml0L2Zvcm1hdFVuaXRzLmpzP2Q0MzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgRGl2aWRlcyBhIG51bWJlciBieSBhIGdpdmVuIGV4cG9uZW50IG9mIGJhc2UgMTAgKDEwZXhwb25lbnQpLCBhbmQgZm9ybWF0cyBpdCBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuLlxuICpcbiAqIC0gRG9jczogaHR0cHM6Ly92aWVtLnNoL2RvY3MvdXRpbGl0aWVzL2Zvcm1hdFVuaXRzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGZvcm1hdFVuaXRzIH0gZnJvbSAndmllbSdcbiAqXG4gKiBmb3JtYXRVbml0cyg0MjAwMDAwMDAwMDBuLCA5KVxuICogLy8gJzQyMCdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGxldCBkaXNwbGF5ID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IGRpc3BsYXkuc3RhcnRzV2l0aCgnLScpO1xuICAgIGlmIChuZWdhdGl2ZSlcbiAgICAgICAgZGlzcGxheSA9IGRpc3BsYXkuc2xpY2UoMSk7XG4gICAgZGlzcGxheSA9IGRpc3BsYXkucGFkU3RhcnQoZGVjaW1hbHMsICcwJyk7XG4gICAgbGV0IFtpbnRlZ2VyLCBmcmFjdGlvbl0gPSBbXG4gICAgICAgIGRpc3BsYXkuc2xpY2UoMCwgZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyksXG4gICAgICAgIGRpc3BsYXkuc2xpY2UoZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyksXG4gICAgXTtcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnJlcGxhY2UoLygwKykkLywgJycpO1xuICAgIHJldHVybiBgJHtuZWdhdGl2ZSA/ICctJyA6ICcnfSR7aW50ZWdlciB8fCAnMCd9JHtmcmFjdGlvbiA/IGAuJHtmcmFjdGlvbn1gIDogJyd9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdFVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/viem/_esm/utils/unit/formatUnits.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/psl/data/rules.json":
/*!******************************************!*\
  !*** ./node_modules/psl/data/rules.json ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('["ac","com.ac","edu.ac","gov.ac","net.ac","mil.ac","org.ac","ad","nom.ad","ae","co.ae","net.ae","org.ae","sch.ae","ac.ae","gov.ae","mil.ae","aero","accident-investigation.aero","accident-prevention.aero","aerobatic.aero","aeroclub.aero","aerodrome.aero","agents.aero","aircraft.aero","airline.aero","airport.aero","air-surveillance.aero","airtraffic.aero","air-traffic-control.aero","ambulance.aero","amusement.aero","association.aero","author.aero","ballooning.aero","broker.aero","caa.aero","cargo.aero","catering.aero","certification.aero","championship.aero","charter.aero","civilaviation.aero","club.aero","conference.aero","consultant.aero","consulting.aero","control.aero","council.aero","crew.aero","design.aero","dgca.aero","educator.aero","emergency.aero","engine.aero","engineer.aero","entertainment.aero","equipment.aero","exchange.aero","express.aero","federation.aero","flight.aero","fuel.aero","gliding.aero","government.aero","groundhandling.aero","group.aero","hanggliding.aero","homebuilt.aero","insurance.aero","journal.aero","journalist.aero","leasing.aero","logistics.aero","magazine.aero","maintenance.aero","media.aero","microlight.aero","modelling.aero","navigation.aero","parachuting.aero","paragliding.aero","passenger-association.aero","pilot.aero","press.aero","production.aero","recreation.aero","repbody.aero","res.aero","research.aero","rotorcraft.aero","safety.aero","scientist.aero","services.aero","show.aero","skydiving.aero","software.aero","student.aero","trader.aero","trading.aero","trainer.aero","union.aero","workinggroup.aero","works.aero","af","gov.af","com.af","org.af","net.af","edu.af","ag","com.ag","org.ag","net.ag","co.ag","nom.ag","ai","off.ai","com.ai","net.ai","org.ai","al","com.al","edu.al","gov.al","mil.al","net.al","org.al","am","co.am","com.am","commune.am","net.am","org.am","ao","ed.ao","gv.ao","og.ao","co.ao","pb.ao","it.ao","aq","ar","bet.ar","com.ar","coop.ar","edu.ar","gob.ar","gov.ar","int.ar","mil.ar","musica.ar","mutual.ar","net.ar","org.ar","senasa.ar","tur.ar","arpa","e164.arpa","in-addr.arpa","ip6.arpa","iris.arpa","uri.arpa","urn.arpa","as","gov.as","asia","at","ac.at","co.at","gv.at","or.at","sth.ac.at","au","com.au","net.au","org.au","edu.au","gov.au","asn.au","id.au","info.au","conf.au","oz.au","act.au","nsw.au","nt.au","qld.au","sa.au","tas.au","vic.au","wa.au","act.edu.au","catholic.edu.au","nsw.edu.au","nt.edu.au","qld.edu.au","sa.edu.au","tas.edu.au","vic.edu.au","wa.edu.au","qld.gov.au","sa.gov.au","tas.gov.au","vic.gov.au","wa.gov.au","schools.nsw.edu.au","aw","com.aw","ax","az","com.az","net.az","int.az","gov.az","org.az","edu.az","info.az","pp.az","mil.az","name.az","pro.az","biz.az","ba","com.ba","edu.ba","gov.ba","mil.ba","net.ba","org.ba","bb","biz.bb","co.bb","com.bb","edu.bb","gov.bb","info.bb","net.bb","org.bb","store.bb","tv.bb","*.bd","be","ac.be","bf","gov.bf","bg","a.bg","b.bg","c.bg","d.bg","e.bg","f.bg","g.bg","h.bg","i.bg","j.bg","k.bg","l.bg","m.bg","n.bg","o.bg","p.bg","q.bg","r.bg","s.bg","t.bg","u.bg","v.bg","w.bg","x.bg","y.bg","z.bg","0.bg","1.bg","2.bg","3.bg","4.bg","5.bg","6.bg","7.bg","8.bg","9.bg","bh","com.bh","edu.bh","net.bh","org.bh","gov.bh","bi","co.bi","com.bi","edu.bi","or.bi","org.bi","biz","bj","asso.bj","barreau.bj","gouv.bj","bm","com.bm","edu.bm","gov.bm","net.bm","org.bm","bn","com.bn","edu.bn","gov.bn","net.bn","org.bn","bo","com.bo","edu.bo","gob.bo","int.bo","org.bo","net.bo","mil.bo","tv.bo","web.bo","academia.bo","agro.bo","arte.bo","blog.bo","bolivia.bo","ciencia.bo","cooperativa.bo","democracia.bo","deporte.bo","ecologia.bo","economia.bo","empresa.bo","indigena.bo","industria.bo","info.bo","medicina.bo","movimiento.bo","musica.bo","natural.bo","nombre.bo","noticias.bo","patria.bo","politica.bo","profesional.bo","plurinacional.bo","pueblo.bo","revista.bo","salud.bo","tecnologia.bo","tksat.bo","transporte.bo","wiki.bo","br","9guacu.br","abc.br","adm.br","adv.br","agr.br","aju.br","am.br","anani.br","aparecida.br","app.br","arq.br","art.br","ato.br","b.br","barueri.br","belem.br","bhz.br","bib.br","bio.br","blog.br","bmd.br","boavista.br","bsb.br","campinagrande.br","campinas.br","caxias.br","cim.br","cng.br","cnt.br","com.br","contagem.br","coop.br","coz.br","cri.br","cuiaba.br","curitiba.br","def.br","des.br","det.br","dev.br","ecn.br","eco.br","edu.br","emp.br","enf.br","eng.br","esp.br","etc.br","eti.br","far.br","feira.br","flog.br","floripa.br","fm.br","fnd.br","fortal.br","fot.br","foz.br","fst.br","g12.br","geo.br","ggf.br","goiania.br","gov.br","ac.gov.br","al.gov.br","am.gov.br","ap.gov.br","ba.gov.br","ce.gov.br","df.gov.br","es.gov.br","go.gov.br","ma.gov.br","mg.gov.br","ms.gov.br","mt.gov.br","pa.gov.br","pb.gov.br","pe.gov.br","pi.gov.br","pr.gov.br","rj.gov.br","rn.gov.br","ro.gov.br","rr.gov.br","rs.gov.br","sc.gov.br","se.gov.br","sp.gov.br","to.gov.br","gru.br","imb.br","ind.br","inf.br","jab.br","jampa.br","jdf.br","joinville.br","jor.br","jus.br","leg.br","lel.br","log.br","londrina.br","macapa.br","maceio.br","manaus.br","maringa.br","mat.br","med.br","mil.br","morena.br","mp.br","mus.br","natal.br","net.br","niteroi.br","*.nom.br","not.br","ntr.br","odo.br","ong.br","org.br","osasco.br","palmas.br","poa.br","ppg.br","pro.br","psc.br","psi.br","pvh.br","qsl.br","radio.br","rec.br","recife.br","rep.br","ribeirao.br","rio.br","riobranco.br","riopreto.br","salvador.br","sampa.br","santamaria.br","santoandre.br","saobernardo.br","saogonca.br","seg.br","sjc.br","slg.br","slz.br","sorocaba.br","srv.br","taxi.br","tc.br","tec.br","teo.br","the.br","tmp.br","trd.br","tur.br","tv.br","udi.br","vet.br","vix.br","vlog.br","wiki.br","zlg.br","bs","com.bs","net.bs","org.bs","edu.bs","gov.bs","bt","com.bt","edu.bt","gov.bt","net.bt","org.bt","bv","bw","co.bw","org.bw","by","gov.by","mil.by","com.by","of.by","bz","com.bz","net.bz","org.bz","edu.bz","gov.bz","ca","ab.ca","bc.ca","mb.ca","nb.ca","nf.ca","nl.ca","ns.ca","nt.ca","nu.ca","on.ca","pe.ca","qc.ca","sk.ca","yk.ca","gc.ca","cat","cc","cd","gov.cd","cf","cg","ch","ci","org.ci","or.ci","com.ci","co.ci","edu.ci","ed.ci","ac.ci","net.ci","go.ci","asso.ci","aéroport.ci","int.ci","presse.ci","md.ci","gouv.ci","*.ck","!www.ck","cl","co.cl","gob.cl","gov.cl","mil.cl","cm","co.cm","com.cm","gov.cm","net.cm","cn","ac.cn","com.cn","edu.cn","gov.cn","net.cn","org.cn","mil.cn","公司.cn","网络.cn","網絡.cn","ah.cn","bj.cn","cq.cn","fj.cn","gd.cn","gs.cn","gz.cn","gx.cn","ha.cn","hb.cn","he.cn","hi.cn","hl.cn","hn.cn","jl.cn","js.cn","jx.cn","ln.cn","nm.cn","nx.cn","qh.cn","sc.cn","sd.cn","sh.cn","sn.cn","sx.cn","tj.cn","xj.cn","xz.cn","yn.cn","zj.cn","hk.cn","mo.cn","tw.cn","co","arts.co","com.co","edu.co","firm.co","gov.co","info.co","int.co","mil.co","net.co","nom.co","org.co","rec.co","web.co","com","coop","cr","ac.cr","co.cr","ed.cr","fi.cr","go.cr","or.cr","sa.cr","cu","com.cu","edu.cu","org.cu","net.cu","gov.cu","inf.cu","cv","com.cv","edu.cv","int.cv","nome.cv","org.cv","cw","com.cw","edu.cw","net.cw","org.cw","cx","gov.cx","cy","ac.cy","biz.cy","com.cy","ekloges.cy","gov.cy","ltd.cy","mil.cy","net.cy","org.cy","press.cy","pro.cy","tm.cy","cz","de","dj","dk","dm","com.dm","net.dm","org.dm","edu.dm","gov.dm","do","art.do","com.do","edu.do","gob.do","gov.do","mil.do","net.do","org.do","sld.do","web.do","dz","art.dz","asso.dz","com.dz","edu.dz","gov.dz","org.dz","net.dz","pol.dz","soc.dz","tm.dz","ec","com.ec","info.ec","net.ec","fin.ec","k12.ec","med.ec","pro.ec","org.ec","edu.ec","gov.ec","gob.ec","mil.ec","edu","ee","edu.ee","gov.ee","riik.ee","lib.ee","med.ee","com.ee","pri.ee","aip.ee","org.ee","fie.ee","eg","com.eg","edu.eg","eun.eg","gov.eg","mil.eg","name.eg","net.eg","org.eg","sci.eg","*.er","es","com.es","nom.es","org.es","gob.es","edu.es","et","com.et","gov.et","org.et","edu.et","biz.et","name.et","info.et","net.et","eu","fi","aland.fi","fj","ac.fj","biz.fj","com.fj","gov.fj","info.fj","mil.fj","name.fj","net.fj","org.fj","pro.fj","*.fk","com.fm","edu.fm","net.fm","org.fm","fm","fo","fr","asso.fr","com.fr","gouv.fr","nom.fr","prd.fr","tm.fr","aeroport.fr","avocat.fr","avoues.fr","cci.fr","chambagri.fr","chirurgiens-dentistes.fr","experts-comptables.fr","geometre-expert.fr","greta.fr","huissier-justice.fr","medecin.fr","notaires.fr","pharmacien.fr","port.fr","veterinaire.fr","ga","gb","edu.gd","gov.gd","gd","ge","com.ge","edu.ge","gov.ge","org.ge","mil.ge","net.ge","pvt.ge","gf","gg","co.gg","net.gg","org.gg","gh","com.gh","edu.gh","gov.gh","org.gh","mil.gh","gi","com.gi","ltd.gi","gov.gi","mod.gi","edu.gi","org.gi","gl","co.gl","com.gl","edu.gl","net.gl","org.gl","gm","gn","ac.gn","com.gn","edu.gn","gov.gn","org.gn","net.gn","gov","gp","com.gp","net.gp","mobi.gp","edu.gp","org.gp","asso.gp","gq","gr","com.gr","edu.gr","net.gr","org.gr","gov.gr","gs","gt","com.gt","edu.gt","gob.gt","ind.gt","mil.gt","net.gt","org.gt","gu","com.gu","edu.gu","gov.gu","guam.gu","info.gu","net.gu","org.gu","web.gu","gw","gy","co.gy","com.gy","edu.gy","gov.gy","net.gy","org.gy","hk","com.hk","edu.hk","gov.hk","idv.hk","net.hk","org.hk","公司.hk","教育.hk","敎育.hk","政府.hk","個人.hk","个��.hk","箇人.hk","網络.hk","网络.hk","组織.hk","網絡.hk","网絡.hk","组织.hk","組織.hk","組织.hk","hm","hn","com.hn","edu.hn","org.hn","net.hn","mil.hn","gob.hn","hr","iz.hr","from.hr","name.hr","com.hr","ht","com.ht","shop.ht","firm.ht","info.ht","adult.ht","net.ht","pro.ht","org.ht","med.ht","art.ht","coop.ht","pol.ht","asso.ht","edu.ht","rel.ht","gouv.ht","perso.ht","hu","co.hu","info.hu","org.hu","priv.hu","sport.hu","tm.hu","2000.hu","agrar.hu","bolt.hu","casino.hu","city.hu","erotica.hu","erotika.hu","film.hu","forum.hu","games.hu","hotel.hu","ingatlan.hu","jogasz.hu","konyvelo.hu","lakas.hu","media.hu","news.hu","reklam.hu","sex.hu","shop.hu","suli.hu","szex.hu","tozsde.hu","utazas.hu","video.hu","id","ac.id","biz.id","co.id","desa.id","go.id","mil.id","my.id","net.id","or.id","ponpes.id","sch.id","web.id","ie","gov.ie","il","ac.il","co.il","gov.il","idf.il","k12.il","muni.il","net.il","org.il","im","ac.im","co.im","com.im","ltd.co.im","net.im","org.im","plc.co.im","tt.im","tv.im","in","co.in","firm.in","net.in","org.in","gen.in","ind.in","nic.in","ac.in","edu.in","res.in","gov.in","mil.in","info","int","eu.int","io","com.io","iq","gov.iq","edu.iq","mil.iq","com.iq","org.iq","net.iq","ir","ac.ir","co.ir","gov.ir","id.ir","net.ir","org.ir","sch.ir","ایران.ir","ايران.ir","is","net.is","com.is","edu.is","gov.is","org.is","int.is","it","gov.it","edu.it","abr.it","abruzzo.it","aosta-valley.it","aostavalley.it","bas.it","basilicata.it","cal.it","calabria.it","cam.it","campania.it","emilia-romagna.it","emiliaromagna.it","emr.it","friuli-v-giulia.it","friuli-ve-giulia.it","friuli-vegiulia.it","friuli-venezia-giulia.it","friuli-veneziagiulia.it","friuli-vgiulia.it","friuliv-giulia.it","friulive-giulia.it","friulivegiulia.it","friulivenezia-giulia.it","friuliveneziagiulia.it","friulivgiulia.it","fvg.it","laz.it","lazio.it","lig.it","liguria.it","lom.it","lombardia.it","lombardy.it","lucania.it","mar.it","marche.it","mol.it","molise.it","piedmont.it","piemonte.it","pmn.it","pug.it","puglia.it","sar.it","sardegna.it","sardinia.it","sic.it","sicilia.it","sicily.it","taa.it","tos.it","toscana.it","trentin-sud-tirol.it","trentin-süd-tirol.it","trentin-sudtirol.it","trentin-südtirol.it","trentin-sued-tirol.it","trentin-suedtirol.it","trentino-a-adige.it","trentino-aadige.it","trentino-alto-adige.it","trentino-altoadige.it","trentino-s-tirol.it","trentino-stirol.it","trentino-sud-tirol.it","trentino-süd-tirol.it","trentino-sudtirol.it","trentino-südtirol.it","trentino-sued-tirol.it","trentino-suedtirol.it","trentino.it","trentinoa-adige.it","trentinoaadige.it","trentinoalto-adige.it","trentinoaltoadige.it","trentinos-tirol.it","trentinostirol.it","trentinosud-tirol.it","trentinosüd-tirol.it","trentinosudtirol.it","trentinosüdtirol.it","trentinosued-tirol.it","trentinosuedtirol.it","trentinsud-tirol.it","trentinsüd-tirol.it","trentinsudtirol.it","trentinsüdtirol.it","trentinsued-tirol.it","trentinsuedtirol.it","tuscany.it","umb.it","umbria.it","val-d-aosta.it","val-daosta.it","vald-aosta.it","valdaosta.it","valle-aosta.it","valle-d-aosta.it","valle-daosta.it","valleaosta.it","valled-aosta.it","valledaosta.it","vallee-aoste.it","vallée-aoste.it","vallee-d-aoste.it","vallée-d-aoste.it","valleeaoste.it","valléeaoste.it","valleedaoste.it","valléedaoste.it","vao.it","vda.it","ven.it","veneto.it","ag.it","agrigento.it","al.it","alessandria.it","alto-adige.it","altoadige.it","an.it","ancona.it","andria-barletta-trani.it","andria-trani-barletta.it","andriabarlettatrani.it","andriatranibarletta.it","ao.it","aosta.it","aoste.it","ap.it","aq.it","aquila.it","ar.it","arezzo.it","ascoli-piceno.it","ascolipiceno.it","asti.it","at.it","av.it","avellino.it","ba.it","balsan-sudtirol.it","balsan-südtirol.it","balsan-suedtirol.it","balsan.it","bari.it","barletta-trani-andria.it","barlettatraniandria.it","belluno.it","benevento.it","bergamo.it","bg.it","bi.it","biella.it","bl.it","bn.it","bo.it","bologna.it","bolzano-altoadige.it","bolzano.it","bozen-sudtirol.it","bozen-südtirol.it","bozen-suedtirol.it","bozen.it","br.it","brescia.it","brindisi.it","bs.it","bt.it","bulsan-sudtirol.it","bulsan-südtirol.it","bulsan-suedtirol.it","bulsan.it","bz.it","ca.it","cagliari.it","caltanissetta.it","campidano-medio.it","campidanomedio.it","campobasso.it","carbonia-iglesias.it","carboniaiglesias.it","carrara-massa.it","carraramassa.it","caserta.it","catania.it","catanzaro.it","cb.it","ce.it","cesena-forli.it","cesena-forlì.it","cesenaforli.it","cesenaforlì.it","ch.it","chieti.it","ci.it","cl.it","cn.it","co.it","como.it","cosenza.it","cr.it","cremona.it","crotone.it","cs.it","ct.it","cuneo.it","cz.it","dell-ogliastra.it","dellogliastra.it","en.it","enna.it","fc.it","fe.it","fermo.it","ferrara.it","fg.it","fi.it","firenze.it","florence.it","fm.it","foggia.it","forli-cesena.it","forlì-cesena.it","forlicesena.it","forlìcesena.it","fr.it","frosinone.it","ge.it","genoa.it","genova.it","go.it","gorizia.it","gr.it","grosseto.it","iglesias-carbonia.it","iglesiascarbonia.it","im.it","imperia.it","is.it","isernia.it","kr.it","la-spezia.it","laquila.it","laspezia.it","latina.it","lc.it","le.it","lecce.it","lecco.it","li.it","livorno.it","lo.it","lodi.it","lt.it","lu.it","lucca.it","macerata.it","mantova.it","massa-carrara.it","massacarrara.it","matera.it","mb.it","mc.it","me.it","medio-campidano.it","mediocampidano.it","messina.it","mi.it","milan.it","milano.it","mn.it","mo.it","modena.it","monza-brianza.it","monza-e-della-brianza.it","monza.it","monzabrianza.it","monzaebrianza.it","monzaedellabrianza.it","ms.it","mt.it","na.it","naples.it","napoli.it","no.it","novara.it","nu.it","nuoro.it","og.it","ogliastra.it","olbia-tempio.it","olbiatempio.it","or.it","oristano.it","ot.it","pa.it","padova.it","padua.it","palermo.it","parma.it","pavia.it","pc.it","pd.it","pe.it","perugia.it","pesaro-urbino.it","pesarourbino.it","pescara.it","pg.it","pi.it","piacenza.it","pisa.it","pistoia.it","pn.it","po.it","pordenone.it","potenza.it","pr.it","prato.it","pt.it","pu.it","pv.it","pz.it","ra.it","ragusa.it","ravenna.it","rc.it","re.it","reggio-calabria.it","reggio-emilia.it","reggiocalabria.it","reggioemilia.it","rg.it","ri.it","rieti.it","rimini.it","rm.it","rn.it","ro.it","roma.it","rome.it","rovigo.it","sa.it","salerno.it","sassari.it","savona.it","si.it","siena.it","siracusa.it","so.it","sondrio.it","sp.it","sr.it","ss.it","suedtirol.it","südtirol.it","sv.it","ta.it","taranto.it","te.it","tempio-olbia.it","tempioolbia.it","teramo.it","terni.it","tn.it","to.it","torino.it","tp.it","tr.it","trani-andria-barletta.it","trani-barletta-andria.it","traniandriabarletta.it","tranibarlettaandria.it","trapani.it","trento.it","treviso.it","trieste.it","ts.it","turin.it","tv.it","ud.it","udine.it","urbino-pesaro.it","urbinopesaro.it","va.it","varese.it","vb.it","vc.it","ve.it","venezia.it","venice.it","verbania.it","vercelli.it","verona.it","vi.it","vibo-valentia.it","vibovalentia.it","vicenza.it","viterbo.it","vr.it","vs.it","vt.it","vv.it","je","co.je","net.je","org.je","*.jm","jo","com.jo","org.jo","net.jo","edu.jo","sch.jo","gov.jo","mil.jo","name.jo","jobs","jp","ac.jp","ad.jp","co.jp","ed.jp","go.jp","gr.jp","lg.jp","ne.jp","or.jp","aichi.jp","akita.jp","aomori.jp","chiba.jp","ehime.jp","fukui.jp","fukuoka.jp","fukushima.jp","gifu.jp","gunma.jp","hiroshima.jp","hokkaido.jp","hyogo.jp","ibaraki.jp","ishikawa.jp","iwate.jp","kagawa.jp","kagoshima.jp","kanagawa.jp","kochi.jp","kumamoto.jp","kyoto.jp","mie.jp","miyagi.jp","miyazaki.jp","nagano.jp","nagasaki.jp","nara.jp","niigata.jp","oita.jp","okayama.jp","okinawa.jp","osaka.jp","saga.jp","saitama.jp","shiga.jp","shimane.jp","shizuoka.jp","tochigi.jp","tokushima.jp","tokyo.jp","tottori.jp","toyama.jp","wakayama.jp","yamagata.jp","yamaguchi.jp","yamanashi.jp","栃木.jp","愛知.jp","愛媛.jp","兵庫.jp","熊本.jp","茨城.jp","北海道.jp","千葉.jp","和歌山.jp","長崎.jp","長野.jp","新潟.jp","青森.jp","静岡.jp","東京.jp","石川.jp","埼玉.jp","三重.jp","京都.jp","佐賀.jp","大分.jp","大阪.jp","奈良.jp","宮城.jp","宮崎.jp","富山.jp","山口.jp","山形.jp","山梨.jp","岩手.jp","岐阜.jp","岡山.jp","島根.jp","広島.jp","徳島.jp","沖縄.jp","滋賀.jp","神奈川.jp","福井.jp","福岡.jp","福島.jp","秋田.jp","群馬.jp","香川.jp","高知.jp","鳥取.jp","鹿児島.jp","*.kawasaki.jp","*.kitakyushu.jp","*.kobe.jp","*.nagoya.jp","*.sapporo.jp","*.sendai.jp","*.yokohama.jp","!city.kawasaki.jp","!city.kitakyushu.jp","!city.kobe.jp","!city.nagoya.jp","!city.sapporo.jp","!city.sendai.jp","!city.yokohama.jp","aisai.aichi.jp","ama.aichi.jp","anjo.aichi.jp","asuke.aichi.jp","chiryu.aichi.jp","chita.aichi.jp","fuso.aichi.jp","gamagori.aichi.jp","handa.aichi.jp","hazu.aichi.jp","hekinan.aichi.jp","higashiura.aichi.jp","ichinomiya.aichi.jp","inazawa.aichi.jp","inuyama.aichi.jp","isshiki.aichi.jp","iwakura.aichi.jp","kanie.aichi.jp","kariya.aichi.jp","kasugai.aichi.jp","kira.aichi.jp","kiyosu.aichi.jp","komaki.aichi.jp","konan.aichi.jp","kota.aichi.jp","mihama.aichi.jp","miyoshi.aichi.jp","nishio.aichi.jp","nisshin.aichi.jp","obu.aichi.jp","oguchi.aichi.jp","oharu.aichi.jp","okazaki.aichi.jp","owariasahi.aichi.jp","seto.aichi.jp","shikatsu.aichi.jp","shinshiro.aichi.jp","shitara.aichi.jp","tahara.aichi.jp","takahama.aichi.jp","tobishima.aichi.jp","toei.aichi.jp","togo.aichi.jp","tokai.aichi.jp","tokoname.aichi.jp","toyoake.aichi.jp","toyohashi.aichi.jp","toyokawa.aichi.jp","toyone.aichi.jp","toyota.aichi.jp","tsushima.aichi.jp","yatomi.aichi.jp","akita.akita.jp","daisen.akita.jp","fujisato.akita.jp","gojome.akita.jp","hachirogata.akita.jp","happou.akita.jp","higashinaruse.akita.jp","honjo.akita.jp","honjyo.akita.jp","ikawa.akita.jp","kamikoani.akita.jp","kamioka.akita.jp","katagami.akita.jp","kazuno.akita.jp","kitaakita.akita.jp","kosaka.akita.jp","kyowa.akita.jp","misato.akita.jp","mitane.akita.jp","moriyoshi.akita.jp","nikaho.akita.jp","noshiro.akita.jp","odate.akita.jp","oga.akita.jp","ogata.akita.jp","semboku.akita.jp","yokote.akita.jp","yurihonjo.akita.jp","aomori.aomori.jp","gonohe.aomori.jp","hachinohe.aomori.jp","hashikami.aomori.jp","hiranai.aomori.jp","hirosaki.aomori.jp","itayanagi.aomori.jp","kuroishi.aomori.jp","misawa.aomori.jp","mutsu.aomori.jp","nakadomari.aomori.jp","noheji.aomori.jp","oirase.aomori.jp","owani.aomori.jp","rokunohe.aomori.jp","sannohe.aomori.jp","shichinohe.aomori.jp","shingo.aomori.jp","takko.aomori.jp","towada.aomori.jp","tsugaru.aomori.jp","tsuruta.aomori.jp","abiko.chiba.jp","asahi.chiba.jp","chonan.chiba.jp","chosei.chiba.jp","choshi.chiba.jp","chuo.chiba.jp","funabashi.chiba.jp","futtsu.chiba.jp","hanamigawa.chiba.jp","ichihara.chiba.jp","ichikawa.chiba.jp","ichinomiya.chiba.jp","inzai.chiba.jp","isumi.chiba.jp","kamagaya.chiba.jp","kamogawa.chiba.jp","kashiwa.chiba.jp","katori.chiba.jp","katsuura.chiba.jp","kimitsu.chiba.jp","kisarazu.chiba.jp","kozaki.chiba.jp","kujukuri.chiba.jp","kyonan.chiba.jp","matsudo.chiba.jp","midori.chiba.jp","mihama.chiba.jp","minamiboso.chiba.jp","mobara.chiba.jp","mutsuzawa.chiba.jp","nagara.chiba.jp","nagareyama.chiba.jp","narashino.chiba.jp","narita.chiba.jp","noda.chiba.jp","oamishirasato.chiba.jp","omigawa.chiba.jp","onjuku.chiba.jp","otaki.chiba.jp","sakae.chiba.jp","sakura.chiba.jp","shimofusa.chiba.jp","shirako.chiba.jp","shiroi.chiba.jp","shisui.chiba.jp","sodegaura.chiba.jp","sosa.chiba.jp","tako.chiba.jp","tateyama.chiba.jp","togane.chiba.jp","tohnosho.chiba.jp","tomisato.chiba.jp","urayasu.chiba.jp","yachimata.chiba.jp","yachiyo.chiba.jp","yokaichiba.chiba.jp","yokoshibahikari.chiba.jp","yotsukaido.chiba.jp","ainan.ehime.jp","honai.ehime.jp","ikata.ehime.jp","imabari.ehime.jp","iyo.ehime.jp","kamijima.ehime.jp","kihoku.ehime.jp","kumakogen.ehime.jp","masaki.ehime.jp","matsuno.ehime.jp","matsuyama.ehime.jp","namikata.ehime.jp","niihama.ehime.jp","ozu.ehime.jp","saijo.ehime.jp","seiyo.ehime.jp","shikokuchuo.ehime.jp","tobe.ehime.jp","toon.ehime.jp","uchiko.ehime.jp","uwajima.ehime.jp","yawatahama.ehime.jp","echizen.fukui.jp","eiheiji.fukui.jp","fukui.fukui.jp","ikeda.fukui.jp","katsuyama.fukui.jp","mihama.fukui.jp","minamiechizen.fukui.jp","obama.fukui.jp","ohi.fukui.jp","ono.fukui.jp","sabae.fukui.jp","sakai.fukui.jp","takahama.fukui.jp","tsuruga.fukui.jp","wakasa.fukui.jp","ashiya.fukuoka.jp","buzen.fukuoka.jp","chikugo.fukuoka.jp","chikuho.fukuoka.jp","chikujo.fukuoka.jp","chikushino.fukuoka.jp","chikuzen.fukuoka.jp","chuo.fukuoka.jp","dazaifu.fukuoka.jp","fukuchi.fukuoka.jp","hakata.fukuoka.jp","higashi.fukuoka.jp","hirokawa.fukuoka.jp","hisayama.fukuoka.jp","iizuka.fukuoka.jp","inatsuki.fukuoka.jp","kaho.fukuoka.jp","kasuga.fukuoka.jp","kasuya.fukuoka.jp","kawara.fukuoka.jp","keisen.fukuoka.jp","koga.fukuoka.jp","kurate.fukuoka.jp","kurogi.fukuoka.jp","kurume.fukuoka.jp","minami.fukuoka.jp","miyako.fukuoka.jp","miyama.fukuoka.jp","miyawaka.fukuoka.jp","mizumaki.fukuoka.jp","munakata.fukuoka.jp","nakagawa.fukuoka.jp","nakama.fukuoka.jp","nishi.fukuoka.jp","nogata.fukuoka.jp","ogori.fukuoka.jp","okagaki.fukuoka.jp","okawa.fukuoka.jp","oki.fukuoka.jp","omuta.fukuoka.jp","onga.fukuoka.jp","onojo.fukuoka.jp","oto.fukuoka.jp","saigawa.fukuoka.jp","sasaguri.fukuoka.jp","shingu.fukuoka.jp","shinyoshitomi.fukuoka.jp","shonai.fukuoka.jp","soeda.fukuoka.jp","sue.fukuoka.jp","tachiarai.fukuoka.jp","tagawa.fukuoka.jp","takata.fukuoka.jp","toho.fukuoka.jp","toyotsu.fukuoka.jp","tsuiki.fukuoka.jp","ukiha.fukuoka.jp","umi.fukuoka.jp","usui.fukuoka.jp","yamada.fukuoka.jp","yame.fukuoka.jp","yanagawa.fukuoka.jp","yukuhashi.fukuoka.jp","aizubange.fukushima.jp","aizumisato.fukushima.jp","aizuwakamatsu.fukushima.jp","asakawa.fukushima.jp","bandai.fukushima.jp","date.fukushima.jp","fukushima.fukushima.jp","furudono.fukushima.jp","futaba.fukushima.jp","hanawa.fukushima.jp","higashi.fukushima.jp","hirata.fukushima.jp","hirono.fukushima.jp","iitate.fukushima.jp","inawashiro.fukushima.jp","ishikawa.fukushima.jp","iwaki.fukushima.jp","izumizaki.fukushima.jp","kagamiishi.fukushima.jp","kaneyama.fukushima.jp","kawamata.fukushima.jp","kitakata.fukushima.jp","kitashiobara.fukushima.jp","koori.fukushima.jp","koriyama.fukushima.jp","kunimi.fukushima.jp","miharu.fukushima.jp","mishima.fukushima.jp","namie.fukushima.jp","nango.fukushima.jp","nishiaizu.fukushima.jp","nishigo.fukushima.jp","okuma.fukushima.jp","omotego.fukushima.jp","ono.fukushima.jp","otama.fukushima.jp","samegawa.fukushima.jp","shimogo.fukushima.jp","shirakawa.fukushima.jp","showa.fukushima.jp","soma.fukushima.jp","sukagawa.fukushima.jp","taishin.fukushima.jp","tamakawa.fukushima.jp","tanagura.fukushima.jp","tenei.fukushima.jp","yabuki.fukushima.jp","yamato.fukushima.jp","yamatsuri.fukushima.jp","yanaizu.fukushima.jp","yugawa.fukushima.jp","anpachi.gifu.jp","ena.gifu.jp","gifu.gifu.jp","ginan.gifu.jp","godo.gifu.jp","gujo.gifu.jp","hashima.gifu.jp","hichiso.gifu.jp","hida.gifu.jp","higashishirakawa.gifu.jp","ibigawa.gifu.jp","ikeda.gifu.jp","kakamigahara.gifu.jp","kani.gifu.jp","kasahara.gifu.jp","kasamatsu.gifu.jp","kawaue.gifu.jp","kitagata.gifu.jp","mino.gifu.jp","minokamo.gifu.jp","mitake.gifu.jp","mizunami.gifu.jp","motosu.gifu.jp","nakatsugawa.gifu.jp","ogaki.gifu.jp","sakahogi.gifu.jp","seki.gifu.jp","sekigahara.gifu.jp","shirakawa.gifu.jp","tajimi.gifu.jp","takayama.gifu.jp","tarui.gifu.jp","toki.gifu.jp","tomika.gifu.jp","wanouchi.gifu.jp","yamagata.gifu.jp","yaotsu.gifu.jp","yoro.gifu.jp","annaka.gunma.jp","chiyoda.gunma.jp","fujioka.gunma.jp","higashiagatsuma.gunma.jp","isesaki.gunma.jp","itakura.gunma.jp","kanna.gunma.jp","kanra.gunma.jp","katashina.gunma.jp","kawaba.gunma.jp","kiryu.gunma.jp","kusatsu.gunma.jp","maebashi.gunma.jp","meiwa.gunma.jp","midori.gunma.jp","minakami.gunma.jp","naganohara.gunma.jp","nakanojo.gunma.jp","nanmoku.gunma.jp","numata.gunma.jp","oizumi.gunma.jp","ora.gunma.jp","ota.gunma.jp","shibukawa.gunma.jp","shimonita.gunma.jp","shinto.gunma.jp","showa.gunma.jp","takasaki.gunma.jp","takayama.gunma.jp","tamamura.gunma.jp","tatebayashi.gunma.jp","tomioka.gunma.jp","tsukiyono.gunma.jp","tsumagoi.gunma.jp","ueno.gunma.jp","yoshioka.gunma.jp","asaminami.hiroshima.jp","daiwa.hiroshima.jp","etajima.hiroshima.jp","fuchu.hiroshima.jp","fukuyama.hiroshima.jp","hatsukaichi.hiroshima.jp","higashihiroshima.hiroshima.jp","hongo.hiroshima.jp","jinsekikogen.hiroshima.jp","kaita.hiroshima.jp","kui.hiroshima.jp","kumano.hiroshima.jp","kure.hiroshima.jp","mihara.hiroshima.jp","miyoshi.hiroshima.jp","naka.hiroshima.jp","onomichi.hiroshima.jp","osakikamijima.hiroshima.jp","otake.hiroshima.jp","saka.hiroshima.jp","sera.hiroshima.jp","seranishi.hiroshima.jp","shinichi.hiroshima.jp","shobara.hiroshima.jp","takehara.hiroshima.jp","abashiri.hokkaido.jp","abira.hokkaido.jp","aibetsu.hokkaido.jp","akabira.hokkaido.jp","akkeshi.hokkaido.jp","asahikawa.hokkaido.jp","ashibetsu.hokkaido.jp","ashoro.hokkaido.jp","assabu.hokkaido.jp","atsuma.hokkaido.jp","bibai.hokkaido.jp","biei.hokkaido.jp","bifuka.hokkaido.jp","bihoro.hokkaido.jp","biratori.hokkaido.jp","chippubetsu.hokkaido.jp","chitose.hokkaido.jp","date.hokkaido.jp","ebetsu.hokkaido.jp","embetsu.hokkaido.jp","eniwa.hokkaido.jp","erimo.hokkaido.jp","esan.hokkaido.jp","esashi.hokkaido.jp","fukagawa.hokkaido.jp","fukushima.hokkaido.jp","furano.hokkaido.jp","furubira.hokkaido.jp","haboro.hokkaido.jp","hakodate.hokkaido.jp","hamatonbetsu.hokkaido.jp","hidaka.hokkaido.jp","higashikagura.hokkaido.jp","higashikawa.hokkaido.jp","hiroo.hokkaido.jp","hokuryu.hokkaido.jp","hokuto.hokkaido.jp","honbetsu.hokkaido.jp","horokanai.hokkaido.jp","horonobe.hokkaido.jp","ikeda.hokkaido.jp","imakane.hokkaido.jp","ishikari.hokkaido.jp","iwamizawa.hokkaido.jp","iwanai.hokkaido.jp","kamifurano.hokkaido.jp","kamikawa.hokkaido.jp","kamishihoro.hokkaido.jp","kamisunagawa.hokkaido.jp","kamoenai.hokkaido.jp","kayabe.hokkaido.jp","kembuchi.hokkaido.jp","kikonai.hokkaido.jp","kimobetsu.hokkaido.jp","kitahiroshima.hokkaido.jp","kitami.hokkaido.jp","kiyosato.hokkaido.jp","koshimizu.hokkaido.jp","kunneppu.hokkaido.jp","kuriyama.hokkaido.jp","kuromatsunai.hokkaido.jp","kushiro.hokkaido.jp","kutchan.hokkaido.jp","kyowa.hokkaido.jp","mashike.hokkaido.jp","matsumae.hokkaido.jp","mikasa.hokkaido.jp","minamifurano.hokkaido.jp","mombetsu.hokkaido.jp","moseushi.hokkaido.jp","mukawa.hokkaido.jp","muroran.hokkaido.jp","naie.hokkaido.jp","nakagawa.hokkaido.jp","nakasatsunai.hokkaido.jp","nakatombetsu.hokkaido.jp","nanae.hokkaido.jp","nanporo.hokkaido.jp","nayoro.hokkaido.jp","nemuro.hokkaido.jp","niikappu.hokkaido.jp","niki.hokkaido.jp","nishiokoppe.hokkaido.jp","noboribetsu.hokkaido.jp","numata.hokkaido.jp","obihiro.hokkaido.jp","obira.hokkaido.jp","oketo.hokkaido.jp","okoppe.hokkaido.jp","otaru.hokkaido.jp","otobe.hokkaido.jp","otofuke.hokkaido.jp","otoineppu.hokkaido.jp","oumu.hokkaido.jp","ozora.hokkaido.jp","pippu.hokkaido.jp","rankoshi.hokkaido.jp","rebun.hokkaido.jp","rikubetsu.hokkaido.jp","rishiri.hokkaido.jp","rishirifuji.hokkaido.jp","saroma.hokkaido.jp","sarufutsu.hokkaido.jp","shakotan.hokkaido.jp","shari.hokkaido.jp","shibecha.hokkaido.jp","shibetsu.hokkaido.jp","shikabe.hokkaido.jp","shikaoi.hokkaido.jp","shimamaki.hokkaido.jp","shimizu.hokkaido.jp","shimokawa.hokkaido.jp","shinshinotsu.hokkaido.jp","shintoku.hokkaido.jp","shiranuka.hokkaido.jp","shiraoi.hokkaido.jp","shiriuchi.hokkaido.jp","sobetsu.hokkaido.jp","sunagawa.hokkaido.jp","taiki.hokkaido.jp","takasu.hokkaido.jp","takikawa.hokkaido.jp","takinoue.hokkaido.jp","teshikaga.hokkaido.jp","tobetsu.hokkaido.jp","tohma.hokkaido.jp","tomakomai.hokkaido.jp","tomari.hokkaido.jp","toya.hokkaido.jp","toyako.hokkaido.jp","toyotomi.hokkaido.jp","toyoura.hokkaido.jp","tsubetsu.hokkaido.jp","tsukigata.hokkaido.jp","urakawa.hokkaido.jp","urausu.hokkaido.jp","uryu.hokkaido.jp","utashinai.hokkaido.jp","wakkanai.hokkaido.jp","wassamu.hokkaido.jp","yakumo.hokkaido.jp","yoichi.hokkaido.jp","aioi.hyogo.jp","akashi.hyogo.jp","ako.hyogo.jp","amagasaki.hyogo.jp","aogaki.hyogo.jp","asago.hyogo.jp","ashiya.hyogo.jp","awaji.hyogo.jp","fukusaki.hyogo.jp","goshiki.hyogo.jp","harima.hyogo.jp","himeji.hyogo.jp","ichikawa.hyogo.jp","inagawa.hyogo.jp","itami.hyogo.jp","kakogawa.hyogo.jp","kamigori.hyogo.jp","kamikawa.hyogo.jp","kasai.hyogo.jp","kasuga.hyogo.jp","kawanishi.hyogo.jp","miki.hyogo.jp","minamiawaji.hyogo.jp","nishinomiya.hyogo.jp","nishiwaki.hyogo.jp","ono.hyogo.jp","sanda.hyogo.jp","sannan.hyogo.jp","sasayama.hyogo.jp","sayo.hyogo.jp","shingu.hyogo.jp","shinonsen.hyogo.jp","shiso.hyogo.jp","sumoto.hyogo.jp","taishi.hyogo.jp","taka.hyogo.jp","takarazuka.hyogo.jp","takasago.hyogo.jp","takino.hyogo.jp","tamba.hyogo.jp","tatsuno.hyogo.jp","toyooka.hyogo.jp","yabu.hyogo.jp","yashiro.hyogo.jp","yoka.hyogo.jp","yokawa.hyogo.jp","ami.ibaraki.jp","asahi.ibaraki.jp","bando.ibaraki.jp","chikusei.ibaraki.jp","daigo.ibaraki.jp","fujishiro.ibaraki.jp","hitachi.ibaraki.jp","hitachinaka.ibaraki.jp","hitachiomiya.ibaraki.jp","hitachiota.ibaraki.jp","ibaraki.ibaraki.jp","ina.ibaraki.jp","inashiki.ibaraki.jp","itako.ibaraki.jp","iwama.ibaraki.jp","joso.ibaraki.jp","kamisu.ibaraki.jp","kasama.ibaraki.jp","kashima.ibaraki.jp","kasumigaura.ibaraki.jp","koga.ibaraki.jp","miho.ibaraki.jp","mito.ibaraki.jp","moriya.ibaraki.jp","naka.ibaraki.jp","namegata.ibaraki.jp","oarai.ibaraki.jp","ogawa.ibaraki.jp","omitama.ibaraki.jp","ryugasaki.ibaraki.jp","sakai.ibaraki.jp","sakuragawa.ibaraki.jp","shimodate.ibaraki.jp","shimotsuma.ibaraki.jp","shirosato.ibaraki.jp","sowa.ibaraki.jp","suifu.ibaraki.jp","takahagi.ibaraki.jp","tamatsukuri.ibaraki.jp","tokai.ibaraki.jp","tomobe.ibaraki.jp","tone.ibaraki.jp","toride.ibaraki.jp","tsuchiura.ibaraki.jp","tsukuba.ibaraki.jp","uchihara.ibaraki.jp","ushiku.ibaraki.jp","yachiyo.ibaraki.jp","yamagata.ibaraki.jp","yawara.ibaraki.jp","yuki.ibaraki.jp","anamizu.ishikawa.jp","hakui.ishikawa.jp","hakusan.ishikawa.jp","kaga.ishikawa.jp","kahoku.ishikawa.jp","kanazawa.ishikawa.jp","kawakita.ishikawa.jp","komatsu.ishikawa.jp","nakanoto.ishikawa.jp","nanao.ishikawa.jp","nomi.ishikawa.jp","nonoichi.ishikawa.jp","noto.ishikawa.jp","shika.ishikawa.jp","suzu.ishikawa.jp","tsubata.ishikawa.jp","tsurugi.ishikawa.jp","uchinada.ishikawa.jp","wajima.ishikawa.jp","fudai.iwate.jp","fujisawa.iwate.jp","hanamaki.iwate.jp","hiraizumi.iwate.jp","hirono.iwate.jp","ichinohe.iwate.jp","ichinoseki.iwate.jp","iwaizumi.iwate.jp","iwate.iwate.jp","joboji.iwate.jp","kamaishi.iwate.jp","kanegasaki.iwate.jp","karumai.iwate.jp","kawai.iwate.jp","kitakami.iwate.jp","kuji.iwate.jp","kunohe.iwate.jp","kuzumaki.iwate.jp","miyako.iwate.jp","mizusawa.iwate.jp","morioka.iwate.jp","ninohe.iwate.jp","noda.iwate.jp","ofunato.iwate.jp","oshu.iwate.jp","otsuchi.iwate.jp","rikuzentakata.iwate.jp","shiwa.iwate.jp","shizukuishi.iwate.jp","sumita.iwate.jp","tanohata.iwate.jp","tono.iwate.jp","yahaba.iwate.jp","yamada.iwate.jp","ayagawa.kagawa.jp","higashikagawa.kagawa.jp","kanonji.kagawa.jp","kotohira.kagawa.jp","manno.kagawa.jp","marugame.kagawa.jp","mitoyo.kagawa.jp","naoshima.kagawa.jp","sanuki.kagawa.jp","tadotsu.kagawa.jp","takamatsu.kagawa.jp","tonosho.kagawa.jp","uchinomi.kagawa.jp","utazu.kagawa.jp","zentsuji.kagawa.jp","akune.kagoshima.jp","amami.kagoshima.jp","hioki.kagoshima.jp","isa.kagoshima.jp","isen.kagoshima.jp","izumi.kagoshima.jp","kagoshima.kagoshima.jp","kanoya.kagoshima.jp","kawanabe.kagoshima.jp","kinko.kagoshima.jp","kouyama.kagoshima.jp","makurazaki.kagoshima.jp","matsumoto.kagoshima.jp","minamitane.kagoshima.jp","nakatane.kagoshima.jp","nishinoomote.kagoshima.jp","satsumasendai.kagoshima.jp","soo.kagoshima.jp","tarumizu.kagoshima.jp","yusui.kagoshima.jp","aikawa.kanagawa.jp","atsugi.kanagawa.jp","ayase.kanagawa.jp","chigasaki.kanagawa.jp","ebina.kanagawa.jp","fujisawa.kanagawa.jp","hadano.kanagawa.jp","hakone.kanagawa.jp","hiratsuka.kanagawa.jp","isehara.kanagawa.jp","kaisei.kanagawa.jp","kamakura.kanagawa.jp","kiyokawa.kanagawa.jp","matsuda.kanagawa.jp","minamiashigara.kanagawa.jp","miura.kanagawa.jp","nakai.kanagawa.jp","ninomiya.kanagawa.jp","odawara.kanagawa.jp","oi.kanagawa.jp","oiso.kanagawa.jp","sagamihara.kanagawa.jp","samukawa.kanagawa.jp","tsukui.kanagawa.jp","yamakita.kanagawa.jp","yamato.kanagawa.jp","yokosuka.kanagawa.jp","yugawara.kanagawa.jp","zama.kanagawa.jp","zushi.kanagawa.jp","aki.kochi.jp","geisei.kochi.jp","hidaka.kochi.jp","higashitsuno.kochi.jp","ino.kochi.jp","kagami.kochi.jp","kami.kochi.jp","kitagawa.kochi.jp","kochi.kochi.jp","mihara.kochi.jp","motoyama.kochi.jp","muroto.kochi.jp","nahari.kochi.jp","nakamura.kochi.jp","nankoku.kochi.jp","nishitosa.kochi.jp","niyodogawa.kochi.jp","ochi.kochi.jp","okawa.kochi.jp","otoyo.kochi.jp","otsuki.kochi.jp","sakawa.kochi.jp","sukumo.kochi.jp","susaki.kochi.jp","tosa.kochi.jp","tosashimizu.kochi.jp","toyo.kochi.jp","tsuno.kochi.jp","umaji.kochi.jp","yasuda.kochi.jp","yusuhara.kochi.jp","amakusa.kumamoto.jp","arao.kumamoto.jp","aso.kumamoto.jp","choyo.kumamoto.jp","gyokuto.kumamoto.jp","kamiamakusa.kumamoto.jp","kikuchi.kumamoto.jp","kumamoto.kumamoto.jp","mashiki.kumamoto.jp","mifune.kumamoto.jp","minamata.kumamoto.jp","minamioguni.kumamoto.jp","nagasu.kumamoto.jp","nishihara.kumamoto.jp","oguni.kumamoto.jp","ozu.kumamoto.jp","sumoto.kumamoto.jp","takamori.kumamoto.jp","uki.kumamoto.jp","uto.kumamoto.jp","yamaga.kumamoto.jp","yamato.kumamoto.jp","yatsushiro.kumamoto.jp","ayabe.kyoto.jp","fukuchiyama.kyoto.jp","higashiyama.kyoto.jp","ide.kyoto.jp","ine.kyoto.jp","joyo.kyoto.jp","kameoka.kyoto.jp","kamo.kyoto.jp","kita.kyoto.jp","kizu.kyoto.jp","kumiyama.kyoto.jp","kyotamba.kyoto.jp","kyotanabe.kyoto.jp","kyotango.kyoto.jp","maizuru.kyoto.jp","minami.kyoto.jp","minamiyamashiro.kyoto.jp","miyazu.kyoto.jp","muko.kyoto.jp","nagaokakyo.kyoto.jp","nakagyo.kyoto.jp","nantan.kyoto.jp","oyamazaki.kyoto.jp","sakyo.kyoto.jp","seika.kyoto.jp","tanabe.kyoto.jp","uji.kyoto.jp","ujitawara.kyoto.jp","wazuka.kyoto.jp","yamashina.kyoto.jp","yawata.kyoto.jp","asahi.mie.jp","inabe.mie.jp","ise.mie.jp","kameyama.mie.jp","kawagoe.mie.jp","kiho.mie.jp","kisosaki.mie.jp","kiwa.mie.jp","komono.mie.jp","kumano.mie.jp","kuwana.mie.jp","matsusaka.mie.jp","meiwa.mie.jp","mihama.mie.jp","minamiise.mie.jp","misugi.mie.jp","miyama.mie.jp","nabari.mie.jp","shima.mie.jp","suzuka.mie.jp","tado.mie.jp","taiki.mie.jp","taki.mie.jp","tamaki.mie.jp","toba.mie.jp","tsu.mie.jp","udono.mie.jp","ureshino.mie.jp","watarai.mie.jp","yokkaichi.mie.jp","furukawa.miyagi.jp","higashimatsushima.miyagi.jp","ishinomaki.miyagi.jp","iwanuma.miyagi.jp","kakuda.miyagi.jp","kami.miyagi.jp","kawasaki.miyagi.jp","marumori.miyagi.jp","matsushima.miyagi.jp","minamisanriku.miyagi.jp","misato.miyagi.jp","murata.miyagi.jp","natori.miyagi.jp","ogawara.miyagi.jp","ohira.miyagi.jp","onagawa.miyagi.jp","osaki.miyagi.jp","rifu.miyagi.jp","semine.miyagi.jp","shibata.miyagi.jp","shichikashuku.miyagi.jp","shikama.miyagi.jp","shiogama.miyagi.jp","shiroishi.miyagi.jp","tagajo.miyagi.jp","taiwa.miyagi.jp","tome.miyagi.jp","tomiya.miyagi.jp","wakuya.miyagi.jp","watari.miyagi.jp","yamamoto.miyagi.jp","zao.miyagi.jp","aya.miyazaki.jp","ebino.miyazaki.jp","gokase.miyazaki.jp","hyuga.miyazaki.jp","kadogawa.miyazaki.jp","kawaminami.miyazaki.jp","kijo.miyazaki.jp","kitagawa.miyazaki.jp","kitakata.miyazaki.jp","kitaura.miyazaki.jp","kobayashi.miyazaki.jp","kunitomi.miyazaki.jp","kushima.miyazaki.jp","mimata.miyazaki.jp","miyakonojo.miyazaki.jp","miyazaki.miyazaki.jp","morotsuka.miyazaki.jp","nichinan.miyazaki.jp","nishimera.miyazaki.jp","nobeoka.miyazaki.jp","saito.miyazaki.jp","shiiba.miyazaki.jp","shintomi.miyazaki.jp","takaharu.miyazaki.jp","takanabe.miyazaki.jp","takazaki.miyazaki.jp","tsuno.miyazaki.jp","achi.nagano.jp","agematsu.nagano.jp","anan.nagano.jp","aoki.nagano.jp","asahi.nagano.jp","azumino.nagano.jp","chikuhoku.nagano.jp","chikuma.nagano.jp","chino.nagano.jp","fujimi.nagano.jp","hakuba.nagano.jp","hara.nagano.jp","hiraya.nagano.jp","iida.nagano.jp","iijima.nagano.jp","iiyama.nagano.jp","iizuna.nagano.jp","ikeda.nagano.jp","ikusaka.nagano.jp","ina.nagano.jp","karuizawa.nagano.jp","kawakami.nagano.jp","kiso.nagano.jp","kisofukushima.nagano.jp","kitaaiki.nagano.jp","komagane.nagano.jp","komoro.nagano.jp","matsukawa.nagano.jp","matsumoto.nagano.jp","miasa.nagano.jp","minamiaiki.nagano.jp","minamimaki.nagano.jp","minamiminowa.nagano.jp","minowa.nagano.jp","miyada.nagano.jp","miyota.nagano.jp","mochizuki.nagano.jp","nagano.nagano.jp","nagawa.nagano.jp","nagiso.nagano.jp","nakagawa.nagano.jp","nakano.nagano.jp","nozawaonsen.nagano.jp","obuse.nagano.jp","ogawa.nagano.jp","okaya.nagano.jp","omachi.nagano.jp","omi.nagano.jp","ookuwa.nagano.jp","ooshika.nagano.jp","otaki.nagano.jp","otari.nagano.jp","sakae.nagano.jp","sakaki.nagano.jp","saku.nagano.jp","sakuho.nagano.jp","shimosuwa.nagano.jp","shinanomachi.nagano.jp","shiojiri.nagano.jp","suwa.nagano.jp","suzaka.nagano.jp","takagi.nagano.jp","takamori.nagano.jp","takayama.nagano.jp","tateshina.nagano.jp","tatsuno.nagano.jp","togakushi.nagano.jp","togura.nagano.jp","tomi.nagano.jp","ueda.nagano.jp","wada.nagano.jp","yamagata.nagano.jp","yamanouchi.nagano.jp","yasaka.nagano.jp","yasuoka.nagano.jp","chijiwa.nagasaki.jp","futsu.nagasaki.jp","goto.nagasaki.jp","hasami.nagasaki.jp","hirado.nagasaki.jp","iki.nagasaki.jp","isahaya.nagasaki.jp","kawatana.nagasaki.jp","kuchinotsu.nagasaki.jp","matsuura.nagasaki.jp","nagasaki.nagasaki.jp","obama.nagasaki.jp","omura.nagasaki.jp","oseto.nagasaki.jp","saikai.nagasaki.jp","sasebo.nagasaki.jp","seihi.nagasaki.jp","shimabara.nagasaki.jp","shinkamigoto.nagasaki.jp","togitsu.nagasaki.jp","tsushima.nagasaki.jp","unzen.nagasaki.jp","ando.nara.jp","gose.nara.jp","heguri.nara.jp","higashiyoshino.nara.jp","ikaruga.nara.jp","ikoma.nara.jp","kamikitayama.nara.jp","kanmaki.nara.jp","kashiba.nara.jp","kashihara.nara.jp","katsuragi.nara.jp","kawai.nara.jp","kawakami.nara.jp","kawanishi.nara.jp","koryo.nara.jp","kurotaki.nara.jp","mitsue.nara.jp","miyake.nara.jp","nara.nara.jp","nosegawa.nara.jp","oji.nara.jp","ouda.nara.jp","oyodo.nara.jp","sakurai.nara.jp","sango.nara.jp","shimoichi.nara.jp","shimokitayama.nara.jp","shinjo.nara.jp","soni.nara.jp","takatori.nara.jp","tawaramoto.nara.jp","tenkawa.nara.jp","tenri.nara.jp","uda.nara.jp","yamatokoriyama.nara.jp","yamatotakada.nara.jp","yamazoe.nara.jp","yoshino.nara.jp","aga.niigata.jp","agano.niigata.jp","gosen.niigata.jp","itoigawa.niigata.jp","izumozaki.niigata.jp","joetsu.niigata.jp","kamo.niigata.jp","kariwa.niigata.jp","kashiwazaki.niigata.jp","minamiuonuma.niigata.jp","mitsuke.niigata.jp","muika.niigata.jp","murakami.niigata.jp","myoko.niigata.jp","nagaoka.niigata.jp","niigata.niigata.jp","ojiya.niigata.jp","omi.niigata.jp","sado.niigata.jp","sanjo.niigata.jp","seiro.niigata.jp","seirou.niigata.jp","sekikawa.niigata.jp","shibata.niigata.jp","tagami.niigata.jp","tainai.niigata.jp","tochio.niigata.jp","tokamachi.niigata.jp","tsubame.niigata.jp","tsunan.niigata.jp","uonuma.niigata.jp","yahiko.niigata.jp","yoita.niigata.jp","yuzawa.niigata.jp","beppu.oita.jp","bungoono.oita.jp","bungotakada.oita.jp","hasama.oita.jp","hiji.oita.jp","himeshima.oita.jp","hita.oita.jp","kamitsue.oita.jp","kokonoe.oita.jp","kuju.oita.jp","kunisaki.oita.jp","kusu.oita.jp","oita.oita.jp","saiki.oita.jp","taketa.oita.jp","tsukumi.oita.jp","usa.oita.jp","usuki.oita.jp","yufu.oita.jp","akaiwa.okayama.jp","asakuchi.okayama.jp","bizen.okayama.jp","hayashima.okayama.jp","ibara.okayama.jp","kagamino.okayama.jp","kasaoka.okayama.jp","kibichuo.okayama.jp","kumenan.okayama.jp","kurashiki.okayama.jp","maniwa.okayama.jp","misaki.okayama.jp","nagi.okayama.jp","niimi.okayama.jp","nishiawakura.okayama.jp","okayama.okayama.jp","satosho.okayama.jp","setouchi.okayama.jp","shinjo.okayama.jp","shoo.okayama.jp","soja.okayama.jp","takahashi.okayama.jp","tamano.okayama.jp","tsuyama.okayama.jp","wake.okayama.jp","yakage.okayama.jp","aguni.okinawa.jp","ginowan.okinawa.jp","ginoza.okinawa.jp","gushikami.okinawa.jp","haebaru.okinawa.jp","higashi.okinawa.jp","hirara.okinawa.jp","iheya.okinawa.jp","ishigaki.okinawa.jp","ishikawa.okinawa.jp","itoman.okinawa.jp","izena.okinawa.jp","kadena.okinawa.jp","kin.okinawa.jp","kitadaito.okinawa.jp","kitanakagusuku.okinawa.jp","kumejima.okinawa.jp","kunigami.okinawa.jp","minamidaito.okinawa.jp","motobu.okinawa.jp","nago.okinawa.jp","naha.okinawa.jp","nakagusuku.okinawa.jp","nakijin.okinawa.jp","nanjo.okinawa.jp","nishihara.okinawa.jp","ogimi.okinawa.jp","okinawa.okinawa.jp","onna.okinawa.jp","shimoji.okinawa.jp","taketomi.okinawa.jp","tarama.okinawa.jp","tokashiki.okinawa.jp","tomigusuku.okinawa.jp","tonaki.okinawa.jp","urasoe.okinawa.jp","uruma.okinawa.jp","yaese.okinawa.jp","yomitan.okinawa.jp","yonabaru.okinawa.jp","yonaguni.okinawa.jp","zamami.okinawa.jp","abeno.osaka.jp","chihayaakasaka.osaka.jp","chuo.osaka.jp","daito.osaka.jp","fujiidera.osaka.jp","habikino.osaka.jp","hannan.osaka.jp","higashiosaka.osaka.jp","higashisumiyoshi.osaka.jp","higashiyodogawa.osaka.jp","hirakata.osaka.jp","ibaraki.osaka.jp","ikeda.osaka.jp","izumi.osaka.jp","izumiotsu.osaka.jp","izumisano.osaka.jp","kadoma.osaka.jp","kaizuka.osaka.jp","kanan.osaka.jp","kashiwara.osaka.jp","katano.osaka.jp","kawachinagano.osaka.jp","kishiwada.osaka.jp","kita.osaka.jp","kumatori.osaka.jp","matsubara.osaka.jp","minato.osaka.jp","minoh.osaka.jp","misaki.osaka.jp","moriguchi.osaka.jp","neyagawa.osaka.jp","nishi.osaka.jp","nose.osaka.jp","osakasayama.osaka.jp","sakai.osaka.jp","sayama.osaka.jp","sennan.osaka.jp","settsu.osaka.jp","shijonawate.osaka.jp","shimamoto.osaka.jp","suita.osaka.jp","tadaoka.osaka.jp","taishi.osaka.jp","tajiri.osaka.jp","takaishi.osaka.jp","takatsuki.osaka.jp","tondabayashi.osaka.jp","toyonaka.osaka.jp","toyono.osaka.jp","yao.osaka.jp","ariake.saga.jp","arita.saga.jp","fukudomi.saga.jp","genkai.saga.jp","hamatama.saga.jp","hizen.saga.jp","imari.saga.jp","kamimine.saga.jp","kanzaki.saga.jp","karatsu.saga.jp","kashima.saga.jp","kitagata.saga.jp","kitahata.saga.jp","kiyama.saga.jp","kouhoku.saga.jp","kyuragi.saga.jp","nishiarita.saga.jp","ogi.saga.jp","omachi.saga.jp","ouchi.saga.jp","saga.saga.jp","shiroishi.saga.jp","taku.saga.jp","tara.saga.jp","tosu.saga.jp","yoshinogari.saga.jp","arakawa.saitama.jp","asaka.saitama.jp","chichibu.saitama.jp","fujimi.saitama.jp","fujimino.saitama.jp","fukaya.saitama.jp","hanno.saitama.jp","hanyu.saitama.jp","hasuda.saitama.jp","hatogaya.saitama.jp","hatoyama.saitama.jp","hidaka.saitama.jp","higashichichibu.saitama.jp","higashimatsuyama.saitama.jp","honjo.saitama.jp","ina.saitama.jp","iruma.saitama.jp","iwatsuki.saitama.jp","kamiizumi.saitama.jp","kamikawa.saitama.jp","kamisato.saitama.jp","kasukabe.saitama.jp","kawagoe.saitama.jp","kawaguchi.saitama.jp","kawajima.saitama.jp","kazo.saitama.jp","kitamoto.saitama.jp","koshigaya.saitama.jp","kounosu.saitama.jp","kuki.saitama.jp","kumagaya.saitama.jp","matsubushi.saitama.jp","minano.saitama.jp","misato.saitama.jp","miyashiro.saitama.jp","miyoshi.saitama.jp","moroyama.saitama.jp","nagatoro.saitama.jp","namegawa.saitama.jp","niiza.saitama.jp","ogano.saitama.jp","ogawa.saitama.jp","ogose.saitama.jp","okegawa.saitama.jp","omiya.saitama.jp","otaki.saitama.jp","ranzan.saitama.jp","ryokami.saitama.jp","saitama.saitama.jp","sakado.saitama.jp","satte.saitama.jp","sayama.saitama.jp","shiki.saitama.jp","shiraoka.saitama.jp","soka.saitama.jp","sugito.saitama.jp","toda.saitama.jp","tokigawa.saitama.jp","tokorozawa.saitama.jp","tsurugashima.saitama.jp","urawa.saitama.jp","warabi.saitama.jp","yashio.saitama.jp","yokoze.saitama.jp","yono.saitama.jp","yorii.saitama.jp","yoshida.saitama.jp","yoshikawa.saitama.jp","yoshimi.saitama.jp","aisho.shiga.jp","gamo.shiga.jp","higashiomi.shiga.jp","hikone.shiga.jp","koka.shiga.jp","konan.shiga.jp","kosei.shiga.jp","koto.shiga.jp","kusatsu.shiga.jp","maibara.shiga.jp","moriyama.shiga.jp","nagahama.shiga.jp","nishiazai.shiga.jp","notogawa.shiga.jp","omihachiman.shiga.jp","otsu.shiga.jp","ritto.shiga.jp","ryuoh.shiga.jp","takashima.shiga.jp","takatsuki.shiga.jp","torahime.shiga.jp","toyosato.shiga.jp","yasu.shiga.jp","akagi.shimane.jp","ama.shimane.jp","gotsu.shimane.jp","hamada.shimane.jp","higashiizumo.shimane.jp","hikawa.shimane.jp","hikimi.shimane.jp","izumo.shimane.jp","kakinoki.shimane.jp","masuda.shimane.jp","matsue.shimane.jp","misato.shimane.jp","nishinoshima.shimane.jp","ohda.shimane.jp","okinoshima.shimane.jp","okuizumo.shimane.jp","shimane.shimane.jp","tamayu.shimane.jp","tsuwano.shimane.jp","unnan.shimane.jp","yakumo.shimane.jp","yasugi.shimane.jp","yatsuka.shimane.jp","arai.shizuoka.jp","atami.shizuoka.jp","fuji.shizuoka.jp","fujieda.shizuoka.jp","fujikawa.shizuoka.jp","fujinomiya.shizuoka.jp","fukuroi.shizuoka.jp","gotemba.shizuoka.jp","haibara.shizuoka.jp","hamamatsu.shizuoka.jp","higashiizu.shizuoka.jp","ito.shizuoka.jp","iwata.shizuoka.jp","izu.shizuoka.jp","izunokuni.shizuoka.jp","kakegawa.shizuoka.jp","kannami.shizuoka.jp","kawanehon.shizuoka.jp","kawazu.shizuoka.jp","kikugawa.shizuoka.jp","kosai.shizuoka.jp","makinohara.shizuoka.jp","matsuzaki.shizuoka.jp","minamiizu.shizuoka.jp","mishima.shizuoka.jp","morimachi.shizuoka.jp","nishiizu.shizuoka.jp","numazu.shizuoka.jp","omaezaki.shizuoka.jp","shimada.shizuoka.jp","shimizu.shizuoka.jp","shimoda.shizuoka.jp","shizuoka.shizuoka.jp","susono.shizuoka.jp","yaizu.shizuoka.jp","yoshida.shizuoka.jp","ashikaga.tochigi.jp","bato.tochigi.jp","haga.tochigi.jp","ichikai.tochigi.jp","iwafune.tochigi.jp","kaminokawa.tochigi.jp","kanuma.tochigi.jp","karasuyama.tochigi.jp","kuroiso.tochigi.jp","mashiko.tochigi.jp","mibu.tochigi.jp","moka.tochigi.jp","motegi.tochigi.jp","nasu.tochigi.jp","nasushiobara.tochigi.jp","nikko.tochigi.jp","nishikata.tochigi.jp","nogi.tochigi.jp","ohira.tochigi.jp","ohtawara.tochigi.jp","oyama.tochigi.jp","sakura.tochigi.jp","sano.tochigi.jp","shimotsuke.tochigi.jp","shioya.tochigi.jp","takanezawa.tochigi.jp","tochigi.tochigi.jp","tsuga.tochigi.jp","ujiie.tochigi.jp","utsunomiya.tochigi.jp","yaita.tochigi.jp","aizumi.tokushima.jp","anan.tokushima.jp","ichiba.tokushima.jp","itano.tokushima.jp","kainan.tokushima.jp","komatsushima.tokushima.jp","matsushige.tokushima.jp","mima.tokushima.jp","minami.tokushima.jp","miyoshi.tokushima.jp","mugi.tokushima.jp","nakagawa.tokushima.jp","naruto.tokushima.jp","sanagochi.tokushima.jp","shishikui.tokushima.jp","tokushima.tokushima.jp","wajiki.tokushima.jp","adachi.tokyo.jp","akiruno.tokyo.jp","akishima.tokyo.jp","aogashima.tokyo.jp","arakawa.tokyo.jp","bunkyo.tokyo.jp","chiyoda.tokyo.jp","chofu.tokyo.jp","chuo.tokyo.jp","edogawa.tokyo.jp","fuchu.tokyo.jp","fussa.tokyo.jp","hachijo.tokyo.jp","hachioji.tokyo.jp","hamura.tokyo.jp","higashikurume.tokyo.jp","higashimurayama.tokyo.jp","higashiyamato.tokyo.jp","hino.tokyo.jp","hinode.tokyo.jp","hinohara.tokyo.jp","inagi.tokyo.jp","itabashi.tokyo.jp","katsushika.tokyo.jp","kita.tokyo.jp","kiyose.tokyo.jp","kodaira.tokyo.jp","koganei.tokyo.jp","kokubunji.tokyo.jp","komae.tokyo.jp","koto.tokyo.jp","kouzushima.tokyo.jp","kunitachi.tokyo.jp","machida.tokyo.jp","meguro.tokyo.jp","minato.tokyo.jp","mitaka.tokyo.jp","mizuho.tokyo.jp","musashimurayama.tokyo.jp","musashino.tokyo.jp","nakano.tokyo.jp","nerima.tokyo.jp","ogasawara.tokyo.jp","okutama.tokyo.jp","ome.tokyo.jp","oshima.tokyo.jp","ota.tokyo.jp","setagaya.tokyo.jp","shibuya.tokyo.jp","shinagawa.tokyo.jp","shinjuku.tokyo.jp","suginami.tokyo.jp","sumida.tokyo.jp","tachikawa.tokyo.jp","taito.tokyo.jp","tama.tokyo.jp","toshima.tokyo.jp","chizu.tottori.jp","hino.tottori.jp","kawahara.tottori.jp","koge.tottori.jp","kotoura.tottori.jp","misasa.tottori.jp","nanbu.tottori.jp","nichinan.tottori.jp","sakaiminato.tottori.jp","tottori.tottori.jp","wakasa.tottori.jp","yazu.tottori.jp","yonago.tottori.jp","asahi.toyama.jp","fuchu.toyama.jp","fukumitsu.toyama.jp","funahashi.toyama.jp","himi.toyama.jp","imizu.toyama.jp","inami.toyama.jp","johana.toyama.jp","kamiichi.toyama.jp","kurobe.toyama.jp","nakaniikawa.toyama.jp","namerikawa.toyama.jp","nanto.toyama.jp","nyuzen.toyama.jp","oyabe.toyama.jp","taira.toyama.jp","takaoka.toyama.jp","tateyama.toyama.jp","toga.toyama.jp","tonami.toyama.jp","toyama.toyama.jp","unazuki.toyama.jp","uozu.toyama.jp","yamada.toyama.jp","arida.wakayama.jp","aridagawa.wakayama.jp","gobo.wakayama.jp","hashimoto.wakayama.jp","hidaka.wakayama.jp","hirogawa.wakayama.jp","inami.wakayama.jp","iwade.wakayama.jp","kainan.wakayama.jp","kamitonda.wakayama.jp","katsuragi.wakayama.jp","kimino.wakayama.jp","kinokawa.wakayama.jp","kitayama.wakayama.jp","koya.wakayama.jp","koza.wakayama.jp","kozagawa.wakayama.jp","kudoyama.wakayama.jp","kushimoto.wakayama.jp","mihama.wakayama.jp","misato.wakayama.jp","nachikatsuura.wakayama.jp","shingu.wakayama.jp","shirahama.wakayama.jp","taiji.wakayama.jp","tanabe.wakayama.jp","wakayama.wakayama.jp","yuasa.wakayama.jp","yura.wakayama.jp","asahi.yamagata.jp","funagata.yamagata.jp","higashine.yamagata.jp","iide.yamagata.jp","kahoku.yamagata.jp","kaminoyama.yamagata.jp","kaneyama.yamagata.jp","kawanishi.yamagata.jp","mamurogawa.yamagata.jp","mikawa.yamagata.jp","murayama.yamagata.jp","nagai.yamagata.jp","nakayama.yamagata.jp","nanyo.yamagata.jp","nishikawa.yamagata.jp","obanazawa.yamagata.jp","oe.yamagata.jp","oguni.yamagata.jp","ohkura.yamagata.jp","oishida.yamagata.jp","sagae.yamagata.jp","sakata.yamagata.jp","sakegawa.yamagata.jp","shinjo.yamagata.jp","shirataka.yamagata.jp","shonai.yamagata.jp","takahata.yamagata.jp","tendo.yamagata.jp","tozawa.yamagata.jp","tsuruoka.yamagata.jp","yamagata.yamagata.jp","yamanobe.yamagata.jp","yonezawa.yamagata.jp","yuza.yamagata.jp","abu.yamaguchi.jp","hagi.yamaguchi.jp","hikari.yamaguchi.jp","hofu.yamaguchi.jp","iwakuni.yamaguchi.jp","kudamatsu.yamaguchi.jp","mitou.yamaguchi.jp","nagato.yamaguchi.jp","oshima.yamaguchi.jp","shimonoseki.yamaguchi.jp","shunan.yamaguchi.jp","tabuse.yamaguchi.jp","tokuyama.yamaguchi.jp","toyota.yamaguchi.jp","ube.yamaguchi.jp","yuu.yamaguchi.jp","chuo.yamanashi.jp","doshi.yamanashi.jp","fuefuki.yamanashi.jp","fujikawa.yamanashi.jp","fujikawaguchiko.yamanashi.jp","fujiyoshida.yamanashi.jp","hayakawa.yamanashi.jp","hokuto.yamanashi.jp","ichikawamisato.yamanashi.jp","kai.yamanashi.jp","kofu.yamanashi.jp","koshu.yamanashi.jp","kosuge.yamanashi.jp","minami-alps.yamanashi.jp","minobu.yamanashi.jp","nakamichi.yamanashi.jp","nanbu.yamanashi.jp","narusawa.yamanashi.jp","nirasaki.yamanashi.jp","nishikatsura.yamanashi.jp","oshino.yamanashi.jp","otsuki.yamanashi.jp","showa.yamanashi.jp","tabayama.yamanashi.jp","tsuru.yamanashi.jp","uenohara.yamanashi.jp","yamanakako.yamanashi.jp","yamanashi.yamanashi.jp","ke","ac.ke","co.ke","go.ke","info.ke","me.ke","mobi.ke","ne.ke","or.ke","sc.ke","kg","org.kg","net.kg","com.kg","edu.kg","gov.kg","mil.kg","*.kh","ki","edu.ki","biz.ki","net.ki","org.ki","gov.ki","info.ki","com.ki","km","org.km","nom.km","gov.km","prd.km","tm.km","edu.km","mil.km","ass.km","com.km","coop.km","asso.km","presse.km","medecin.km","notaires.km","pharmaciens.km","veterinaire.km","gouv.km","kn","net.kn","org.kn","edu.kn","gov.kn","kp","com.kp","edu.kp","gov.kp","org.kp","rep.kp","tra.kp","kr","ac.kr","co.kr","es.kr","go.kr","hs.kr","kg.kr","mil.kr","ms.kr","ne.kr","or.kr","pe.kr","re.kr","sc.kr","busan.kr","chungbuk.kr","chungnam.kr","daegu.kr","daejeon.kr","gangwon.kr","gwangju.kr","gyeongbuk.kr","gyeonggi.kr","gyeongnam.kr","incheon.kr","jeju.kr","jeonbuk.kr","jeonnam.kr","seoul.kr","ulsan.kr","kw","com.kw","edu.kw","emb.kw","gov.kw","ind.kw","net.kw","org.kw","ky","com.ky","edu.ky","net.ky","org.ky","kz","org.kz","edu.kz","net.kz","gov.kz","mil.kz","com.kz","la","int.la","net.la","info.la","edu.la","gov.la","per.la","com.la","org.la","lb","com.lb","edu.lb","gov.lb","net.lb","org.lb","lc","com.lc","net.lc","co.lc","org.lc","edu.lc","gov.lc","li","lk","gov.lk","sch.lk","net.lk","int.lk","com.lk","org.lk","edu.lk","ngo.lk","soc.lk","web.lk","ltd.lk","assn.lk","grp.lk","hotel.lk","ac.lk","lr","com.lr","edu.lr","gov.lr","org.lr","net.lr","ls","ac.ls","biz.ls","co.ls","edu.ls","gov.ls","info.ls","net.ls","org.ls","sc.ls","lt","gov.lt","lu","lv","com.lv","edu.lv","gov.lv","org.lv","mil.lv","id.lv","net.lv","asn.lv","conf.lv","ly","com.ly","net.ly","gov.ly","plc.ly","edu.ly","sch.ly","med.ly","org.ly","id.ly","ma","co.ma","net.ma","gov.ma","org.ma","ac.ma","press.ma","mc","tm.mc","asso.mc","md","me","co.me","net.me","org.me","edu.me","ac.me","gov.me","its.me","priv.me","mg","org.mg","nom.mg","gov.mg","prd.mg","tm.mg","edu.mg","mil.mg","com.mg","co.mg","mh","mil","mk","com.mk","org.mk","net.mk","edu.mk","gov.mk","inf.mk","name.mk","ml","com.ml","edu.ml","gouv.ml","gov.ml","net.ml","org.ml","presse.ml","*.mm","mn","gov.mn","edu.mn","org.mn","mo","com.mo","net.mo","org.mo","edu.mo","gov.mo","mobi","mp","mq","mr","gov.mr","ms","com.ms","edu.ms","gov.ms","net.ms","org.ms","mt","com.mt","edu.mt","net.mt","org.mt","mu","com.mu","net.mu","org.mu","gov.mu","ac.mu","co.mu","or.mu","museum","academy.museum","agriculture.museum","air.museum","airguard.museum","alabama.museum","alaska.museum","amber.museum","ambulance.museum","american.museum","americana.museum","americanantiques.museum","americanart.museum","amsterdam.museum","and.museum","annefrank.museum","anthro.museum","anthropology.museum","antiques.museum","aquarium.museum","arboretum.museum","archaeological.museum","archaeology.museum","architecture.museum","art.museum","artanddesign.museum","artcenter.museum","artdeco.museum","arteducation.museum","artgallery.museum","arts.museum","artsandcrafts.museum","asmatart.museum","assassination.museum","assisi.museum","association.museum","astronomy.museum","atlanta.museum","austin.museum","australia.museum","automotive.museum","aviation.museum","axis.museum","badajoz.museum","baghdad.museum","bahn.museum","bale.museum","baltimore.museum","barcelona.museum","baseball.museum","basel.museum","baths.museum","bauern.museum","beauxarts.museum","beeldengeluid.museum","bellevue.museum","bergbau.museum","berkeley.museum","berlin.museum","bern.museum","bible.museum","bilbao.museum","bill.museum","birdart.museum","birthplace.museum","bonn.museum","boston.museum","botanical.museum","botanicalgarden.museum","botanicgarden.museum","botany.museum","brandywinevalley.museum","brasil.museum","bristol.museum","british.museum","britishcolumbia.museum","broadcast.museum","brunel.museum","brussel.museum","brussels.museum","bruxelles.museum","building.museum","burghof.museum","bus.museum","bushey.museum","cadaques.museum","california.museum","cambridge.museum","can.museum","canada.museum","capebreton.museum","carrier.museum","cartoonart.museum","casadelamoneda.museum","castle.museum","castres.museum","celtic.museum","center.museum","chattanooga.museum","cheltenham.museum","chesapeakebay.museum","chicago.museum","children.museum","childrens.museum","childrensgarden.museum","chiropractic.museum","chocolate.museum","christiansburg.museum","cincinnati.museum","cinema.museum","circus.museum","civilisation.museum","civilization.museum","civilwar.museum","clinton.museum","clock.museum","coal.museum","coastaldefence.museum","cody.museum","coldwar.museum","collection.museum","colonialwilliamsburg.museum","coloradoplateau.museum","columbia.museum","columbus.museum","communication.museum","communications.museum","community.museum","computer.museum","computerhistory.museum","comunicações.museum","contemporary.museum","contemporaryart.museum","convent.museum","copenhagen.museum","corporation.museum","correios-e-telecomunicações.museum","corvette.museum","costume.museum","countryestate.museum","county.museum","crafts.museum","cranbrook.museum","creation.museum","cultural.museum","culturalcenter.museum","culture.museum","cyber.museum","cymru.museum","dali.museum","dallas.museum","database.museum","ddr.museum","decorativearts.museum","delaware.museum","delmenhorst.museum","denmark.museum","depot.museum","design.museum","detroit.museum","dinosaur.museum","discovery.museum","dolls.museum","donostia.museum","durham.museum","eastafrica.museum","eastcoast.museum","education.museum","educational.museum","egyptian.museum","eisenbahn.museum","elburg.museum","elvendrell.museum","embroidery.museum","encyclopedic.museum","england.museum","entomology.museum","environment.museum","environmentalconservation.museum","epilepsy.museum","essex.museum","estate.museum","ethnology.museum","exeter.museum","exhibition.museum","family.museum","farm.museum","farmequipment.museum","farmers.museum","farmstead.museum","field.museum","figueres.museum","filatelia.museum","film.museum","fineart.museum","finearts.museum","finland.museum","flanders.museum","florida.museum","force.museum","fortmissoula.museum","fortworth.museum","foundation.museum","francaise.museum","frankfurt.museum","franziskaner.museum","freemasonry.museum","freiburg.museum","fribourg.museum","frog.museum","fundacio.museum","furniture.museum","gallery.museum","garden.museum","gateway.museum","geelvinck.museum","gemological.museum","geology.museum","georgia.museum","giessen.museum","glas.museum","glass.museum","gorge.museum","grandrapids.museum","graz.museum","guernsey.museum","halloffame.museum","hamburg.museum","handson.museum","harvestcelebration.museum","hawaii.museum","health.museum","heimatunduhren.museum","hellas.museum","helsinki.museum","hembygdsforbund.museum","heritage.museum","histoire.museum","historical.museum","historicalsociety.museum","historichouses.museum","historisch.museum","historisches.museum","history.museum","historyofscience.museum","horology.museum","house.museum","humanities.museum","illustration.museum","imageandsound.museum","indian.museum","indiana.museum","indianapolis.museum","indianmarket.museum","intelligence.museum","interactive.museum","iraq.museum","iron.museum","isleofman.museum","jamison.museum","jefferson.museum","jerusalem.museum","jewelry.museum","jewish.museum","jewishart.museum","jfk.museum","journalism.museum","judaica.museum","judygarland.museum","juedisches.museum","juif.museum","karate.museum","karikatur.museum","kids.museum","koebenhavn.museum","koeln.museum","kunst.museum","kunstsammlung.museum","kunstunddesign.museum","labor.museum","labour.museum","lajolla.museum","lancashire.museum","landes.museum","lans.museum","läns.museum","larsson.museum","lewismiller.museum","lincoln.museum","linz.museum","living.museum","livinghistory.museum","localhistory.museum","london.museum","losangeles.museum","louvre.museum","loyalist.museum","lucerne.museum","luxembourg.museum","luzern.museum","mad.museum","madrid.museum","mallorca.museum","manchester.museum","mansion.museum","mansions.museum","manx.museum","marburg.museum","maritime.museum","maritimo.museum","maryland.museum","marylhurst.museum","media.museum","medical.museum","medizinhistorisches.museum","meeres.museum","memorial.museum","mesaverde.museum","michigan.museum","midatlantic.museum","military.museum","mill.museum","miners.museum","mining.museum","minnesota.museum","missile.museum","missoula.museum","modern.museum","moma.museum","money.museum","monmouth.museum","monticello.museum","montreal.museum","moscow.museum","motorcycle.museum","muenchen.museum","muenster.museum","mulhouse.museum","muncie.museum","museet.museum","museumcenter.museum","museumvereniging.museum","music.museum","national.museum","nationalfirearms.museum","nationalheritage.museum","nativeamerican.museum","naturalhistory.museum","naturalhistorymuseum.museum","naturalsciences.museum","nature.museum","naturhistorisches.museum","natuurwetenschappen.museum","naumburg.museum","naval.museum","nebraska.museum","neues.museum","newhampshire.museum","newjersey.museum","newmexico.museum","newport.museum","newspaper.museum","newyork.museum","niepce.museum","norfolk.museum","north.museum","nrw.museum","nyc.museum","nyny.museum","oceanographic.museum","oceanographique.museum","omaha.museum","online.museum","ontario.museum","openair.museum","oregon.museum","oregontrail.museum","otago.museum","oxford.museum","pacific.museum","paderborn.museum","palace.museum","paleo.museum","palmsprings.museum","panama.museum","paris.museum","pasadena.museum","pharmacy.museum","philadelphia.museum","philadelphiaarea.museum","philately.museum","phoenix.museum","photography.museum","pilots.museum","pittsburgh.museum","planetarium.museum","plantation.museum","plants.museum","plaza.museum","portal.museum","portland.museum","portlligat.museum","posts-and-telecommunications.museum","preservation.museum","presidio.museum","press.museum","project.museum","public.museum","pubol.museum","quebec.museum","railroad.museum","railway.museum","research.museum","resistance.museum","riodejaneiro.museum","rochester.museum","rockart.museum","roma.museum","russia.museum","saintlouis.museum","salem.museum","salvadordali.museum","salzburg.museum","sandiego.museum","sanfrancisco.museum","santabarbara.museum","santacruz.museum","santafe.museum","saskatchewan.museum","satx.museum","savannahga.museum","schlesisches.museum","schoenbrunn.museum","schokoladen.museum","school.museum","schweiz.museum","science.museum","scienceandhistory.museum","scienceandindustry.museum","sciencecenter.museum","sciencecenters.museum","science-fiction.museum","sciencehistory.museum","sciences.museum","sciencesnaturelles.museum","scotland.museum","seaport.museum","settlement.museum","settlers.museum","shell.museum","sherbrooke.museum","sibenik.museum","silk.museum","ski.museum","skole.museum","society.museum","sologne.museum","soundandvision.museum","southcarolina.museum","southwest.museum","space.museum","spy.museum","square.museum","stadt.museum","stalbans.museum","starnberg.museum","state.museum","stateofdelaware.museum","station.museum","steam.museum","steiermark.museum","stjohn.museum","stockholm.museum","stpetersburg.museum","stuttgart.museum","suisse.museum","surgeonshall.museum","surrey.museum","svizzera.museum","sweden.museum","sydney.museum","tank.museum","tcm.museum","technology.museum","telekommunikation.museum","television.museum","texas.museum","textile.museum","theater.museum","time.museum","timekeeping.museum","topology.museum","torino.museum","touch.museum","town.museum","transport.museum","tree.museum","trolley.museum","trust.museum","trustee.museum","uhren.museum","ulm.museum","undersea.museum","university.museum","usa.museum","usantiques.museum","usarts.museum","uscountryestate.museum","usculture.museum","usdecorativearts.museum","usgarden.museum","ushistory.museum","ushuaia.museum","uslivinghistory.museum","utah.museum","uvic.museum","valley.museum","vantaa.museum","versailles.museum","viking.museum","village.museum","virginia.museum","virtual.museum","virtuel.museum","vlaanderen.museum","volkenkunde.museum","wales.museum","wallonie.museum","war.museum","washingtondc.museum","watchandclock.museum","watch-and-clock.museum","western.museum","westfalen.museum","whaling.museum","wildlife.museum","williamsburg.museum","windmill.museum","workshop.museum","york.museum","yorkshire.museum","yosemite.museum","youth.museum","zoological.museum","zoology.museum","ירושלים.museum","иком.museum","mv","aero.mv","biz.mv","com.mv","coop.mv","edu.mv","gov.mv","info.mv","int.mv","mil.mv","museum.mv","name.mv","net.mv","org.mv","pro.mv","mw","ac.mw","biz.mw","co.mw","com.mw","coop.mw","edu.mw","gov.mw","int.mw","museum.mw","net.mw","org.mw","mx","com.mx","org.mx","gob.mx","edu.mx","net.mx","my","biz.my","com.my","edu.my","gov.my","mil.my","name.my","net.my","org.my","mz","ac.mz","adv.mz","co.mz","edu.mz","gov.mz","mil.mz","net.mz","org.mz","na","info.na","pro.na","name.na","school.na","or.na","dr.na","us.na","mx.na","ca.na","in.na","cc.na","tv.na","ws.na","mobi.na","co.na","com.na","org.na","name","nc","asso.nc","nom.nc","ne","net","nf","com.nf","net.nf","per.nf","rec.nf","web.nf","arts.nf","firm.nf","info.nf","other.nf","store.nf","ng","com.ng","edu.ng","gov.ng","i.ng","mil.ng","mobi.ng","name.ng","net.ng","org.ng","sch.ng","ni","ac.ni","biz.ni","co.ni","com.ni","edu.ni","gob.ni","in.ni","info.ni","int.ni","mil.ni","net.ni","nom.ni","org.ni","web.ni","nl","no","fhs.no","vgs.no","fylkesbibl.no","folkebibl.no","museum.no","idrett.no","priv.no","mil.no","stat.no","dep.no","kommune.no","herad.no","aa.no","ah.no","bu.no","fm.no","hl.no","hm.no","jan-mayen.no","mr.no","nl.no","nt.no","of.no","ol.no","oslo.no","rl.no","sf.no","st.no","svalbard.no","tm.no","tr.no","va.no","vf.no","gs.aa.no","gs.ah.no","gs.bu.no","gs.fm.no","gs.hl.no","gs.hm.no","gs.jan-mayen.no","gs.mr.no","gs.nl.no","gs.nt.no","gs.of.no","gs.ol.no","gs.oslo.no","gs.rl.no","gs.sf.no","gs.st.no","gs.svalbard.no","gs.tm.no","gs.tr.no","gs.va.no","gs.vf.no","akrehamn.no","åkrehamn.no","algard.no","ålgård.no","arna.no","brumunddal.no","bryne.no","bronnoysund.no","brønnøysund.no","drobak.no","drøbak.no","egersund.no","fetsund.no","floro.no","florø.no","fredrikstad.no","hokksund.no","honefoss.no","hønefoss.no","jessheim.no","jorpeland.no","jørpeland.no","kirkenes.no","kopervik.no","krokstadelva.no","langevag.no","langevåg.no","leirvik.no","mjondalen.no","mjøndalen.no","mo-i-rana.no","mosjoen.no","mosjøen.no","nesoddtangen.no","orkanger.no","osoyro.no","osøyro.no","raholt.no","råholt.no","sandnessjoen.no","sandnessjøen.no","skedsmokorset.no","slattum.no","spjelkavik.no","stathelle.no","stavern.no","stjordalshalsen.no","stjørdalshalsen.no","tananger.no","tranby.no","vossevangen.no","afjord.no","åfjord.no","agdenes.no","al.no","ål.no","alesund.no","ålesund.no","alstahaug.no","alta.no","áltá.no","alaheadju.no","álaheadju.no","alvdal.no","amli.no","åmli.no","amot.no","åmot.no","andebu.no","andoy.no","andøy.no","andasuolo.no","ardal.no","årdal.no","aremark.no","arendal.no","ås.no","aseral.no","åseral.no","asker.no","askim.no","askvoll.no","askoy.no","askøy.no","asnes.no","åsnes.no","audnedaln.no","aukra.no","aure.no","aurland.no","aurskog-holand.no","aurskog-høland.no","austevoll.no","austrheim.no","averoy.no","averøy.no","balestrand.no","ballangen.no","balat.no","bálát.no","balsfjord.no","bahccavuotna.no","báhccavuotna.no","bamble.no","bardu.no","beardu.no","beiarn.no","bajddar.no","bájddar.no","baidar.no","báidár.no","berg.no","bergen.no","berlevag.no","berlevåg.no","bearalvahki.no","bearalváhki.no","bindal.no","birkenes.no","bjarkoy.no","bjarkøy.no","bjerkreim.no","bjugn.no","bodo.no","bodø.no","badaddja.no","bådåddjå.no","budejju.no","bokn.no","bremanger.no","bronnoy.no","brønnøy.no","bygland.no","bykle.no","barum.no","bærum.no","bo.telemark.no","bø.telemark.no","bo.nordland.no","bø.nordland.no","bievat.no","bievát.no","bomlo.no","bømlo.no","batsfjord.no","båtsfjord.no","bahcavuotna.no","báhcavuotna.no","dovre.no","drammen.no","drangedal.no","dyroy.no","dyrøy.no","donna.no","dønna.no","eid.no","eidfjord.no","eidsberg.no","eidskog.no","eidsvoll.no","eigersund.no","elverum.no","enebakk.no","engerdal.no","etne.no","etnedal.no","evenes.no","evenassi.no","evenášši.no","evje-og-hornnes.no","farsund.no","fauske.no","fuossko.no","fuoisku.no","fedje.no","fet.no","finnoy.no","finnøy.no","fitjar.no","fjaler.no","fjell.no","flakstad.no","flatanger.no","flekkefjord.no","flesberg.no","flora.no","fla.no","flå.no","folldal.no","forsand.no","fosnes.no","frei.no","frogn.no","froland.no","frosta.no","frana.no","fræna.no","froya.no","frøya.no","fusa.no","fyresdal.no","forde.no","førde.no","gamvik.no","gangaviika.no","gáŋgaviika.no","gaular.no","gausdal.no","gildeskal.no","gildeskål.no","giske.no","gjemnes.no","gjerdrum.no","gjerstad.no","gjesdal.no","gjovik.no","gjøvik.no","gloppen.no","gol.no","gran.no","grane.no","granvin.no","gratangen.no","grimstad.no","grong.no","kraanghke.no","kråanghke.no","grue.no","gulen.no","hadsel.no","halden.no","halsa.no","hamar.no","hamaroy.no","habmer.no","hábmer.no","hapmir.no","hápmir.no","hammerfest.no","hammarfeasta.no","hámmárfeasta.no","haram.no","hareid.no","harstad.no","hasvik.no","aknoluokta.no","ákŋoluokta.no","hattfjelldal.no","aarborte.no","haugesund.no","hemne.no","hemnes.no","hemsedal.no","heroy.more-og-romsdal.no","herøy.møre-og-romsdal.no","heroy.nordland.no","herøy.nordland.no","hitra.no","hjartdal.no","hjelmeland.no","hobol.no","hobøl.no","hof.no","hol.no","hole.no","holmestrand.no","holtalen.no","holtålen.no","hornindal.no","horten.no","hurdal.no","hurum.no","hvaler.no","hyllestad.no","hagebostad.no","hægebostad.no","hoyanger.no","høyanger.no","hoylandet.no","høylandet.no","ha.no","hå.no","ibestad.no","inderoy.no","inderøy.no","iveland.no","jevnaker.no","jondal.no","jolster.no","jølster.no","karasjok.no","karasjohka.no","kárášjohka.no","karlsoy.no","galsa.no","gálsá.no","karmoy.no","karmøy.no","kautokeino.no","guovdageaidnu.no","klepp.no","klabu.no","klæbu.no","kongsberg.no","kongsvinger.no","kragero.no","kragerø.no","kristiansand.no","kristiansund.no","krodsherad.no","krødsherad.no","kvalsund.no","rahkkeravju.no","ráhkkerávju.no","kvam.no","kvinesdal.no","kvinnherad.no","kviteseid.no","kvitsoy.no","kvitsøy.no","kvafjord.no","kvæfjord.no","giehtavuoatna.no","kvanangen.no","kvænangen.no","navuotna.no","návuotna.no","kafjord.no","kåfjord.no","gaivuotna.no","gáivuotna.no","larvik.no","lavangen.no","lavagis.no","loabat.no","loabát.no","lebesby.no","davvesiida.no","leikanger.no","leirfjord.no","leka.no","leksvik.no","lenvik.no","leangaviika.no","leaŋgaviika.no","lesja.no","levanger.no","lier.no","lierne.no","lillehammer.no","lillesand.no","lindesnes.no","lindas.no","lindås.no","lom.no","loppa.no","lahppi.no","láhppi.no","lund.no","lunner.no","luroy.no","lurøy.no","luster.no","lyngdal.no","lyngen.no","ivgu.no","lardal.no","lerdal.no","lærdal.no","lodingen.no","lødingen.no","lorenskog.no","lørenskog.no","loten.no","løten.no","malvik.no","masoy.no","måsøy.no","muosat.no","muosát.no","mandal.no","marker.no","marnardal.no","masfjorden.no","meland.no","meldal.no","melhus.no","meloy.no","meløy.no","meraker.no","meråker.no","moareke.no","moåreke.no","midsund.no","midtre-gauldal.no","modalen.no","modum.no","molde.no","moskenes.no","moss.no","mosvik.no","malselv.no","målselv.no","malatvuopmi.no","málatvuopmi.no","namdalseid.no","aejrie.no","namsos.no","namsskogan.no","naamesjevuemie.no","nååmesjevuemie.no","laakesvuemie.no","nannestad.no","narvik.no","narviika.no","naustdal.no","nedre-eiker.no","nes.akershus.no","nes.buskerud.no","nesna.no","nesodden.no","nesseby.no","unjarga.no","unjárga.no","nesset.no","nissedal.no","nittedal.no","nord-aurdal.no","nord-fron.no","nord-odal.no","norddal.no","nordkapp.no","davvenjarga.no","davvenjárga.no","nordre-land.no","nordreisa.no","raisa.no","ráisa.no","nore-og-uvdal.no","notodden.no","naroy.no","nærøy.no","notteroy.no","nøtterøy.no","odda.no","oksnes.no","øksnes.no","oppdal.no","oppegard.no","oppegård.no","orkdal.no","orland.no","ørland.no","orskog.no","ørskog.no","orsta.no","ørsta.no","os.hedmark.no","os.hordaland.no","osen.no","osteroy.no","osterøy.no","ostre-toten.no","østre-toten.no","overhalla.no","ovre-eiker.no","øvre-eiker.no","oyer.no","øyer.no","oygarden.no","øygarden.no","oystre-slidre.no","øystre-slidre.no","porsanger.no","porsangu.no","porsáŋgu.no","porsgrunn.no","radoy.no","radøy.no","rakkestad.no","rana.no","ruovat.no","randaberg.no","rauma.no","rendalen.no","rennebu.no","rennesoy.no","rennesøy.no","rindal.no","ringebu.no","ringerike.no","ringsaker.no","rissa.no","risor.no","risør.no","roan.no","rollag.no","rygge.no","ralingen.no","rælingen.no","rodoy.no","rødøy.no","romskog.no","rømskog.no","roros.no","røros.no","rost.no","røst.no","royken.no","røyken.no","royrvik.no","røyrvik.no","rade.no","råde.no","salangen.no","siellak.no","saltdal.no","salat.no","sálát.no","sálat.no","samnanger.no","sande.more-og-romsdal.no","sande.møre-og-romsdal.no","sande.vestfold.no","sandefjord.no","sandnes.no","sandoy.no","sandøy.no","sarpsborg.no","sauda.no","sauherad.no","sel.no","selbu.no","selje.no","seljord.no","sigdal.no","siljan.no","sirdal.no","skaun.no","skedsmo.no","ski.no","skien.no","skiptvet.no","skjervoy.no","skjervøy.no","skierva.no","skiervá.no","skjak.no","skjåk.no","skodje.no","skanland.no","skånland.no","skanit.no","skánit.no","smola.no","smøla.no","snillfjord.no","snasa.no","snåsa.no","snoasa.no","snaase.no","snåase.no","sogndal.no","sokndal.no","sola.no","solund.no","songdalen.no","sortland.no","spydeberg.no","stange.no","stavanger.no","steigen.no","steinkjer.no","stjordal.no","stjørdal.no","stokke.no","stor-elvdal.no","stord.no","stordal.no","storfjord.no","omasvuotna.no","strand.no","stranda.no","stryn.no","sula.no","suldal.no","sund.no","sunndal.no","surnadal.no","sveio.no","svelvik.no","sykkylven.no","sogne.no","søgne.no","somna.no","sømna.no","sondre-land.no","søndre-land.no","sor-aurdal.no","sør-aurdal.no","sor-fron.no","sør-fron.no","sor-odal.no","sør-odal.no","sor-varanger.no","sør-varanger.no","matta-varjjat.no","mátta-várjjat.no","sorfold.no","sørfold.no","sorreisa.no","sørreisa.no","sorum.no","sørum.no","tana.no","deatnu.no","time.no","tingvoll.no","tinn.no","tjeldsund.no","dielddanuorri.no","tjome.no","tjøme.no","tokke.no","tolga.no","torsken.no","tranoy.no","tranøy.no","tromso.no","tromsø.no","tromsa.no","romsa.no","trondheim.no","troandin.no","trysil.no","trana.no","træna.no","trogstad.no","trøgstad.no","tvedestrand.no","tydal.no","tynset.no","tysfjord.no","divtasvuodna.no","divttasvuotna.no","tysnes.no","tysvar.no","tysvær.no","tonsberg.no","tønsberg.no","ullensaker.no","ullensvang.no","ulvik.no","utsira.no","vadso.no","vadsø.no","cahcesuolo.no","čáhcesuolo.no","vaksdal.no","valle.no","vang.no","vanylven.no","vardo.no","vardø.no","varggat.no","várggát.no","vefsn.no","vaapste.no","vega.no","vegarshei.no","vegårshei.no","vennesla.no","verdal.no","verran.no","vestby.no","vestnes.no","vestre-slidre.no","vestre-toten.no","vestvagoy.no","vestvågøy.no","vevelstad.no","vik.no","vikna.no","vindafjord.no","volda.no","voss.no","varoy.no","værøy.no","vagan.no","vågan.no","voagat.no","vagsoy.no","vågsøy.no","vaga.no","vågå.no","valer.ostfold.no","våler.østfold.no","valer.hedmark.no","våler.hedmark.no","*.np","nr","biz.nr","info.nr","gov.nr","edu.nr","org.nr","net.nr","com.nr","nu","nz","ac.nz","co.nz","cri.nz","geek.nz","gen.nz","govt.nz","health.nz","iwi.nz","kiwi.nz","maori.nz","mil.nz","māori.nz","net.nz","org.nz","parliament.nz","school.nz","om","co.om","com.om","edu.om","gov.om","med.om","museum.om","net.om","org.om","pro.om","onion","org","pa","ac.pa","gob.pa","com.pa","org.pa","sld.pa","edu.pa","net.pa","ing.pa","abo.pa","med.pa","nom.pa","pe","edu.pe","gob.pe","nom.pe","mil.pe","org.pe","com.pe","net.pe","pf","com.pf","org.pf","edu.pf","*.pg","ph","com.ph","net.ph","org.ph","gov.ph","edu.ph","ngo.ph","mil.ph","i.ph","pk","com.pk","net.pk","edu.pk","org.pk","fam.pk","biz.pk","web.pk","gov.pk","gob.pk","gok.pk","gon.pk","gop.pk","gos.pk","info.pk","pl","com.pl","net.pl","org.pl","aid.pl","agro.pl","atm.pl","auto.pl","biz.pl","edu.pl","gmina.pl","gsm.pl","info.pl","mail.pl","miasta.pl","media.pl","mil.pl","nieruchomosci.pl","nom.pl","pc.pl","powiat.pl","priv.pl","realestate.pl","rel.pl","sex.pl","shop.pl","sklep.pl","sos.pl","szkola.pl","targi.pl","tm.pl","tourism.pl","travel.pl","turystyka.pl","gov.pl","ap.gov.pl","ic.gov.pl","is.gov.pl","us.gov.pl","kmpsp.gov.pl","kppsp.gov.pl","kwpsp.gov.pl","psp.gov.pl","wskr.gov.pl","kwp.gov.pl","mw.gov.pl","ug.gov.pl","um.gov.pl","umig.gov.pl","ugim.gov.pl","upow.gov.pl","uw.gov.pl","starostwo.gov.pl","pa.gov.pl","po.gov.pl","psse.gov.pl","pup.gov.pl","rzgw.gov.pl","sa.gov.pl","so.gov.pl","sr.gov.pl","wsa.gov.pl","sko.gov.pl","uzs.gov.pl","wiih.gov.pl","winb.gov.pl","pinb.gov.pl","wios.gov.pl","witd.gov.pl","wzmiuw.gov.pl","piw.gov.pl","wiw.gov.pl","griw.gov.pl","wif.gov.pl","oum.gov.pl","sdn.gov.pl","zp.gov.pl","uppo.gov.pl","mup.gov.pl","wuoz.gov.pl","konsulat.gov.pl","oirm.gov.pl","augustow.pl","babia-gora.pl","bedzin.pl","beskidy.pl","bialowieza.pl","bialystok.pl","bielawa.pl","bieszczady.pl","boleslawiec.pl","bydgoszcz.pl","bytom.pl","cieszyn.pl","czeladz.pl","czest.pl","dlugoleka.pl","elblag.pl","elk.pl","glogow.pl","gniezno.pl","gorlice.pl","grajewo.pl","ilawa.pl","jaworzno.pl","jelenia-gora.pl","jgora.pl","kalisz.pl","kazimierz-dolny.pl","karpacz.pl","kartuzy.pl","kaszuby.pl","katowice.pl","kepno.pl","ketrzyn.pl","klodzko.pl","kobierzyce.pl","kolobrzeg.pl","konin.pl","konskowola.pl","kutno.pl","lapy.pl","lebork.pl","legnica.pl","lezajsk.pl","limanowa.pl","lomza.pl","lowicz.pl","lubin.pl","lukow.pl","malbork.pl","malopolska.pl","mazowsze.pl","mazury.pl","mielec.pl","mielno.pl","mragowo.pl","naklo.pl","nowaruda.pl","nysa.pl","olawa.pl","olecko.pl","olkusz.pl","olsztyn.pl","opoczno.pl","opole.pl","ostroda.pl","ostroleka.pl","ostrowiec.pl","ostrowwlkp.pl","pila.pl","pisz.pl","podhale.pl","podlasie.pl","polkowice.pl","pomorze.pl","pomorskie.pl","prochowice.pl","pruszkow.pl","przeworsk.pl","pulawy.pl","radom.pl","rawa-maz.pl","rybnik.pl","rzeszow.pl","sanok.pl","sejny.pl","slask.pl","slupsk.pl","sosnowiec.pl","stalowa-wola.pl","skoczow.pl","starachowice.pl","stargard.pl","suwalki.pl","swidnica.pl","swiebodzin.pl","swinoujscie.pl","szczecin.pl","szczytno.pl","tarnobrzeg.pl","tgory.pl","turek.pl","tychy.pl","ustka.pl","walbrzych.pl","warmia.pl","warszawa.pl","waw.pl","wegrow.pl","wielun.pl","wlocl.pl","wloclawek.pl","wodzislaw.pl","wolomin.pl","wroclaw.pl","zachpomor.pl","zagan.pl","zarow.pl","zgora.pl","zgorzelec.pl","pm","pn","gov.pn","co.pn","org.pn","edu.pn","net.pn","post","pr","com.pr","net.pr","org.pr","gov.pr","edu.pr","isla.pr","pro.pr","biz.pr","info.pr","name.pr","est.pr","prof.pr","ac.pr","pro","aaa.pro","aca.pro","acct.pro","avocat.pro","bar.pro","cpa.pro","eng.pro","jur.pro","law.pro","med.pro","recht.pro","ps","edu.ps","gov.ps","sec.ps","plo.ps","com.ps","org.ps","net.ps","pt","net.pt","gov.pt","org.pt","edu.pt","int.pt","publ.pt","com.pt","nome.pt","pw","co.pw","ne.pw","or.pw","ed.pw","go.pw","belau.pw","py","com.py","coop.py","edu.py","gov.py","mil.py","net.py","org.py","qa","com.qa","edu.qa","gov.qa","mil.qa","name.qa","net.qa","org.qa","sch.qa","re","asso.re","com.re","nom.re","ro","arts.ro","com.ro","firm.ro","info.ro","nom.ro","nt.ro","org.ro","rec.ro","store.ro","tm.ro","www.ro","rs","ac.rs","co.rs","edu.rs","gov.rs","in.rs","org.rs","ru","rw","ac.rw","co.rw","coop.rw","gov.rw","mil.rw","net.rw","org.rw","sa","com.sa","net.sa","org.sa","gov.sa","med.sa","pub.sa","edu.sa","sch.sa","sb","com.sb","edu.sb","gov.sb","net.sb","org.sb","sc","com.sc","gov.sc","net.sc","org.sc","edu.sc","sd","com.sd","net.sd","org.sd","edu.sd","med.sd","tv.sd","gov.sd","info.sd","se","a.se","ac.se","b.se","bd.se","brand.se","c.se","d.se","e.se","f.se","fh.se","fhsk.se","fhv.se","g.se","h.se","i.se","k.se","komforb.se","kommunalforbund.se","komvux.se","l.se","lanbib.se","m.se","n.se","naturbruksgymn.se","o.se","org.se","p.se","parti.se","pp.se","press.se","r.se","s.se","t.se","tm.se","u.se","w.se","x.se","y.se","z.se","sg","com.sg","net.sg","org.sg","gov.sg","edu.sg","per.sg","sh","com.sh","net.sh","gov.sh","org.sh","mil.sh","si","sj","sk","sl","com.sl","net.sl","edu.sl","gov.sl","org.sl","sm","sn","art.sn","com.sn","edu.sn","gouv.sn","org.sn","perso.sn","univ.sn","so","com.so","edu.so","gov.so","me.so","net.so","org.so","sr","ss","biz.ss","com.ss","edu.ss","gov.ss","me.ss","net.ss","org.ss","sch.ss","st","co.st","com.st","consulado.st","edu.st","embaixada.st","mil.st","net.st","org.st","principe.st","saotome.st","store.st","su","sv","com.sv","edu.sv","gob.sv","org.sv","red.sv","sx","gov.sx","sy","edu.sy","gov.sy","net.sy","mil.sy","com.sy","org.sy","sz","co.sz","ac.sz","org.sz","tc","td","tel","tf","tg","th","ac.th","co.th","go.th","in.th","mi.th","net.th","or.th","tj","ac.tj","biz.tj","co.tj","com.tj","edu.tj","go.tj","gov.tj","int.tj","mil.tj","name.tj","net.tj","nic.tj","org.tj","test.tj","web.tj","tk","tl","gov.tl","tm","com.tm","co.tm","org.tm","net.tm","nom.tm","gov.tm","mil.tm","edu.tm","tn","com.tn","ens.tn","fin.tn","gov.tn","ind.tn","info.tn","intl.tn","mincom.tn","nat.tn","net.tn","org.tn","perso.tn","tourism.tn","to","com.to","gov.to","net.to","org.to","edu.to","mil.to","tr","av.tr","bbs.tr","bel.tr","biz.tr","com.tr","dr.tr","edu.tr","gen.tr","gov.tr","info.tr","mil.tr","k12.tr","kep.tr","name.tr","net.tr","org.tr","pol.tr","tel.tr","tsk.tr","tv.tr","web.tr","nc.tr","gov.nc.tr","tt","co.tt","com.tt","org.tt","net.tt","biz.tt","info.tt","pro.tt","int.tt","coop.tt","jobs.tt","mobi.tt","travel.tt","museum.tt","aero.tt","name.tt","gov.tt","edu.tt","tv","tw","edu.tw","gov.tw","mil.tw","com.tw","net.tw","org.tw","idv.tw","game.tw","ebiz.tw","club.tw","網路.tw","組織.tw","商業.tw","tz","ac.tz","co.tz","go.tz","hotel.tz","info.tz","me.tz","mil.tz","mobi.tz","ne.tz","or.tz","sc.tz","tv.tz","ua","com.ua","edu.ua","gov.ua","in.ua","net.ua","org.ua","cherkassy.ua","cherkasy.ua","chernigov.ua","chernihiv.ua","chernivtsi.ua","chernovtsy.ua","ck.ua","cn.ua","cr.ua","crimea.ua","cv.ua","dn.ua","dnepropetrovsk.ua","dnipropetrovsk.ua","donetsk.ua","dp.ua","if.ua","ivano-frankivsk.ua","kh.ua","kharkiv.ua","kharkov.ua","kherson.ua","khmelnitskiy.ua","khmelnytskyi.ua","kiev.ua","kirovograd.ua","km.ua","kr.ua","krym.ua","ks.ua","kv.ua","kyiv.ua","lg.ua","lt.ua","lugansk.ua","lutsk.ua","lv.ua","lviv.ua","mk.ua","mykolaiv.ua","nikolaev.ua","od.ua","odesa.ua","odessa.ua","pl.ua","poltava.ua","rivne.ua","rovno.ua","rv.ua","sb.ua","sebastopol.ua","sevastopol.ua","sm.ua","sumy.ua","te.ua","ternopil.ua","uz.ua","uzhgorod.ua","vinnica.ua","vinnytsia.ua","vn.ua","volyn.ua","yalta.ua","zaporizhzhe.ua","zaporizhzhia.ua","zhitomir.ua","zhytomyr.ua","zp.ua","zt.ua","ug","co.ug","or.ug","ac.ug","sc.ug","go.ug","ne.ug","com.ug","org.ug","uk","ac.uk","co.uk","gov.uk","ltd.uk","me.uk","net.uk","nhs.uk","org.uk","plc.uk","police.uk","*.sch.uk","us","dni.us","fed.us","isa.us","kids.us","nsn.us","ak.us","al.us","ar.us","as.us","az.us","ca.us","co.us","ct.us","dc.us","de.us","fl.us","ga.us","gu.us","hi.us","ia.us","id.us","il.us","in.us","ks.us","ky.us","la.us","ma.us","md.us","me.us","mi.us","mn.us","mo.us","ms.us","mt.us","nc.us","nd.us","ne.us","nh.us","nj.us","nm.us","nv.us","ny.us","oh.us","ok.us","or.us","pa.us","pr.us","ri.us","sc.us","sd.us","tn.us","tx.us","ut.us","vi.us","vt.us","va.us","wa.us","wi.us","wv.us","wy.us","k12.ak.us","k12.al.us","k12.ar.us","k12.as.us","k12.az.us","k12.ca.us","k12.co.us","k12.ct.us","k12.dc.us","k12.de.us","k12.fl.us","k12.ga.us","k12.gu.us","k12.ia.us","k12.id.us","k12.il.us","k12.in.us","k12.ks.us","k12.ky.us","k12.la.us","k12.ma.us","k12.md.us","k12.me.us","k12.mi.us","k12.mn.us","k12.mo.us","k12.ms.us","k12.mt.us","k12.nc.us","k12.ne.us","k12.nh.us","k12.nj.us","k12.nm.us","k12.nv.us","k12.ny.us","k12.oh.us","k12.ok.us","k12.or.us","k12.pa.us","k12.pr.us","k12.sc.us","k12.tn.us","k12.tx.us","k12.ut.us","k12.vi.us","k12.vt.us","k12.va.us","k12.wa.us","k12.wi.us","k12.wy.us","cc.ak.us","cc.al.us","cc.ar.us","cc.as.us","cc.az.us","cc.ca.us","cc.co.us","cc.ct.us","cc.dc.us","cc.de.us","cc.fl.us","cc.ga.us","cc.gu.us","cc.hi.us","cc.ia.us","cc.id.us","cc.il.us","cc.in.us","cc.ks.us","cc.ky.us","cc.la.us","cc.ma.us","cc.md.us","cc.me.us","cc.mi.us","cc.mn.us","cc.mo.us","cc.ms.us","cc.mt.us","cc.nc.us","cc.nd.us","cc.ne.us","cc.nh.us","cc.nj.us","cc.nm.us","cc.nv.us","cc.ny.us","cc.oh.us","cc.ok.us","cc.or.us","cc.pa.us","cc.pr.us","cc.ri.us","cc.sc.us","cc.sd.us","cc.tn.us","cc.tx.us","cc.ut.us","cc.vi.us","cc.vt.us","cc.va.us","cc.wa.us","cc.wi.us","cc.wv.us","cc.wy.us","lib.ak.us","lib.al.us","lib.ar.us","lib.as.us","lib.az.us","lib.ca.us","lib.co.us","lib.ct.us","lib.dc.us","lib.fl.us","lib.ga.us","lib.gu.us","lib.hi.us","lib.ia.us","lib.id.us","lib.il.us","lib.in.us","lib.ks.us","lib.ky.us","lib.la.us","lib.ma.us","lib.md.us","lib.me.us","lib.mi.us","lib.mn.us","lib.mo.us","lib.ms.us","lib.mt.us","lib.nc.us","lib.nd.us","lib.ne.us","lib.nh.us","lib.nj.us","lib.nm.us","lib.nv.us","lib.ny.us","lib.oh.us","lib.ok.us","lib.or.us","lib.pa.us","lib.pr.us","lib.ri.us","lib.sc.us","lib.sd.us","lib.tn.us","lib.tx.us","lib.ut.us","lib.vi.us","lib.vt.us","lib.va.us","lib.wa.us","lib.wi.us","lib.wy.us","pvt.k12.ma.us","chtr.k12.ma.us","paroch.k12.ma.us","ann-arbor.mi.us","cog.mi.us","dst.mi.us","eaton.mi.us","gen.mi.us","mus.mi.us","tec.mi.us","washtenaw.mi.us","uy","com.uy","edu.uy","gub.uy","mil.uy","net.uy","org.uy","uz","co.uz","com.uz","net.uz","org.uz","va","vc","com.vc","net.vc","org.vc","gov.vc","mil.vc","edu.vc","ve","arts.ve","bib.ve","co.ve","com.ve","e12.ve","edu.ve","firm.ve","gob.ve","gov.ve","info.ve","int.ve","mil.ve","net.ve","nom.ve","org.ve","rar.ve","rec.ve","store.ve","tec.ve","web.ve","vg","vi","co.vi","com.vi","k12.vi","net.vi","org.vi","vn","com.vn","net.vn","org.vn","edu.vn","gov.vn","int.vn","ac.vn","biz.vn","info.vn","name.vn","pro.vn","health.vn","vu","com.vu","edu.vu","net.vu","org.vu","wf","ws","com.ws","net.ws","org.ws","gov.ws","edu.ws","yt","امارات","հայ","বাংলা","бг","البحرين","бел","中国","中國","الجزائر","مصر","ею","ευ","موريتانيا","გე","ελ","香港","公司.香港","教育.香港","政府.香港","個人.香港","網絡.香港","組織.香港","ಭಾರತ","ଭାରତ","ভাৰত","भारतम्","भारोत","ڀارت","ഭാരതം","भारत","بارت","بھارت","భారత్","ભારત","ਭਾਰਤ","ভারত","இந்தியா","ایران","ايران","عراق","الاردن","한국","қаз","ລາວ","ලංකා","இலங்கை","المغرب","мкд","мон","澳門","澳门","مليسيا","عمان","پاکستان","پاكستان","فلسطين","срб","пр.срб","орг.срб","обр.срб","од.срб","упр.срб","ак.срб","рф","قطر","السعودية","السعودیة","السعودیۃ","السعوديه","سودان","新加坡","சிங்கப்பூர்","سورية","سوريا","ไทย","ศึกษา.ไทย","ธุรกิจ.ไทย","รัฐบาล.ไทย","ทหาร.ไทย","เน็ต.ไทย","องค์กร.ไทย","تونس","台灣","台湾","臺灣","укр","اليمن","xxx","ye","com.ye","edu.ye","gov.ye","net.ye","mil.ye","org.ye","ac.za","agric.za","alt.za","co.za","edu.za","gov.za","grondar.za","law.za","mil.za","net.za","ngo.za","nic.za","nis.za","nom.za","org.za","school.za","tm.za","web.za","zm","ac.zm","biz.zm","co.zm","com.zm","edu.zm","gov.zm","info.zm","mil.zm","net.zm","org.zm","sch.zm","zw","ac.zw","co.zw","gov.zw","mil.zw","org.zw","aaa","aarp","abarth","abb","abbott","abbvie","abc","able","abogado","abudhabi","academy","accenture","accountant","accountants","aco","actor","adac","ads","adult","aeg","aetna","afl","africa","agakhan","agency","aig","airbus","airforce","airtel","akdn","alfaromeo","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","amazon","americanexpress","americanfamily","amex","amfam","amica","amsterdam","analytics","android","anquan","anz","aol","apartments","app","apple","aquarelle","arab","aramco","archi","army","art","arte","asda","associates","athleta","attorney","auction","audi","audible","audio","auspost","author","auto","autos","avianca","aws","axa","azure","baby","baidu","banamex","bananarepublic","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bbc","bbt","bbva","bcg","bcn","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bharti","bible","bid","bike","bing","bingo","bio","black","blackfriday","blockbuster","blog","bloomberg","blue","bms","bmw","bnpparibas","boats","boehringer","bofa","bom","bond","boo","book","booking","bosch","bostik","boston","bot","boutique","box","bradesco","bridgestone","broadway","broker","brother","brussels","bugatti","build","builders","business","buy","buzz","bzh","cab","cafe","cal","call","calvinklein","cam","camera","camp","cancerresearch","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","casa","case","cash","casino","catering","catholic","cba","cbn","cbre","cbs","center","ceo","cern","cfa","cfd","chanel","channel","charity","chase","chat","cheap","chintai","christmas","chrome","church","cipriani","circle","cisco","citadel","citi","citic","city","cityeats","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","coach","codes","coffee","college","cologne","comcast","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cookingchannel","cool","corsica","country","coupon","coupons","courses","cpa","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","cuisinella","cymru","cyou","dabur","dad","dance","data","date","dating","datsun","day","dclk","dds","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dnp","docs","doctor","dog","domains","dot","download","drive","dtv","dubai","dunlop","dupont","durban","dvag","dvr","earth","eat","eco","edeka","education","email","emerck","energy","engineer","engineering","enterprises","epson","equipment","ericsson","erni","esq","estate","etisalat","eurovision","eus","events","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fiat","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","flickr","flights","flir","florist","flowers","fly","foo","food","foodnetwork","football","ford","forex","forsale","forum","foundation","fox","free","fresenius","frl","frogans","frontdoor","frontier","ftr","fujitsu","fun","fund","furniture","futbol","fyi","gal","gallery","gallo","gallup","game","games","gap","garden","gay","gbiz","gdn","gea","gent","genting","george","ggee","gift","gifts","gives","giving","glass","gle","global","globo","gmail","gmbh","gmo","gmx","godaddy","gold","goldpoint","golf","goo","goodyear","goog","google","gop","got","grainger","graphics","gratis","green","gripe","grocery","group","guardian","gucci","guge","guide","guitars","guru","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hgtv","hiphop","hisamitsu","hitachi","hiv","hkt","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","horse","hospital","host","hosting","hot","hoteles","hotels","hotmail","house","how","hsbc","hughes","hyatt","hyundai","ibm","icbc","ice","icu","ieee","ifm","ikano","imamat","imdb","immo","immobilien","inc","industries","infiniti","ing","ink","institute","insurance","insure","international","intuit","investments","ipiranga","irish","ismaili","ist","istanbul","itau","itv","jaguar","java","jcb","jeep","jetzt","jewelry","jio","jll","jmp","jnj","joburg","jot","joy","jpmorgan","jprs","juegos","juniper","kaufen","kddi","kerryhotels","kerrylogistics","kerryproperties","kfh","kia","kids","kim","kinder","kindle","kitchen","kiwi","koeln","komatsu","kosher","kpmg","kpn","krd","kred","kuokgroup","kyoto","lacaixa","lamborghini","lamer","lancaster","lancia","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","linde","link","lipsy","live","living","llc","llp","loan","loans","locker","locus","loft","lol","london","lotte","lotto","love","lpl","lplfinancial","ltd","ltda","lundbeck","luxe","luxury","macys","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","maserati","mattel","mba","mckinsey","med","media","meet","melbourne","meme","memorial","men","menu","merckmsd","miami","microsoft","mini","mint","mit","mitsubishi","mlb","mls","mma","mobile","moda","moe","moi","mom","monash","money","monster","mormon","mortgage","moscow","moto","motorcycles","mov","movie","msd","mtn","mtr","music","mutual","nab","nagoya","natura","navy","nba","nec","netbank","netflix","network","neustar","new","news","next","nextdirect","nexus","nfl","ngo","nhk","nico","nike","nikon","ninja","nissan","nissay","nokia","northwesternmutual","norton","now","nowruz","nowtv","nra","nrw","ntt","nyc","obi","observer","office","okinawa","olayan","olayangroup","oldnavy","ollo","omega","one","ong","onl","online","ooo","open","oracle","orange","organic","origins","osaka","otsuka","ott","ovh","page","panasonic","paris","pars","partners","parts","party","passagens","pay","pccw","pet","pfizer","pharmacy","phd","philips","phone","photo","photography","photos","physio","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","place","play","playstation","plumbing","plus","pnc","pohl","poker","politie","porn","pramerica","praxi","press","prime","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","pub","pwc","qpon","quebec","quest","racing","radio","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","ril","rio","rip","rocher","rocks","rodeo","rogers","room","rsvp","rugby","ruhr","run","rwe","ryukyu","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sarl","sas","save","saxo","sbi","sbs","sca","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scot","search","seat","secure","security","seek","select","sener","services","ses","seven","sew","sex","sexy","sfr","shangrila","sharp","shaw","shell","shia","shiksha","shoes","shop","shopping","shouji","show","showtime","silk","sina","singles","site","ski","skin","sky","skype","sling","smart","smile","sncf","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","spa","space","sport","spot","srl","stada","staples","star","statebank","statefarm","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","sucks","supplies","supply","support","surf","surgery","suzuki","swatch","swiss","sydney","systems","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tci","tdk","team","tech","technology","temasek","tennis","teva","thd","theater","theatre","tiaa","tickets","tienda","tiffany","tips","tires","tirol","tjmaxx","tjx","tkmaxx","tmall","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","trade","trading","training","travel","travelchannel","travelers","travelersinsurance","trust","trv","tube","tui","tunes","tushu","tvs","ubank","ubs","unicom","university","uno","uol","ups","vacations","vana","vanguard","vegas","ventures","verisign","versicherung","vet","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","viva","vivo","vlaanderen","vodka","volkswagen","volvo","vote","voting","voto","voyage","vuelos","wales","walmart","walter","wang","wanggou","watch","watches","weather","weatherchannel","webcam","weber","website","wedding","weibo","weir","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","wtc","wtf","xbox","xerox","xfinity","xihuan","xin","कॉम","セール","佛山","慈善","集团","在线","点看","คอม","八卦","موقع","公益","公司","香格里拉","网站","移动","我爱你","москва","католик","онлайн","сайт","联通","קום","时尚","微博","淡马锡","ファッション","орг","नेट","ストア","アマゾン","삼성","商标","商店","商城","дети","ポイント","新闻","家電","كوم","中文网","中信","娱乐","谷歌","電訊盈科","购物","クラウド","通販","网店","संगठन","餐厅","网络","ком","亚马逊","诺基亚","食品","飞利浦","手机","ارامكو","العليان","اتصالات","بازار","ابوظبي","كاثوليك","همراه","닷컴","政府","شبكة","بيتك","عرب","机构","组织机构","健康","招聘","рус","大拿","みんな","グーグル","世界","書籍","网址","닷넷","コム","天主教","游戏","vermögensberater","vermögensberatung","企业","信息","嘉里大酒店","嘉里","广东","政务","xyz","yachts","yahoo","yamaxun","yandex","yodobashi","yoga","yokohama","you","youtube","yun","zappos","zara","zero","zip","zone","zuerich","cc.ua","inf.ua","ltd.ua","611.to","graphox.us","*.devcdnaccesso.com","adobeaemcloud.com","*.dev.adobeaemcloud.com","hlx.live","adobeaemcloud.net","hlx.page","hlx3.page","beep.pl","airkitapps.com","airkitapps-au.com","airkitapps.eu","aivencloud.com","barsy.ca","*.compute.estate","*.alces.network","kasserver.com","altervista.org","alwaysdata.net","cloudfront.net","*.compute.amazonaws.com","*.compute-1.amazonaws.com","*.compute.amazonaws.com.cn","us-east-1.amazonaws.com","cn-north-1.eb.amazonaws.com.cn","cn-northwest-1.eb.amazonaws.com.cn","elasticbeanstalk.com","ap-northeast-1.elasticbeanstalk.com","ap-northeast-2.elasticbeanstalk.com","ap-northeast-3.elasticbeanstalk.com","ap-south-1.elasticbeanstalk.com","ap-southeast-1.elasticbeanstalk.com","ap-southeast-2.elasticbeanstalk.com","ca-central-1.elasticbeanstalk.com","eu-central-1.elasticbeanstalk.com","eu-west-1.elasticbeanstalk.com","eu-west-2.elasticbeanstalk.com","eu-west-3.elasticbeanstalk.com","sa-east-1.elasticbeanstalk.com","us-east-1.elasticbeanstalk.com","us-east-2.elasticbeanstalk.com","us-gov-west-1.elasticbeanstalk.com","us-west-1.elasticbeanstalk.com","us-west-2.elasticbeanstalk.com","*.elb.amazonaws.com","*.elb.amazonaws.com.cn","awsglobalaccelerator.com","s3.amazonaws.com","s3-ap-northeast-1.amazonaws.com","s3-ap-northeast-2.amazonaws.com","s3-ap-south-1.amazonaws.com","s3-ap-southeast-1.amazonaws.com","s3-ap-southeast-2.amazonaws.com","s3-ca-central-1.amazonaws.com","s3-eu-central-1.amazonaws.com","s3-eu-west-1.amazonaws.com","s3-eu-west-2.amazonaws.com","s3-eu-west-3.amazonaws.com","s3-external-1.amazonaws.com","s3-fips-us-gov-west-1.amazonaws.com","s3-sa-east-1.amazonaws.com","s3-us-gov-west-1.amazonaws.com","s3-us-east-2.amazonaws.com","s3-us-west-1.amazonaws.com","s3-us-west-2.amazonaws.com","s3.ap-northeast-2.amazonaws.com","s3.ap-south-1.amazonaws.com","s3.cn-north-1.amazonaws.com.cn","s3.ca-central-1.amazonaws.com","s3.eu-central-1.amazonaws.com","s3.eu-west-2.amazonaws.com","s3.eu-west-3.amazonaws.com","s3.us-east-2.amazonaws.com","s3.dualstack.ap-northeast-1.amazonaws.com","s3.dualstack.ap-northeast-2.amazonaws.com","s3.dualstack.ap-south-1.amazonaws.com","s3.dualstack.ap-southeast-1.amazonaws.com","s3.dualstack.ap-southeast-2.amazonaws.com","s3.dualstack.ca-central-1.amazonaws.com","s3.dualstack.eu-central-1.amazonaws.com","s3.dualstack.eu-west-1.amazonaws.com","s3.dualstack.eu-west-2.amazonaws.com","s3.dualstack.eu-west-3.amazonaws.com","s3.dualstack.sa-east-1.amazonaws.com","s3.dualstack.us-east-1.amazonaws.com","s3.dualstack.us-east-2.amazonaws.com","s3-website-us-east-1.amazonaws.com","s3-website-us-west-1.amazonaws.com","s3-website-us-west-2.amazonaws.com","s3-website-ap-northeast-1.amazonaws.com","s3-website-ap-southeast-1.amazonaws.com","s3-website-ap-southeast-2.amazonaws.com","s3-website-eu-west-1.amazonaws.com","s3-website-sa-east-1.amazonaws.com","s3-website.ap-northeast-2.amazonaws.com","s3-website.ap-south-1.amazonaws.com","s3-website.ca-central-1.amazonaws.com","s3-website.eu-central-1.amazonaws.com","s3-website.eu-west-2.amazonaws.com","s3-website.eu-west-3.amazonaws.com","s3-website.us-east-2.amazonaws.com","t3l3p0rt.net","tele.amune.org","apigee.io","siiites.com","appspacehosted.com","appspaceusercontent.com","appudo.net","on-aptible.com","user.aseinet.ne.jp","gv.vc","d.gv.vc","user.party.eus","pimienta.org","poivron.org","potager.org","sweetpepper.org","myasustor.com","cdn.prod.atlassian-dev.net","translated.page","myfritz.net","onavstack.net","*.awdev.ca","*.advisor.ws","ecommerce-shop.pl","b-data.io","backplaneapp.io","balena-devices.com","rs.ba","*.banzai.cloud","app.banzaicloud.io","*.backyards.banzaicloud.io","base.ec","official.ec","buyshop.jp","fashionstore.jp","handcrafted.jp","kawaiishop.jp","supersale.jp","theshop.jp","shopselect.net","base.shop","*.beget.app","betainabox.com","bnr.la","bitbucket.io","blackbaudcdn.net","of.je","bluebite.io","boomla.net","boutir.com","boxfuse.io","square7.ch","bplaced.com","bplaced.de","square7.de","bplaced.net","square7.net","shop.brendly.rs","browsersafetymark.io","uk0.bigv.io","dh.bytemark.co.uk","vm.bytemark.co.uk","cafjs.com","mycd.eu","drr.ac","uwu.ai","carrd.co","crd.co","ju.mp","ae.org","br.com","cn.com","com.de","com.se","de.com","eu.com","gb.net","hu.net","jp.net","jpn.com","mex.com","ru.com","sa.com","se.net","uk.com","uk.net","us.com","za.bz","za.com","ar.com","hu.com","kr.com","no.com","qc.com","uy.com","africa.com","gr.com","in.net","web.in","us.org","co.com","aus.basketball","nz.basketball","radio.am","radio.fm","c.la","certmgr.org","cx.ua","discourse.group","discourse.team","cleverapps.io","clerk.app","clerkstage.app","*.lcl.dev","*.lclstage.dev","*.stg.dev","*.stgstage.dev","clickrising.net","c66.me","cloud66.ws","cloud66.zone","jdevcloud.com","wpdevcloud.com","cloudaccess.host","freesite.host","cloudaccess.net","cloudcontrolled.com","cloudcontrolapp.com","*.cloudera.site","pages.dev","trycloudflare.com","workers.dev","wnext.app","co.ca","*.otap.co","co.cz","c.cdn77.org","cdn77-ssl.net","r.cdn77.net","rsc.cdn77.org","ssl.origin.cdn77-secure.org","cloudns.asia","cloudns.biz","cloudns.club","cloudns.cc","cloudns.eu","cloudns.in","cloudns.info","cloudns.org","cloudns.pro","cloudns.pw","cloudns.us","cnpy.gdn","codeberg.page","co.nl","co.no","webhosting.be","hosting-cluster.nl","ac.ru","edu.ru","gov.ru","int.ru","mil.ru","test.ru","dyn.cosidns.de","dynamisches-dns.de","dnsupdater.de","internet-dns.de","l-o-g-i-n.de","dynamic-dns.info","feste-ip.net","knx-server.net","static-access.net","realm.cz","*.cryptonomic.net","cupcake.is","curv.dev","*.customer-oci.com","*.oci.customer-oci.com","*.ocp.customer-oci.com","*.ocs.customer-oci.com","cyon.link","cyon.site","fnwk.site","folionetwork.site","platform0.app","daplie.me","localhost.daplie.me","dattolocal.com","dattorelay.com","dattoweb.com","mydatto.com","dattolocal.net","mydatto.net","biz.dk","co.dk","firm.dk","reg.dk","store.dk","dyndns.dappnode.io","*.dapps.earth","*.bzz.dapps.earth","builtwithdark.com","demo.datadetect.com","instance.datadetect.com","edgestack.me","ddns5.com","debian.net","deno.dev","deno-staging.dev","dedyn.io","deta.app","deta.dev","*.rss.my.id","*.diher.solutions","discordsays.com","discordsez.com","jozi.biz","dnshome.de","online.th","shop.th","drayddns.com","shoparena.pl","dreamhosters.com","mydrobo.com","drud.io","drud.us","duckdns.org","bip.sh","bitbridge.net","dy.fi","tunk.org","dyndns-at-home.com","dyndns-at-work.com","dyndns-blog.com","dyndns-free.com","dyndns-home.com","dyndns-ip.com","dyndns-mail.com","dyndns-office.com","dyndns-pics.com","dyndns-remote.com","dyndns-server.com","dyndns-web.com","dyndns-wiki.com","dyndns-work.com","dyndns.biz","dyndns.info","dyndns.org","dyndns.tv","at-band-camp.net","ath.cx","barrel-of-knowledge.info","barrell-of-knowledge.info","better-than.tv","blogdns.com","blogdns.net","blogdns.org","blogsite.org","boldlygoingnowhere.org","broke-it.net","buyshouses.net","cechire.com","dnsalias.com","dnsalias.net","dnsalias.org","dnsdojo.com","dnsdojo.net","dnsdojo.org","does-it.net","doesntexist.com","doesntexist.org","dontexist.com","dontexist.net","dontexist.org","doomdns.com","doomdns.org","dvrdns.org","dyn-o-saur.com","dynalias.com","dynalias.net","dynalias.org","dynathome.net","dyndns.ws","endofinternet.net","endofinternet.org","endoftheinternet.org","est-a-la-maison.com","est-a-la-masion.com","est-le-patron.com","est-mon-blogueur.com","for-better.biz","for-more.biz","for-our.info","for-some.biz","for-the.biz","forgot.her.name","forgot.his.name","from-ak.com","from-al.com","from-ar.com","from-az.net","from-ca.com","from-co.net","from-ct.com","from-dc.com","from-de.com","from-fl.com","from-ga.com","from-hi.com","from-ia.com","from-id.com","from-il.com","from-in.com","from-ks.com","from-ky.com","from-la.net","from-ma.com","from-md.com","from-me.org","from-mi.com","from-mn.com","from-mo.com","from-ms.com","from-mt.com","from-nc.com","from-nd.com","from-ne.com","from-nh.com","from-nj.com","from-nm.com","from-nv.com","from-ny.net","from-oh.com","from-ok.com","from-or.com","from-pa.com","from-pr.com","from-ri.com","from-sc.com","from-sd.com","from-tn.com","from-tx.com","from-ut.com","from-va.com","from-vt.com","from-wa.com","from-wi.com","from-wv.com","from-wy.com","ftpaccess.cc","fuettertdasnetz.de","game-host.org","game-server.cc","getmyip.com","gets-it.net","go.dyndns.org","gotdns.com","gotdns.org","groks-the.info","groks-this.info","ham-radio-op.net","here-for-more.info","hobby-site.com","hobby-site.org","home.dyndns.org","homedns.org","homeftp.net","homeftp.org","homeip.net","homelinux.com","homelinux.net","homelinux.org","homeunix.com","homeunix.net","homeunix.org","iamallama.com","in-the-band.net","is-a-anarchist.com","is-a-blogger.com","is-a-bookkeeper.com","is-a-bruinsfan.org","is-a-bulls-fan.com","is-a-candidate.org","is-a-caterer.com","is-a-celticsfan.org","is-a-chef.com","is-a-chef.net","is-a-chef.org","is-a-conservative.com","is-a-cpa.com","is-a-cubicle-slave.com","is-a-democrat.com","is-a-designer.com","is-a-doctor.com","is-a-financialadvisor.com","is-a-geek.com","is-a-geek.net","is-a-geek.org","is-a-green.com","is-a-guru.com","is-a-hard-worker.com","is-a-hunter.com","is-a-knight.org","is-a-landscaper.com","is-a-lawyer.com","is-a-liberal.com","is-a-libertarian.com","is-a-linux-user.org","is-a-llama.com","is-a-musician.com","is-a-nascarfan.com","is-a-nurse.com","is-a-painter.com","is-a-patsfan.org","is-a-personaltrainer.com","is-a-photographer.com","is-a-player.com","is-a-republican.com","is-a-rockstar.com","is-a-socialist.com","is-a-soxfan.org","is-a-student.com","is-a-teacher.com","is-a-techie.com","is-a-therapist.com","is-an-accountant.com","is-an-actor.com","is-an-actress.com","is-an-anarchist.com","is-an-artist.com","is-an-engineer.com","is-an-entertainer.com","is-by.us","is-certified.com","is-found.org","is-gone.com","is-into-anime.com","is-into-cars.com","is-into-cartoons.com","is-into-games.com","is-leet.com","is-lost.org","is-not-certified.com","is-saved.org","is-slick.com","is-uberleet.com","is-very-bad.org","is-very-evil.org","is-very-good.org","is-very-nice.org","is-very-sweet.org","is-with-theband.com","isa-geek.com","isa-geek.net","isa-geek.org","isa-hockeynut.com","issmarterthanyou.com","isteingeek.de","istmein.de","kicks-ass.net","kicks-ass.org","knowsitall.info","land-4-sale.us","lebtimnetz.de","leitungsen.de","likes-pie.com","likescandy.com","merseine.nu","mine.nu","misconfused.org","mypets.ws","myphotos.cc","neat-url.com","office-on-the.net","on-the-web.tv","podzone.net","podzone.org","readmyblog.org","saves-the-whales.com","scrapper-site.net","scrapping.cc","selfip.biz","selfip.com","selfip.info","selfip.net","selfip.org","sells-for-less.com","sells-for-u.com","sells-it.net","sellsyourhome.org","servebbs.com","servebbs.net","servebbs.org","serveftp.net","serveftp.org","servegame.org","shacknet.nu","simple-url.com","space-to-rent.com","stuff-4-sale.org","stuff-4-sale.us","teaches-yoga.com","thruhere.net","traeumtgerade.de","webhop.biz","webhop.info","webhop.net","webhop.org","worse-than.tv","writesthisblog.com","ddnss.de","dyn.ddnss.de","dyndns.ddnss.de","dyndns1.de","dyn-ip24.de","home-webserver.de","dyn.home-webserver.de","myhome-server.de","ddnss.org","definima.net","definima.io","ondigitalocean.app","*.digitaloceanspaces.com","bci.dnstrace.pro","ddnsfree.com","ddnsgeek.com","giize.com","gleeze.com","kozow.com","loseyourip.com","ooguy.com","theworkpc.com","casacam.net","dynu.net","accesscam.org","camdvr.org","freeddns.org","mywire.org","webredirect.org","myddns.rocks","blogsite.xyz","dynv6.net","e4.cz","eero.online","eero-stage.online","elementor.cloud","elementor.cool","en-root.fr","mytuleap.com","tuleap-partners.com","encr.app","encoreapi.com","onred.one","staging.onred.one","eu.encoway.cloud","eu.org","al.eu.org","asso.eu.org","at.eu.org","au.eu.org","be.eu.org","bg.eu.org","ca.eu.org","cd.eu.org","ch.eu.org","cn.eu.org","cy.eu.org","cz.eu.org","de.eu.org","dk.eu.org","edu.eu.org","ee.eu.org","es.eu.org","fi.eu.org","fr.eu.org","gr.eu.org","hr.eu.org","hu.eu.org","ie.eu.org","il.eu.org","in.eu.org","int.eu.org","is.eu.org","it.eu.org","jp.eu.org","kr.eu.org","lt.eu.org","lu.eu.org","lv.eu.org","mc.eu.org","me.eu.org","mk.eu.org","mt.eu.org","my.eu.org","net.eu.org","ng.eu.org","nl.eu.org","no.eu.org","nz.eu.org","paris.eu.org","pl.eu.org","pt.eu.org","q-a.eu.org","ro.eu.org","ru.eu.org","se.eu.org","si.eu.org","sk.eu.org","tr.eu.org","uk.eu.org","us.eu.org","eurodir.ru","eu-1.evennode.com","eu-2.evennode.com","eu-3.evennode.com","eu-4.evennode.com","us-1.evennode.com","us-2.evennode.com","us-3.evennode.com","us-4.evennode.com","twmail.cc","twmail.net","twmail.org","mymailer.com.tw","url.tw","onfabrica.com","apps.fbsbx.com","ru.net","adygeya.ru","bashkiria.ru","bir.ru","cbg.ru","com.ru","dagestan.ru","grozny.ru","kalmykia.ru","kustanai.ru","marine.ru","mordovia.ru","msk.ru","mytis.ru","nalchik.ru","nov.ru","pyatigorsk.ru","spb.ru","vladikavkaz.ru","vladimir.ru","abkhazia.su","adygeya.su","aktyubinsk.su","arkhangelsk.su","armenia.su","ashgabad.su","azerbaijan.su","balashov.su","bashkiria.su","bryansk.su","bukhara.su","chimkent.su","dagestan.su","east-kazakhstan.su","exnet.su","georgia.su","grozny.su","ivanovo.su","jambyl.su","kalmykia.su","kaluga.su","karacol.su","karaganda.su","karelia.su","khakassia.su","krasnodar.su","kurgan.su","kustanai.su","lenug.su","mangyshlak.su","mordovia.su","msk.su","murmansk.su","nalchik.su","navoi.su","north-kazakhstan.su","nov.su","obninsk.su","penza.su","pokrovsk.su","sochi.su","spb.su","tashkent.su","termez.su","togliatti.su","troitsk.su","tselinograd.su","tula.su","tuva.su","vladikavkaz.su","vladimir.su","vologda.su","channelsdvr.net","u.channelsdvr.net","edgecompute.app","fastly-terrarium.com","fastlylb.net","map.fastlylb.net","freetls.fastly.net","map.fastly.net","a.prod.fastly.net","global.prod.fastly.net","a.ssl.fastly.net","b.ssl.fastly.net","global.ssl.fastly.net","fastvps-server.com","fastvps.host","myfast.host","fastvps.site","myfast.space","fedorainfracloud.org","fedorapeople.org","cloud.fedoraproject.org","app.os.fedoraproject.org","app.os.stg.fedoraproject.org","conn.uk","copro.uk","hosp.uk","mydobiss.com","fh-muenster.io","filegear.me","filegear-au.me","filegear-de.me","filegear-gb.me","filegear-ie.me","filegear-jp.me","filegear-sg.me","firebaseapp.com","fireweb.app","flap.id","onflashdrive.app","fldrv.com","fly.dev","edgeapp.net","shw.io","flynnhosting.net","forgeblocks.com","id.forgerock.io","framer.app","framercanvas.com","*.frusky.de","ravpage.co.il","0e.vc","freebox-os.com","freeboxos.com","fbx-os.fr","fbxos.fr","freebox-os.fr","freeboxos.fr","freedesktop.org","freemyip.com","wien.funkfeuer.at","*.futurecms.at","*.ex.futurecms.at","*.in.futurecms.at","futurehosting.at","futuremailing.at","*.ex.ortsinfo.at","*.kunden.ortsinfo.at","*.statics.cloud","independent-commission.uk","independent-inquest.uk","independent-inquiry.uk","independent-panel.uk","independent-review.uk","public-inquiry.uk","royal-commission.uk","campaign.gov.uk","service.gov.uk","api.gov.uk","gehirn.ne.jp","usercontent.jp","gentapps.com","gentlentapis.com","lab.ms","cdn-edges.net","ghost.io","gsj.bz","githubusercontent.com","githubpreview.dev","github.io","gitlab.io","gitapp.si","gitpage.si","glitch.me","nog.community","co.ro","shop.ro","lolipop.io","angry.jp","babyblue.jp","babymilk.jp","backdrop.jp","bambina.jp","bitter.jp","blush.jp","boo.jp","boy.jp","boyfriend.jp","but.jp","candypop.jp","capoo.jp","catfood.jp","cheap.jp","chicappa.jp","chillout.jp","chips.jp","chowder.jp","chu.jp","ciao.jp","cocotte.jp","coolblog.jp","cranky.jp","cutegirl.jp","daa.jp","deca.jp","deci.jp","digick.jp","egoism.jp","fakefur.jp","fem.jp","flier.jp","floppy.jp","fool.jp","frenchkiss.jp","girlfriend.jp","girly.jp","gloomy.jp","gonna.jp","greater.jp","hacca.jp","heavy.jp","her.jp","hiho.jp","hippy.jp","holy.jp","hungry.jp","icurus.jp","itigo.jp","jellybean.jp","kikirara.jp","kill.jp","kilo.jp","kuron.jp","littlestar.jp","lolipopmc.jp","lolitapunk.jp","lomo.jp","lovepop.jp","lovesick.jp","main.jp","mods.jp","mond.jp","mongolian.jp","moo.jp","namaste.jp","nikita.jp","nobushi.jp","noor.jp","oops.jp","parallel.jp","parasite.jp","pecori.jp","peewee.jp","penne.jp","pepper.jp","perma.jp","pigboat.jp","pinoko.jp","punyu.jp","pupu.jp","pussycat.jp","pya.jp","raindrop.jp","readymade.jp","sadist.jp","schoolbus.jp","secret.jp","staba.jp","stripper.jp","sub.jp","sunnyday.jp","thick.jp","tonkotsu.jp","under.jp","upper.jp","velvet.jp","verse.jp","versus.jp","vivian.jp","watson.jp","weblike.jp","whitesnow.jp","zombie.jp","heteml.net","cloudapps.digital","london.cloudapps.digital","pymnt.uk","homeoffice.gov.uk","ro.im","goip.de","run.app","a.run.app","web.app","*.0emm.com","appspot.com","*.r.appspot.com","codespot.com","googleapis.com","googlecode.com","pagespeedmobilizer.com","publishproxy.com","withgoogle.com","withyoutube.com","*.gateway.dev","cloud.goog","translate.goog","*.usercontent.goog","cloudfunctions.net","blogspot.ae","blogspot.al","blogspot.am","blogspot.ba","blogspot.be","blogspot.bg","blogspot.bj","blogspot.ca","blogspot.cf","blogspot.ch","blogspot.cl","blogspot.co.at","blogspot.co.id","blogspot.co.il","blogspot.co.ke","blogspot.co.nz","blogspot.co.uk","blogspot.co.za","blogspot.com","blogspot.com.ar","blogspot.com.au","blogspot.com.br","blogspot.com.by","blogspot.com.co","blogspot.com.cy","blogspot.com.ee","blogspot.com.eg","blogspot.com.es","blogspot.com.mt","blogspot.com.ng","blogspot.com.tr","blogspot.com.uy","blogspot.cv","blogspot.cz","blogspot.de","blogspot.dk","blogspot.fi","blogspot.fr","blogspot.gr","blogspot.hk","blogspot.hr","blogspot.hu","blogspot.ie","blogspot.in","blogspot.is","blogspot.it","blogspot.jp","blogspot.kr","blogspot.li","blogspot.lt","blogspot.lu","blogspot.md","blogspot.mk","blogspot.mr","blogspot.mx","blogspot.my","blogspot.nl","blogspot.no","blogspot.pe","blogspot.pt","blogspot.qa","blogspot.re","blogspot.ro","blogspot.rs","blogspot.ru","blogspot.se","blogspot.sg","blogspot.si","blogspot.sk","blogspot.sn","blogspot.td","blogspot.tw","blogspot.ug","blogspot.vn","goupile.fr","gov.nl","awsmppl.com","günstigbestellen.de","günstigliefern.de","fin.ci","free.hr","caa.li","ua.rs","conf.se","hs.zone","hs.run","hashbang.sh","hasura.app","hasura-app.io","pages.it.hs-heilbronn.de","hepforge.org","herokuapp.com","herokussl.com","ravendb.cloud","myravendb.com","ravendb.community","ravendb.me","development.run","ravendb.run","homesklep.pl","secaas.hk","hoplix.shop","orx.biz","biz.gl","col.ng","firm.ng","gen.ng","ltd.ng","ngo.ng","edu.scot","sch.so","hostyhosting.io","häkkinen.fi","*.moonscale.io","moonscale.net","iki.fi","ibxos.it","iliadboxos.it","impertrixcdn.com","impertrix.com","smushcdn.com","wphostedmail.com","wpmucdn.com","tempurl.host","wpmudev.host","dyn-berlin.de","in-berlin.de","in-brb.de","in-butter.de","in-dsl.de","in-dsl.net","in-dsl.org","in-vpn.de","in-vpn.net","in-vpn.org","biz.at","info.at","info.cx","ac.leg.br","al.leg.br","am.leg.br","ap.leg.br","ba.leg.br","ce.leg.br","df.leg.br","es.leg.br","go.leg.br","ma.leg.br","mg.leg.br","ms.leg.br","mt.leg.br","pa.leg.br","pb.leg.br","pe.leg.br","pi.leg.br","pr.leg.br","rj.leg.br","rn.leg.br","ro.leg.br","rr.leg.br","rs.leg.br","sc.leg.br","se.leg.br","sp.leg.br","to.leg.br","pixolino.com","na4u.ru","iopsys.se","ipifony.net","iservschule.de","mein-iserv.de","schulplattform.de","schulserver.de","test-iserv.de","iserv.dev","iobb.net","mel.cloudlets.com.au","cloud.interhostsolutions.be","users.scale.virtualcloud.com.br","mycloud.by","alp1.ae.flow.ch","appengine.flow.ch","es-1.axarnet.cloud","diadem.cloud","vip.jelastic.cloud","jele.cloud","it1.eur.aruba.jenv-aruba.cloud","it1.jenv-aruba.cloud","keliweb.cloud","cs.keliweb.cloud","oxa.cloud","tn.oxa.cloud","uk.oxa.cloud","primetel.cloud","uk.primetel.cloud","ca.reclaim.cloud","uk.reclaim.cloud","us.reclaim.cloud","ch.trendhosting.cloud","de.trendhosting.cloud","jele.club","amscompute.com","clicketcloud.com","dopaas.com","hidora.com","paas.hosted-by-previder.com","rag-cloud.hosteur.com","rag-cloud-ch.hosteur.com","jcloud.ik-server.com","jcloud-ver-jpc.ik-server.com","demo.jelastic.com","kilatiron.com","paas.massivegrid.com","jed.wafaicloud.com","lon.wafaicloud.com","ryd.wafaicloud.com","j.scaleforce.com.cy","jelastic.dogado.eu","fi.cloudplatform.fi","demo.datacenter.fi","paas.datacenter.fi","jele.host","mircloud.host","paas.beebyte.io","sekd1.beebyteapp.io","jele.io","cloud-fr1.unispace.io","jc.neen.it","cloud.jelastic.open.tim.it","jcloud.kz","upaas.kazteleport.kz","cloudjiffy.net","fra1-de.cloudjiffy.net","west1-us.cloudjiffy.net","jls-sto1.elastx.net","jls-sto2.elastx.net","jls-sto3.elastx.net","faststacks.net","fr-1.paas.massivegrid.net","lon-1.paas.massivegrid.net","lon-2.paas.massivegrid.net","ny-1.paas.massivegrid.net","ny-2.paas.massivegrid.net","sg-1.paas.massivegrid.net","jelastic.saveincloud.net","nordeste-idc.saveincloud.net","j.scaleforce.net","jelastic.tsukaeru.net","sdscloud.pl","unicloud.pl","mircloud.ru","jelastic.regruhosting.ru","enscaled.sg","jele.site","jelastic.team","orangecloud.tn","j.layershift.co.uk","phx.enscaled.us","mircloud.us","myjino.ru","*.hosting.myjino.ru","*.landing.myjino.ru","*.spectrum.myjino.ru","*.vps.myjino.ru","jotelulu.cloud","*.triton.zone","*.cns.joyent.com","js.org","kaas.gg","khplay.nl","ktistory.com","kapsi.fi","keymachine.de","kinghost.net","uni5.net","knightpoint.systems","koobin.events","oya.to","kuleuven.cloud","ezproxy.kuleuven.be","co.krd","edu.krd","krellian.net","webthings.io","git-repos.de","lcube-server.de","svn-repos.de","leadpages.co","lpages.co","lpusercontent.com","lelux.site","co.business","co.education","co.events","co.financial","co.network","co.place","co.technology","app.lmpm.com","linkyard.cloud","linkyard-cloud.ch","members.linode.com","*.nodebalancer.linode.com","*.linodeobjects.com","ip.linodeusercontent.com","we.bs","*.user.localcert.dev","localzone.xyz","loginline.app","loginline.dev","loginline.io","loginline.services","loginline.site","servers.run","lohmus.me","krasnik.pl","leczna.pl","lubartow.pl","lublin.pl","poniatowa.pl","swidnik.pl","glug.org.uk","lug.org.uk","lugs.org.uk","barsy.bg","barsy.co.uk","barsyonline.co.uk","barsycenter.com","barsyonline.com","barsy.club","barsy.de","barsy.eu","barsy.in","barsy.info","barsy.io","barsy.me","barsy.menu","barsy.mobi","barsy.net","barsy.online","barsy.org","barsy.pro","barsy.pub","barsy.ro","barsy.shop","barsy.site","barsy.support","barsy.uk","*.magentosite.cloud","mayfirst.info","mayfirst.org","hb.cldmail.ru","cn.vu","mazeplay.com","mcpe.me","mcdir.me","mcdir.ru","mcpre.ru","vps.mcdir.ru","mediatech.by","mediatech.dev","hra.health","miniserver.com","memset.net","messerli.app","*.cloud.metacentrum.cz","custom.metacentrum.cz","flt.cloud.muni.cz","usr.cloud.muni.cz","meteorapp.com","eu.meteorapp.com","co.pl","*.azurecontainer.io","azurewebsites.net","azure-mobile.net","cloudapp.net","azurestaticapps.net","1.azurestaticapps.net","centralus.azurestaticapps.net","eastasia.azurestaticapps.net","eastus2.azurestaticapps.net","westeurope.azurestaticapps.net","westus2.azurestaticapps.net","csx.cc","mintere.site","forte.id","mozilla-iot.org","bmoattachments.org","net.ru","org.ru","pp.ru","hostedpi.com","customer.mythic-beasts.com","caracal.mythic-beasts.com","fentiger.mythic-beasts.com","lynx.mythic-beasts.com","ocelot.mythic-beasts.com","oncilla.mythic-beasts.com","onza.mythic-beasts.com","sphinx.mythic-beasts.com","vs.mythic-beasts.com","x.mythic-beasts.com","yali.mythic-beasts.com","cust.retrosnub.co.uk","ui.nabu.casa","pony.club","of.fashion","in.london","of.london","from.marketing","with.marketing","for.men","repair.men","and.mom","for.mom","for.one","under.one","for.sale","that.win","from.work","to.work","cloud.nospamproxy.com","netlify.app","4u.com","ngrok.io","nh-serv.co.uk","nfshost.com","*.developer.app","noop.app","*.northflank.app","*.build.run","*.code.run","*.database.run","*.migration.run","noticeable.news","dnsking.ch","mypi.co","n4t.co","001www.com","ddnslive.com","myiphost.com","forumz.info","16-b.it","32-b.it","64-b.it","soundcast.me","tcp4.me","dnsup.net","hicam.net","now-dns.net","ownip.net","vpndns.net","dynserv.org","now-dns.org","x443.pw","now-dns.top","ntdll.top","freeddns.us","crafting.xyz","zapto.xyz","nsupdate.info","nerdpol.ovh","blogsyte.com","brasilia.me","cable-modem.org","ciscofreak.com","collegefan.org","couchpotatofries.org","damnserver.com","ddns.me","ditchyourip.com","dnsfor.me","dnsiskinky.com","dvrcam.info","dynns.com","eating-organic.net","fantasyleague.cc","geekgalaxy.com","golffan.us","health-carereform.com","homesecuritymac.com","homesecuritypc.com","hopto.me","ilovecollege.info","loginto.me","mlbfan.org","mmafan.biz","myactivedirectory.com","mydissent.net","myeffect.net","mymediapc.net","mypsx.net","mysecuritycamera.com","mysecuritycamera.net","mysecuritycamera.org","net-freaks.com","nflfan.org","nhlfan.net","no-ip.ca","no-ip.co.uk","no-ip.net","noip.us","onthewifi.com","pgafan.net","point2this.com","pointto.us","privatizehealthinsurance.net","quicksytes.com","read-books.org","securitytactics.com","serveexchange.com","servehumour.com","servep2p.com","servesarcasm.com","stufftoread.com","ufcfan.org","unusualperson.com","workisboring.com","3utilities.com","bounceme.net","ddns.net","ddnsking.com","gotdns.ch","hopto.org","myftp.biz","myftp.org","myvnc.com","no-ip.biz","no-ip.info","no-ip.org","noip.me","redirectme.net","servebeer.com","serveblog.net","servecounterstrike.com","serveftp.com","servegame.com","servehalflife.com","servehttp.com","serveirc.com","serveminecraft.net","servemp3.com","servepics.com","servequake.com","sytes.net","webhop.me","zapto.org","stage.nodeart.io","pcloud.host","nyc.mn","static.observableusercontent.com","cya.gg","omg.lol","cloudycluster.net","omniwe.site","service.one","nid.io","opensocial.site","opencraft.hosting","orsites.com","operaunite.com","tech.orange","authgear-staging.com","authgearapps.com","skygearapp.com","outsystemscloud.com","*.webpaas.ovh.net","*.hosting.ovh.net","ownprovider.com","own.pm","*.owo.codes","ox.rs","oy.lc","pgfog.com","pagefrontapp.com","pagexl.com","*.paywhirl.com","bar0.net","bar1.net","bar2.net","rdv.to","art.pl","gliwice.pl","krakow.pl","poznan.pl","wroc.pl","zakopane.pl","pantheonsite.io","gotpantheon.com","mypep.link","perspecta.cloud","lk3.ru","on-web.fr","bc.platform.sh","ent.platform.sh","eu.platform.sh","us.platform.sh","*.platformsh.site","*.tst.site","platter-app.com","platter-app.dev","platterp.us","pdns.page","plesk.page","pleskns.com","dyn53.io","onporter.run","co.bn","postman-echo.com","pstmn.io","mock.pstmn.io","httpbin.org","prequalifyme.today","xen.prgmr.com","priv.at","prvcy.page","*.dweb.link","protonet.io","chirurgiens-dentistes-en-france.fr","byen.site","pubtls.org","pythonanywhere.com","eu.pythonanywhere.com","qoto.io","qualifioapp.com","qbuser.com","cloudsite.builders","instances.spawn.cc","instantcloud.cn","ras.ru","qa2.com","qcx.io","*.sys.qcx.io","dev-myqnapcloud.com","alpha-myqnapcloud.com","myqnapcloud.com","*.quipelements.com","vapor.cloud","vaporcloud.io","rackmaze.com","rackmaze.net","g.vbrplsbx.io","*.on-k3s.io","*.on-rancher.cloud","*.on-rio.io","readthedocs.io","rhcloud.com","app.render.com","onrender.com","repl.co","id.repl.co","repl.run","resindevice.io","devices.resinstaging.io","hzc.io","wellbeingzone.eu","wellbeingzone.co.uk","adimo.co.uk","itcouldbewor.se","git-pages.rit.edu","rocky.page","биз.рус","ком.рус","крым.рус","мир.рус","мск.рус","орг.рус","самара.рус","сочи.рус","спб.рус","я.рус","*.builder.code.com","*.dev-builder.code.com","*.stg-builder.code.com","sandcats.io","logoip.de","logoip.com","fr-par-1.baremetal.scw.cloud","fr-par-2.baremetal.scw.cloud","nl-ams-1.baremetal.scw.cloud","fnc.fr-par.scw.cloud","functions.fnc.fr-par.scw.cloud","k8s.fr-par.scw.cloud","nodes.k8s.fr-par.scw.cloud","s3.fr-par.scw.cloud","s3-website.fr-par.scw.cloud","whm.fr-par.scw.cloud","priv.instances.scw.cloud","pub.instances.scw.cloud","k8s.scw.cloud","k8s.nl-ams.scw.cloud","nodes.k8s.nl-ams.scw.cloud","s3.nl-ams.scw.cloud","s3-website.nl-ams.scw.cloud","whm.nl-ams.scw.cloud","k8s.pl-waw.scw.cloud","nodes.k8s.pl-waw.scw.cloud","s3.pl-waw.scw.cloud","s3-website.pl-waw.scw.cloud","scalebook.scw.cloud","smartlabeling.scw.cloud","dedibox.fr","schokokeks.net","gov.scot","service.gov.scot","scrysec.com","firewall-gateway.com","firewall-gateway.de","my-gateway.de","my-router.de","spdns.de","spdns.eu","firewall-gateway.net","my-firewall.org","myfirewall.org","spdns.org","seidat.net","sellfy.store","senseering.net","minisite.ms","magnet.page","biz.ua","co.ua","pp.ua","shiftcrypto.dev","shiftcrypto.io","shiftedit.io","myshopblocks.com","myshopify.com","shopitsite.com","shopware.store","mo-siemens.io","1kapp.com","appchizi.com","applinzi.com","sinaapp.com","vipsinaapp.com","siteleaf.net","bounty-full.com","alpha.bounty-full.com","beta.bounty-full.com","small-web.org","vp4.me","try-snowplow.com","srht.site","stackhero-network.com","musician.io","novecore.site","static.land","dev.static.land","sites.static.land","storebase.store","vps-host.net","atl.jelastic.vps-host.net","njs.jelastic.vps-host.net","ric.jelastic.vps-host.net","playstation-cloud.com","apps.lair.io","*.stolos.io","spacekit.io","customer.speedpartner.de","myspreadshop.at","myspreadshop.com.au","myspreadshop.be","myspreadshop.ca","myspreadshop.ch","myspreadshop.com","myspreadshop.de","myspreadshop.dk","myspreadshop.es","myspreadshop.fi","myspreadshop.fr","myspreadshop.ie","myspreadshop.it","myspreadshop.net","myspreadshop.nl","myspreadshop.no","myspreadshop.pl","myspreadshop.se","myspreadshop.co.uk","api.stdlib.com","storj.farm","utwente.io","soc.srcf.net","user.srcf.net","temp-dns.com","supabase.co","supabase.in","supabase.net","su.paba.se","*.s5y.io","*.sensiosite.cloud","syncloud.it","dscloud.biz","direct.quickconnect.cn","dsmynas.com","familyds.com","diskstation.me","dscloud.me","i234.me","myds.me","synology.me","dscloud.mobi","dsmynas.net","familyds.net","dsmynas.org","familyds.org","vpnplus.to","direct.quickconnect.to","tabitorder.co.il","taifun-dns.de","beta.tailscale.net","ts.net","gda.pl","gdansk.pl","gdynia.pl","med.pl","sopot.pl","site.tb-hosting.com","edugit.io","s3.teckids.org","telebit.app","telebit.io","*.telebit.xyz","gwiddle.co.uk","*.firenet.ch","*.svc.firenet.ch","reservd.com","thingdustdata.com","cust.dev.thingdust.io","cust.disrec.thingdust.io","cust.prod.thingdust.io","cust.testing.thingdust.io","reservd.dev.thingdust.io","reservd.disrec.thingdust.io","reservd.testing.thingdust.io","tickets.io","arvo.network","azimuth.network","tlon.network","torproject.net","pages.torproject.net","bloxcms.com","townnews-staging.com","tbits.me","12hp.at","2ix.at","4lima.at","lima-city.at","12hp.ch","2ix.ch","4lima.ch","lima-city.ch","trafficplex.cloud","de.cool","12hp.de","2ix.de","4lima.de","lima-city.de","1337.pictures","clan.rip","lima-city.rocks","webspace.rocks","lima.zone","*.transurl.be","*.transurl.eu","*.transurl.nl","site.transip.me","tuxfamily.org","dd-dns.de","diskstation.eu","diskstation.org","dray-dns.de","draydns.de","dyn-vpn.de","dynvpn.de","mein-vigor.de","my-vigor.de","my-wan.de","syno-ds.de","synology-diskstation.de","synology-ds.de","typedream.app","pro.typeform.com","uber.space","*.uberspace.de","hk.com","hk.org","ltd.hk","inc.hk","name.pm","sch.tf","biz.wf","sch.wf","org.yt","virtualuser.de","virtual-user.de","upli.io","urown.cloud","dnsupdate.info","lib.de.us","2038.io","vercel.app","vercel.dev","now.sh","router.management","v-info.info","voorloper.cloud","neko.am","nyaa.am","be.ax","cat.ax","es.ax","eu.ax","gg.ax","mc.ax","us.ax","xy.ax","nl.ci","xx.gl","app.gp","blog.gt","de.gt","to.gt","be.gy","cc.hn","blog.kg","io.kg","jp.kg","tv.kg","uk.kg","us.kg","de.ls","at.md","de.md","jp.md","to.md","indie.porn","vxl.sh","ch.tc","me.tc","we.tc","nyan.to","at.vg","blog.vu","dev.vu","me.vu","v.ua","*.vultrobjects.com","wafflecell.com","*.webhare.dev","reserve-online.net","reserve-online.com","bookonline.app","hotelwithflight.com","wedeploy.io","wedeploy.me","wedeploy.sh","remotewd.com","pages.wiardweb.com","wmflabs.org","toolforge.org","wmcloud.org","panel.gg","daemon.panel.gg","messwithdns.com","woltlab-demo.com","myforum.community","community-pro.de","diskussionsbereich.de","community-pro.net","meinforum.net","affinitylottery.org.uk","raffleentry.org.uk","weeklylottery.org.uk","wpenginepowered.com","js.wpenginepowered.com","wixsite.com","editorx.io","half.host","xnbay.com","u2.xnbay.com","u2-local.xnbay.com","cistron.nl","demon.nl","xs4all.space","yandexcloud.net","storage.yandexcloud.net","website.yandexcloud.net","official.academy","yolasite.com","ybo.faith","yombo.me","homelink.one","ybo.party","ybo.review","ybo.science","ybo.trade","ynh.fr","nohost.me","noho.st","za.net","za.org","bss.design","basicserver.io","virtualserver.io","enterprisecloud.nu"]');

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Fpedrorosalba%2Fmediolano-dapp%2Fweb%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);